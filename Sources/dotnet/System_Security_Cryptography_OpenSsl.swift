// this file is automatically generated
// Copyright 2021 SourceGear

import jumptable_dotnet;

// System
// System.Security
// System.Security.Cryptography
extension System.Security.Cryptography {
// type: System.Security.Cryptography.DSAOpenSsl
    /**
    Provides an implementation of the Digital Signature Algorithm (DSA) backed by OpenSSL.

    */
public final class DSAOpenSsl
    :
    dotnet.System.Security.Cryptography.DSA
{
    public class override func get_type_handle() -> TypeHandle {
        return System_Security_Cryptography_DSAOpenSsl_get_type_handle();
    }
    public required init(hndl: NonnullHandle) { super.init(hndl: hndl); }
    public required init(gval: GVal) { super.init(gval: gval); }
    // .ctor()
// docid: M:System.Security.Cryptography.DSAOpenSsl.#ctor
    /**
    Initializes a new instance of the  class with a default key size of 2048 bits.

    */
    public init() throws {
        var __thrown : NullableHandle = nil;
        let h = System_Security_Cryptography_DSAOpenSsl_ctor_0__0(&__thrown);
        if let __ex = __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
            super.init(hndl: h);
        }
    }
    // .ctor(System.Int32)
// docid: M:System.Security.Cryptography.DSAOpenSsl.#ctor(System.Int32)
    /**
    Initializes a new instance of the  class with a specified key size.

    - Parameter keySize: The size of the key to generate, when a key is needed.
    */
    public init(keySize : Swift.Int32) throws {
        var __thrown : NullableHandle = nil;
        let h = System_Security_Cryptography_DSAOpenSsl_ctor_0__1__i32(&__thrown, keySize);
        if let __ex = __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
            super.init(hndl: h);
        }
    }
    // .ctor(System.IntPtr)
// docid: M:System.Security.Cryptography.DSAOpenSsl.#ctor(System.IntPtr)
    /**
    Initializes a new instance of the  class from an existing OpenSSL key represented as a DSA(ASTERISK).

    - Parameter handle: The OpenSSL DSA(ASTERISK) value to use as the key.
    */
    public init(handle : dotnet.System.IntPtr) throws {
        var __thrown : NullableHandle = nil;
        let h = System_Security_Cryptography_DSAOpenSsl_ctor_0__1__IntPtr(&__thrown, handle.get_value());
        if let __ex = __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
            super.init(hndl: h);
        }
    }
    // .ctor(System.Security.Cryptography.DSAParameters)
// docid: M:System.Security.Cryptography.DSAOpenSsl.#ctor(System.Security.Cryptography.DSAParameters)
    /**
    Initializes a new instance of the  class and imports parameters from an existing key.

    - Parameter parameters: The key parameters to import.
    */
    public init(parameters : dotnet.System.Security.Cryptography.DSAParameters) throws {
        var __thrown : NullableHandle = nil;
        let h = System_Security_Cryptography_DSAOpenSsl_ctor_0__1__DSAParameters(&__thrown, parameters.get_handle());
        if let __ex = __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
            super.init(hndl: h);
        }
    }
    // .ctor(System.Security.Cryptography.SafeEvpPKeyHandle)
// docid: M:System.Security.Cryptography.DSAOpenSsl.#ctor(System.Security.Cryptography.SafeEvpPKeyHandle)
    /**
    Initializes a new instance of the  class from an existing OpenSSL key represented as an EVP_PKEY(ASTERISK).

    - Parameter pkeyHandle: The OpenSSL EVP_PKEY(ASTERISK) value to use as the key, represented as a .
    */
    public init(pkeyHandle : dotnet.System.Security.Cryptography.SafeEvpPKeyHandle) throws {
        var __thrown : NullableHandle = nil;
        let h = System_Security_Cryptography_DSAOpenSsl_ctor_0__1__SafeEvpPKeyHandle(&__thrown, pkeyHandle.get_handle());
        if let __ex = __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
            super.init(hndl: h);
        }
    }
    // System.Byte[] CreateSignature(System.Byte[])
// docid: M:System.Security.Cryptography.DSAOpenSsl.CreateSignature(System.Byte[])
    /**
    When overridden in a derived class, creates the  signature for the specified hash value.

    - Parameter rgbHash: The hash value to be signed.
    - Returns: The digital signature for the specified hash value.

    */
    public override func CreateSignature(rgbHash : dotnet.System_Arr<Swift.UInt8>) throws -> dotnet.System_Arr<Swift.UInt8> {
        var __thrown : NullableHandle = nil;
        let __return = System_Security_Cryptography_DSAOpenSsl_u8Array__CreateSignature_0__1__u8Array(&__thrown, self.get_handle(), rgbHash.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return dotnet.System_Arr<Swift.UInt8>(hndl : __return);
        }
    }
    // System.Security.Cryptography.SafeEvpPKeyHandle DuplicateKeyHandle()
// docid: M:System.Security.Cryptography.DSAOpenSsl.DuplicateKeyHandle
    /**
    Gets a  representation of the cryptographic key.

    - Returns: A  representation of the cryptographic key.

    */
    public func DuplicateKeyHandle() throws -> dotnet.System.Security.Cryptography.SafeEvpPKeyHandle {
        var __thrown : NullableHandle = nil;
        let __return = System_Security_Cryptography_DSAOpenSsl_SafeEvpPKeyHandle__DuplicateKeyHandle_0__0(&__thrown, self.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return dotnet.System.Security.Cryptography.SafeEvpPKeyHandle(hndl : __return);
        }
    }
    // System.Security.Cryptography.DSAParameters ExportParameters(bool)
// docid: M:System.Security.Cryptography.DSAOpenSsl.ExportParameters(System.Boolean)
    /**
    Exports the  representing this key.

    - Parameter includePrivateParameters: 
         to include private parameters; otherwise, .
    - Returns: The DSA parameters for the current cryptographic key.

    */
    public override func ExportParameters(includePrivateParameters : Bool) throws -> dotnet.System.Security.Cryptography.DSAParameters {
        var __thrown : NullableHandle = nil;
        let __return = System_Security_Cryptography_DSAOpenSsl_DSAParameters__ExportParameters_0__1__bool(&__thrown, self.get_handle(), Swift.Int32(includePrivateParameters ? 1 : 0));
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return dotnet.System.Security.Cryptography.DSAParameters(hndl : __return);
        }
    }
    // void ImportParameters(System.Security.Cryptography.DSAParameters)
// docid: M:System.Security.Cryptography.DSAOpenSsl.ImportParameters(System.Security.Cryptography.DSAParameters)
    /**
    Imports the specified .

    - Parameter parameters: The key parameters to import.
    */
    public override func ImportParameters(parameters : dotnet.System.Security.Cryptography.DSAParameters) throws {
        var __thrown : NullableHandle = nil;
        System_Security_Cryptography_DSAOpenSsl_void__ImportParameters_0__1__DSAParameters(&__thrown, self.get_handle(), parameters.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
            return;
        }
    }
    // bool VerifySignature(System.Byte[], System.Byte[])
// docid: M:System.Security.Cryptography.DSAOpenSsl.VerifySignature(System.Byte[],System.Byte[])
    /**
    Verifies if the specified digital signature matches the specified hash.

    - Parameter rgbHash: The signed hash.
    - Parameter rgbSignature: The digital signature to be verified.
    - Returns: 
         if  matches the signature computed using the specified hash; otherwise, .

    */
    public override func VerifySignature(rgbHash : dotnet.System_Arr<Swift.UInt8>, rgbSignature : dotnet.System_Arr<Swift.UInt8>) throws -> Bool {
        var __thrown : NullableHandle = nil;
        let __return = System_Security_Cryptography_DSAOpenSsl_bool__VerifySignature_0__2__u8Array_u8Array(&__thrown, self.get_handle(), rgbHash.get_handle(), rgbSignature.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return (__return) != 0;
        }
    }
    // [IsSpecialName] void set_KeySize(System.Int32)
// docid: M:System.Security.Cryptography.DSAOpenSsl.set_KeySize(System.Int32)
    public override func set_KeySize(value : Swift.Int32) throws {
        var __thrown : NullableHandle = nil;
        System_Security_Cryptography_DSAOpenSsl_void__set_KeySize_0__1__i32(&__thrown, self.get_handle(), value);
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
            return;
        }
    }
    // [IsSpecialName] System.Security.Cryptography.KeySizes[] get_LegalKeySizes()
// docid: M:System.Security.Cryptography.DSAOpenSsl.get_LegalKeySizes
    public override func get_LegalKeySizes() throws -> dotnet.System_Arr<dotnet.System.Security.Cryptography.KeySizes> {
        var __thrown : NullableHandle = nil;
        let __return = System_Security_Cryptography_DSAOpenSsl_KeySizesArray__get_LegalKeySizes_0__0(&__thrown, self.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return dotnet.System_Arr<dotnet.System.Security.Cryptography.KeySizes>(hndl : __return);
        }
    }
    /**
    Gets the key sizes, in bits, that are supported by the DSA algorithm.

    */
    public override var LegalKeySizes : dotnet.System_Arr<dotnet.System.Security.Cryptography.KeySizes> {
        get {
            return try! get_LegalKeySizes();
        }
    }
} // DSAOpenSsl


// type: System.Security.Cryptography.ECDiffieHellmanOpenSsl
    /**
    Provides an implementation of the Elliptic Curve Diffie-Hellman (ECDH) algorithm backed by OpenSSL.

    */
public final class ECDiffieHellmanOpenSsl
    :
    dotnet.System.Security.Cryptography.ECDiffieHellman
{
    public class override func get_type_handle() -> TypeHandle {
        return System_Security_Cryptography_ECDiffieHellmanOpenSsl_get_type_handle();
    }
    public required init(hndl: NonnullHandle) { super.init(hndl: hndl); }
    public required init(gval: GVal) { super.init(gval: gval); }
    // .ctor()
// docid: M:System.Security.Cryptography.ECDiffieHellmanOpenSsl.#ctor
    /**
    Initializes a new instance of the  class with a default curve of NIST P-521/secp521r1.

    */
    public init() throws {
        var __thrown : NullableHandle = nil;
        let h = System_Security_Cryptography_ECDiffieHellmanOpenSsl_ctor_0__0(&__thrown);
        if let __ex = __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
            super.init(hndl: h);
        }
    }
    // .ctor(System.Int32)
// docid: M:System.Security.Cryptography.ECDiffieHellmanOpenSsl.#ctor(System.Int32)
    /**
    Initializes a new instance of the  class defaulting to the NIST prime curve of the specified size.

    - Parameter keySize: The size of the key to generate, when a key is needed.
    */
    public init(keySize : Swift.Int32) throws {
        var __thrown : NullableHandle = nil;
        let h = System_Security_Cryptography_ECDiffieHellmanOpenSsl_ctor_0__1__i32(&__thrown, keySize);
        if let __ex = __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
            super.init(hndl: h);
        }
    }
    // .ctor(System.IntPtr)
// docid: M:System.Security.Cryptography.ECDiffieHellmanOpenSsl.#ctor(System.IntPtr)
    /**
    Initializes a new instance of the  class from an existing OpenSSL key represented as an EC_KEY(ASTERISK).

    - Parameter handle: The OpenSSL EC_KEY(ASTERISK) value to use as the key.
    */
    public init(handle : dotnet.System.IntPtr) throws {
        var __thrown : NullableHandle = nil;
        let h = System_Security_Cryptography_ECDiffieHellmanOpenSsl_ctor_0__1__IntPtr(&__thrown, handle.get_value());
        if let __ex = __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
            super.init(hndl: h);
        }
    }
    // .ctor(System.Security.Cryptography.ECCurve)
// docid: M:System.Security.Cryptography.ECDiffieHellmanOpenSsl.#ctor(System.Security.Cryptography.ECCurve)
    /**
    Initializes a new instance of the  class and generates a new key on the specified curve.

    - Parameter curve: The curve used to generate an ephemeral public/private key pair.
    */
    public init(curve : dotnet.System.Security.Cryptography.ECCurve) throws {
        var __thrown : NullableHandle = nil;
        let h = System_Security_Cryptography_ECDiffieHellmanOpenSsl_ctor_0__1__ECCurve(&__thrown, curve.get_handle());
        if let __ex = __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
            super.init(hndl: h);
        }
    }
    // .ctor(System.Security.Cryptography.SafeEvpPKeyHandle)
// docid: M:System.Security.Cryptography.ECDiffieHellmanOpenSsl.#ctor(System.Security.Cryptography.SafeEvpPKeyHandle)
    /**
    Initializes a new instance of the  class from an existing OpenSSL key represented as an EVP_PKEY(ASTERISK).

    - Parameter pkeyHandle: The OpenSSL EVP_PKEY(ASTERISK) value to use as the key, represented as a .
    */
    public init(pkeyHandle : dotnet.System.Security.Cryptography.SafeEvpPKeyHandle) throws {
        var __thrown : NullableHandle = nil;
        let h = System_Security_Cryptography_ECDiffieHellmanOpenSsl_ctor_0__1__SafeEvpPKeyHandle(&__thrown, pkeyHandle.get_handle());
        if let __ex = __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
            super.init(hndl: h);
        }
    }
    // System.Byte[] DeriveKeyFromHash(System.Security.Cryptography.ECDiffieHellmanPublicKey, System.Security.Cryptography.HashAlgorithmName, System.Byte[], System.Byte[])
// docid: M:System.Security.Cryptography.ECDiffieHellmanOpenSsl.DeriveKeyFromHash(System.Security.Cryptography.ECDiffieHellmanPublicKey,System.Security.Cryptography.HashAlgorithmName,System.Byte[],System.Byte[])
    /**
    Performs key derivation using a specified hash algorithm with optional prepended or appended data.

    - Parameter otherPartyPublicKey: The other party's public key.
    - Parameter hashAlgorithm: The hash algorithm to use to derive the key material.
    - Parameter secretPrepend: A value to prepend to the derived secret before hashing.
    - Parameter secretAppend: A value to append to the derived secret before hashing.
    - Returns: The hash of the shared secret after prepending or appending data as requested.

    */
    public override func DeriveKeyFromHash(otherPartyPublicKey : dotnet.System.Security.Cryptography.ECDiffieHellmanPublicKey, hashAlgorithm : dotnet.System.Security.Cryptography.HashAlgorithmName, secretPrepend : Optional<dotnet.System_Arr<Swift.UInt8>>, secretAppend : Optional<dotnet.System_Arr<Swift.UInt8>>) throws -> dotnet.System_Arr<Swift.UInt8> {
        var __thrown : NullableHandle = nil;
        let __return = System_Security_Cryptography_ECDiffieHellmanOpenSsl_u8Array__DeriveKeyFromHash_0__4__ECDiffieHellmanPublicKey_HashAlgorithmName_u8Array_u8Array(&__thrown, self.get_handle(), otherPartyPublicKey.get_handle(), hashAlgorithm.get_handle(), (secretPrepend?.get_handle()), (secretAppend?.get_handle()));
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return dotnet.System_Arr<Swift.UInt8>(hndl : __return);
        }
    }
    // System.Byte[] DeriveKeyFromHmac(System.Security.Cryptography.ECDiffieHellmanPublicKey, System.Security.Cryptography.HashAlgorithmName, System.Byte[], System.Byte[], System.Byte[])
// docid: M:System.Security.Cryptography.ECDiffieHellmanOpenSsl.DeriveKeyFromHmac(System.Security.Cryptography.ECDiffieHellmanPublicKey,System.Security.Cryptography.HashAlgorithmName,System.Byte[],System.Byte[],System.Byte[])
    /**
    Performs key derivation using a specified HMAC (Hash-based Message Authentication Code) algorithm with optional prepended or appended data.

    - Parameter otherPartyPublicKey: The other party's public key.
    - Parameter hashAlgorithm: The hash algorithm to use to derive the key material.
    - Parameter hmacKey: The key for the HMAC.
    - Parameter secretPrepend: A value to prepend to the derived secret before hashing.
    - Parameter secretAppend: A value to append to the derived secret before hashing.
    - Returns: The HMAC of the shared secret after prepending or appending data as requested.

    */
    public override func DeriveKeyFromHmac(otherPartyPublicKey : dotnet.System.Security.Cryptography.ECDiffieHellmanPublicKey, hashAlgorithm : dotnet.System.Security.Cryptography.HashAlgorithmName, hmacKey : Optional<dotnet.System_Arr<Swift.UInt8>>, secretPrepend : Optional<dotnet.System_Arr<Swift.UInt8>>, secretAppend : Optional<dotnet.System_Arr<Swift.UInt8>>) throws -> dotnet.System_Arr<Swift.UInt8> {
        var __thrown : NullableHandle = nil;
        let __return = System_Security_Cryptography_ECDiffieHellmanOpenSsl_u8Array__DeriveKeyFromHmac_0__5__ECDiffieHellmanPublicKey_HashAlgorithmName_u8Array_u8Array_u8Array(&__thrown, self.get_handle(), otherPartyPublicKey.get_handle(), hashAlgorithm.get_handle(), (hmacKey?.get_handle()), (secretPrepend?.get_handle()), (secretAppend?.get_handle()));
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return dotnet.System_Arr<Swift.UInt8>(hndl : __return);
        }
    }
    // System.Byte[] DeriveKeyMaterial(System.Security.Cryptography.ECDiffieHellmanPublicKey)
// docid: M:System.Security.Cryptography.ECDiffieHellmanOpenSsl.DeriveKeyMaterial(System.Security.Cryptography.ECDiffieHellmanPublicKey)
    /**
    Performs a key derivation on the shared secret.

    - Parameter otherPartyPublicKey: The other party's public key.
    - Returns: The SHA-256 hash of the shared secret.

    */
    public override func DeriveKeyMaterial(otherPartyPublicKey : dotnet.System.Security.Cryptography.ECDiffieHellmanPublicKey) throws -> dotnet.System_Arr<Swift.UInt8> {
        var __thrown : NullableHandle = nil;
        let __return = System_Security_Cryptography_ECDiffieHellmanOpenSsl_u8Array__DeriveKeyMaterial_0__1__ECDiffieHellmanPublicKey(&__thrown, self.get_handle(), otherPartyPublicKey.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return dotnet.System_Arr<Swift.UInt8>(hndl : __return);
        }
    }
    // System.Byte[] DeriveKeyTls(System.Security.Cryptography.ECDiffieHellmanPublicKey, System.Byte[], System.Byte[])
// docid: M:System.Security.Cryptography.ECDiffieHellmanOpenSsl.DeriveKeyTls(System.Security.Cryptography.ECDiffieHellmanPublicKey,System.Byte[],System.Byte[])
    /**
    Performs key derivation using the TLS (Transport Layer Security) 1.1 PRF (Pseudo-Random Function).

    - Parameter otherPartyPublicKey: The other party's public key.
    - Parameter prfLabel: The ASCII-encoded PRF label.
    - Parameter prfSeed: The 64-byte PRF seed.
    - Returns: The first 48 bytes from the TLS 1.1 PRF, using the shared secret as the key.

    */
    public override func DeriveKeyTls(otherPartyPublicKey : dotnet.System.Security.Cryptography.ECDiffieHellmanPublicKey, prfLabel : dotnet.System_Arr<Swift.UInt8>, prfSeed : dotnet.System_Arr<Swift.UInt8>) throws -> dotnet.System_Arr<Swift.UInt8> {
        var __thrown : NullableHandle = nil;
        let __return = System_Security_Cryptography_ECDiffieHellmanOpenSsl_u8Array__DeriveKeyTls_0__3__ECDiffieHellmanPublicKey_u8Array_u8Array(&__thrown, self.get_handle(), otherPartyPublicKey.get_handle(), prfLabel.get_handle(), prfSeed.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return dotnet.System_Arr<Swift.UInt8>(hndl : __return);
        }
    }
    // System.Security.Cryptography.SafeEvpPKeyHandle DuplicateKeyHandle()
// docid: M:System.Security.Cryptography.ECDiffieHellmanOpenSsl.DuplicateKeyHandle
    /**
    Gets a  representation of the cryptographic key.

    - Returns: A  representation of the cryptographic key.

    */
    public func DuplicateKeyHandle() throws -> dotnet.System.Security.Cryptography.SafeEvpPKeyHandle {
        var __thrown : NullableHandle = nil;
        let __return = System_Security_Cryptography_ECDiffieHellmanOpenSsl_SafeEvpPKeyHandle__DuplicateKeyHandle_0__0(&__thrown, self.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return dotnet.System.Security.Cryptography.SafeEvpPKeyHandle(hndl : __return);
        }
    }
    // System.Security.Cryptography.ECParameters ExportExplicitParameters(bool)
// docid: M:System.Security.Cryptography.ECDiffieHellmanOpenSsl.ExportExplicitParameters(System.Boolean)
    /**
    Exports either the public or the public and private key information using the explicit curve form from the current key to an  structure so that it can be passed to the  method.

    - Parameter includePrivateParameters: 
         to include private parameters; otherwise, .
    - Returns: An object that represents the point on the curve for this key, using the explicit curve format.

    */
    public override func ExportExplicitParameters(includePrivateParameters : Bool) throws -> dotnet.System.Security.Cryptography.ECParameters {
        var __thrown : NullableHandle = nil;
        let __return = System_Security_Cryptography_ECDiffieHellmanOpenSsl_ECParameters__ExportExplicitParameters_0__1__bool(&__thrown, self.get_handle(), Swift.Int32(includePrivateParameters ? 1 : 0));
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return dotnet.System.Security.Cryptography.ECParameters(hndl : __return);
        }
    }
    // System.Security.Cryptography.ECParameters ExportParameters(bool)
// docid: M:System.Security.Cryptography.ECDiffieHellmanOpenSsl.ExportParameters(System.Boolean)
    /**
    Exports the key used by the  object into an  object.

    - Parameter includePrivateParameters: 
         to include private parameters; otherwise, .
    - Returns: The key and named curve parameters used by the  object.

    */
    public override func ExportParameters(includePrivateParameters : Bool) throws -> dotnet.System.Security.Cryptography.ECParameters {
        var __thrown : NullableHandle = nil;
        let __return = System_Security_Cryptography_ECDiffieHellmanOpenSsl_ECParameters__ExportParameters_0__1__bool(&__thrown, self.get_handle(), Swift.Int32(includePrivateParameters ? 1 : 0));
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return dotnet.System.Security.Cryptography.ECParameters(hndl : __return);
        }
    }
    // void GenerateKey(System.Security.Cryptography.ECCurve)
// docid: M:System.Security.Cryptography.ECDiffieHellmanOpenSsl.GenerateKey(System.Security.Cryptography.ECCurve)
    /**
    Generates a new ephemeral public/private key pair for the specified curve.

    - Parameter curve: The curve used to generate an ephemeral public/private key pair.
    */
    public override func GenerateKey(curve : dotnet.System.Security.Cryptography.ECCurve) throws {
        var __thrown : NullableHandle = nil;
        System_Security_Cryptography_ECDiffieHellmanOpenSsl_void__GenerateKey_0__1__ECCurve(&__thrown, self.get_handle(), curve.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
            return;
        }
    }
    // void ImportParameters(System.Security.Cryptography.ECParameters)
// docid: M:System.Security.Cryptography.ECDiffieHellmanOpenSsl.ImportParameters(System.Security.Cryptography.ECParameters)
    /**
    Imports the specified parameters for an  object as a key into the current instance.

    - Parameter parameters: The curve's parameters to import.
    */
    public override func ImportParameters(parameters : dotnet.System.Security.Cryptography.ECParameters) throws {
        var __thrown : NullableHandle = nil;
        System_Security_Cryptography_ECDiffieHellmanOpenSsl_void__ImportParameters_0__1__ECParameters(&__thrown, self.get_handle(), parameters.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
            return;
        }
    }
    // [IsSpecialName] System.Security.Cryptography.ECDiffieHellmanPublicKey get_PublicKey()
// docid: M:System.Security.Cryptography.ECDiffieHellmanOpenSsl.get_PublicKey
    public override func get_PublicKey() throws -> dotnet.System.Security.Cryptography.ECDiffieHellmanPublicKey {
        var __thrown : NullableHandle = nil;
        let __return = System_Security_Cryptography_ECDiffieHellmanOpenSsl_ECDiffieHellmanPublicKey__get_PublicKey_0__0(&__thrown, self.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return dotnet.System.Security.Cryptography.ECDiffieHellmanPublicKey(hndl : __return);
        }
    }
    /**
    Gets the public key that can be used by another  object to generate a shared secret agreement.

    */
    public override var PublicKey : dotnet.System.Security.Cryptography.ECDiffieHellmanPublicKey {
        get {
            return try! get_PublicKey();
        }
    }
} // ECDiffieHellmanOpenSsl


// type: System.Security.Cryptography.ECDsaOpenSsl
    /**
    Provides an implementation of the Elliptic Curve Digital Signature Algorithm (ECDSA) backed by OpenSSL.

    */
public final class ECDsaOpenSsl
    :
    dotnet.System.Security.Cryptography.ECDsa
{
    public class override func get_type_handle() -> TypeHandle {
        return System_Security_Cryptography_ECDsaOpenSsl_get_type_handle();
    }
    public required init(hndl: NonnullHandle) { super.init(hndl: hndl); }
    public required init(gval: GVal) { super.init(gval: gval); }
    // .ctor()
// docid: M:System.Security.Cryptography.ECDsaOpenSsl.#ctor
    /**
    Initializes a new instance of the  class.

    */
    public init() throws {
        var __thrown : NullableHandle = nil;
        let h = System_Security_Cryptography_ECDsaOpenSsl_ctor_0__0(&__thrown);
        if let __ex = __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
            super.init(hndl: h);
        }
    }
    // .ctor(System.Int32)
// docid: M:System.Security.Cryptography.ECDsaOpenSsl.#ctor(System.Int32)
    /**
    Initializes a new instance of the  class with a specified target key size.

    - Parameter keySize: The size of the key. Valid key sizes are 256, 384, and 521 bits.
    */
    public init(keySize : Swift.Int32) throws {
        var __thrown : NullableHandle = nil;
        let h = System_Security_Cryptography_ECDsaOpenSsl_ctor_0__1__i32(&__thrown, keySize);
        if let __ex = __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
            super.init(hndl: h);
        }
    }
    // .ctor(System.IntPtr)
// docid: M:System.Security.Cryptography.ECDsaOpenSsl.#ctor(System.IntPtr)
    /**
    Initializes a new instance of the  class from an existing OpenSSL key represented as an EC_KEY(ASTERISK).

    - Parameter handle: The OpenSSL EC_KEY(ASTERISK) value to use as the key.
    */
    public init(handle : dotnet.System.IntPtr) throws {
        var __thrown : NullableHandle = nil;
        let h = System_Security_Cryptography_ECDsaOpenSsl_ctor_0__1__IntPtr(&__thrown, handle.get_value());
        if let __ex = __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
            super.init(hndl: h);
        }
    }
    // .ctor(System.Security.Cryptography.ECCurve)
// docid: M:System.Security.Cryptography.ECDsaOpenSsl.#ctor(System.Security.Cryptography.ECCurve)
    /**
    Initializes a new instance of the  class and generates a new key on the specified curve.

    - Parameter curve: The curve used to generate an ephemeral public/private key pair.
    */
    public init(curve : dotnet.System.Security.Cryptography.ECCurve) throws {
        var __thrown : NullableHandle = nil;
        let h = System_Security_Cryptography_ECDsaOpenSsl_ctor_0__1__ECCurve(&__thrown, curve.get_handle());
        if let __ex = __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
            super.init(hndl: h);
        }
    }
    // .ctor(System.Security.Cryptography.SafeEvpPKeyHandle)
// docid: M:System.Security.Cryptography.ECDsaOpenSsl.#ctor(System.Security.Cryptography.SafeEvpPKeyHandle)
    /**
    Initializes a new instance of the  class from an existing OpenSSL key represented as an EVP_PKEY(ASTERISK).

    - Parameter pkeyHandle: The OpenSSL EVP_PKEY(ASTERISK) value to use as the key, represented as a .
    */
    public init(pkeyHandle : dotnet.System.Security.Cryptography.SafeEvpPKeyHandle) throws {
        var __thrown : NullableHandle = nil;
        let h = System_Security_Cryptography_ECDsaOpenSsl_ctor_0__1__SafeEvpPKeyHandle(&__thrown, pkeyHandle.get_handle());
        if let __ex = __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
            super.init(hndl: h);
        }
    }
    // System.Security.Cryptography.SafeEvpPKeyHandle DuplicateKeyHandle()
// docid: M:System.Security.Cryptography.ECDsaOpenSsl.DuplicateKeyHandle
    /**
    Gets a  representation of the cryptographic key.

    - Returns: A  representation of the cryptographic key.

    */
    public func DuplicateKeyHandle() throws -> dotnet.System.Security.Cryptography.SafeEvpPKeyHandle {
        var __thrown : NullableHandle = nil;
        let __return = System_Security_Cryptography_ECDsaOpenSsl_SafeEvpPKeyHandle__DuplicateKeyHandle_0__0(&__thrown, self.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return dotnet.System.Security.Cryptography.SafeEvpPKeyHandle(hndl : __return);
        }
    }
    // System.Security.Cryptography.ECParameters ExportExplicitParameters(bool)
// docid: M:System.Security.Cryptography.ECDsaOpenSsl.ExportExplicitParameters(System.Boolean)
    /**
    Exports the key and explicit curve parameters used by the Elliptic curve cryptography (ECC) object into an  object.

    - Parameter includePrivateParameters: 
         to include private parameters; otherwise, .
    - Returns: The key and explicit curve parameters used by the ECC object.

    */
    public override func ExportExplicitParameters(includePrivateParameters : Bool) throws -> dotnet.System.Security.Cryptography.ECParameters {
        var __thrown : NullableHandle = nil;
        let __return = System_Security_Cryptography_ECDsaOpenSsl_ECParameters__ExportExplicitParameters_0__1__bool(&__thrown, self.get_handle(), Swift.Int32(includePrivateParameters ? 1 : 0));
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return dotnet.System.Security.Cryptography.ECParameters(hndl : __return);
        }
    }
    // System.Security.Cryptography.ECParameters ExportParameters(bool)
// docid: M:System.Security.Cryptography.ECDsaOpenSsl.ExportParameters(System.Boolean)
    /**
    Exports the key used by the Elliptic curve cryptography (ECC) object into an  object. If the key was created as a named curve, the  field contains named curve parameters; otherwise, it contains explicit parameters.

    - Parameter includePrivateParameters: 
         to include private parameters; otherwise, .
    - Returns: The key and named curve parameters used by the ECC object.

    */
    public override func ExportParameters(includePrivateParameters : Bool) throws -> dotnet.System.Security.Cryptography.ECParameters {
        var __thrown : NullableHandle = nil;
        let __return = System_Security_Cryptography_ECDsaOpenSsl_ECParameters__ExportParameters_0__1__bool(&__thrown, self.get_handle(), Swift.Int32(includePrivateParameters ? 1 : 0));
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return dotnet.System.Security.Cryptography.ECParameters(hndl : __return);
        }
    }
    // void GenerateKey(System.Security.Cryptography.ECCurve)
// docid: M:System.Security.Cryptography.ECDsaOpenSsl.GenerateKey(System.Security.Cryptography.ECCurve)
    /**
    Generates a new ephemeral public/private key pair for the specified curve, replacing the current key.

    - Parameter curve: The curve to use to generate the key.
    */
    public override func GenerateKey(curve : dotnet.System.Security.Cryptography.ECCurve) throws {
        var __thrown : NullableHandle = nil;
        System_Security_Cryptography_ECDsaOpenSsl_void__GenerateKey_0__1__ECCurve(&__thrown, self.get_handle(), curve.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
            return;
        }
    }
    // void ImportParameters(System.Security.Cryptography.ECParameters)
// docid: M:System.Security.Cryptography.ECDsaOpenSsl.ImportParameters(System.Security.Cryptography.ECParameters)
    /**
    Replaces the current key for this instance with one using the specified key parameters.

    - Parameter parameters: The curve parameters.
    */
    public override func ImportParameters(parameters : dotnet.System.Security.Cryptography.ECParameters) throws {
        var __thrown : NullableHandle = nil;
        System_Security_Cryptography_ECDsaOpenSsl_void__ImportParameters_0__1__ECParameters(&__thrown, self.get_handle(), parameters.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
            return;
        }
    }
    // System.Byte[] SignHash(System.Byte[])
// docid: M:System.Security.Cryptography.ECDsaOpenSsl.SignHash(System.Byte[])
    /**
    Generates a digital signature for the specified hash value.

    - Parameter hash: The hash value of the data that is being signed.
    - Returns: A digital signature for the specified hash value.

    */
    public override func SignHash(hash : dotnet.System_Arr<Swift.UInt8>) throws -> dotnet.System_Arr<Swift.UInt8> {
        var __thrown : NullableHandle = nil;
        let __return = System_Security_Cryptography_ECDsaOpenSsl_u8Array__SignHash_0__1__u8Array(&__thrown, self.get_handle(), hash.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return dotnet.System_Arr<Swift.UInt8>(hndl : __return);
        }
    }
    // bool VerifyHash(System.Byte[], System.Byte[])
// docid: M:System.Security.Cryptography.ECDsaOpenSsl.VerifyHash(System.Byte[],System.Byte[])
    /**
    Verifies that a digital signature is appropriate for the current key and provided data hash.

    - Parameter hash: The hash value of the data to be verified.
    - Parameter signature: The digital signature of the data to be verified against the hash value.
    - Returns: 
         if the signature is valid; otherwise, .

    */
    public override func VerifyHash(hash : dotnet.System_Arr<Swift.UInt8>, signature : dotnet.System_Arr<Swift.UInt8>) throws -> Bool {
        var __thrown : NullableHandle = nil;
        let __return = System_Security_Cryptography_ECDsaOpenSsl_bool__VerifyHash_0__2__u8Array_u8Array(&__thrown, self.get_handle(), hash.get_handle(), signature.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return (__return) != 0;
        }
    }
    // [IsSpecialName] System.Int32 get_KeySize()
// docid: M:System.Security.Cryptography.ECDsaOpenSsl.get_KeySize
    public override func get_KeySize() throws -> Swift.Int32 {
        var __thrown : NullableHandle = nil;
        let __return = System_Security_Cryptography_ECDsaOpenSsl_i32__get_KeySize_0__0(&__thrown, self.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return __return;
        }
    }
    // [IsSpecialName] void set_KeySize(System.Int32)
// docid: M:System.Security.Cryptography.ECDsaOpenSsl.set_KeySize(System.Int32)
    public override func set_KeySize(value : Swift.Int32) throws {
        var __thrown : NullableHandle = nil;
        System_Security_Cryptography_ECDsaOpenSsl_void__set_KeySize_0__1__i32(&__thrown, self.get_handle(), value);
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
            return;
        }
    }
    // [IsSpecialName] System.Security.Cryptography.KeySizes[] get_LegalKeySizes()
// docid: M:System.Security.Cryptography.ECDsaOpenSsl.get_LegalKeySizes
    public override func get_LegalKeySizes() throws -> dotnet.System_Arr<dotnet.System.Security.Cryptography.KeySizes> {
        var __thrown : NullableHandle = nil;
        let __return = System_Security_Cryptography_ECDsaOpenSsl_KeySizesArray__get_LegalKeySizes_0__0(&__thrown, self.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return dotnet.System_Arr<dotnet.System.Security.Cryptography.KeySizes>(hndl : __return);
        }
    }
    /**
    Gets or sets the size, in bits, of the key modulus used by the asymmetric algorithm.

    */
    public override var KeySize : Swift.Int32 {
        get {
            return try! get_KeySize();
        }
        set(v) {
            return try! set_KeySize(value: v);
        }
    }
    /**
    Gets the key sizes, in bits, that are supported by the  property setter.

    */
    public override var LegalKeySizes : dotnet.System_Arr<dotnet.System.Security.Cryptography.KeySizes> {
        get {
            return try! get_LegalKeySizes();
        }
    }
} // ECDsaOpenSsl


// type: System.Security.Cryptography.RSAOpenSsl
    /**
    Provides an implementation of the RSA algorithm backed by OpenSSL.

    */
public final class RSAOpenSsl
    :
    dotnet.System.Security.Cryptography.RSA
{
    public class override func get_type_handle() -> TypeHandle {
        return System_Security_Cryptography_RSAOpenSsl_get_type_handle();
    }
    public required init(hndl: NonnullHandle) { super.init(hndl: hndl); }
    public required init(gval: GVal) { super.init(gval: gval); }
    // .ctor()
// docid: M:System.Security.Cryptography.RSAOpenSsl.#ctor
    /**
    Initializes a new instance of the  class with a random 2048-bit key pair.

    */
    public init() throws {
        var __thrown : NullableHandle = nil;
        let h = System_Security_Cryptography_RSAOpenSsl_ctor_0__0(&__thrown);
        if let __ex = __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
            super.init(hndl: h);
        }
    }
    // .ctor(System.Int32)
// docid: M:System.Security.Cryptography.RSAOpenSsl.#ctor(System.Int32)
    /**
    Initializes a new instance of the  class with a randomly generated key of the specified size.

    - Parameter keySize: The size of the key to generate in bits.
    */
    public init(keySize : Swift.Int32) throws {
        var __thrown : NullableHandle = nil;
        let h = System_Security_Cryptography_RSAOpenSsl_ctor_0__1__i32(&__thrown, keySize);
        if let __ex = __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
            super.init(hndl: h);
        }
    }
    // .ctor(System.IntPtr)
// docid: M:System.Security.Cryptography.RSAOpenSsl.#ctor(System.IntPtr)
    /**
    Initializes a new instance of the  class from an existing OpenSSL key represented as an RSA(ASTERISK).

    - Parameter handle: The OpenSSL RSA(ASTERISK) value to use as the key.
    */
    public init(handle : dotnet.System.IntPtr) throws {
        var __thrown : NullableHandle = nil;
        let h = System_Security_Cryptography_RSAOpenSsl_ctor_0__1__IntPtr(&__thrown, handle.get_value());
        if let __ex = __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
            super.init(hndl: h);
        }
    }
    // .ctor(System.Security.Cryptography.RSAParameters)
// docid: M:System.Security.Cryptography.RSAOpenSsl.#ctor(System.Security.Cryptography.RSAParameters)
    /**
    Initializes a new instance of the  class using specified key parameters.

    - Parameter parameters: The parameters for the key.
    */
    public init(parameters : dotnet.System.Security.Cryptography.RSAParameters) throws {
        var __thrown : NullableHandle = nil;
        let h = System_Security_Cryptography_RSAOpenSsl_ctor_0__1__RSAParameters(&__thrown, parameters.get_handle());
        if let __ex = __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
            super.init(hndl: h);
        }
    }
    // .ctor(System.Security.Cryptography.SafeEvpPKeyHandle)
// docid: M:System.Security.Cryptography.RSAOpenSsl.#ctor(System.Security.Cryptography.SafeEvpPKeyHandle)
    /**
    Initializes a new instance of the  class from an existing OpenSSL key represented as an EVP_PKEY(ASTERISK).

    - Parameter pkeyHandle: The OpenSSL EVP_PKEY(ASTERISK) value to use as the key, represented as a .
    */
    public init(pkeyHandle : dotnet.System.Security.Cryptography.SafeEvpPKeyHandle) throws {
        var __thrown : NullableHandle = nil;
        let h = System_Security_Cryptography_RSAOpenSsl_ctor_0__1__SafeEvpPKeyHandle(&__thrown, pkeyHandle.get_handle());
        if let __ex = __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
            super.init(hndl: h);
        }
    }
    // System.Byte[] Decrypt(System.Byte[], System.Security.Cryptography.RSAEncryptionPadding)
// docid: M:System.Security.Cryptography.RSAOpenSsl.Decrypt(System.Byte[],System.Security.Cryptography.RSAEncryptionPadding)
    /**
    Decrypts the input data using the specified padding mode.

    - Parameter data: The data to decrypt.
    - Parameter padding: The padding mode.
    - Returns: The decrypted data.

    */
    public override func Decrypt(data : dotnet.System_Arr<Swift.UInt8>, padding : dotnet.System.Security.Cryptography.RSAEncryptionPadding) throws -> dotnet.System_Arr<Swift.UInt8> {
        var __thrown : NullableHandle = nil;
        let __return = System_Security_Cryptography_RSAOpenSsl_u8Array__Decrypt_0__2__u8Array_RSAEncryptionPadding(&__thrown, self.get_handle(), data.get_handle(), padding.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return dotnet.System_Arr<Swift.UInt8>(hndl : __return);
        }
    }
    // System.Security.Cryptography.SafeEvpPKeyHandle DuplicateKeyHandle()
// docid: M:System.Security.Cryptography.RSAOpenSsl.DuplicateKeyHandle
    /**
    Gets a  representation of the cryptographic key.

    - Returns: A  representation of the cryptographic key.

    */
    public func DuplicateKeyHandle() throws -> dotnet.System.Security.Cryptography.SafeEvpPKeyHandle {
        var __thrown : NullableHandle = nil;
        let __return = System_Security_Cryptography_RSAOpenSsl_SafeEvpPKeyHandle__DuplicateKeyHandle_0__0(&__thrown, self.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return dotnet.System.Security.Cryptography.SafeEvpPKeyHandle(hndl : __return);
        }
    }
    // System.Byte[] Encrypt(System.Byte[], System.Security.Cryptography.RSAEncryptionPadding)
// docid: M:System.Security.Cryptography.RSAOpenSsl.Encrypt(System.Byte[],System.Security.Cryptography.RSAEncryptionPadding)
    /**
    Encrypts the input data using the specified padding mode.

    - Parameter data: The data to encrypt.
    - Parameter padding: The padding mode.
    - Returns: The encrypted data.

    */
    public override func Encrypt(data : dotnet.System_Arr<Swift.UInt8>, padding : dotnet.System.Security.Cryptography.RSAEncryptionPadding) throws -> dotnet.System_Arr<Swift.UInt8> {
        var __thrown : NullableHandle = nil;
        let __return = System_Security_Cryptography_RSAOpenSsl_u8Array__Encrypt_0__2__u8Array_RSAEncryptionPadding(&__thrown, self.get_handle(), data.get_handle(), padding.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return dotnet.System_Arr<Swift.UInt8>(hndl : __return);
        }
    }
    // System.Security.Cryptography.RSAParameters ExportParameters(bool)
// docid: M:System.Security.Cryptography.RSAOpenSsl.ExportParameters(System.Boolean)
    /**
    Exports the .

    - Parameter includePrivateParameters: 
         to include private parameters; otherwise, .
    - Returns: The parameters for .

    */
    public override func ExportParameters(includePrivateParameters : Bool) throws -> dotnet.System.Security.Cryptography.RSAParameters {
        var __thrown : NullableHandle = nil;
        let __return = System_Security_Cryptography_RSAOpenSsl_RSAParameters__ExportParameters_0__1__bool(&__thrown, self.get_handle(), Swift.Int32(includePrivateParameters ? 1 : 0));
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return dotnet.System.Security.Cryptography.RSAParameters(hndl : __return);
        }
    }
    // void ImportParameters(System.Security.Cryptography.RSAParameters)
// docid: M:System.Security.Cryptography.RSAOpenSsl.ImportParameters(System.Security.Cryptography.RSAParameters)
    /**
    Imports the specified .

    - Parameter parameters: The parameters for .
    */
    public override func ImportParameters(parameters : dotnet.System.Security.Cryptography.RSAParameters) throws {
        var __thrown : NullableHandle = nil;
        System_Security_Cryptography_RSAOpenSsl_void__ImportParameters_0__1__RSAParameters(&__thrown, self.get_handle(), parameters.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
            return;
        }
    }
    // System.Byte[] SignHash(System.Byte[], System.Security.Cryptography.HashAlgorithmName, System.Security.Cryptography.RSASignaturePadding)
// docid: M:System.Security.Cryptography.RSAOpenSsl.SignHash(System.Byte[],System.Security.Cryptography.HashAlgorithmName,System.Security.Cryptography.RSASignaturePadding)
    /**
    Computes the signature for the specified hash value using the specified padding.

    - Parameter hash: The hash value of the data to be signed.
    - Parameter hashAlgorithm: The hash algorithm used to create the hash value of the data.
    - Parameter padding: The padding.
    - Returns: The RSA signature for the specified hash value.

    */
    public override func SignHash(hash : dotnet.System_Arr<Swift.UInt8>, hashAlgorithm : dotnet.System.Security.Cryptography.HashAlgorithmName, padding : dotnet.System.Security.Cryptography.RSASignaturePadding) throws -> dotnet.System_Arr<Swift.UInt8> {
        var __thrown : NullableHandle = nil;
        let __return = System_Security_Cryptography_RSAOpenSsl_u8Array__SignHash_0__3__u8Array_HashAlgorithmName_RSASignaturePadding(&__thrown, self.get_handle(), hash.get_handle(), hashAlgorithm.get_handle(), padding.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return dotnet.System_Arr<Swift.UInt8>(hndl : __return);
        }
    }
    // bool VerifyHash(System.Byte[], System.Byte[], System.Security.Cryptography.HashAlgorithmName, System.Security.Cryptography.RSASignaturePadding)
// docid: M:System.Security.Cryptography.RSAOpenSsl.VerifyHash(System.Byte[],System.Byte[],System.Security.Cryptography.HashAlgorithmName,System.Security.Cryptography.RSASignaturePadding)
    /**
    Verifies that a digital signature is valid by determining the hash value in the signature using the specified hash algorithm and padding, and comparing it to the provided hash value.

    - Parameter hash: The hash value of the signed data.
    - Parameter signature: The signature data to be verified.
    - Parameter hashAlgorithm: The hash algorithm used to create the hash value.
    - Parameter padding: The padding mode.
    - Returns: 
         if the signature is valid; otherwise, .

    */
    public override func VerifyHash(hash : dotnet.System_Arr<Swift.UInt8>, signature : dotnet.System_Arr<Swift.UInt8>, hashAlgorithm : dotnet.System.Security.Cryptography.HashAlgorithmName, padding : dotnet.System.Security.Cryptography.RSASignaturePadding) throws -> Bool {
        var __thrown : NullableHandle = nil;
        let __return = System_Security_Cryptography_RSAOpenSsl_bool__VerifyHash_0__4__u8Array_u8Array_HashAlgorithmName_RSASignaturePadding(&__thrown, self.get_handle(), hash.get_handle(), signature.get_handle(), hashAlgorithm.get_handle(), padding.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return (__return) != 0;
        }
    }
    // [IsSpecialName] void set_KeySize(System.Int32)
// docid: M:System.Security.Cryptography.RSAOpenSsl.set_KeySize(System.Int32)
    public override func set_KeySize(value : Swift.Int32) throws {
        var __thrown : NullableHandle = nil;
        System_Security_Cryptography_RSAOpenSsl_void__set_KeySize_0__1__i32(&__thrown, self.get_handle(), value);
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
            return;
        }
    }
    // [IsSpecialName] System.Security.Cryptography.KeySizes[] get_LegalKeySizes()
// docid: M:System.Security.Cryptography.RSAOpenSsl.get_LegalKeySizes
    public override func get_LegalKeySizes() throws -> dotnet.System_Arr<dotnet.System.Security.Cryptography.KeySizes> {
        var __thrown : NullableHandle = nil;
        let __return = System_Security_Cryptography_RSAOpenSsl_KeySizesArray__get_LegalKeySizes_0__0(&__thrown, self.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return dotnet.System_Arr<dotnet.System.Security.Cryptography.KeySizes>(hndl : __return);
        }
    }
    /**
    Gets the key sizes, in bits, that are supported by this implementation of RSA.

    */
    public override var LegalKeySizes : dotnet.System_Arr<dotnet.System.Security.Cryptography.KeySizes> {
        get {
            return try! get_LegalKeySizes();
        }
    }
} // RSAOpenSsl


// type: System.Security.Cryptography.SafeEvpPKeyHandle
    /**
    Represents the  pointer type from OpenSSL.

    */
public final class SafeEvpPKeyHandle
    :
    dotnet.System.Runtime.InteropServices.SafeHandle
{
    public class override func get_type_handle() -> TypeHandle {
        return System_Security_Cryptography_SafeEvpPKeyHandle_get_type_handle();
    }
    public required init(hndl: NonnullHandle) { super.init(hndl: hndl); }
    public required init(gval: GVal) { super.init(gval: gval); }
    // .ctor()
// docid: M:System.Security.Cryptography.SafeEvpPKeyHandle.#ctor
    public init() throws {
        var __thrown : NullableHandle = nil;
        let h = System_Security_Cryptography_SafeEvpPKeyHandle_ctor_0__0(&__thrown);
        if let __ex = __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
            super.init(hndl: h);
        }
    }
    // .ctor(System.IntPtr, bool)
// docid: M:System.Security.Cryptography.SafeEvpPKeyHandle.#ctor(System.IntPtr,System.Boolean)
    /**
    Initializes a new instance of the  class with the specified handle value.

    - Parameter handle: The handle value to represent.
    - Parameter ownsHandle: 
         to reliably let  release the handle during the finalization phase; otherwise,  (not recommended).
    */
    public init(handle : dotnet.System.IntPtr, ownsHandle : Bool) throws {
        var __thrown : NullableHandle = nil;
        let h = System_Security_Cryptography_SafeEvpPKeyHandle_ctor_0__2__IntPtr_bool(&__thrown, handle.get_value(), Swift.Int32(ownsHandle ? 1 : 0));
        if let __ex = __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
            super.init(hndl: h);
        }
    }
    // System.Security.Cryptography.SafeEvpPKeyHandle DuplicateHandle()
// docid: M:System.Security.Cryptography.SafeEvpPKeyHandle.DuplicateHandle
    /**
    Creates another instance of this type which has an independent lifetime but tracks the same resource.

    - Returns: Another instance of this type which has an independent lifetime but tracks the same resource.

    */
    public func DuplicateHandle() throws -> dotnet.System.Security.Cryptography.SafeEvpPKeyHandle {
        var __thrown : NullableHandle = nil;
        let __return = System_Security_Cryptography_SafeEvpPKeyHandle_SafeEvpPKeyHandle__DuplicateHandle_0__0(&__thrown, self.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return dotnet.System.Security.Cryptography.SafeEvpPKeyHandle(hndl : __return);
        }
    }
    // [IsSpecialName] System.Int64 get_OpenSslVersion()
// docid: M:System.Security.Cryptography.SafeEvpPKeyHandle.get_OpenSslVersion
    public class func get_OpenSslVersion() throws -> Swift.Int64 {
        var __thrown : NullableHandle = nil;
        let __return = System_Security_Cryptography_SafeEvpPKeyHandle_i64__get_OpenSslVersion_0__0(&__thrown);
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return __return;
        }
    }
    // [IsSpecialName] bool get_IsInvalid()
// docid: M:System.Security.Cryptography.SafeEvpPKeyHandle.get_IsInvalid
    public override func get_IsInvalid() throws -> Bool {
        var __thrown : NullableHandle = nil;
        let __return = System_Security_Cryptography_SafeEvpPKeyHandle_bool__get_IsInvalid_0__0(&__thrown, self.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return (__return) != 0;
        }
    }
    /**
    Gets a value indicating whether the handle value is invalid.

    */
    public override var IsInvalid : Bool {
        get {
            return try! get_IsInvalid();
        }
    }
    /**
    Gets a value representing the version number as reported by the loaded version of OpenSSL.

    */
    public static var OpenSslVersion : Swift.Int64 {
        get {
            return try! get_OpenSslVersion();
        }
    }
} // SafeEvpPKeyHandle


}



