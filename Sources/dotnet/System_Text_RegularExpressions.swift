// this file is automatically generated
// Copyright 2021 SourceGear

import jumptable_dotnet;

// System
// System.Text
// System.Text.RegularExpressions
extension System.Text.RegularExpressions {
// type: System.Text.RegularExpressions.Capture
    /**
    Represents the results from a single successful subexpression capture.

    */
open class Capture
    :
    dotnet.System.Object
{
    open class override func get_type_handle() -> TypeHandle {
        return System_Text_RegularExpressions_Capture_get_type_handle();
    }
    public required init(hndl: NonnullHandle) { super.init(hndl: hndl); }
    public required init(gval: GVal) { super.init(gval: gval); }
    // System.String ToString()
// docid: M:System.Text.RegularExpressions.Capture.ToString
    /**
    Retrieves the captured substring from the input string by calling the  property.

    - Returns: The substring that was captured by the match.

    */
    open override func ToString() throws -> dotnet.System.String {
        var __thrown : NullableHandle = nil;
        let __return = System_Text_RegularExpressions_Capture_String__ToString_0__0(&__thrown, self.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return dotnet.System.String(hndl : __return);
        }
    }
    // [IsSpecialName] System.Int32 get_Index()
// docid: M:System.Text.RegularExpressions.Capture.get_Index
    open func get_Index() throws -> Swift.Int32 {
        var __thrown : NullableHandle = nil;
        let __return = System_Text_RegularExpressions_Capture_i32__get_Index_0__0(&__thrown, self.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return __return;
        }
    }
    // [IsSpecialName] System.Int32 get_Length()
// docid: M:System.Text.RegularExpressions.Capture.get_Length
    open func get_Length() throws -> Swift.Int32 {
        var __thrown : NullableHandle = nil;
        let __return = System_Text_RegularExpressions_Capture_i32__get_Length_0__0(&__thrown, self.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return __return;
        }
    }
    // [IsSpecialName] System.String get_Value()
// docid: M:System.Text.RegularExpressions.Capture.get_Value
    open func get_Value() throws -> dotnet.System.String {
        var __thrown : NullableHandle = nil;
        let __return = System_Text_RegularExpressions_Capture_String__get_Value_0__0(&__thrown, self.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return dotnet.System.String(hndl : __return);
        }
    }
    /**
    The position in the original string where the first character of the captured substring is found.

    */
    open var Index : Swift.Int32 {
        get {
            return try! get_Index();
        }
    }
    /**
    Gets the length of the captured substring.

    */
    open var Length : Swift.Int32 {
        get {
            return try! get_Length();
        }
    }
    /**
    Gets the captured substring from the input string.

    */
    open var Value : dotnet.System.String {
        get {
            return try! get_Value();
        }
    }
} // Capture


// type: System.Text.RegularExpressions.CaptureCollection
    /**
    Represents the set of captures made by a single capturing group. The collection is immutable (read-only) and has no public constructor.

    */
open class CaptureCollection
    :
    dotnet.System.Object,
    System_Collections_IEnumerable,
    System_Collections_ICollection,
    System_Collections_IList
{
    open class override func get_type_handle() -> TypeHandle {
        return System_Text_RegularExpressions_CaptureCollection_get_type_handle();
    }
    public required init(hndl: NonnullHandle) { super.init(hndl: hndl); }
    public required init(gval: GVal) { super.init(gval: gval); }
    // void CopyTo(System.Array, System.Int32)
// docid: M:System.Text.RegularExpressions.CaptureCollection.CopyTo(System.Array,System.Int32)
    /**
    Copies all the elements of the collection to the given array beginning at the given index.

    - Parameter array: The array the collection is to be copied into.
    - Parameter arrayIndex: The position in the destination array where copying is to begin.
    */
    open /* method final */ func CopyTo(array : dotnet.System.Array, arrayIndex : Swift.Int32) throws {
        var __thrown : NullableHandle = nil;
        System_Text_RegularExpressions_CaptureCollection_void__CopyTo_0__2__Array_i32(&__thrown, self.get_handle(), array.get_handle(), arrayIndex);
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
            return;
        }
    }
    // void CopyTo(System.Text.RegularExpressions.Capture[], System.Int32)
// docid: M:System.Text.RegularExpressions.CaptureCollection.CopyTo(System.Text.RegularExpressions.Capture[],System.Int32)
    /**
    Copies the elements of the collection to an , starting at a particular  index.

    - Parameter array: The one-dimensional  that is the destination of the elements copied from the collection. The  must have zero-based indexing.
    - Parameter arrayIndex: The zero-based index in  at which copying begins.
    */
    open /* method final */ func CopyTo(array : dotnet.System_Arr<dotnet.System.Text.RegularExpressions.Capture>, arrayIndex : Swift.Int32) throws {
        var __thrown : NullableHandle = nil;
        System_Text_RegularExpressions_CaptureCollection_void__CopyTo_0__2__CaptureArray_i32(&__thrown, self.get_handle(), array.get_handle(), arrayIndex);
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
            return;
        }
    }
    // System.Collections.IEnumerator GetEnumerator()
// docid: M:System.Text.RegularExpressions.CaptureCollection.GetEnumerator
    /**
    Provides an enumerator that iterates through the collection.

    - Returns: An object that contains all  objects within the .

    */
    open /* method final */ func GetEnumerator() throws -> dotnet.System.Collections.IEnumerator {
        var __thrown : NullableHandle = nil;
        let __return = System_Text_RegularExpressions_CaptureCollection_IEnumerator__GetEnumerator_0__0(&__thrown, self.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return dotnet.System.Collections.IEnumerator(hndl : __return);
        }
    }
    // [IsSpecialName] System.Int32 get_Count()
// docid: M:System.Text.RegularExpressions.CaptureCollection.get_Count
    open /* method final */ func get_Count() throws -> Swift.Int32 {
        var __thrown : NullableHandle = nil;
        let __return = System_Text_RegularExpressions_CaptureCollection_i32__get_Count_0__0(&__thrown, self.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return __return;
        }
    }
    // [IsSpecialName] bool get_IsReadOnly()
// docid: M:System.Text.RegularExpressions.CaptureCollection.get_IsReadOnly
    open /* method final */ func get_IsReadOnly() throws -> Bool {
        var __thrown : NullableHandle = nil;
        let __return = System_Text_RegularExpressions_CaptureCollection_bool__get_IsReadOnly_0__0(&__thrown, self.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return (__return) != 0;
        }
    }
    // [IsSpecialName] bool get_IsSynchronized()
// docid: M:System.Text.RegularExpressions.CaptureCollection.get_IsSynchronized
    open /* method final */ func get_IsSynchronized() throws -> Bool {
        var __thrown : NullableHandle = nil;
        let __return = System_Text_RegularExpressions_CaptureCollection_bool__get_IsSynchronized_0__0(&__thrown, self.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return (__return) != 0;
        }
    }
    // [IsSpecialName] System.Object get_SyncRoot()
// docid: M:System.Text.RegularExpressions.CaptureCollection.get_SyncRoot
    open /* method final */ func get_SyncRoot() throws -> dotnet.System.Object {
        var __thrown : NullableHandle = nil;
        let __return = System_Text_RegularExpressions_CaptureCollection_Object__get_SyncRoot_0__0(&__thrown, self.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return dotnet.System.Object(hndl : __return);
        }
    }
    // [IsSpecialName] System.Text.RegularExpressions.Capture get_Item(System.Int32)
// docid: M:System.Text.RegularExpressions.CaptureCollection.get_Item(System.Int32)
//BEGIN method_is_override
//matches_1
//matches :
    open /* method final */ func get_Item(i : Swift.Int32) throws -> dotnet.System.Text.RegularExpressions.Capture {
        var __thrown : NullableHandle = nil;
        let __return = System_Text_RegularExpressions_CaptureCollection_Capture__get_Item_0__1__i32(&__thrown, self.get_handle(), i);
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return dotnet.System.Text.RegularExpressions.Capture(hndl : __return);
        }
    }
    /**
    Gets the number of substrings captured by the group.

    */
    public var Count : Swift.Int32 {
        get {
            return try! get_Count();
        }
    }
    /**
    Gets a value that indicates whether the collection is read only.

    */
    public var IsReadOnly : Bool {
        get {
            return try! get_IsReadOnly();
        }
    }
    /**
    Gets a value that indicates whether access to the collection is synchronized (thread-safe).

    */
    public var IsSynchronized : Bool {
        get {
            return try! get_IsSynchronized();
        }
    }
    /**
    Gets an object that can be used to synchronize access to the collection.

    */
    public var SyncRoot : dotnet.System.Object {
        get {
            return try! get_SyncRoot();
        }
    }
} // CaptureCollection


// type: System.Text.RegularExpressions.Group
    /**
    Represents the results from a single capturing group.

    */
open class Group
    :
    dotnet.System.Text.RegularExpressions.Capture
{
    open class override func get_type_handle() -> TypeHandle {
        return System_Text_RegularExpressions_Group_get_type_handle();
    }
    public required init(hndl: NonnullHandle) { super.init(hndl: hndl); }
    public required init(gval: GVal) { super.init(gval: gval); }
    // System.Text.RegularExpressions.Group Synchronized(System.Text.RegularExpressions.Group)
// docid: M:System.Text.RegularExpressions.Group.Synchronized(System.Text.RegularExpressions.Group)
    /**
    Returns a  object equivalent to the one supplied that is safe to share between multiple threads.

    - Parameter inner: The input  object.
    - Returns: A regular expression  object.

    */
    open class func Synchronized(inner : dotnet.System.Text.RegularExpressions.Group) throws -> dotnet.System.Text.RegularExpressions.Group {
        var __thrown : NullableHandle = nil;
        let __return = System_Text_RegularExpressions_Group_Group__Synchronized_0__1__Group(&__thrown, inner.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return dotnet.System.Text.RegularExpressions.Group(hndl : __return);
        }
    }
    // [IsSpecialName] System.Text.RegularExpressions.CaptureCollection get_Captures()
// docid: M:System.Text.RegularExpressions.Group.get_Captures
    open func get_Captures() throws -> dotnet.System.Text.RegularExpressions.CaptureCollection {
        var __thrown : NullableHandle = nil;
        let __return = System_Text_RegularExpressions_Group_CaptureCollection__get_Captures_0__0(&__thrown, self.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return dotnet.System.Text.RegularExpressions.CaptureCollection(hndl : __return);
        }
    }
    // [IsSpecialName] System.String get_Name()
// docid: M:System.Text.RegularExpressions.Group.get_Name
    open func get_Name() throws -> dotnet.System.String {
        var __thrown : NullableHandle = nil;
        let __return = System_Text_RegularExpressions_Group_String__get_Name_0__0(&__thrown, self.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return dotnet.System.String(hndl : __return);
        }
    }
    // [IsSpecialName] bool get_Success()
// docid: M:System.Text.RegularExpressions.Group.get_Success
    open func get_Success() throws -> Bool {
        var __thrown : NullableHandle = nil;
        let __return = System_Text_RegularExpressions_Group_bool__get_Success_0__0(&__thrown, self.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return (__return) != 0;
        }
    }
    /**
    Gets a collection of all the captures matched by the capturing group, in innermost-leftmost-first order (or innermost-rightmost-first order if the regular expression is modified with the  option). The collection may have zero or more items.

    */
    open var Captures : dotnet.System.Text.RegularExpressions.CaptureCollection {
        get {
            return try! get_Captures();
        }
    }
    /**
    Returns the name of the capturing group represented by the current instance.

    */
    open var Name : dotnet.System.String {
        get {
            return try! get_Name();
        }
    }
    /**
    Gets a value indicating whether the match is successful.

    */
    open var Success : Bool {
        get {
            return try! get_Success();
        }
    }
} // Group


// type: System.Text.RegularExpressions.GroupCollection
    /**
    Returns the set of captured groups in a single match. The collection is immutable (read-only) and has no public constructor.

    */
open class GroupCollection
    :
    dotnet.System.Object,
    System_Collections_IEnumerable,
    System_Collections_ICollection,
    System_Collections_IList
{
    open class override func get_type_handle() -> TypeHandle {
        return System_Text_RegularExpressions_GroupCollection_get_type_handle();
    }
    public required init(hndl: NonnullHandle) { super.init(hndl: hndl); }
    public required init(gval: GVal) { super.init(gval: gval); }
    // bool ContainsKey(System.String)
// docid: M:System.Text.RegularExpressions.GroupCollection.ContainsKey(System.String)
    /**
    Determines whether the group collection contains a captured group identified by the specified name.

    - Parameter key: A string with the name of the captured group to locate.
    - Returns: 
         if the group collection contains a captured group identified by ;  otherwise.

    */
    open /* method final */ func ContainsKey(key : dotnet.System.String) throws -> Bool {
        var __thrown : NullableHandle = nil;
        let __return = System_Text_RegularExpressions_GroupCollection_bool__ContainsKey_0__1__String(&__thrown, self.get_handle(), key.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return (__return) != 0;
        }
    }
    // void CopyTo(System.Array, System.Int32)
// docid: M:System.Text.RegularExpressions.GroupCollection.CopyTo(System.Array,System.Int32)
    /**
    Copies all the elements of the collection to the given array beginning at the given index.

    - Parameter array: The array the collection is to be copied into.
    - Parameter arrayIndex: The position in the destination array where the copying is to begin.
    */
    open /* method final */ func CopyTo(array : dotnet.System.Array, arrayIndex : Swift.Int32) throws {
        var __thrown : NullableHandle = nil;
        System_Text_RegularExpressions_GroupCollection_void__CopyTo_0__2__Array_i32(&__thrown, self.get_handle(), array.get_handle(), arrayIndex);
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
            return;
        }
    }
    // void CopyTo(System.Text.RegularExpressions.Group[], System.Int32)
// docid: M:System.Text.RegularExpressions.GroupCollection.CopyTo(System.Text.RegularExpressions.Group[],System.Int32)
    /**
    Copies the elements of the group collection to a  array, starting at a particular array index.

    - Parameter array: The one-dimensional array that is the destination of the elements copied from the group collection. The array must have zero-based indexing.
    - Parameter arrayIndex: The zero-based index in  at which copying begins.
    */
    open /* method final */ func CopyTo(array : dotnet.System_Arr<dotnet.System.Text.RegularExpressions.Group>, arrayIndex : Swift.Int32) throws {
        var __thrown : NullableHandle = nil;
        System_Text_RegularExpressions_GroupCollection_void__CopyTo_0__2__GroupArray_i32(&__thrown, self.get_handle(), array.get_handle(), arrayIndex);
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
            return;
        }
    }
    // System.Collections.IEnumerator GetEnumerator()
// docid: M:System.Text.RegularExpressions.GroupCollection.GetEnumerator
    /**
    Provides an enumerator that iterates through the collection.

    - Returns: An enumerator that contains all  objects in the .

    */
    open /* method final */ func GetEnumerator() throws -> dotnet.System.Collections.IEnumerator {
        var __thrown : NullableHandle = nil;
        let __return = System_Text_RegularExpressions_GroupCollection_IEnumerator__GetEnumerator_0__0(&__thrown, self.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return dotnet.System.Collections.IEnumerator(hndl : __return);
        }
    }
    // bool TryGetValue(System.String, ref System.Text.RegularExpressions.Group)
// docid: M:System.Text.RegularExpressions.GroupCollection.TryGetValue(System.String,System.Text.RegularExpressions.Group@)
    /**
    Attempts to retrieve a group identified by the provided name key, if it exists in the group collection.

    - Parameter key: A string with the group name key to look for.
    - Parameter value: When the method returns, the group whose name is , if it is found; otherwise,  if not found.
    - Returns: 
         if a group identified by the provided name key exists;  otherwise.

    */
    open /* method final */ func TryGetValue(key : dotnet.System.String, value : inout dotnet.System.Text.RegularExpressions.Group) throws -> Bool {
        var __thrown : NullableHandle = nil;
            var _tmp_out_value = value.get_handle();
        let __return = System_Text_RegularExpressions_GroupCollection_bool__TryGetValue_0__2__String_outGroup(&__thrown, self.get_handle(), key.get_handle(), &_tmp_out_value);
        let _tmp2_value = dotnet.System.Text.RegularExpressions.Group(hndl: _tmp_out_value);
            value = _tmp2_value;
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return (__return) != 0;
        }
    }
    // [IsSpecialName] System.Int32 get_Count()
// docid: M:System.Text.RegularExpressions.GroupCollection.get_Count
    open /* method final */ func get_Count() throws -> Swift.Int32 {
        var __thrown : NullableHandle = nil;
        let __return = System_Text_RegularExpressions_GroupCollection_i32__get_Count_0__0(&__thrown, self.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return __return;
        }
    }
    // [IsSpecialName] bool get_IsReadOnly()
// docid: M:System.Text.RegularExpressions.GroupCollection.get_IsReadOnly
    open /* method final */ func get_IsReadOnly() throws -> Bool {
        var __thrown : NullableHandle = nil;
        let __return = System_Text_RegularExpressions_GroupCollection_bool__get_IsReadOnly_0__0(&__thrown, self.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return (__return) != 0;
        }
    }
    // [IsSpecialName] bool get_IsSynchronized()
// docid: M:System.Text.RegularExpressions.GroupCollection.get_IsSynchronized
    open /* method final */ func get_IsSynchronized() throws -> Bool {
        var __thrown : NullableHandle = nil;
        let __return = System_Text_RegularExpressions_GroupCollection_bool__get_IsSynchronized_0__0(&__thrown, self.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return (__return) != 0;
        }
    }
    // [IsSpecialName] System.Collections.Generic.IEnumerable<System.String> get_Keys()
// docid: M:System.Text.RegularExpressions.GroupCollection.get_Keys
    open /* method final */ func get_Keys() throws -> dotnet.System.Collections.Generic.IEnumerable_1<dotnet.System.String> {
        var __thrown : NullableHandle = nil;
        let __return = System_Text_RegularExpressions_GroupCollection_System_Collections_Generic_IEnumerable_string___get_Keys_0__0(&__thrown, self.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return dotnet.System.Collections.Generic.IEnumerable_1(hndl : __return);
        }
    }
    // [IsSpecialName] System.Object get_SyncRoot()
// docid: M:System.Text.RegularExpressions.GroupCollection.get_SyncRoot
    open /* method final */ func get_SyncRoot() throws -> dotnet.System.Object {
        var __thrown : NullableHandle = nil;
        let __return = System_Text_RegularExpressions_GroupCollection_Object__get_SyncRoot_0__0(&__thrown, self.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return dotnet.System.Object(hndl : __return);
        }
    }
    // [IsSpecialName] System.Collections.Generic.IEnumerable<System.Text.RegularExpressions.Group> get_Values()
// docid: M:System.Text.RegularExpressions.GroupCollection.get_Values
    open /* method final */ func get_Values() throws -> dotnet.System.Collections.Generic.IEnumerable_1<dotnet.System.Text.RegularExpressions.Group> {
        var __thrown : NullableHandle = nil;
        let __return = System_Text_RegularExpressions_GroupCollection_System_Collections_Generic_IEnumerable_System_Text_RegularExpressions_Group___get_Values_0__0(&__thrown, self.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return dotnet.System.Collections.Generic.IEnumerable_1(hndl : __return);
        }
    }
    // [IsSpecialName] System.Text.RegularExpressions.Group get_Item(System.Int32)
// docid: M:System.Text.RegularExpressions.GroupCollection.get_Item(System.Int32)
//BEGIN method_is_override
//matches_1
//matches :
    open /* method final */ func get_Item(groupnum : Swift.Int32) throws -> dotnet.System.Text.RegularExpressions.Group {
        var __thrown : NullableHandle = nil;
        let __return = System_Text_RegularExpressions_GroupCollection_Group__get_Item_0__1__i32(&__thrown, self.get_handle(), groupnum);
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return dotnet.System.Text.RegularExpressions.Group(hndl : __return);
        }
    }
    // [IsSpecialName] System.Text.RegularExpressions.Group get_Item(System.String)
// docid: M:System.Text.RegularExpressions.GroupCollection.get_Item(System.String)
//BEGIN method_is_override
//matches_1
//matches :
    open /* method final */ func get_Item(groupname : dotnet.System.String) throws -> dotnet.System.Text.RegularExpressions.Group {
        var __thrown : NullableHandle = nil;
        let __return = System_Text_RegularExpressions_GroupCollection_Group__get_Item_0__1__String(&__thrown, self.get_handle(), groupname.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return dotnet.System.Text.RegularExpressions.Group(hndl : __return);
        }
    }
    /**
    Returns the number of groups in the collection.

    */
    public var Count : Swift.Int32 {
        get {
            return try! get_Count();
        }
    }
    /**
    Gets a value that indicates whether the collection is read-only.

    */
    public var IsReadOnly : Bool {
        get {
            return try! get_IsReadOnly();
        }
    }
    /**
    Gets a value that indicates whether access to the  is synchronized (thread-safe).

    */
    public var IsSynchronized : Bool {
        get {
            return try! get_IsSynchronized();
        }
    }
    /**
    Gets a string enumeration that contains the name keys of the group collection.

    */
    public var Keys : dotnet.System.Collections.Generic.IEnumerable_1<dotnet.System.String> {
        get {
            return try! get_Keys();
        }
    }
    /**
    Gets an object that can be used to synchronize access to the .

    */
    public var SyncRoot : dotnet.System.Object {
        get {
            return try! get_SyncRoot();
        }
    }
    /**
    Gets a group enumeration with all the groups in the group collection.

    */
    public var Values : dotnet.System.Collections.Generic.IEnumerable_1<dotnet.System.Text.RegularExpressions.Group> {
        get {
            return try! get_Values();
        }
    }
} // GroupCollection


// type: System.Text.RegularExpressions.Match
    /**
    Represents the results from a single regular expression match.

    */
open class Match
    :
    dotnet.System.Text.RegularExpressions.Group
{
    open class override func get_type_handle() -> TypeHandle {
        return System_Text_RegularExpressions_Match_get_type_handle();
    }
    public required init(hndl: NonnullHandle) { super.init(hndl: hndl); }
    public required init(gval: GVal) { super.init(gval: gval); }
    // System.Text.RegularExpressions.Match NextMatch()
// docid: M:System.Text.RegularExpressions.Match.NextMatch
    /**
    Returns a new  object with the results for the next match, starting at the position at which the last match ended (at the character after the last matched character).

    - Returns: The next regular expression match.

    */
    open func NextMatch() throws -> dotnet.System.Text.RegularExpressions.Match {
        var __thrown : NullableHandle = nil;
        let __return = System_Text_RegularExpressions_Match_Match__NextMatch_0__0(&__thrown, self.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return dotnet.System.Text.RegularExpressions.Match(hndl : __return);
        }
    }
    // System.String Result(System.String)
// docid: M:System.Text.RegularExpressions.Match.Result(System.String)
    /**
    Returns the expansion of the specified replacement pattern.

    - Parameter replacement: The replacement pattern to use.
    - Returns: The expanded version of the  parameter.

    */
    open func Result(replacement : dotnet.System.String) throws -> dotnet.System.String {
        var __thrown : NullableHandle = nil;
        let __return = System_Text_RegularExpressions_Match_String__Result_0__1__String(&__thrown, self.get_handle(), replacement.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return dotnet.System.String(hndl : __return);
        }
    }
    // System.Text.RegularExpressions.Match Synchronized(System.Text.RegularExpressions.Match)
// docid: M:System.Text.RegularExpressions.Match.Synchronized(System.Text.RegularExpressions.Match)
    /**
    Returns a  instance equivalent to the one supplied that is suitable to share between multiple threads.

    - Parameter inner: A regular expression match equivalent to the one expected.
    - Returns: A regular expression match that is suitable to share between multiple threads.

    */
    open class func Synchronized(inner : dotnet.System.Text.RegularExpressions.Match) throws -> dotnet.System.Text.RegularExpressions.Match {
        var __thrown : NullableHandle = nil;
        let __return = System_Text_RegularExpressions_Match_Match__Synchronized_0__1__Match(&__thrown, inner.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return dotnet.System.Text.RegularExpressions.Match(hndl : __return);
        }
    }
    // [IsSpecialName] System.Text.RegularExpressions.Match get_Empty()
// docid: M:System.Text.RegularExpressions.Match.get_Empty
    open class func get_Empty() throws -> dotnet.System.Text.RegularExpressions.Match {
        var __thrown : NullableHandle = nil;
        let __return = System_Text_RegularExpressions_Match_Match__get_Empty_0__0(&__thrown);
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return dotnet.System.Text.RegularExpressions.Match(hndl : __return);
        }
    }
    // [IsSpecialName] System.Text.RegularExpressions.GroupCollection get_Groups()
// docid: M:System.Text.RegularExpressions.Match.get_Groups
    open func get_Groups() throws -> dotnet.System.Text.RegularExpressions.GroupCollection {
        var __thrown : NullableHandle = nil;
        let __return = System_Text_RegularExpressions_Match_GroupCollection__get_Groups_0__0(&__thrown, self.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return dotnet.System.Text.RegularExpressions.GroupCollection(hndl : __return);
        }
    }
    /**
    Gets the empty group. All failed matches return this empty match.

    */
    public static var Empty : dotnet.System.Text.RegularExpressions.Match {
        get {
            return try! get_Empty();
        }
    }
    /**
    Gets a collection of groups matched by the regular expression.

    */
    open var Groups : dotnet.System.Text.RegularExpressions.GroupCollection {
        get {
            return try! get_Groups();
        }
    }
} // Match


// type: System.Text.RegularExpressions.MatchCollection
    /**
    Represents the set of successful matches found by iteratively applying a regular expression pattern to the input string.  The collection is immutable (read-only) and has no public constructor. The  method returns a  object.

    */
open class MatchCollection
    :
    dotnet.System.Object,
    System_Collections_IEnumerable,
    System_Collections_ICollection,
    System_Collections_IList
{
    open class override func get_type_handle() -> TypeHandle {
        return System_Text_RegularExpressions_MatchCollection_get_type_handle();
    }
    public required init(hndl: NonnullHandle) { super.init(hndl: hndl); }
    public required init(gval: GVal) { super.init(gval: gval); }
    // void CopyTo(System.Array, System.Int32)
// docid: M:System.Text.RegularExpressions.MatchCollection.CopyTo(System.Array,System.Int32)
    /**
    Copies all the elements of the collection to the given array starting at the given index.

    - Parameter array: The array the collection is to be copied into.
    - Parameter arrayIndex: The position in the array where copying is to begin.
    */
    open /* method final */ func CopyTo(array : dotnet.System.Array, arrayIndex : Swift.Int32) throws {
        var __thrown : NullableHandle = nil;
        System_Text_RegularExpressions_MatchCollection_void__CopyTo_0__2__Array_i32(&__thrown, self.get_handle(), array.get_handle(), arrayIndex);
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
            return;
        }
    }
    // void CopyTo(System.Text.RegularExpressions.Match[], System.Int32)
// docid: M:System.Text.RegularExpressions.MatchCollection.CopyTo(System.Text.RegularExpressions.Match[],System.Int32)
    /**
    Copies the elements of the collection to an , starting at a particular  index.

    - Parameter array: The one-dimensional  that is the destination of the elements copied from the collection. The  must have zero-based indexing.
    - Parameter arrayIndex: The zero-based index in  at which copying begins.
    */
    open /* method final */ func CopyTo(array : dotnet.System_Arr<dotnet.System.Text.RegularExpressions.Match>, arrayIndex : Swift.Int32) throws {
        var __thrown : NullableHandle = nil;
        System_Text_RegularExpressions_MatchCollection_void__CopyTo_0__2__MatchArray_i32(&__thrown, self.get_handle(), array.get_handle(), arrayIndex);
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
            return;
        }
    }
    // System.Collections.IEnumerator GetEnumerator()
// docid: M:System.Text.RegularExpressions.MatchCollection.GetEnumerator
    /**
    Provides an enumerator that iterates through the collection.

    - Returns: An object that contains all  objects within the .

    */
    open /* method final */ func GetEnumerator() throws -> dotnet.System.Collections.IEnumerator {
        var __thrown : NullableHandle = nil;
        let __return = System_Text_RegularExpressions_MatchCollection_IEnumerator__GetEnumerator_0__0(&__thrown, self.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return dotnet.System.Collections.IEnumerator(hndl : __return);
        }
    }
    // [IsSpecialName] System.Int32 get_Count()
// docid: M:System.Text.RegularExpressions.MatchCollection.get_Count
    open /* method final */ func get_Count() throws -> Swift.Int32 {
        var __thrown : NullableHandle = nil;
        let __return = System_Text_RegularExpressions_MatchCollection_i32__get_Count_0__0(&__thrown, self.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return __return;
        }
    }
    // [IsSpecialName] bool get_IsReadOnly()
// docid: M:System.Text.RegularExpressions.MatchCollection.get_IsReadOnly
    open /* method final */ func get_IsReadOnly() throws -> Bool {
        var __thrown : NullableHandle = nil;
        let __return = System_Text_RegularExpressions_MatchCollection_bool__get_IsReadOnly_0__0(&__thrown, self.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return (__return) != 0;
        }
    }
    // [IsSpecialName] bool get_IsSynchronized()
// docid: M:System.Text.RegularExpressions.MatchCollection.get_IsSynchronized
    open /* method final */ func get_IsSynchronized() throws -> Bool {
        var __thrown : NullableHandle = nil;
        let __return = System_Text_RegularExpressions_MatchCollection_bool__get_IsSynchronized_0__0(&__thrown, self.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return (__return) != 0;
        }
    }
    // [IsSpecialName] System.Object get_SyncRoot()
// docid: M:System.Text.RegularExpressions.MatchCollection.get_SyncRoot
    open /* method final */ func get_SyncRoot() throws -> dotnet.System.Object {
        var __thrown : NullableHandle = nil;
        let __return = System_Text_RegularExpressions_MatchCollection_Object__get_SyncRoot_0__0(&__thrown, self.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return dotnet.System.Object(hndl : __return);
        }
    }
    // [IsSpecialName] System.Text.RegularExpressions.Match get_Item(System.Int32)
// docid: M:System.Text.RegularExpressions.MatchCollection.get_Item(System.Int32)
//BEGIN method_is_override
//matches_1
//matches :
    open func get_Item(i : Swift.Int32) throws -> dotnet.System.Text.RegularExpressions.Match {
        var __thrown : NullableHandle = nil;
        let __return = System_Text_RegularExpressions_MatchCollection_Match__get_Item_0__1__i32(&__thrown, self.get_handle(), i);
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return dotnet.System.Text.RegularExpressions.Match(hndl : __return);
        }
    }
    /**
    Gets the number of matches.

    */
    public var Count : Swift.Int32 {
        get {
            return try! get_Count();
        }
    }
    /**
    Gets a value that indicates whether the collection is read only.

    */
    public var IsReadOnly : Bool {
        get {
            return try! get_IsReadOnly();
        }
    }
    /**
    Gets a value indicating whether access to the collection is synchronized (thread-safe).

    */
    public var IsSynchronized : Bool {
        get {
            return try! get_IsSynchronized();
        }
    }
    /**
    Gets an object that can be used to synchronize access to the collection.

    */
    public var SyncRoot : dotnet.System.Object {
        get {
            return try! get_SyncRoot();
        }
    }
} // MatchCollection


// type: System.Text.RegularExpressions.MatchEvaluator
    /**
    Represents the method that is called each time a regular expression match is found during a  method operation.

    */
public final class MatchEvaluator
    :
    dotnet.System.Delegate
{
    public class override func get_type_handle() -> TypeHandle {
        return System_Text_RegularExpressions_MatchEvaluator_get_type_handle();
    }
    public required init(hndl: NonnullHandle) { super.init(hndl: hndl); }
    public required init(gval: GVal) { super.init(gval: gval); }
    // System.String Invoke(System.Text.RegularExpressions.Match)
// docid: M:System.Text.RegularExpressions.MatchEvaluator.Invoke(System.Text.RegularExpressions.Match)
    public func Invoke(match : dotnet.System.Text.RegularExpressions.Match) throws -> dotnet.System.String {
        var __thrown : NullableHandle = nil;
        let __return = System_Text_RegularExpressions_MatchEvaluator_String__Invoke_0__1__Match(&__thrown, self.get_handle(), match.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return dotnet.System.String(hndl : __return);
        }
    }
    // System.IAsyncResult BeginInvoke(System.Text.RegularExpressions.Match, System.AsyncCallback, System.Object)
// docid: M:System.Text.RegularExpressions.MatchEvaluator.BeginInvoke(System.Text.RegularExpressions.Match,System.AsyncCallback,System.Object)
    public func BeginInvoke(match : dotnet.System.Text.RegularExpressions.Match, callback : Optional<dotnet.System.AsyncCallback>, object : Optional<dotnet.System.Object>) throws -> Optional<dotnet.System.IAsyncResult> {
        var __thrown : NullableHandle = nil;
        let __return = System_Text_RegularExpressions_MatchEvaluator_IAsyncResult__BeginInvoke_0__3__Match_AsyncCallback_Object(&__thrown, self.get_handle(), match.get_handle(), callback?.get_handle() ?? nil, object?.get_handle() ?? nil);
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        if let __ret_unwrapped = __return {
            return dotnet.System.IAsyncResult(hndl : __ret_unwrapped);
        } else {
            return nil;
        }
        }
    }
    // System.String EndInvoke(System.IAsyncResult)
// docid: M:System.Text.RegularExpressions.MatchEvaluator.EndInvoke(System.IAsyncResult)
    public func EndInvoke(result : Optional<dotnet.System.IAsyncResult>) throws -> dotnet.System.String {
        var __thrown : NullableHandle = nil;
        let __return = System_Text_RegularExpressions_MatchEvaluator_String__EndInvoke_0__1__IAsyncResult(&__thrown, self.get_handle(), result?.get_handle() ?? nil);
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return dotnet.System.String(hndl : __return);
        }
    }
    public init(_ callback : @escaping (dotnet.System.Text.RegularExpressions.Match) throws -> dotnet.System.String) throws
    {
        let __bridge : (UnsafeMutablePointer<NullableHandle>, NonnullHandle) -> NonnullHandle =
        {
            (thrown : UnsafeMutablePointer<NullableHandle>, match : NonnullHandle) -> NonnullHandle in
            do
            {
                thrown.pointee = nil;
                let ret = try callback(dotnet.System.Text.RegularExpressions.Match(hndl: match));
                return __copy_handle(ret.get_handle());
            }
            catch let e as dotnet.System.Exception
            {
                thrown.pointee = __copy_handle(e.get_handle());
                return NonnullHandle(bitPattern: 8675309)!;
            }
            catch
            {
                let e = try! dotnet.System.Exception(message: "TODO fail inside closure");
                thrown.pointee = __copy_handle(e.get_handle());
                return NonnullHandle(bitPattern: 8675309)!;
            }
        };
        let cbarg = UnsafeRawPointer(Unmanaged.passRetained(__bridge as AnyObject).toOpaque());
        func __cb(cb : UnsafeRawPointer?, thrown : UnsafeMutablePointer<NullableHandle>, match : NonnullHandle) -> NonnullHandle
        {
            let f = Unmanaged<AnyObject>.fromOpaque(cb!).takeUnretainedValue() as! (UnsafeMutablePointer<NullableHandle>, NonnullHandle) -> NonnullHandle;
            return f(thrown, match);
        }
        var __thrown : NullableHandle = nil;
        let h = System_Text_RegularExpressions_MatchEvaluator_create(
            &__thrown,
            cbarg,
            nil, // TODO deinit
            __cb
            );
            // TODO check thrown
        if let __ex = __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
            super.init(hndl: h);
        }
    }
    // System.String Invoke(System.Text.RegularExpressions.Match)
// docid: M:System.Text.RegularExpressions.MatchEvaluator.Invoke(System.Text.RegularExpressions.Match)
    public func callAsFunction(match : dotnet.System.Text.RegularExpressions.Match) throws -> dotnet.System.String {
        var __thrown : NullableHandle = nil;
        let __return = System_Text_RegularExpressions_MatchEvaluator_String__Invoke_0__1__Match(&__thrown, self.get_handle(), match.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return dotnet.System.String(hndl : __return);
        }
    }
} // MatchEvaluator


// type: System.Text.RegularExpressions.Regex
    /**
    Represents an immutable regular expression.

    */
open class Regex
    :
    dotnet.System.Object,
    System_Runtime_Serialization_ISerializable
{
    open class override func get_type_handle() -> TypeHandle {
        return System_Text_RegularExpressions_Regex_get_type_handle();
    }
    public required init(hndl: NonnullHandle) { super.init(hndl: hndl); }
    public required init(gval: GVal) { super.init(gval: gval); }
    // static field: System.TimeSpan InfiniteMatchTimeout
    /**
    Specifies that a pattern-matching operation should not time out.

    */
    open class var InfiniteMatchTimeout : dotnet.System.TimeSpan {
        get {
        let __return = dotnet.System.TimeSpan(hndl: System_Text_RegularExpressions_Regex_get_InfiniteMatchTimeout());
            return __return;
        }
    }
    // .ctor(System.String)
// docid: M:System.Text.RegularExpressions.Regex.#ctor(System.String)
    /**
    Initializes a new instance of the  class for the specified regular expression.

    - Parameter pattern: The regular expression pattern to match.
    */
    public init(pattern : dotnet.System.String) throws {
        var __thrown : NullableHandle = nil;
        let h = System_Text_RegularExpressions_Regex_ctor_0__1__String(&__thrown, pattern.get_handle());
        if let __ex = __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
            super.init(hndl: h);
        }
    }
    // .ctor(System.String, System.Text.RegularExpressions.RegexOptions)
// docid: M:System.Text.RegularExpressions.Regex.#ctor(System.String,System.Text.RegularExpressions.RegexOptions)
    /**
    Initializes a new instance of the  class for the specified regular expression, with options that modify the pattern.

    - Parameter pattern: The regular expression pattern to match.
    - Parameter options: A bitwise combination of the enumeration values that modify the regular expression.
    */
    public init(pattern : dotnet.System.String, options : dotnet.System.Text.RegularExpressions.RegexOptions) throws {
        var __thrown : NullableHandle = nil;
        let h = System_Text_RegularExpressions_Regex_ctor_0__2__String_RegexOptions(&__thrown, pattern.get_handle(), options.get_value());
        if let __ex = __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
            super.init(hndl: h);
        }
    }
// TODO COPE ctor (span) .ctor(System.String, System.Text.RegularExpressions.RegexOptions, System.TimeSpan)
    // void CompileToAssembly(System.Text.RegularExpressions.RegexCompilationInfo[], System.Reflection.AssemblyName)
// docid: M:System.Text.RegularExpressions.Regex.CompileToAssembly(System.Text.RegularExpressions.RegexCompilationInfo[],System.Reflection.AssemblyName)
    /**
    Compiles one or more specified  objects to a named assembly.

    - Parameter regexinfos: An array that describes the regular expressions to compile.
    - Parameter assemblyname: The file name of the assembly.
    */
    open class func CompileToAssembly(regexinfos : dotnet.System_Arr<dotnet.System.Text.RegularExpressions.RegexCompilationInfo>, assemblyname : dotnet.System.Reflection.AssemblyName) throws {
        var __thrown : NullableHandle = nil;
        System_Text_RegularExpressions_Regex_void__CompileToAssembly_0__2__RegexCompilationInfoArray_AssemblyName(&__thrown, regexinfos.get_handle(), assemblyname.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
            return;
        }
    }
    // void CompileToAssembly(System.Text.RegularExpressions.RegexCompilationInfo[], System.Reflection.AssemblyName, System.Reflection.Emit.CustomAttributeBuilder[])
// docid: M:System.Text.RegularExpressions.Regex.CompileToAssembly(System.Text.RegularExpressions.RegexCompilationInfo[],System.Reflection.AssemblyName,System.Reflection.Emit.CustomAttributeBuilder[])
    /**
    Compiles one or more specified  objects to a named assembly with the specified attributes.

    - Parameter regexinfos: An array that describes the regular expressions to compile.
    - Parameter assemblyname: The file name of the assembly.
    - Parameter attributes: An array that defines the attributes to apply to the assembly.
    */
    open class func CompileToAssembly(regexinfos : dotnet.System_Arr<dotnet.System.Text.RegularExpressions.RegexCompilationInfo>, assemblyname : dotnet.System.Reflection.AssemblyName, attributes : Optional<dotnet.System_Arr<dotnet.System.Reflection.Emit.CustomAttributeBuilder>>) throws {
        var __thrown : NullableHandle = nil;
        System_Text_RegularExpressions_Regex_void__CompileToAssembly_0__3__RegexCompilationInfoArray_AssemblyName_CustomAttributeBuilderArray(&__thrown, regexinfos.get_handle(), assemblyname.get_handle(), (attributes?.get_handle()));
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
            return;
        }
    }
    // void CompileToAssembly(System.Text.RegularExpressions.RegexCompilationInfo[], System.Reflection.AssemblyName, System.Reflection.Emit.CustomAttributeBuilder[], System.String)
// docid: M:System.Text.RegularExpressions.Regex.CompileToAssembly(System.Text.RegularExpressions.RegexCompilationInfo[],System.Reflection.AssemblyName,System.Reflection.Emit.CustomAttributeBuilder[],System.String)
    /**
    Compiles one or more specified  objects and a specified resource file to a named assembly with the specified attributes.

    - Parameter regexinfos: An array that describes the regular expressions to compile.
    - Parameter assemblyname: The file name of the assembly.
    - Parameter attributes: An array that defines the attributes to apply to the assembly.
    - Parameter resourceFile: The name of the Win32 resource file to include in the assembly.
    */
    open class func CompileToAssembly(regexinfos : dotnet.System_Arr<dotnet.System.Text.RegularExpressions.RegexCompilationInfo>, assemblyname : dotnet.System.Reflection.AssemblyName, attributes : Optional<dotnet.System_Arr<dotnet.System.Reflection.Emit.CustomAttributeBuilder>>, resourceFile : Optional<dotnet.System.String>) throws {
        var __thrown : NullableHandle = nil;
        System_Text_RegularExpressions_Regex_void__CompileToAssembly_0__4__RegexCompilationInfoArray_AssemblyName_CustomAttributeBuilderArray_String(&__thrown, regexinfos.get_handle(), assemblyname.get_handle(), (attributes?.get_handle()), resourceFile?.get_handle() ?? nil);
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
            return;
        }
    }
    // System.String Escape(System.String)
// docid: M:System.Text.RegularExpressions.Regex.Escape(System.String)
    /**
    Escapes a minimal set of characters (\, (ASTERISK), +, ?, |, {, [, (,), ^, $, ., #, and white space) by replacing them with their escape codes. This instructs the regular expression engine to interpret these characters literally rather than as metacharacters.

    - Parameter str: The input string that contains the text to convert.
    - Returns: A string of characters with metacharacters converted to their escaped form.

    */
    open class func Escape(str : dotnet.System.String) throws -> dotnet.System.String {
        var __thrown : NullableHandle = nil;
        let __return = System_Text_RegularExpressions_Regex_String__Escape_0__1__String(&__thrown, str.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return dotnet.System.String(hndl : __return);
        }
    }
    // System.String[] GetGroupNames()
// docid: M:System.Text.RegularExpressions.Regex.GetGroupNames
    /**
    Returns an array of capturing group names for the regular expression.

    - Returns: A string array of group names.

    */
    open func GetGroupNames() throws -> dotnet.System_Arr<dotnet.System.String> {
        var __thrown : NullableHandle = nil;
        let __return = System_Text_RegularExpressions_Regex_StringArray__GetGroupNames_0__0(&__thrown, self.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return dotnet.System_Arr<dotnet.System.String>(hndl : __return);
        }
    }
    // System.Int32[] GetGroupNumbers()
// docid: M:System.Text.RegularExpressions.Regex.GetGroupNumbers
    /**
    Returns an array of capturing group numbers that correspond to group names in an array.

    - Returns: An integer array of group numbers.

    */
    open func GetGroupNumbers() throws -> dotnet.System_Arr<Swift.Int32> {
        var __thrown : NullableHandle = nil;
        let __return = System_Text_RegularExpressions_Regex_i32Array__GetGroupNumbers_0__0(&__thrown, self.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return dotnet.System_Arr<Swift.Int32>(hndl : __return);
        }
    }
    // System.String GroupNameFromNumber(System.Int32)
// docid: M:System.Text.RegularExpressions.Regex.GroupNameFromNumber(System.Int32)
    /**
    Gets the group name that corresponds to the specified group number.

    - Parameter i: The group number to convert to the corresponding group name.
    - Returns: A string that contains the group name associated with the specified group number. If there is no group name that corresponds to , the method returns .

    */
    open func GroupNameFromNumber(i : Swift.Int32) throws -> dotnet.System.String {
        var __thrown : NullableHandle = nil;
        let __return = System_Text_RegularExpressions_Regex_String__GroupNameFromNumber_0__1__i32(&__thrown, self.get_handle(), i);
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return dotnet.System.String(hndl : __return);
        }
    }
    // System.Int32 GroupNumberFromName(System.String)
// docid: M:System.Text.RegularExpressions.Regex.GroupNumberFromName(System.String)
    /**
    Returns the group number that corresponds to the specified group name.

    - Parameter name: The group name to convert to the corresponding group number.
    - Returns: The group number that corresponds to the specified group name, or -1 if  is not a valid group name.

    */
    open func GroupNumberFromName(name : dotnet.System.String) throws -> Swift.Int32 {
        var __thrown : NullableHandle = nil;
        let __return = System_Text_RegularExpressions_Regex_i32__GroupNumberFromName_0__1__String(&__thrown, self.get_handle(), name.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return __return;
        }
    }
    // bool IsMatch(System.String)
// docid: M:System.Text.RegularExpressions.Regex.IsMatch(System.String)
    /**
    Indicates whether the regular expression specified in the  constructor finds a match in a specified input string.

    - Parameter input: The string to search for a match.
    - Returns: 
         if the regular expression finds a match; otherwise, .

    */
    open func IsMatch(input : dotnet.System.String) throws -> Bool {
        var __thrown : NullableHandle = nil;
        let __return = System_Text_RegularExpressions_Regex_bool__IsMatch_0__1__String(&__thrown, self.get_handle(), input.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return (__return) != 0;
        }
    }
    // bool IsMatch(System.String, System.Int32)
// docid: M:System.Text.RegularExpressions.Regex.IsMatch(System.String,System.Int32)
    /**
    Indicates whether the regular expression specified in the  constructor finds a match in the specified input string, beginning at the specified starting position in the string.

    - Parameter input: The string to search for a match.
    - Parameter startat: The character position at which to start the search.
    - Returns: 
         if the regular expression finds a match; otherwise, .

    */
    open func IsMatch(input : dotnet.System.String, startat : Swift.Int32) throws -> Bool {
        var __thrown : NullableHandle = nil;
        let __return = System_Text_RegularExpressions_Regex_bool__IsMatch_0__2__String_i32(&__thrown, self.get_handle(), input.get_handle(), startat);
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return (__return) != 0;
        }
    }
    // bool IsMatch(System.String, System.String)
// docid: M:System.Text.RegularExpressions.Regex.IsMatch(System.String,System.String)
    /**
    Indicates whether the specified regular expression finds a match in the specified input string.

    - Parameter input: The string to search for a match.
    - Parameter pattern: The regular expression pattern to match.
    - Returns: 
         if the regular expression finds a match; otherwise, .

    */
    open class func IsMatch(input : dotnet.System.String, pattern : dotnet.System.String) throws -> Bool {
        var __thrown : NullableHandle = nil;
        let __return = System_Text_RegularExpressions_Regex_bool__IsMatch_0__2__String_String(&__thrown, input.get_handle(), pattern.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return (__return) != 0;
        }
    }
    // bool IsMatch(System.String, System.String, System.Text.RegularExpressions.RegexOptions)
// docid: M:System.Text.RegularExpressions.Regex.IsMatch(System.String,System.String,System.Text.RegularExpressions.RegexOptions)
    /**
    Indicates whether the specified regular expression finds a match in the specified input string, using the specified matching options.

    - Parameter input: The string to search for a match.
    - Parameter pattern: The regular expression pattern to match.
    - Parameter options: A bitwise combination of the enumeration values that provide options for matching.
    - Returns: 
         if the regular expression finds a match; otherwise, .

    */
    open class func IsMatch(input : dotnet.System.String, pattern : dotnet.System.String, options : dotnet.System.Text.RegularExpressions.RegexOptions) throws -> Bool {
        var __thrown : NullableHandle = nil;
        let __return = System_Text_RegularExpressions_Regex_bool__IsMatch_0__3__String_String_RegexOptions(&__thrown, input.get_handle(), pattern.get_handle(), options.get_value());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return (__return) != 0;
        }
    }
// TODO COPE (write_all_methods) (span) bool IsMatch(System.String, System.String, System.Text.RegularExpressions.RegexOptions, System.TimeSpan)
    // System.Text.RegularExpressions.Match Match(System.String)
// docid: M:System.Text.RegularExpressions.Regex.Match(System.String)
    /**
    Searches the specified input string for the first occurrence of the regular expression specified in the  constructor.

    - Parameter input: The string to search for a match.
    - Returns: An object that contains information about the match.

    */
    open func Match(input : dotnet.System.String) throws -> dotnet.System.Text.RegularExpressions.Match {
        var __thrown : NullableHandle = nil;
        let __return = System_Text_RegularExpressions_Regex_Match__Match_0__1__String(&__thrown, self.get_handle(), input.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return dotnet.System.Text.RegularExpressions.Match(hndl : __return);
        }
    }
    // System.Text.RegularExpressions.Match Match(System.String, System.Int32)
// docid: M:System.Text.RegularExpressions.Regex.Match(System.String,System.Int32)
    /**
    Searches the input string for the first occurrence of a regular expression, beginning at the specified starting position in the string.

    - Parameter input: The string to search for a match.
    - Parameter startat: The zero-based character position at which to start the search.
    - Returns: An object that contains information about the match.

    */
    open func Match(input : dotnet.System.String, startat : Swift.Int32) throws -> dotnet.System.Text.RegularExpressions.Match {
        var __thrown : NullableHandle = nil;
        let __return = System_Text_RegularExpressions_Regex_Match__Match_0__2__String_i32(&__thrown, self.get_handle(), input.get_handle(), startat);
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return dotnet.System.Text.RegularExpressions.Match(hndl : __return);
        }
    }
    // System.Text.RegularExpressions.Match Match(System.String, System.Int32, System.Int32)
// docid: M:System.Text.RegularExpressions.Regex.Match(System.String,System.Int32,System.Int32)
    /**
    Searches the input string for the first occurrence of a regular expression, beginning at the specified starting position and searching only the specified number of characters.

    - Parameter input: The string to search for a match.
    - Parameter beginning: The zero-based character position in the input string that defines the leftmost position to be searched.
    - Parameter length: The number of characters in the substring to include in the search.
    - Returns: An object that contains information about the match.

    */
    open func Match(input : dotnet.System.String, beginning : Swift.Int32, length : Swift.Int32) throws -> dotnet.System.Text.RegularExpressions.Match {
        var __thrown : NullableHandle = nil;
        let __return = System_Text_RegularExpressions_Regex_Match__Match_0__3__String_i32_i32(&__thrown, self.get_handle(), input.get_handle(), beginning, length);
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return dotnet.System.Text.RegularExpressions.Match(hndl : __return);
        }
    }
    // System.Text.RegularExpressions.Match Match(System.String, System.String)
// docid: M:System.Text.RegularExpressions.Regex.Match(System.String,System.String)
    /**
    Searches the specified input string for the first occurrence of the specified regular expression.

    - Parameter input: The string to search for a match.
    - Parameter pattern: The regular expression pattern to match.
    - Returns: An object that contains information about the match.

    */
    open class func Match(input : dotnet.System.String, pattern : dotnet.System.String) throws -> dotnet.System.Text.RegularExpressions.Match {
        var __thrown : NullableHandle = nil;
        let __return = System_Text_RegularExpressions_Regex_Match__Match_0__2__String_String(&__thrown, input.get_handle(), pattern.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return dotnet.System.Text.RegularExpressions.Match(hndl : __return);
        }
    }
    // System.Text.RegularExpressions.Match Match(System.String, System.String, System.Text.RegularExpressions.RegexOptions)
// docid: M:System.Text.RegularExpressions.Regex.Match(System.String,System.String,System.Text.RegularExpressions.RegexOptions)
    /**
    Searches the input string for the first occurrence of the specified regular expression, using the specified matching options.

    - Parameter input: The string to search for a match.
    - Parameter pattern: The regular expression pattern to match.
    - Parameter options: A bitwise combination of the enumeration values that provide options for matching.
    - Returns: An object that contains information about the match.

    */
    open class func Match(input : dotnet.System.String, pattern : dotnet.System.String, options : dotnet.System.Text.RegularExpressions.RegexOptions) throws -> dotnet.System.Text.RegularExpressions.Match {
        var __thrown : NullableHandle = nil;
        let __return = System_Text_RegularExpressions_Regex_Match__Match_0__3__String_String_RegexOptions(&__thrown, input.get_handle(), pattern.get_handle(), options.get_value());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return dotnet.System.Text.RegularExpressions.Match(hndl : __return);
        }
    }
// TODO COPE (write_all_methods) (span) System.Text.RegularExpressions.Match Match(System.String, System.String, System.Text.RegularExpressions.RegexOptions, System.TimeSpan)
    // System.Text.RegularExpressions.MatchCollection Matches(System.String)
// docid: M:System.Text.RegularExpressions.Regex.Matches(System.String)
    /**
    Searches the specified input string for all occurrences of a regular expression.

    - Parameter input: The string to search for a match.
    - Returns: A collection of the  objects found by the search. If no matches are found, the method returns an empty collection object.

    */
    open func Matches(input : dotnet.System.String) throws -> dotnet.System.Text.RegularExpressions.MatchCollection {
        var __thrown : NullableHandle = nil;
        let __return = System_Text_RegularExpressions_Regex_MatchCollection__Matches_0__1__String(&__thrown, self.get_handle(), input.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return dotnet.System.Text.RegularExpressions.MatchCollection(hndl : __return);
        }
    }
    // System.Text.RegularExpressions.MatchCollection Matches(System.String, System.Int32)
// docid: M:System.Text.RegularExpressions.Regex.Matches(System.String,System.Int32)
    /**
    Searches the specified input string for all occurrences of a regular expression, beginning at the specified starting position in the string.

    - Parameter input: The string to search for a match.
    - Parameter startat: The character position in the input string at which to start the search.
    - Returns: A collection of the  objects found by the search. If no matches are found, the method returns an empty collection object.

    */
    open func Matches(input : dotnet.System.String, startat : Swift.Int32) throws -> dotnet.System.Text.RegularExpressions.MatchCollection {
        var __thrown : NullableHandle = nil;
        let __return = System_Text_RegularExpressions_Regex_MatchCollection__Matches_0__2__String_i32(&__thrown, self.get_handle(), input.get_handle(), startat);
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return dotnet.System.Text.RegularExpressions.MatchCollection(hndl : __return);
        }
    }
    // System.Text.RegularExpressions.MatchCollection Matches(System.String, System.String)
// docid: M:System.Text.RegularExpressions.Regex.Matches(System.String,System.String)
    /**
    Searches the specified input string for all occurrences of a specified regular expression.

    - Parameter input: The string to search for a match.
    - Parameter pattern: The regular expression pattern to match.
    - Returns: A collection of the  objects found by the search. If no matches are found, the method returns an empty collection object.

    */
    open class func Matches(input : dotnet.System.String, pattern : dotnet.System.String) throws -> dotnet.System.Text.RegularExpressions.MatchCollection {
        var __thrown : NullableHandle = nil;
        let __return = System_Text_RegularExpressions_Regex_MatchCollection__Matches_0__2__String_String(&__thrown, input.get_handle(), pattern.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return dotnet.System.Text.RegularExpressions.MatchCollection(hndl : __return);
        }
    }
    // System.Text.RegularExpressions.MatchCollection Matches(System.String, System.String, System.Text.RegularExpressions.RegexOptions)
// docid: M:System.Text.RegularExpressions.Regex.Matches(System.String,System.String,System.Text.RegularExpressions.RegexOptions)
    /**
    Searches the specified input string for all occurrences of a specified regular expression, using the specified matching options.

    - Parameter input: The string to search for a match.
    - Parameter pattern: The regular expression pattern to match.
    - Parameter options: A bitwise combination of the enumeration values that specify options for matching.
    - Returns: A collection of the  objects found by the search. If no matches are found, the method returns an empty collection object.

    */
    open class func Matches(input : dotnet.System.String, pattern : dotnet.System.String, options : dotnet.System.Text.RegularExpressions.RegexOptions) throws -> dotnet.System.Text.RegularExpressions.MatchCollection {
        var __thrown : NullableHandle = nil;
        let __return = System_Text_RegularExpressions_Regex_MatchCollection__Matches_0__3__String_String_RegexOptions(&__thrown, input.get_handle(), pattern.get_handle(), options.get_value());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return dotnet.System.Text.RegularExpressions.MatchCollection(hndl : __return);
        }
    }
// TODO COPE (write_all_methods) (span) System.Text.RegularExpressions.MatchCollection Matches(System.String, System.String, System.Text.RegularExpressions.RegexOptions, System.TimeSpan)
    // System.String Replace(System.String, System.String)
// docid: M:System.Text.RegularExpressions.Regex.Replace(System.String,System.String)
    /**
    In a specified input string, replaces all strings that match a regular expression pattern with a specified replacement string.

    - Parameter input: The string to search for a match.
    - Parameter replacement: The replacement string.
    - Returns: A new string that is identical to the input string, except that the replacement string takes the place of each matched string. If the regular expression pattern is not matched in the current instance, the method returns the current instance unchanged.

    */
    open func Replace(input : dotnet.System.String, replacement : dotnet.System.String) throws -> dotnet.System.String {
        var __thrown : NullableHandle = nil;
        let __return = System_Text_RegularExpressions_Regex_String__Replace_0__2__String_String(&__thrown, self.get_handle(), input.get_handle(), replacement.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return dotnet.System.String(hndl : __return);
        }
    }
    // System.String Replace(System.String, System.String, System.Int32)
// docid: M:System.Text.RegularExpressions.Regex.Replace(System.String,System.String,System.Int32)
    /**
    In a specified input string, replaces a specified maximum number of strings that match a regular expression pattern with a specified replacement string.

    - Parameter input: The string to search for a match.
    - Parameter replacement: The replacement string.
    - Parameter count: The maximum number of times the replacement can occur.
    - Returns: A new string that is identical to the input string, except that the replacement string takes the place of each matched string. If the regular expression pattern is not matched in the current instance, the method returns the current instance unchanged.

    */
    open func Replace(input : dotnet.System.String, replacement : dotnet.System.String, count : Swift.Int32) throws -> dotnet.System.String {
        var __thrown : NullableHandle = nil;
        let __return = System_Text_RegularExpressions_Regex_String__Replace_0__3__String_String_i32(&__thrown, self.get_handle(), input.get_handle(), replacement.get_handle(), count);
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return dotnet.System.String(hndl : __return);
        }
    }
    // System.String Replace(System.String, System.String, System.Int32, System.Int32)
// docid: M:System.Text.RegularExpressions.Regex.Replace(System.String,System.String,System.Int32,System.Int32)
    /**
    In a specified input substring, replaces a specified maximum number of strings that match a regular expression pattern with a specified replacement string.

    - Parameter input: The string to search for a match.
    - Parameter replacement: The replacement string.
    - Parameter count: Maximum number of times the replacement can occur.
    - Parameter startat: The character position in the input string where the search begins.
    - Returns: A new string that is identical to the input string, except that the replacement string takes the place of each matched string. If the regular expression pattern is not matched in the current instance, the method returns the current instance unchanged.

    */
    open func Replace(input : dotnet.System.String, replacement : dotnet.System.String, count : Swift.Int32, startat : Swift.Int32) throws -> dotnet.System.String {
        var __thrown : NullableHandle = nil;
        let __return = System_Text_RegularExpressions_Regex_String__Replace_0__4__String_String_i32_i32(&__thrown, self.get_handle(), input.get_handle(), replacement.get_handle(), count, startat);
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return dotnet.System.String(hndl : __return);
        }
    }
    // System.String Replace(System.String, System.String, System.String)
// docid: M:System.Text.RegularExpressions.Regex.Replace(System.String,System.String,System.String)
    /**
    In a specified input string, replaces all strings that match a specified regular expression with a specified replacement string.

    - Parameter input: The string to search for a match.
    - Parameter pattern: The regular expression pattern to match.
    - Parameter replacement: The replacement string.
    - Returns: A new string that is identical to the input string, except that the replacement string takes the place of each matched string. If  is not matched in the current instance, the method returns the current instance unchanged.

    */
    open class func Replace(input : dotnet.System.String, pattern : dotnet.System.String, replacement : dotnet.System.String) throws -> dotnet.System.String {
        var __thrown : NullableHandle = nil;
        let __return = System_Text_RegularExpressions_Regex_String__Replace_0__3__String_String_String(&__thrown, input.get_handle(), pattern.get_handle(), replacement.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return dotnet.System.String(hndl : __return);
        }
    }
    // System.String Replace(System.String, System.String, System.String, System.Text.RegularExpressions.RegexOptions)
// docid: M:System.Text.RegularExpressions.Regex.Replace(System.String,System.String,System.String,System.Text.RegularExpressions.RegexOptions)
    /**
    In a specified input string, replaces all strings that match a specified regular expression with a specified replacement string. Specified options modify the matching operation.

    - Parameter input: The string to search for a match.
    - Parameter pattern: The regular expression pattern to match.
    - Parameter replacement: The replacement string.
    - Parameter options: A bitwise combination of the enumeration values that provide options for matching.
    - Returns: A new string that is identical to the input string, except that the replacement string takes the place of each matched string. If  is not matched in the current instance, the method returns the current instance unchanged.

    */
    open class func Replace(input : dotnet.System.String, pattern : dotnet.System.String, replacement : dotnet.System.String, options : dotnet.System.Text.RegularExpressions.RegexOptions) throws -> dotnet.System.String {
        var __thrown : NullableHandle = nil;
        let __return = System_Text_RegularExpressions_Regex_String__Replace_0__4__String_String_String_RegexOptions(&__thrown, input.get_handle(), pattern.get_handle(), replacement.get_handle(), options.get_value());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return dotnet.System.String(hndl : __return);
        }
    }
// TODO COPE (write_all_methods) (span) System.String Replace(System.String, System.String, System.String, System.Text.RegularExpressions.RegexOptions, System.TimeSpan)
    // System.String Replace(System.String, System.String, System.Text.RegularExpressions.MatchEvaluator)
// docid: M:System.Text.RegularExpressions.Regex.Replace(System.String,System.String,System.Text.RegularExpressions.MatchEvaluator)
    /**
    In a specified input string, replaces all strings that match a specified regular expression with a string returned by a  delegate.

    - Parameter input: The string to search for a match.
    - Parameter pattern: The regular expression pattern to match.
    - Parameter evaluator: A custom method that examines each match and returns either the original matched string or a replacement string.
    - Returns: A new string that is identical to the input string, except that a replacement string takes the place of each matched string. If  is not matched in the current instance, the method returns the current instance unchanged.

    */
    open class func Replace(input : dotnet.System.String, pattern : dotnet.System.String, evaluator : dotnet.System.Text.RegularExpressions.MatchEvaluator) throws -> dotnet.System.String {
        var __thrown : NullableHandle = nil;
        let __return = System_Text_RegularExpressions_Regex_String__Replace_0__3__String_String_MatchEvaluator(&__thrown, input.get_handle(), pattern.get_handle(), evaluator.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return dotnet.System.String(hndl : __return);
        }
    }
    // delegate closure overload
    open class func Replace(input : dotnet.System.String, pattern : dotnet.System.String, evaluator : @escaping (dotnet.System.Text.RegularExpressions.Match) throws -> dotnet.System.String) throws -> dotnet.System.String {
        let del_evaluator = try dotnet.System.Text.RegularExpressions.MatchEvaluator(evaluator);
        return try Replace(input: input, pattern: pattern, evaluator: del_evaluator);
    }
    // System.String Replace(System.String, System.String, System.Text.RegularExpressions.MatchEvaluator, System.Text.RegularExpressions.RegexOptions)
// docid: M:System.Text.RegularExpressions.Regex.Replace(System.String,System.String,System.Text.RegularExpressions.MatchEvaluator,System.Text.RegularExpressions.RegexOptions)
    /**
    In a specified input string, replaces all strings that match a specified regular expression with a string returned by a  delegate. Specified options modify the matching operation.

    - Parameter input: The string to search for a match.
    - Parameter pattern: The regular expression pattern to match.
    - Parameter evaluator: A custom method that examines each match and returns either the original matched string or a replacement string.
    - Parameter options: A bitwise combination of the enumeration values that provide options for matching.
    - Returns: A new string that is identical to the input string, except that a replacement string takes the place of each matched string. If  is not matched in the current instance, the method returns the current instance unchanged.

    */
    open class func Replace(input : dotnet.System.String, pattern : dotnet.System.String, evaluator : dotnet.System.Text.RegularExpressions.MatchEvaluator, options : dotnet.System.Text.RegularExpressions.RegexOptions) throws -> dotnet.System.String {
        var __thrown : NullableHandle = nil;
        let __return = System_Text_RegularExpressions_Regex_String__Replace_0__4__String_String_MatchEvaluator_RegexOptions(&__thrown, input.get_handle(), pattern.get_handle(), evaluator.get_handle(), options.get_value());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return dotnet.System.String(hndl : __return);
        }
    }
    // delegate closure overload
    open class func Replace(input : dotnet.System.String, pattern : dotnet.System.String, evaluator : @escaping (dotnet.System.Text.RegularExpressions.Match) throws -> dotnet.System.String, options : dotnet.System.Text.RegularExpressions.RegexOptions) throws -> dotnet.System.String {
        let del_evaluator = try dotnet.System.Text.RegularExpressions.MatchEvaluator(evaluator);
        return try Replace(input: input, pattern: pattern, evaluator: del_evaluator, options: options);
    }
// TODO COPE (write_all_methods) (span) System.String Replace(System.String, System.String, System.Text.RegularExpressions.MatchEvaluator, System.Text.RegularExpressions.RegexOptions, System.TimeSpan)
    // System.String Replace(System.String, System.Text.RegularExpressions.MatchEvaluator)
// docid: M:System.Text.RegularExpressions.Regex.Replace(System.String,System.Text.RegularExpressions.MatchEvaluator)
    /**
    In a specified input string, replaces all strings that match a specified regular expression with a string returned by a  delegate.

    - Parameter input: The string to search for a match.
    - Parameter evaluator: A custom method that examines each match and returns either the original matched string or a replacement string.
    - Returns: A new string that is identical to the input string, except that a replacement string takes the place of each matched string. If the regular expression pattern is not matched in the current instance, the method returns the current instance unchanged.

    */
    open func Replace(input : dotnet.System.String, evaluator : dotnet.System.Text.RegularExpressions.MatchEvaluator) throws -> dotnet.System.String {
        var __thrown : NullableHandle = nil;
        let __return = System_Text_RegularExpressions_Regex_String__Replace_0__2__String_MatchEvaluator(&__thrown, self.get_handle(), input.get_handle(), evaluator.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return dotnet.System.String(hndl : __return);
        }
    }
    // delegate closure overload
    open func Replace(input : dotnet.System.String, evaluator : @escaping (dotnet.System.Text.RegularExpressions.Match) throws -> dotnet.System.String) throws -> dotnet.System.String {
        let del_evaluator = try dotnet.System.Text.RegularExpressions.MatchEvaluator(evaluator);
        return try Replace(input: input, evaluator: del_evaluator);
    }
    // System.String Replace(System.String, System.Text.RegularExpressions.MatchEvaluator, System.Int32)
// docid: M:System.Text.RegularExpressions.Regex.Replace(System.String,System.Text.RegularExpressions.MatchEvaluator,System.Int32)
    /**
    In a specified input string, replaces a specified maximum number of strings that match a regular expression pattern with a string returned by a  delegate.

    - Parameter input: The string to search for a match.
    - Parameter evaluator: A custom method that examines each match and returns either the original matched string or a replacement string.
    - Parameter count: The maximum number of times the replacement will occur.
    - Returns: A new string that is identical to the input string, except that a replacement string takes the place of each matched string. If the regular expression pattern is not matched in the current instance, the method returns the current instance unchanged.

    */
    open func Replace(input : dotnet.System.String, evaluator : dotnet.System.Text.RegularExpressions.MatchEvaluator, count : Swift.Int32) throws -> dotnet.System.String {
        var __thrown : NullableHandle = nil;
        let __return = System_Text_RegularExpressions_Regex_String__Replace_0__3__String_MatchEvaluator_i32(&__thrown, self.get_handle(), input.get_handle(), evaluator.get_handle(), count);
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return dotnet.System.String(hndl : __return);
        }
    }
    // delegate closure overload
    open func Replace(input : dotnet.System.String, evaluator : @escaping (dotnet.System.Text.RegularExpressions.Match) throws -> dotnet.System.String, count : Swift.Int32) throws -> dotnet.System.String {
        let del_evaluator = try dotnet.System.Text.RegularExpressions.MatchEvaluator(evaluator);
        return try Replace(input: input, evaluator: del_evaluator, count: count);
    }
    // System.String Replace(System.String, System.Text.RegularExpressions.MatchEvaluator, System.Int32, System.Int32)
// docid: M:System.Text.RegularExpressions.Regex.Replace(System.String,System.Text.RegularExpressions.MatchEvaluator,System.Int32,System.Int32)
    /**
    In a specified input substring, replaces a specified maximum number of strings that match a regular expression pattern with a string returned by a  delegate.

    - Parameter input: The string to search for a match.
    - Parameter evaluator: A custom method that examines each match and returns either the original matched string or a replacement string.
    - Parameter count: The maximum number of times the replacement will occur.
    - Parameter startat: The character position in the input string where the search begins.
    - Returns: A new string that is identical to the input string, except that a replacement string takes the place of each matched string. If the regular expression pattern is not matched in the current instance, the method returns the current instance unchanged.

    */
    open func Replace(input : dotnet.System.String, evaluator : dotnet.System.Text.RegularExpressions.MatchEvaluator, count : Swift.Int32, startat : Swift.Int32) throws -> dotnet.System.String {
        var __thrown : NullableHandle = nil;
        let __return = System_Text_RegularExpressions_Regex_String__Replace_0__4__String_MatchEvaluator_i32_i32(&__thrown, self.get_handle(), input.get_handle(), evaluator.get_handle(), count, startat);
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return dotnet.System.String(hndl : __return);
        }
    }
    // delegate closure overload
    open func Replace(input : dotnet.System.String, evaluator : @escaping (dotnet.System.Text.RegularExpressions.Match) throws -> dotnet.System.String, count : Swift.Int32, startat : Swift.Int32) throws -> dotnet.System.String {
        let del_evaluator = try dotnet.System.Text.RegularExpressions.MatchEvaluator(evaluator);
        return try Replace(input: input, evaluator: del_evaluator, count: count, startat: startat);
    }
    // System.String[] Split(System.String)
// docid: M:System.Text.RegularExpressions.Regex.Split(System.String)
    /**
    Splits an input string into an array of substrings at the positions defined by a regular expression pattern specified in the  constructor.

    - Parameter input: The string to split.
    - Returns: An array of strings.

    */
    open func Split(input : dotnet.System.String) throws -> dotnet.System_Arr<dotnet.System.String> {
        var __thrown : NullableHandle = nil;
        let __return = System_Text_RegularExpressions_Regex_StringArray__Split_0__1__String(&__thrown, self.get_handle(), input.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return dotnet.System_Arr<dotnet.System.String>(hndl : __return);
        }
    }
    // System.String[] Split(System.String, System.Int32)
// docid: M:System.Text.RegularExpressions.Regex.Split(System.String,System.Int32)
    /**
    Splits an input string a specified maximum number of times into an array of substrings, at the positions defined by a regular expression specified in the  constructor.

    - Parameter input: The string to be split.
    - Parameter count: The maximum number of times the split can occur.
    - Returns: An array of strings.

    */
    open func Split(input : dotnet.System.String, count : Swift.Int32) throws -> dotnet.System_Arr<dotnet.System.String> {
        var __thrown : NullableHandle = nil;
        let __return = System_Text_RegularExpressions_Regex_StringArray__Split_0__2__String_i32(&__thrown, self.get_handle(), input.get_handle(), count);
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return dotnet.System_Arr<dotnet.System.String>(hndl : __return);
        }
    }
    // System.String[] Split(System.String, System.Int32, System.Int32)
// docid: M:System.Text.RegularExpressions.Regex.Split(System.String,System.Int32,System.Int32)
    /**
    Splits an input string a specified maximum number of times into an array of substrings, at the positions defined by a regular expression specified in the  constructor. The search for the regular expression pattern starts at a specified character position in the input string.

    - Parameter input: The string to be split.
    - Parameter count: The maximum number of times the split can occur.
    - Parameter startat: The character position in the input string where the search will begin.
    - Returns: An array of strings.

    */
    open func Split(input : dotnet.System.String, count : Swift.Int32, startat : Swift.Int32) throws -> dotnet.System_Arr<dotnet.System.String> {
        var __thrown : NullableHandle = nil;
        let __return = System_Text_RegularExpressions_Regex_StringArray__Split_0__3__String_i32_i32(&__thrown, self.get_handle(), input.get_handle(), count, startat);
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return dotnet.System_Arr<dotnet.System.String>(hndl : __return);
        }
    }
    // System.String[] Split(System.String, System.String)
// docid: M:System.Text.RegularExpressions.Regex.Split(System.String,System.String)
    /**
    Splits an input string into an array of substrings at the positions defined by a regular expression pattern.

    - Parameter input: The string to split.
    - Parameter pattern: The regular expression pattern to match.
    - Returns: An array of strings.

    */
    open class func Split(input : dotnet.System.String, pattern : dotnet.System.String) throws -> dotnet.System_Arr<dotnet.System.String> {
        var __thrown : NullableHandle = nil;
        let __return = System_Text_RegularExpressions_Regex_StringArray__Split_0__2__String_String(&__thrown, input.get_handle(), pattern.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return dotnet.System_Arr<dotnet.System.String>(hndl : __return);
        }
    }
    // System.String[] Split(System.String, System.String, System.Text.RegularExpressions.RegexOptions)
// docid: M:System.Text.RegularExpressions.Regex.Split(System.String,System.String,System.Text.RegularExpressions.RegexOptions)
    /**
    Splits an input string into an array of substrings at the positions defined by a specified regular expression pattern. Specified options modify the matching operation.

    - Parameter input: The string to split.
    - Parameter pattern: The regular expression pattern to match.
    - Parameter options: A bitwise combination of the enumeration values that provide options for matching.
    - Returns: An array of strings.

    */
    open class func Split(input : dotnet.System.String, pattern : dotnet.System.String, options : dotnet.System.Text.RegularExpressions.RegexOptions) throws -> dotnet.System_Arr<dotnet.System.String> {
        var __thrown : NullableHandle = nil;
        let __return = System_Text_RegularExpressions_Regex_StringArray__Split_0__3__String_String_RegexOptions(&__thrown, input.get_handle(), pattern.get_handle(), options.get_value());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return dotnet.System_Arr<dotnet.System.String>(hndl : __return);
        }
    }
// TODO COPE (write_all_methods) (span) System.String[] Split(System.String, System.String, System.Text.RegularExpressions.RegexOptions, System.TimeSpan)
    // System.String ToString()
// docid: M:System.Text.RegularExpressions.Regex.ToString
    /**
    Returns the regular expression pattern that was passed into the  constructor.

    - Returns: The  parameter that was passed into the  constructor.

    */
    open override func ToString() throws -> dotnet.System.String {
        var __thrown : NullableHandle = nil;
        let __return = System_Text_RegularExpressions_Regex_String__ToString_0__0(&__thrown, self.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return dotnet.System.String(hndl : __return);
        }
    }
    // System.String Unescape(System.String)
// docid: M:System.Text.RegularExpressions.Regex.Unescape(System.String)
    /**
    Converts any escaped characters in the input string.

    - Parameter str: The input string containing the text to convert.
    - Returns: A string of characters with any escaped characters converted to their unescaped form.

    */
    open class func Unescape(str : dotnet.System.String) throws -> dotnet.System.String {
        var __thrown : NullableHandle = nil;
        let __return = System_Text_RegularExpressions_Regex_String__Unescape_0__1__String(&__thrown, str.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return dotnet.System.String(hndl : __return);
        }
    }
    // [IsSpecialName] System.Int32 get_CacheSize()
// docid: M:System.Text.RegularExpressions.Regex.get_CacheSize
    open class func get_CacheSize() throws -> Swift.Int32 {
        var __thrown : NullableHandle = nil;
        let __return = System_Text_RegularExpressions_Regex_i32__get_CacheSize_0__0(&__thrown);
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return __return;
        }
    }
    // [IsSpecialName] void set_CacheSize(System.Int32)
// docid: M:System.Text.RegularExpressions.Regex.set_CacheSize(System.Int32)
    open class func set_CacheSize(value : Swift.Int32) throws {
        var __thrown : NullableHandle = nil;
        System_Text_RegularExpressions_Regex_void__set_CacheSize_0__1__i32(&__thrown, value);
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
            return;
        }
    }
    // [IsSpecialName] System.TimeSpan get_MatchTimeout()
// docid: M:System.Text.RegularExpressions.Regex.get_MatchTimeout
    open func get_MatchTimeout() throws -> dotnet.System.TimeSpan {
        var __thrown : NullableHandle = nil;
        let __return = System_Text_RegularExpressions_Regex_TimeSpan__get_MatchTimeout_0__0(&__thrown, self.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return dotnet.System.TimeSpan(hndl : __return);
        }
    }
    // [IsSpecialName] System.Text.RegularExpressions.RegexOptions get_Options()
// docid: M:System.Text.RegularExpressions.Regex.get_Options
    open func get_Options() throws -> dotnet.System.Text.RegularExpressions.RegexOptions {
        var __thrown : NullableHandle = nil;
        let __return = System_Text_RegularExpressions_Regex_RegexOptions__get_Options_0__0(&__thrown, self.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return dotnet.System.Text.RegularExpressions.RegexOptions(val: __return);
        }
    }
    // [IsSpecialName] bool get_RightToLeft()
// docid: M:System.Text.RegularExpressions.Regex.get_RightToLeft
    open func get_RightToLeft() throws -> Bool {
        var __thrown : NullableHandle = nil;
        let __return = System_Text_RegularExpressions_Regex_bool__get_RightToLeft_0__0(&__thrown, self.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return (__return) != 0;
        }
    }
    /**
    Gets or sets the maximum number of entries in the current static cache of compiled regular expressions.

    */
    public static var CacheSize : Swift.Int32 {
        get {
            return try! get_CacheSize();
        }
        set(v) {
            return try! set_CacheSize(value: v);
        }
    }
    /**
    Gets the time-out interval of the current instance.

    */
    open var MatchTimeout : dotnet.System.TimeSpan {
        get {
            return try! get_MatchTimeout();
        }
    }
    /**
    Gets the options that were passed into the  constructor.

    */
    open var Options : dotnet.System.Text.RegularExpressions.RegexOptions {
        get {
            return try! get_Options();
        }
    }
    /**
    Gets a value that indicates whether the regular expression searches from right to left.

    */
    open var RightToLeft : Bool {
        get {
            return try! get_RightToLeft();
        }
    }
} // Regex


// type: System.Text.RegularExpressions.RegexCompilationInfo
    /**
    Provides information about a regular expression that is used to compile a regular expression to a stand-alone assembly.

    */
open class RegexCompilationInfo
    :
    dotnet.System.Object
{
    open class override func get_type_handle() -> TypeHandle {
        return System_Text_RegularExpressions_RegexCompilationInfo_get_type_handle();
    }
    public required init(hndl: NonnullHandle) { super.init(hndl: hndl); }
    public required init(gval: GVal) { super.init(gval: gval); }
    // .ctor(System.String, System.Text.RegularExpressions.RegexOptions, System.String, System.String, bool)
// docid: M:System.Text.RegularExpressions.RegexCompilationInfo.#ctor(System.String,System.Text.RegularExpressions.RegexOptions,System.String,System.String,System.Boolean)
    /**
    Initializes a new instance of the  class that contains information about a regular expression to be included in an assembly.

    - Parameter pattern: The regular expression to compile.
    - Parameter options: The regular expression options to use when compiling the regular expression.
    - Parameter name: The name of the type that represents the compiled regular expression.
    - Parameter fullnamespace: The namespace to which the new type belongs.
    - Parameter ispublic: 
         to make the compiled regular expression publicly visible; otherwise, .
    */
    public init(pattern : dotnet.System.String, options : dotnet.System.Text.RegularExpressions.RegexOptions, name : dotnet.System.String, fullnamespace : dotnet.System.String, ispublic : Bool) throws {
        var __thrown : NullableHandle = nil;
        let h = System_Text_RegularExpressions_RegexCompilationInfo_ctor_0__5__String_RegexOptions_String_String_bool(&__thrown, pattern.get_handle(), options.get_value(), name.get_handle(), fullnamespace.get_handle(), Swift.Int32(ispublic ? 1 : 0));
        if let __ex = __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
            super.init(hndl: h);
        }
    }
// TODO COPE ctor (span) .ctor(System.String, System.Text.RegularExpressions.RegexOptions, System.String, System.String, bool, System.TimeSpan)
    // [IsSpecialName] bool get_IsPublic()
// docid: M:System.Text.RegularExpressions.RegexCompilationInfo.get_IsPublic
    open func get_IsPublic() throws -> Bool {
        var __thrown : NullableHandle = nil;
        let __return = System_Text_RegularExpressions_RegexCompilationInfo_bool__get_IsPublic_0__0(&__thrown, self.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return (__return) != 0;
        }
    }
    // [IsSpecialName] void set_IsPublic(bool)
// docid: M:System.Text.RegularExpressions.RegexCompilationInfo.set_IsPublic(System.Boolean)
    open func set_IsPublic(value : Bool) throws {
        var __thrown : NullableHandle = nil;
        System_Text_RegularExpressions_RegexCompilationInfo_void__set_IsPublic_0__1__bool(&__thrown, self.get_handle(), Swift.Int32(value ? 1 : 0));
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
            return;
        }
    }
    // [IsSpecialName] System.TimeSpan get_MatchTimeout()
// docid: M:System.Text.RegularExpressions.RegexCompilationInfo.get_MatchTimeout
    open func get_MatchTimeout() throws -> dotnet.System.TimeSpan {
        var __thrown : NullableHandle = nil;
        let __return = System_Text_RegularExpressions_RegexCompilationInfo_TimeSpan__get_MatchTimeout_0__0(&__thrown, self.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return dotnet.System.TimeSpan(hndl : __return);
        }
    }
// TODO COPE (write_all_methods) (span) [IsSpecialName] void set_MatchTimeout(System.TimeSpan)
    // [IsSpecialName] System.String get_Name()
// docid: M:System.Text.RegularExpressions.RegexCompilationInfo.get_Name
    open func get_Name() throws -> dotnet.System.String {
        var __thrown : NullableHandle = nil;
        let __return = System_Text_RegularExpressions_RegexCompilationInfo_String__get_Name_0__0(&__thrown, self.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return dotnet.System.String(hndl : __return);
        }
    }
    // [IsSpecialName] void set_Name(System.String)
// docid: M:System.Text.RegularExpressions.RegexCompilationInfo.set_Name(System.String)
    open func set_Name(value : dotnet.System.String) throws {
        var __thrown : NullableHandle = nil;
        System_Text_RegularExpressions_RegexCompilationInfo_void__set_Name_0__1__String(&__thrown, self.get_handle(), value.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
            return;
        }
    }
    // [IsSpecialName] System.String get_Namespace()
// docid: M:System.Text.RegularExpressions.RegexCompilationInfo.get_Namespace
    open func get_Namespace() throws -> dotnet.System.String {
        var __thrown : NullableHandle = nil;
        let __return = System_Text_RegularExpressions_RegexCompilationInfo_String__get_Namespace_0__0(&__thrown, self.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return dotnet.System.String(hndl : __return);
        }
    }
    // [IsSpecialName] void set_Namespace(System.String)
// docid: M:System.Text.RegularExpressions.RegexCompilationInfo.set_Namespace(System.String)
    open func set_Namespace(value : dotnet.System.String) throws {
        var __thrown : NullableHandle = nil;
        System_Text_RegularExpressions_RegexCompilationInfo_void__set_Namespace_0__1__String(&__thrown, self.get_handle(), value.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
            return;
        }
    }
    // [IsSpecialName] System.Text.RegularExpressions.RegexOptions get_Options()
// docid: M:System.Text.RegularExpressions.RegexCompilationInfo.get_Options
    open func get_Options() throws -> dotnet.System.Text.RegularExpressions.RegexOptions {
        var __thrown : NullableHandle = nil;
        let __return = System_Text_RegularExpressions_RegexCompilationInfo_RegexOptions__get_Options_0__0(&__thrown, self.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return dotnet.System.Text.RegularExpressions.RegexOptions(val: __return);
        }
    }
    // [IsSpecialName] void set_Options(System.Text.RegularExpressions.RegexOptions)
// docid: M:System.Text.RegularExpressions.RegexCompilationInfo.set_Options(System.Text.RegularExpressions.RegexOptions)
    open func set_Options(value : dotnet.System.Text.RegularExpressions.RegexOptions) throws {
        var __thrown : NullableHandle = nil;
        System_Text_RegularExpressions_RegexCompilationInfo_void__set_Options_0__1__RegexOptions(&__thrown, self.get_handle(), value.get_value());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
            return;
        }
    }
    // [IsSpecialName] System.String get_Pattern()
// docid: M:System.Text.RegularExpressions.RegexCompilationInfo.get_Pattern
    open func get_Pattern() throws -> dotnet.System.String {
        var __thrown : NullableHandle = nil;
        let __return = System_Text_RegularExpressions_RegexCompilationInfo_String__get_Pattern_0__0(&__thrown, self.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return dotnet.System.String(hndl : __return);
        }
    }
    // [IsSpecialName] void set_Pattern(System.String)
// docid: M:System.Text.RegularExpressions.RegexCompilationInfo.set_Pattern(System.String)
    open func set_Pattern(value : dotnet.System.String) throws {
        var __thrown : NullableHandle = nil;
        System_Text_RegularExpressions_RegexCompilationInfo_void__set_Pattern_0__1__String(&__thrown, self.get_handle(), value.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
            return;
        }
    }
    /**
    Gets or sets a value that indicates whether the compiled regular expression has public visibility.

    */
    open var IsPublic : Bool {
        get {
            return try! get_IsPublic();
        }
        set(v) {
            return try! set_IsPublic(value: v);
        }
    }
    /**
    Gets or sets the regular expression's default time-out interval.

    */
    open var MatchTimeout : dotnet.System.TimeSpan {
        get {
            return try! get_MatchTimeout();
        }
// TODO COPE prop set (span) [IsSpecialName] void set_MatchTimeout(System.TimeSpan)
    }
    /**
    Gets or sets the name of the type that represents the compiled regular expression.

    */
    open var Name : dotnet.System.String {
        get {
            return try! get_Name();
        }
        set(v) {
            return try! set_Name(value: v);
        }
    }
    /**
    Gets or sets the namespace to which the new type belongs.

    */
    open var Namespace : dotnet.System.String {
        get {
            return try! get_Namespace();
        }
        set(v) {
            return try! set_Namespace(value: v);
        }
    }
    /**
    Gets or sets the options to use when compiling the regular expression.

    */
    open var Options : dotnet.System.Text.RegularExpressions.RegexOptions {
        get {
            return try! get_Options();
        }
        set(v) {
            return try! set_Options(value: v);
        }
    }
    /**
    Gets or sets the regular expression to compile.

    */
    open var Pattern : dotnet.System.String {
        get {
            return try! get_Pattern();
        }
        set(v) {
            return try! set_Pattern(value: v);
        }
    }
} // RegexCompilationInfo


// type: System.Text.RegularExpressions.RegexMatchTimeoutException
    /**
    The exception that is thrown when the execution time of a regular expression pattern-matching method exceeds its time-out interval.

    */
open class RegexMatchTimeoutException
    :
    dotnet.System.TimeoutException
{
    open class override func get_type_handle() -> TypeHandle {
        return System_Text_RegularExpressions_RegexMatchTimeoutException_get_type_handle();
    }
    public required init(hndl: NonnullHandle) { super.init(hndl: hndl); }
    public required init(gval: GVal) { super.init(gval: gval); }
    // .ctor()
// docid: M:System.Text.RegularExpressions.RegexMatchTimeoutException.#ctor
    /**
    Initializes a new instance of the  class with a system-supplied message.

    */
    public override init() throws {
        var __thrown : NullableHandle = nil;
        let h = System_Text_RegularExpressions_RegexMatchTimeoutException_ctor_0__0(&__thrown);
        if let __ex = __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
            super.init(hndl: h);
        }
    }
    // .ctor(System.String)
// docid: M:System.Text.RegularExpressions.RegexMatchTimeoutException.#ctor(System.String)
    /**
    Initializes a new instance of the  class with the specified message string.

    - Parameter message: A string that describes the exception.
    */
    public init(message : dotnet.System.String) throws {
        var __thrown : NullableHandle = nil;
        let h = System_Text_RegularExpressions_RegexMatchTimeoutException_ctor_0__1__String(&__thrown, message.get_handle());
        if let __ex = __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
            super.init(hndl: h);
        }
    }
    // .ctor(System.String, System.Exception)
// docid: M:System.Text.RegularExpressions.RegexMatchTimeoutException.#ctor(System.String,System.Exception)
    /**
    Initializes a new instance of the  class with a specified error message and a reference to the inner exception that is the cause of this exception.

    - Parameter message: A string that describes the exception.
    - Parameter inner: The exception that is the cause of the current exception.
    */
    public init(message : dotnet.System.String, inner : dotnet.System.Exception) throws {
        var __thrown : NullableHandle = nil;
        let h = System_Text_RegularExpressions_RegexMatchTimeoutException_ctor_0__2__String_Exception(&__thrown, message.get_handle(), inner.get_handle());
        if let __ex = __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
            super.init(hndl: h);
        }
    }
// TODO COPE ctor (span) .ctor(System.String, System.String, System.TimeSpan)
    // [IsSpecialName] System.String get_Input()
// docid: M:System.Text.RegularExpressions.RegexMatchTimeoutException.get_Input
    open func get_Input() throws -> dotnet.System.String {
        var __thrown : NullableHandle = nil;
        let __return = System_Text_RegularExpressions_RegexMatchTimeoutException_String__get_Input_0__0(&__thrown, self.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return dotnet.System.String(hndl : __return);
        }
    }
    // [IsSpecialName] System.TimeSpan get_MatchTimeout()
// docid: M:System.Text.RegularExpressions.RegexMatchTimeoutException.get_MatchTimeout
    open func get_MatchTimeout() throws -> dotnet.System.TimeSpan {
        var __thrown : NullableHandle = nil;
        let __return = System_Text_RegularExpressions_RegexMatchTimeoutException_TimeSpan__get_MatchTimeout_0__0(&__thrown, self.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return dotnet.System.TimeSpan(hndl : __return);
        }
    }
    // [IsSpecialName] System.String get_Pattern()
// docid: M:System.Text.RegularExpressions.RegexMatchTimeoutException.get_Pattern
    open func get_Pattern() throws -> dotnet.System.String {
        var __thrown : NullableHandle = nil;
        let __return = System_Text_RegularExpressions_RegexMatchTimeoutException_String__get_Pattern_0__0(&__thrown, self.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return dotnet.System.String(hndl : __return);
        }
    }
    /**
    Gets the input text that the regular expression engine was processing when the time-out occurred.

    */
    open var Input : dotnet.System.String {
        get {
            return try! get_Input();
        }
    }
    /**
    Gets the time-out interval for a regular expression match.

    */
    open var MatchTimeout : dotnet.System.TimeSpan {
        get {
            return try! get_MatchTimeout();
        }
    }
    /**
    Gets the regular expression pattern that was used in the matching operation when the time-out occurred.

    */
    open var Pattern : dotnet.System.String {
        get {
            return try! get_Pattern();
        }
    }
} // RegexMatchTimeoutException


// type: System.Text.RegularExpressions.RegexOptions
    /**
    Provides enumerated values to use to set regular expression options.

    */
public struct RegexOptions : SGBridgeGenericValue {
    let v : Swift.Int32;
    public init(val: Swift.Int32) { self.v = val; }
    public func get_value() -> Swift.Int32 { return self.v; }
    public static func get_type_handle() -> TypeHandle {
        return System_Text_RegularExpressions_RegexOptions_get_type_handle();
    }
    public func to_gval() -> GVal { return GVal(self.v); }
    public func dup_gval() -> GVal { return to_gval(); }
    public init(gval: GVal) { self.v = Swift.Int32(gval); }
    // static field: System.Text.RegularExpressions.RegexOptions None
    /**
    Specifies that no options are set. For more information about the default behavior of the regular expression engine, see the "Default Options" section in the Regular Expression Options article.

    */
    public static var None : dotnet.System.Text.RegularExpressions.RegexOptions {
        get {
        let __return = dotnet.System.Text.RegularExpressions.RegexOptions(val: System_Text_RegularExpressions_RegexOptions_get_None());
            return __return;
        }
    }
    // static field: System.Text.RegularExpressions.RegexOptions IgnoreCase
    /**
    Specifies case-insensitive matching. For more information, see the "Case-Insensitive Matching " section in the Regular Expression Options article.

    */
    public static var IgnoreCase : dotnet.System.Text.RegularExpressions.RegexOptions {
        get {
        let __return = dotnet.System.Text.RegularExpressions.RegexOptions(val: System_Text_RegularExpressions_RegexOptions_get_IgnoreCase());
            return __return;
        }
    }
    // static field: System.Text.RegularExpressions.RegexOptions Multiline
    /**
    Multiline mode. Changes the meaning of ^ and $ so they match at the beginning and end, respectively, of any line, and not just the beginning and end of the entire string. For more information, see the "Multiline Mode" section in the Regular Expression Options article.

    */
    public static var Multiline : dotnet.System.Text.RegularExpressions.RegexOptions {
        get {
        let __return = dotnet.System.Text.RegularExpressions.RegexOptions(val: System_Text_RegularExpressions_RegexOptions_get_Multiline());
            return __return;
        }
    }
    // static field: System.Text.RegularExpressions.RegexOptions ExplicitCapture
    /**
    Specifies that the only valid captures are explicitly named or numbered groups of the form (?<name>...). This allows unnamed parentheses to act as noncapturing groups without the syntactic clumsiness of the expression (?:...). For more information, see the "Explicit Captures Only" section in the Regular Expression Options article.

    */
    public static var ExplicitCapture : dotnet.System.Text.RegularExpressions.RegexOptions {
        get {
        let __return = dotnet.System.Text.RegularExpressions.RegexOptions(val: System_Text_RegularExpressions_RegexOptions_get_ExplicitCapture());
            return __return;
        }
    }
    // static field: System.Text.RegularExpressions.RegexOptions Compiled
    /**
    Specifies that the regular expression is compiled to an assembly. This yields faster execution but increases startup time. This value should not be assigned to the  property when calling the  method. For more information, see the "Compiled Regular Expressions" section in the Regular Expression Options article.

    */
    public static var Compiled : dotnet.System.Text.RegularExpressions.RegexOptions {
        get {
        let __return = dotnet.System.Text.RegularExpressions.RegexOptions(val: System_Text_RegularExpressions_RegexOptions_get_Compiled());
            return __return;
        }
    }
    // static field: System.Text.RegularExpressions.RegexOptions Singleline
    /**
    Specifies single-line mode. Changes the meaning of the dot (.) so it matches every character (instead of every character except \n). For more information, see the "Single-line Mode" section in the Regular Expression Options article.

    */
    public static var Singleline : dotnet.System.Text.RegularExpressions.RegexOptions {
        get {
        let __return = dotnet.System.Text.RegularExpressions.RegexOptions(val: System_Text_RegularExpressions_RegexOptions_get_Singleline());
            return __return;
        }
    }
    // static field: System.Text.RegularExpressions.RegexOptions IgnorePatternWhitespace
    /**
    Eliminates unescaped white space from the pattern and enables comments marked with #. However, this value does not affect or eliminate white space in character classes, numeric quantifiers, or tokens that mark the beginning of individual regular expression language elements. For more information, see the "Ignore White Space" section of the Regular Expression Options article.

    */
    public static var IgnorePatternWhitespace : dotnet.System.Text.RegularExpressions.RegexOptions {
        get {
        let __return = dotnet.System.Text.RegularExpressions.RegexOptions(val: System_Text_RegularExpressions_RegexOptions_get_IgnorePatternWhitespace());
            return __return;
        }
    }
    // static field: System.Text.RegularExpressions.RegexOptions RightToLeft
    /**
    Specifies that the search will be from right to left instead of from left to right. For more information, see the "Right-to-Left Mode" section in the Regular Expression Options article.

    */
    public static var RightToLeft : dotnet.System.Text.RegularExpressions.RegexOptions {
        get {
        let __return = dotnet.System.Text.RegularExpressions.RegexOptions(val: System_Text_RegularExpressions_RegexOptions_get_RightToLeft());
            return __return;
        }
    }
    // static field: System.Text.RegularExpressions.RegexOptions ECMAScript
    /**
    Enables ECMAScript-compliant behavior for the expression. This value can be used only in conjunction with the , , and  values. The use of this value with any other values results in an exception.  
  
 For more information on the  option, see the "ECMAScript Matching Behavior" section in the Regular Expression Options article.

    */
    public static var ECMAScript : dotnet.System.Text.RegularExpressions.RegexOptions {
        get {
        let __return = dotnet.System.Text.RegularExpressions.RegexOptions(val: System_Text_RegularExpressions_RegexOptions_get_ECMAScript());
            return __return;
        }
    }
    // static field: System.Text.RegularExpressions.RegexOptions CultureInvariant
    /**
    Specifies that cultural differences in language is ignored. For more information, see the "Comparison Using the Invariant Culture" section in the Regular Expression Options article.

    */
    public static var CultureInvariant : dotnet.System.Text.RegularExpressions.RegexOptions {
        get {
        let __return = dotnet.System.Text.RegularExpressions.RegexOptions(val: System_Text_RegularExpressions_RegexOptions_get_CultureInvariant());
            return __return;
        }
    }
} // RegexOptions


// type: System.Text.RegularExpressions.RegexParseError
    /**
    Specifies the detailed underlying reason why a  is thrown when a regular expression contains a parsing error.

    */
public struct RegexParseError : SGBridgeGenericValue {
    let v : Swift.Int32;
    public init(val: Swift.Int32) { self.v = val; }
    public func get_value() -> Swift.Int32 { return self.v; }
    public static func get_type_handle() -> TypeHandle {
        return System_Text_RegularExpressions_RegexParseError_get_type_handle();
    }
    public func to_gval() -> GVal { return GVal(self.v); }
    public func dup_gval() -> GVal { return to_gval(); }
    public init(gval: GVal) { self.v = Swift.Int32(gval); }
    // static field: System.Text.RegularExpressions.RegexParseError Unknown
    /**
    An unknown regular expression parse error.

    */
    public static var Unknown : dotnet.System.Text.RegularExpressions.RegexParseError {
        get {
        let __return = dotnet.System.Text.RegularExpressions.RegexParseError(val: System_Text_RegularExpressions_RegexParseError_get_Unknown());
            return __return;
        }
    }
    // static field: System.Text.RegularExpressions.RegexParseError AlternationHasTooManyConditions
    /**
    An alternation in a regular expression has too many conditions.

    */
    public static var AlternationHasTooManyConditions : dotnet.System.Text.RegularExpressions.RegexParseError {
        get {
        let __return = dotnet.System.Text.RegularExpressions.RegexParseError(val: System_Text_RegularExpressions_RegexParseError_get_AlternationHasTooManyConditions());
            return __return;
        }
    }
    // static field: System.Text.RegularExpressions.RegexParseError AlternationHasMalformedCondition
    /**
    An alternation in a regular expression has a malformed condition.

    */
    public static var AlternationHasMalformedCondition : dotnet.System.Text.RegularExpressions.RegexParseError {
        get {
        let __return = dotnet.System.Text.RegularExpressions.RegexParseError(val: System_Text_RegularExpressions_RegexParseError_get_AlternationHasMalformedCondition());
            return __return;
        }
    }
    // static field: System.Text.RegularExpressions.RegexParseError InvalidUnicodePropertyEscape
    /**
    A Unicode property escape in a regular expression is invalid or unknown.

    */
    public static var InvalidUnicodePropertyEscape : dotnet.System.Text.RegularExpressions.RegexParseError {
        get {
        let __return = dotnet.System.Text.RegularExpressions.RegexParseError(val: System_Text_RegularExpressions_RegexParseError_get_InvalidUnicodePropertyEscape());
            return __return;
        }
    }
    // static field: System.Text.RegularExpressions.RegexParseError MalformedUnicodePropertyEscape
    /**
    A Unicode property escape is malformed.

    */
    public static var MalformedUnicodePropertyEscape : dotnet.System.Text.RegularExpressions.RegexParseError {
        get {
        let __return = dotnet.System.Text.RegularExpressions.RegexParseError(val: System_Text_RegularExpressions_RegexParseError_get_MalformedUnicodePropertyEscape());
            return __return;
        }
    }
    // static field: System.Text.RegularExpressions.RegexParseError UnrecognizedEscape
    /**
    An escape character or sequence in a regular expression is invalid.

    */
    public static var UnrecognizedEscape : dotnet.System.Text.RegularExpressions.RegexParseError {
        get {
        let __return = dotnet.System.Text.RegularExpressions.RegexParseError(val: System_Text_RegularExpressions_RegexParseError_get_UnrecognizedEscape());
            return __return;
        }
    }
    // static field: System.Text.RegularExpressions.RegexParseError UnrecognizedControlCharacter
    /**
    A control character in a regular expression is not recognized.

    */
    public static var UnrecognizedControlCharacter : dotnet.System.Text.RegularExpressions.RegexParseError {
        get {
        let __return = dotnet.System.Text.RegularExpressions.RegexParseError(val: System_Text_RegularExpressions_RegexParseError_get_UnrecognizedControlCharacter());
            return __return;
        }
    }
    // static field: System.Text.RegularExpressions.RegexParseError MissingControlCharacter
    /**
    A control character in a regular expression is missing.

    */
    public static var MissingControlCharacter : dotnet.System.Text.RegularExpressions.RegexParseError {
        get {
        let __return = dotnet.System.Text.RegularExpressions.RegexParseError(val: System_Text_RegularExpressions_RegexParseError_get_MissingControlCharacter());
            return __return;
        }
    }
    // static field: System.Text.RegularExpressions.RegexParseError InsufficientOrInvalidHexDigits
    /**
    A hexadecimal escape sequence in a regular expression does not have enough digits, or contains invalid digits.

    */
    public static var InsufficientOrInvalidHexDigits : dotnet.System.Text.RegularExpressions.RegexParseError {
        get {
        let __return = dotnet.System.Text.RegularExpressions.RegexParseError(val: System_Text_RegularExpressions_RegexParseError_get_InsufficientOrInvalidHexDigits());
            return __return;
        }
    }
    // static field: System.Text.RegularExpressions.RegexParseError QuantifierOrCaptureGroupOutOfRange
    /**
    A captured group or a quantifier in a regular expression is not within range, that is, it is larger than .

    */
    public static var QuantifierOrCaptureGroupOutOfRange : dotnet.System.Text.RegularExpressions.RegexParseError {
        get {
        let __return = dotnet.System.Text.RegularExpressions.RegexParseError(val: System_Text_RegularExpressions_RegexParseError_get_QuantifierOrCaptureGroupOutOfRange());
            return __return;
        }
    }
    // static field: System.Text.RegularExpressions.RegexParseError UndefinedNamedReference
    /**
    A used named reference in a regular expression is not defined.

    */
    public static var UndefinedNamedReference : dotnet.System.Text.RegularExpressions.RegexParseError {
        get {
        let __return = dotnet.System.Text.RegularExpressions.RegexParseError(val: System_Text_RegularExpressions_RegexParseError_get_UndefinedNamedReference());
            return __return;
        }
    }
    // static field: System.Text.RegularExpressions.RegexParseError UndefinedNumberedReference
    /**
    A used numbered reference in a regular expression is not defined.

    */
    public static var UndefinedNumberedReference : dotnet.System.Text.RegularExpressions.RegexParseError {
        get {
        let __return = dotnet.System.Text.RegularExpressions.RegexParseError(val: System_Text_RegularExpressions_RegexParseError_get_UndefinedNumberedReference());
            return __return;
        }
    }
    // static field: System.Text.RegularExpressions.RegexParseError MalformedNamedReference
    /**
    A named reference in a regular expression is malformed.

    */
    public static var MalformedNamedReference : dotnet.System.Text.RegularExpressions.RegexParseError {
        get {
        let __return = dotnet.System.Text.RegularExpressions.RegexParseError(val: System_Text_RegularExpressions_RegexParseError_get_MalformedNamedReference());
            return __return;
        }
    }
    // static field: System.Text.RegularExpressions.RegexParseError UnescapedEndingBackslash
    /**
    A regular expression ends with a non-escaped ending backslash.

    */
    public static var UnescapedEndingBackslash : dotnet.System.Text.RegularExpressions.RegexParseError {
        get {
        let __return = dotnet.System.Text.RegularExpressions.RegexParseError(val: System_Text_RegularExpressions_RegexParseError_get_UnescapedEndingBackslash());
            return __return;
        }
    }
    // static field: System.Text.RegularExpressions.RegexParseError UnterminatedComment
    /**
    A comment in a regular expression is not terminated.

    */
    public static var UnterminatedComment : dotnet.System.Text.RegularExpressions.RegexParseError {
        get {
        let __return = dotnet.System.Text.RegularExpressions.RegexParseError(val: System_Text_RegularExpressions_RegexParseError_get_UnterminatedComment());
            return __return;
        }
    }
    // static field: System.Text.RegularExpressions.RegexParseError InvalidGroupingConstruct
    /**
    A grouping construct in a regular expression is invalid or malformed.

    */
    public static var InvalidGroupingConstruct : dotnet.System.Text.RegularExpressions.RegexParseError {
        get {
        let __return = dotnet.System.Text.RegularExpressions.RegexParseError(val: System_Text_RegularExpressions_RegexParseError_get_InvalidGroupingConstruct());
            return __return;
        }
    }
    // static field: System.Text.RegularExpressions.RegexParseError AlternationHasNamedCapture
    /**
    An alternation construct in a regular expression uses a named capture.

    */
    public static var AlternationHasNamedCapture : dotnet.System.Text.RegularExpressions.RegexParseError {
        get {
        let __return = dotnet.System.Text.RegularExpressions.RegexParseError(val: System_Text_RegularExpressions_RegexParseError_get_AlternationHasNamedCapture());
            return __return;
        }
    }
    // static field: System.Text.RegularExpressions.RegexParseError AlternationHasComment
    /**
    An alternation construct in a regular expression contains a comment.

    */
    public static var AlternationHasComment : dotnet.System.Text.RegularExpressions.RegexParseError {
        get {
        let __return = dotnet.System.Text.RegularExpressions.RegexParseError(val: System_Text_RegularExpressions_RegexParseError_get_AlternationHasComment());
            return __return;
        }
    }
    // static field: System.Text.RegularExpressions.RegexParseError AlternationHasMalformedReference
    /**
    An alternation construct in a regular expression contains a malformed reference.

    */
    public static var AlternationHasMalformedReference : dotnet.System.Text.RegularExpressions.RegexParseError {
        get {
        let __return = dotnet.System.Text.RegularExpressions.RegexParseError(val: System_Text_RegularExpressions_RegexParseError_get_AlternationHasMalformedReference());
            return __return;
        }
    }
    // static field: System.Text.RegularExpressions.RegexParseError AlternationHasUndefinedReference
    /**
    An alternation construct in a regular expression contains an undefined reference.

    */
    public static var AlternationHasUndefinedReference : dotnet.System.Text.RegularExpressions.RegexParseError {
        get {
        let __return = dotnet.System.Text.RegularExpressions.RegexParseError(val: System_Text_RegularExpressions_RegexParseError_get_AlternationHasUndefinedReference());
            return __return;
        }
    }
    // static field: System.Text.RegularExpressions.RegexParseError CaptureGroupNameInvalid
    /**
    The group name of a captured group in a regular expression is invalid.

    */
    public static var CaptureGroupNameInvalid : dotnet.System.Text.RegularExpressions.RegexParseError {
        get {
        let __return = dotnet.System.Text.RegularExpressions.RegexParseError(val: System_Text_RegularExpressions_RegexParseError_get_CaptureGroupNameInvalid());
            return __return;
        }
    }
    // static field: System.Text.RegularExpressions.RegexParseError CaptureGroupOfZero
    /**
    A regular expression defines a numbered subexpression named zero.

    */
    public static var CaptureGroupOfZero : dotnet.System.Text.RegularExpressions.RegexParseError {
        get {
        let __return = dotnet.System.Text.RegularExpressions.RegexParseError(val: System_Text_RegularExpressions_RegexParseError_get_CaptureGroupOfZero());
            return __return;
        }
    }
    // static field: System.Text.RegularExpressions.RegexParseError UnterminatedBracket
    /**
    A regular expression has a non-escaped left square bracket, or misses a closing right square bracket.

    */
    public static var UnterminatedBracket : dotnet.System.Text.RegularExpressions.RegexParseError {
        get {
        let __return = dotnet.System.Text.RegularExpressions.RegexParseError(val: System_Text_RegularExpressions_RegexParseError_get_UnterminatedBracket());
            return __return;
        }
    }
    // static field: System.Text.RegularExpressions.RegexParseError ExclusionGroupNotLast
    /**
    A character class in a regular expression with an exclusion group is not the last part of the character class.

    */
    public static var ExclusionGroupNotLast : dotnet.System.Text.RegularExpressions.RegexParseError {
        get {
        let __return = dotnet.System.Text.RegularExpressions.RegexParseError(val: System_Text_RegularExpressions_RegexParseError_get_ExclusionGroupNotLast());
            return __return;
        }
    }
    // static field: System.Text.RegularExpressions.RegexParseError ReversedCharacterRange
    /**
    A character class in a regular expression contains an inverse character range, like z-a instead of a-z.

    */
    public static var ReversedCharacterRange : dotnet.System.Text.RegularExpressions.RegexParseError {
        get {
        let __return = dotnet.System.Text.RegularExpressions.RegexParseError(val: System_Text_RegularExpressions_RegexParseError_get_ReversedCharacterRange());
            return __return;
        }
    }
    // static field: System.Text.RegularExpressions.RegexParseError ShorthandClassInCharacterRange
    /**
    A character-class in a regular expression contains a short-hand class that is not allowed inside a character class.

    */
    public static var ShorthandClassInCharacterRange : dotnet.System.Text.RegularExpressions.RegexParseError {
        get {
        let __return = dotnet.System.Text.RegularExpressions.RegexParseError(val: System_Text_RegularExpressions_RegexParseError_get_ShorthandClassInCharacterRange());
            return __return;
        }
    }
    // static field: System.Text.RegularExpressions.RegexParseError InsufficientClosingParentheses
    /**
    A regular expression has a non-escaped left parenthesis, or misses a closing right parenthesis.

    */
    public static var InsufficientClosingParentheses : dotnet.System.Text.RegularExpressions.RegexParseError {
        get {
        let __return = dotnet.System.Text.RegularExpressions.RegexParseError(val: System_Text_RegularExpressions_RegexParseError_get_InsufficientClosingParentheses());
            return __return;
        }
    }
    // static field: System.Text.RegularExpressions.RegexParseError ReversedQuantifierRange
    /**
    A quantifier range in a regular expression is inverse, like {10,1} instead of (1,10}.

    */
    public static var ReversedQuantifierRange : dotnet.System.Text.RegularExpressions.RegexParseError {
        get {
        let __return = dotnet.System.Text.RegularExpressions.RegexParseError(val: System_Text_RegularExpressions_RegexParseError_get_ReversedQuantifierRange());
            return __return;
        }
    }
    // static field: System.Text.RegularExpressions.RegexParseError NestedQuantifiersNotParenthesized
    /**
    Repeated quantifiers on another quantifier inside a regular expression are not grouped in parentheses.

    */
    public static var NestedQuantifiersNotParenthesized : dotnet.System.Text.RegularExpressions.RegexParseError {
        get {
        let __return = dotnet.System.Text.RegularExpressions.RegexParseError(val: System_Text_RegularExpressions_RegexParseError_get_NestedQuantifiersNotParenthesized());
            return __return;
        }
    }
    // static field: System.Text.RegularExpressions.RegexParseError QuantifierAfterNothing
    /**
    A quantifier in a regular expression is in a position where it cannot quantify anything, like at the beginning of a regular expression or in a group.

    */
    public static var QuantifierAfterNothing : dotnet.System.Text.RegularExpressions.RegexParseError {
        get {
        let __return = dotnet.System.Text.RegularExpressions.RegexParseError(val: System_Text_RegularExpressions_RegexParseError_get_QuantifierAfterNothing());
            return __return;
        }
    }
    // static field: System.Text.RegularExpressions.RegexParseError InsufficientOpeningParentheses
    /**
    A regular expression has a non-escaped right parenthesis, or misses an opening left parenthesis.

    */
    public static var InsufficientOpeningParentheses : dotnet.System.Text.RegularExpressions.RegexParseError {
        get {
        let __return = dotnet.System.Text.RegularExpressions.RegexParseError(val: System_Text_RegularExpressions_RegexParseError_get_InsufficientOpeningParentheses());
            return __return;
        }
    }
    // static field: System.Text.RegularExpressions.RegexParseError UnrecognizedUnicodeProperty
    /**
    A unicode property in a regular expression is not recognized, or invalid.

    */
    public static var UnrecognizedUnicodeProperty : dotnet.System.Text.RegularExpressions.RegexParseError {
        get {
        let __return = dotnet.System.Text.RegularExpressions.RegexParseError(val: System_Text_RegularExpressions_RegexParseError_get_UnrecognizedUnicodeProperty());
            return __return;
        }
    }
} // RegexParseError


// type: System.Text.RegularExpressions.RegexParseException
    /**
    An exception as a result of a parse error in a regular expression, with detailed information in the  and  properties.

    */
public final class RegexParseException
    :
    dotnet.System.ArgumentException
{
    public class override func get_type_handle() -> TypeHandle {
        return System_Text_RegularExpressions_RegexParseException_get_type_handle();
    }
    public required init(hndl: NonnullHandle) { super.init(hndl: hndl); }
    public required init(gval: GVal) { super.init(gval: gval); }
    // void GetObjectData(System.Runtime.Serialization.SerializationInfo, System.Runtime.Serialization.StreamingContext)
// docid: M:System.Text.RegularExpressions.RegexParseException.GetObjectData(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)
    /**
    Sets the  object with the parameter name and additional exception information.

    - Parameter info: The object that holds the serialized object data.
    - Parameter context: The contextual information about the source or destination.
    */
    public override func GetObjectData(info : dotnet.System.Runtime.Serialization.SerializationInfo, context : dotnet.System.Runtime.Serialization.StreamingContext) throws {
        var __thrown : NullableHandle = nil;
        System_Text_RegularExpressions_RegexParseException_void__GetObjectData_0__2__SerializationInfo_StreamingContext(&__thrown, self.get_handle(), info.get_handle(), context.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
            return;
        }
    }
    // [IsSpecialName] System.Text.RegularExpressions.RegexParseError get_Error()
// docid: M:System.Text.RegularExpressions.RegexParseException.get_Error
    public func get_Error() throws -> dotnet.System.Text.RegularExpressions.RegexParseError {
        var __thrown : NullableHandle = nil;
        let __return = System_Text_RegularExpressions_RegexParseException_RegexParseError__get_Error_0__0(&__thrown, self.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return dotnet.System.Text.RegularExpressions.RegexParseError(val: __return);
        }
    }
    // [IsSpecialName] System.Int32 get_Offset()
// docid: M:System.Text.RegularExpressions.RegexParseException.get_Offset
    public func get_Offset() throws -> Swift.Int32 {
        var __thrown : NullableHandle = nil;
        let __return = System_Text_RegularExpressions_RegexParseException_i32__get_Offset_0__0(&__thrown, self.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return __return;
        }
    }
    /**
    Gets the error that happened during parsing.

    */
    public var Error : dotnet.System.Text.RegularExpressions.RegexParseError {
        get {
            return try! get_Error();
        }
    }
    /**
    Gets the zero-based character offset in the regular expression pattern where the parse error occurs.

    */
    public var Offset : Swift.Int32 {
        get {
            return try! get_Offset();
        }
    }
} // RegexParseException


// type: System.Text.RegularExpressions.RegexRunner
    /**
    The  class is the base class for compiled regular expressions.

    */
open class RegexRunner
    :
    dotnet.System.Object
{
    open class override func get_type_handle() -> TypeHandle {
        return System_Text_RegularExpressions_RegexRunner_get_type_handle();
    }
    public required init(hndl: NonnullHandle) { super.init(hndl: hndl); }
    public required init(gval: GVal) { super.init(gval: gval); }
} // RegexRunner


// type: System.Text.RegularExpressions.RegexRunnerFactory
    /**
    Creates a  class for a compiled regular expression.

    */
open class RegexRunnerFactory
    :
    dotnet.System.Object
{
    open class override func get_type_handle() -> TypeHandle {
        return System_Text_RegularExpressions_RegexRunnerFactory_get_type_handle();
    }
    public required init(hndl: NonnullHandle) { super.init(hndl: hndl); }
    public required init(gval: GVal) { super.init(gval: gval); }
} // RegexRunnerFactory


}



