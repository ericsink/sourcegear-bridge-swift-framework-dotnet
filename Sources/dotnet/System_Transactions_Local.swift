// this file is automatically generated
// Copyright 2021 SourceGear

import jumptable_dotnet;

// System
// System.Transactions
extension System.Transactions {
// type: System.Transactions.CommittableTransaction
    /**
    Describes a committable transaction.

    */
public final class CommittableTransaction
    :
    dotnet.System.Transactions.Transaction,
    System_IAsyncResult
{
    public class override func get_type_handle() -> TypeHandle {
        return System_Transactions_CommittableTransaction_get_type_handle();
    }
    public required init(hndl: NonnullHandle) { super.init(hndl: hndl); }
    public required init(gval: GVal) { super.init(gval: gval); }
    // .ctor()
// docid: M:System.Transactions.CommittableTransaction.#ctor
    /**
    Initializes a new instance of the  class.

    */
    public init() throws {
        var __thrown : NullableHandle = nil;
        let h = System_Transactions_CommittableTransaction_ctor_0__0(&__thrown);
        if let __ex = __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
            super.init(hndl: h);
        }
    }
// TODO COPE ctor (span) .ctor(System.TimeSpan)
    // .ctor(System.Transactions.TransactionOptions)
// docid: M:System.Transactions.CommittableTransaction.#ctor(System.Transactions.TransactionOptions)
    /**
    Initializes a new instance of the  class with the specified transaction options.

    - Parameter options: A  structure that describes the transaction options to use for the new transaction.
    */
    public init(options : dotnet.System.Transactions.TransactionOptions) throws {
        var __thrown : NullableHandle = nil;
        let h = System_Transactions_CommittableTransaction_ctor_0__1__TransactionOptions(&__thrown, options.get_handle());
        if let __ex = __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
            super.init(hndl: h);
        }
    }
    // System.IAsyncResult BeginCommit(System.AsyncCallback, System.Object)
// docid: M:System.Transactions.CommittableTransaction.BeginCommit(System.AsyncCallback,System.Object)
    /**
    Begins an attempt to commit the transaction asynchronously.

    - Parameter asyncCallback: The  delegate that is invoked when the transaction completes. This parameter can be , in which case the application is not notified of the transaction's completion. Instead, the application must use the  interface to check for completion and wait accordingly, or call  to wait for completion.
    - Parameter asyncState: An object, which might contain arbitrary state information, associated with the asynchronous commitment. This object is passed to the callback, and is not interpreted by . A null reference is permitted.
    - Returns: An  interface that can be used by the caller to check the status of the asynchronous operation, or to wait for the operation to complete.

    */
    public func BeginCommit(asyncCallback : Optional<dotnet.System.AsyncCallback>, asyncState : Optional<dotnet.System.Object>) throws -> dotnet.System.IAsyncResult {
        var __thrown : NullableHandle = nil;
        let __return = System_Transactions_CommittableTransaction_IAsyncResult__BeginCommit_0__2__AsyncCallback_Object(&__thrown, self.get_handle(), asyncCallback?.get_handle() ?? nil, asyncState?.get_handle() ?? nil);
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return dotnet.System.IAsyncResult(hndl : __return);
        }
    }
    // delegate closure overload
    public func BeginCommit(asyncCallback : @escaping (dotnet.System.IAsyncResult) throws -> Void, asyncState : Optional<dotnet.System.Object>) throws -> dotnet.System.IAsyncResult {
        let del_asyncCallback = try dotnet.System.AsyncCallback(asyncCallback);
        return try BeginCommit(asyncCallback: del_asyncCallback, asyncState: asyncState);
    }
    // void Commit()
// docid: M:System.Transactions.CommittableTransaction.Commit
    /**
    Attempts to commit the transaction.

    */
    public func Commit() throws {
        var __thrown : NullableHandle = nil;
        System_Transactions_CommittableTransaction_void__Commit_0__0(&__thrown, self.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
            return;
        }
    }
    // void EndCommit(System.IAsyncResult)
// docid: M:System.Transactions.CommittableTransaction.EndCommit(System.IAsyncResult)
    /**
    Ends an attempt to commit the transaction asynchronously.

    - Parameter asyncResult: The  object associated with the asynchronous commitment.
    */
    public func EndCommit(asyncResult : dotnet.System.IAsyncResult) throws {
        var __thrown : NullableHandle = nil;
        System_Transactions_CommittableTransaction_void__EndCommit_0__1__IAsyncResult(&__thrown, self.get_handle(), asyncResult.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
            return;
        }
    }
} // CommittableTransaction


// type: System.Transactions.DependentCloneOption
    /**
    Controls what kind of dependent transaction to create.

    */
public struct DependentCloneOption : SGBridgeGenericValue {
    let v : Swift.Int32;
    public init(val: Swift.Int32) { self.v = val; }
    public func get_value() -> Swift.Int32 { return self.v; }
    public static func get_type_handle() -> TypeHandle {
        return System_Transactions_DependentCloneOption_get_type_handle();
    }
    public func to_gval() -> GVal { return GVal(self.v); }
    public func dup_gval() -> GVal { return to_gval(); }
    public init(gval: GVal) { self.v = Swift.Int32(gval); }
    // static field: System.Transactions.DependentCloneOption BlockCommitUntilComplete
    /**
    The dependent transaction blocks the commit process of the transaction until the parent transaction times out, or  is called. In this case, additional work can be done on the transaction and new enlistments can be created.

    */
    public static var BlockCommitUntilComplete : dotnet.System.Transactions.DependentCloneOption {
        get {
        let __return = dotnet.System.Transactions.DependentCloneOption(val: System_Transactions_DependentCloneOption_get_BlockCommitUntilComplete());
            return __return;
        }
    }
    // static field: System.Transactions.DependentCloneOption RollbackIfNotComplete
    /**
    The dependent transaction automatically aborts the transaction if Commit is called on the parent transaction before  is called.

    */
    public static var RollbackIfNotComplete : dotnet.System.Transactions.DependentCloneOption {
        get {
        let __return = dotnet.System.Transactions.DependentCloneOption(val: System_Transactions_DependentCloneOption_get_RollbackIfNotComplete());
            return __return;
        }
    }
} // DependentCloneOption


// type: System.Transactions.DependentTransaction
    /**
    Describes a clone of a transaction providing guarantee that the transaction cannot be committed until the application comes to rest regarding work on the transaction. This class cannot be inherited.

    */
public final class DependentTransaction
    :
    dotnet.System.Transactions.Transaction
{
    public class override func get_type_handle() -> TypeHandle {
        return System_Transactions_DependentTransaction_get_type_handle();
    }
    public required init(hndl: NonnullHandle) { super.init(hndl: hndl); }
    public required init(gval: GVal) { super.init(gval: gval); }
    // void Complete()
// docid: M:System.Transactions.DependentTransaction.Complete
    /**
    Attempts to complete the dependent transaction.

    */
    public func Complete() throws {
        var __thrown : NullableHandle = nil;
        System_Transactions_DependentTransaction_void__Complete_0__0(&__thrown, self.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
            return;
        }
    }
} // DependentTransaction


// type: System.Transactions.Enlistment
    /**
    Facilitates communication between an enlisted transaction participant and the transaction manager during the final phase of the transaction.

    */
open class Enlistment
    :
    dotnet.System.Object
{
    open class override func get_type_handle() -> TypeHandle {
        return System_Transactions_Enlistment_get_type_handle();
    }
    public required init(hndl: NonnullHandle) { super.init(hndl: hndl); }
    public required init(gval: GVal) { super.init(gval: gval); }
    // void Done()
// docid: M:System.Transactions.Enlistment.Done
    /**
    Indicates that the transaction participant has completed its work.

    */
    open func Done() throws {
        var __thrown : NullableHandle = nil;
        System_Transactions_Enlistment_void__Done_0__0(&__thrown, self.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
            return;
        }
    }
} // Enlistment


// type: System.Transactions.EnlistmentOptions
    /**
    Determines whether the object should be enlisted during the prepare phase.

    */
public struct EnlistmentOptions : SGBridgeGenericValue {
    let v : Swift.Int32;
    public init(val: Swift.Int32) { self.v = val; }
    public func get_value() -> Swift.Int32 { return self.v; }
    public static func get_type_handle() -> TypeHandle {
        return System_Transactions_EnlistmentOptions_get_type_handle();
    }
    public func to_gval() -> GVal { return GVal(self.v); }
    public func dup_gval() -> GVal { return to_gval(); }
    public init(gval: GVal) { self.v = Swift.Int32(gval); }
    // static field: System.Transactions.EnlistmentOptions None
    /**
    The object does not require enlistment during the initial phase of the commitment process.

    */
    public static var None : dotnet.System.Transactions.EnlistmentOptions {
        get {
        let __return = dotnet.System.Transactions.EnlistmentOptions(val: System_Transactions_EnlistmentOptions_get_None());
            return __return;
        }
    }
    // static field: System.Transactions.EnlistmentOptions EnlistDuringPrepareRequired
    /**
    The object must enlist during the initial phase of the commitment process.

    */
    public static var EnlistDuringPrepareRequired : dotnet.System.Transactions.EnlistmentOptions {
        get {
        let __return = dotnet.System.Transactions.EnlistmentOptions(val: System_Transactions_EnlistmentOptions_get_EnlistDuringPrepareRequired());
            return __return;
        }
    }
} // EnlistmentOptions


// type: System.Transactions.EnterpriseServicesInteropOption
    /**
    Specifies how distributed transactions interact with COM+ transactions.

    */
public struct EnterpriseServicesInteropOption : SGBridgeGenericValue {
    let v : Swift.Int32;
    public init(val: Swift.Int32) { self.v = val; }
    public func get_value() -> Swift.Int32 { return self.v; }
    public static func get_type_handle() -> TypeHandle {
        return System_Transactions_EnterpriseServicesInteropOption_get_type_handle();
    }
    public func to_gval() -> GVal { return GVal(self.v); }
    public func dup_gval() -> GVal { return to_gval(); }
    public init(gval: GVal) { self.v = Swift.Int32(gval); }
    // static field: System.Transactions.EnterpriseServicesInteropOption None
    /**
    There is no synchronization between  and .

    */
    public static var None : dotnet.System.Transactions.EnterpriseServicesInteropOption {
        get {
        let __return = dotnet.System.Transactions.EnterpriseServicesInteropOption(val: System_Transactions_EnterpriseServicesInteropOption_get_None());
            return __return;
        }
    }
    // static field: System.Transactions.EnterpriseServicesInteropOption Automatic
    /**
    Search for an existing COM+ context and synchronize with it if one exists.

    */
    public static var Automatic : dotnet.System.Transactions.EnterpriseServicesInteropOption {
        get {
        let __return = dotnet.System.Transactions.EnterpriseServicesInteropOption(val: System_Transactions_EnterpriseServicesInteropOption_get_Automatic());
            return __return;
        }
    }
    // static field: System.Transactions.EnterpriseServicesInteropOption Full
    /**
    The  context (which can be retrieved by calling the static method  of the  class) and the  ambient transaction (which can be retrieved by calling the static method  of the  class) are always synchronized. This introduces a performance penalty because new  contexts may need to be created.

    */
    public static var Full : dotnet.System.Transactions.EnterpriseServicesInteropOption {
        get {
        let __return = dotnet.System.Transactions.EnterpriseServicesInteropOption(val: System_Transactions_EnterpriseServicesInteropOption_get_Full());
            return __return;
        }
    }
} // EnterpriseServicesInteropOption


// type: System.Transactions.HostCurrentTransactionCallback
    /**
    Provides a mechanism for the hosting environment to supply its own default notion of .

    */
public final class HostCurrentTransactionCallback
    :
    dotnet.System.Delegate
{
    public class override func get_type_handle() -> TypeHandle {
        return System_Transactions_HostCurrentTransactionCallback_get_type_handle();
    }
    public required init(hndl: NonnullHandle) { super.init(hndl: hndl); }
    public required init(gval: GVal) { super.init(gval: gval); }
    // System.Transactions.Transaction Invoke()
// docid: M:System.Transactions.HostCurrentTransactionCallback.Invoke
    public func Invoke() throws -> Optional<dotnet.System.Transactions.Transaction> {
        var __thrown : NullableHandle = nil;
        let __return = System_Transactions_HostCurrentTransactionCallback_Transaction__Invoke_0__0(&__thrown, self.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        if let __ret_unwrapped = __return {
            return dotnet.System.Transactions.Transaction(hndl : __ret_unwrapped);
        } else {
            return nil;
        }
        }
    }
    // System.IAsyncResult BeginInvoke(System.AsyncCallback, System.Object)
// docid: M:System.Transactions.HostCurrentTransactionCallback.BeginInvoke(System.AsyncCallback,System.Object)
    public func BeginInvoke(callback : Optional<dotnet.System.AsyncCallback>, object : Optional<dotnet.System.Object>) throws -> Optional<dotnet.System.IAsyncResult> {
        var __thrown : NullableHandle = nil;
        let __return = System_Transactions_HostCurrentTransactionCallback_IAsyncResult__BeginInvoke_0__2__AsyncCallback_Object(&__thrown, self.get_handle(), callback?.get_handle() ?? nil, object?.get_handle() ?? nil);
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        if let __ret_unwrapped = __return {
            return dotnet.System.IAsyncResult(hndl : __ret_unwrapped);
        } else {
            return nil;
        }
        }
    }
    // System.Transactions.Transaction EndInvoke(System.IAsyncResult)
// docid: M:System.Transactions.HostCurrentTransactionCallback.EndInvoke(System.IAsyncResult)
    public func EndInvoke(result : Optional<dotnet.System.IAsyncResult>) throws -> Optional<dotnet.System.Transactions.Transaction> {
        var __thrown : NullableHandle = nil;
        let __return = System_Transactions_HostCurrentTransactionCallback_Transaction__EndInvoke_0__1__IAsyncResult(&__thrown, self.get_handle(), result?.get_handle() ?? nil);
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        if let __ret_unwrapped = __return {
            return dotnet.System.Transactions.Transaction(hndl : __ret_unwrapped);
        } else {
            return nil;
        }
        }
    }
    public init(_ callback : @escaping () throws -> dotnet.System.Transactions.Transaction) throws
    {
        let __bridge : (UnsafeMutablePointer<NullableHandle>) -> NullableHandle =
        {
            (thrown : UnsafeMutablePointer<NullableHandle>) -> NullableHandle in
            do
            {
                thrown.pointee = nil;
                let ret = try callback();
                return __copy_handle(ret.get_handle());
            }
            catch let e as dotnet.System.Exception
            {
                thrown.pointee = __copy_handle(e.get_handle());
                return NonnullHandle(bitPattern: 8675309)!;
            }
            catch
            {
                let e = try! dotnet.System.Exception(message: "TODO fail inside closure");
                thrown.pointee = __copy_handle(e.get_handle());
                return NonnullHandle(bitPattern: 8675309)!;
            }
        };
        let cbarg = UnsafeRawPointer(Unmanaged.passRetained(__bridge as AnyObject).toOpaque());
        func __cb(cb : UnsafeRawPointer?, thrown : UnsafeMutablePointer<NullableHandle>) -> NullableHandle
        {
            let f = Unmanaged<AnyObject>.fromOpaque(cb!).takeUnretainedValue() as! (UnsafeMutablePointer<NullableHandle>) -> NullableHandle;
            return f(thrown);
        }
        var __thrown : NullableHandle = nil;
        let h = System_Transactions_HostCurrentTransactionCallback_create(
            &__thrown,
            cbarg,
            nil, // TODO deinit
            __cb
            );
            // TODO check thrown
        if let __ex = __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
            super.init(hndl: h);
        }
    }
    // System.Transactions.Transaction Invoke()
// docid: M:System.Transactions.HostCurrentTransactionCallback.Invoke
    public func callAsFunction() throws -> Optional<dotnet.System.Transactions.Transaction> {
        var __thrown : NullableHandle = nil;
        let __return = System_Transactions_HostCurrentTransactionCallback_Transaction__Invoke_0__0(&__thrown, self.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        if let __ret_unwrapped = __return {
            return dotnet.System.Transactions.Transaction(hndl : __ret_unwrapped);
        } else {
            return nil;
        }
        }
    }
} // HostCurrentTransactionCallback


// type: System.Transactions.IDtcTransaction
    /**
    Describes a DTC transaction.

    */
open class IDtcTransaction
    :
    SGBridgeGenericValue,
    System_Transactions_IDtcTransaction
{
    open class func get_type_handle() -> TypeHandle {
        return System_Transactions_IDtcTransaction_get_type_handle();
    }
    let h : NonnullHandle;
    public func to_gval() -> GVal { return GVal(Swift.Int(bitPattern: self.h)); }
    public func dup_gval() -> GVal { return GVal(Swift.Int(bitPattern: __copy_handle(self.h))); }
    public required init(gval: GVal) { self.h = NonnullHandle(bitPattern: Swift.Int(truncatingIfNeeded: gval))!; }
    public required init(hndl: NonnullHandle) { self.h = hndl; }
    public func get_handle() -> NonnullHandle { return self.h; }

    deinit { __drop_handle(self.h); }

    // void Abort(System.IntPtr, System.Int32, System.Int32)
// docid: M:System.Transactions.IDtcTransaction.Abort(System.IntPtr,System.Int32,System.Int32)
    /**
    Aborts a transaction.

    - Parameter reason: An optional  that indicates why the transaction is being aborted. This parameter can be , indicating that no reason for the abort is provided.
    - Parameter retaining: This value must be .
    - Parameter async: When  is , an asynchronous abort is performed and the caller must use  to learn about the outcome of the transaction.
    */
    open func Abort(reason : dotnet.System.IntPtr, retaining : Swift.Int32, async : Swift.Int32) throws {
        var __thrown : NullableHandle = nil;
        System_Transactions_IDtcTransaction_void__Abort_0__3__IntPtr_i32_i32(&__thrown, self.get_handle(), reason.get_value(), retaining, async);
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
            return;
        }
    }
    // void Commit(System.Int32, System.Int32, System.Int32)
// docid: M:System.Transactions.IDtcTransaction.Commit(System.Int32,System.Int32,System.Int32)
    /**
    Commits a transaction.

    - Parameter retaining: This value must be .
    - Parameter commitType: A value taken from the OLE DB enumeration .
    - Parameter reserved: This value must be zero.
    */
    open func Commit(retaining : Swift.Int32, commitType : Swift.Int32, reserved : Swift.Int32) throws {
        var __thrown : NullableHandle = nil;
        System_Transactions_IDtcTransaction_void__Commit_0__3__i32_i32_i32(&__thrown, self.get_handle(), retaining, commitType, reserved);
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
            return;
        }
    }
    // void GetTransactionInfo(System.IntPtr)
// docid: M:System.Transactions.IDtcTransaction.GetTransactionInfo(System.IntPtr)
    /**
    Retrieves information about a transaction.

    - Parameter transactionInformation: Pointer to the caller-allocated  structure that will receive information about the transaction. This value must not be .
    */
    open func GetTransactionInfo(transactionInformation : dotnet.System.IntPtr) throws {
        var __thrown : NullableHandle = nil;
        System_Transactions_IDtcTransaction_void__GetTransactionInfo_0__1__IntPtr(&__thrown, self.get_handle(), transactionInformation.get_value());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
            return;
        }
    }
} // IDtcTransaction


// type: System.Transactions.IEnlistmentNotification
    /**
    Describes an interface that a resource manager should implement to provide two phase commit notification callbacks for the transaction manager upon enlisting for participation.

    */
open class IEnlistmentNotification
    :
    SGBridgeGenericValue,
    System_Transactions_IEnlistmentNotification
{
    open class func get_type_handle() -> TypeHandle {
        return System_Transactions_IEnlistmentNotification_get_type_handle();
    }
    let h : NonnullHandle;
    public func to_gval() -> GVal { return GVal(Swift.Int(bitPattern: self.h)); }
    public func dup_gval() -> GVal { return GVal(Swift.Int(bitPattern: __copy_handle(self.h))); }
    public required init(gval: GVal) { self.h = NonnullHandle(bitPattern: Swift.Int(truncatingIfNeeded: gval))!; }
    public required init(hndl: NonnullHandle) { self.h = hndl; }
    public func get_handle() -> NonnullHandle { return self.h; }

    deinit { __drop_handle(self.h); }

    // void Commit(System.Transactions.Enlistment)
// docid: M:System.Transactions.IEnlistmentNotification.Commit(System.Transactions.Enlistment)
    /**
    Notifies an enlisted object that a transaction is being committed.

    - Parameter enlistment: An  object used to send a response to the transaction manager.
    */
    open func Commit(enlistment : dotnet.System.Transactions.Enlistment) throws {
        var __thrown : NullableHandle = nil;
        System_Transactions_IEnlistmentNotification_void__Commit_0__1__Enlistment(&__thrown, self.get_handle(), enlistment.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
            return;
        }
    }
    // void InDoubt(System.Transactions.Enlistment)
// docid: M:System.Transactions.IEnlistmentNotification.InDoubt(System.Transactions.Enlistment)
    /**
    Notifies an enlisted object that the status of a transaction is in doubt.

    - Parameter enlistment: An  object used to send a response to the transaction manager.
    */
    open func InDoubt(enlistment : dotnet.System.Transactions.Enlistment) throws {
        var __thrown : NullableHandle = nil;
        System_Transactions_IEnlistmentNotification_void__InDoubt_0__1__Enlistment(&__thrown, self.get_handle(), enlistment.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
            return;
        }
    }
    // void Prepare(System.Transactions.PreparingEnlistment)
// docid: M:System.Transactions.IEnlistmentNotification.Prepare(System.Transactions.PreparingEnlistment)
    /**
    Notifies an enlisted object that a transaction is being prepared for commitment.

    - Parameter preparingEnlistment: A  object used to send a response to the transaction manager.
    */
    open func Prepare(preparingEnlistment : dotnet.System.Transactions.PreparingEnlistment) throws {
        var __thrown : NullableHandle = nil;
        System_Transactions_IEnlistmentNotification_void__Prepare_0__1__PreparingEnlistment(&__thrown, self.get_handle(), preparingEnlistment.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
            return;
        }
    }
    // void Rollback(System.Transactions.Enlistment)
// docid: M:System.Transactions.IEnlistmentNotification.Rollback(System.Transactions.Enlistment)
    /**
    Notifies an enlisted object that a transaction is being rolled back (aborted).

    - Parameter enlistment: A  object used to send a response to the transaction manager.
    */
    open func Rollback(enlistment : dotnet.System.Transactions.Enlistment) throws {
        var __thrown : NullableHandle = nil;
        System_Transactions_IEnlistmentNotification_void__Rollback_0__1__Enlistment(&__thrown, self.get_handle(), enlistment.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
            return;
        }
    }
} // IEnlistmentNotification


// type: System.Transactions.IPromotableSinglePhaseNotification
    /**
    Describes an object that acts as a commit delegate for a non-distributed transaction internal to a resource manager.

    */
open class IPromotableSinglePhaseNotification
    :
    SGBridgeGenericValue,
    System_Transactions_IPromotableSinglePhaseNotification,
    System_Transactions_ITransactionPromoter
{
    open class func get_type_handle() -> TypeHandle {
        return System_Transactions_IPromotableSinglePhaseNotification_get_type_handle();
    }
    let h : NonnullHandle;
    public func to_gval() -> GVal { return GVal(Swift.Int(bitPattern: self.h)); }
    public func dup_gval() -> GVal { return GVal(Swift.Int(bitPattern: __copy_handle(self.h))); }
    public required init(gval: GVal) { self.h = NonnullHandle(bitPattern: Swift.Int(truncatingIfNeeded: gval))!; }
    public required init(hndl: NonnullHandle) { self.h = hndl; }
    public func get_handle() -> NonnullHandle { return self.h; }

    deinit { __drop_handle(self.h); }

    // void Initialize()
// docid: M:System.Transactions.IPromotableSinglePhaseNotification.Initialize
    /**
    Notifies a transaction participant that enlistment has completed successfully.

    */
    open func Initialize() throws {
        var __thrown : NullableHandle = nil;
        System_Transactions_IPromotableSinglePhaseNotification_void__Initialize_0__0(&__thrown, self.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
            return;
        }
    }
    // void Rollback(System.Transactions.SinglePhaseEnlistment)
// docid: M:System.Transactions.IPromotableSinglePhaseNotification.Rollback(System.Transactions.SinglePhaseEnlistment)
    /**
    Notifies an enlisted object that the transaction is being rolled back.

    - Parameter singlePhaseEnlistment: A  object used to send a response to the transaction manager.
    */
    open func Rollback(singlePhaseEnlistment : dotnet.System.Transactions.SinglePhaseEnlistment) throws {
        var __thrown : NullableHandle = nil;
        System_Transactions_IPromotableSinglePhaseNotification_void__Rollback_0__1__SinglePhaseEnlistment(&__thrown, self.get_handle(), singlePhaseEnlistment.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
            return;
        }
    }
    // void SinglePhaseCommit(System.Transactions.SinglePhaseEnlistment)
// docid: M:System.Transactions.IPromotableSinglePhaseNotification.SinglePhaseCommit(System.Transactions.SinglePhaseEnlistment)
    /**
    Notifies an enlisted object that the transaction is being committed.

    - Parameter singlePhaseEnlistment: A  interface used to send a response to the transaction manager.
    */
    open func SinglePhaseCommit(singlePhaseEnlistment : dotnet.System.Transactions.SinglePhaseEnlistment) throws {
        var __thrown : NullableHandle = nil;
        System_Transactions_IPromotableSinglePhaseNotification_void__SinglePhaseCommit_0__1__SinglePhaseEnlistment(&__thrown, self.get_handle(), singlePhaseEnlistment.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
            return;
        }
    }
} // IPromotableSinglePhaseNotification


// type: System.Transactions.ISimpleTransactionSuperior
    /**
    Represents a transaction that is not a root transaction, but can be escalated to be managed by the MSDTC.

    */
open class ISimpleTransactionSuperior
    :
    SGBridgeGenericValue,
    System_Transactions_ISimpleTransactionSuperior,
    System_Transactions_ITransactionPromoter
{
    open class func get_type_handle() -> TypeHandle {
        return System_Transactions_ISimpleTransactionSuperior_get_type_handle();
    }
    let h : NonnullHandle;
    public func to_gval() -> GVal { return GVal(Swift.Int(bitPattern: self.h)); }
    public func dup_gval() -> GVal { return GVal(Swift.Int(bitPattern: __copy_handle(self.h))); }
    public required init(gval: GVal) { self.h = NonnullHandle(bitPattern: Swift.Int(truncatingIfNeeded: gval))!; }
    public required init(hndl: NonnullHandle) { self.h = hndl; }
    public func get_handle() -> NonnullHandle { return self.h; }

    deinit { __drop_handle(self.h); }

    // void Rollback()
// docid: M:System.Transactions.ISimpleTransactionSuperior.Rollback
    /**
    Notifies an enlisted object that the transaction is being rolled back.

    */
    open func Rollback() throws {
        var __thrown : NullableHandle = nil;
        System_Transactions_ISimpleTransactionSuperior_void__Rollback_0__0(&__thrown, self.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
            return;
        }
    }
} // ISimpleTransactionSuperior


// type: System.Transactions.ISinglePhaseNotification
    /**
    Describes a resource object that supports single phase commit optimization to participate in a transaction.

    */
open class ISinglePhaseNotification
    :
    SGBridgeGenericValue,
    System_Transactions_ISinglePhaseNotification,
    System_Transactions_IEnlistmentNotification
{
    open class func get_type_handle() -> TypeHandle {
        return System_Transactions_ISinglePhaseNotification_get_type_handle();
    }
    let h : NonnullHandle;
    public func to_gval() -> GVal { return GVal(Swift.Int(bitPattern: self.h)); }
    public func dup_gval() -> GVal { return GVal(Swift.Int(bitPattern: __copy_handle(self.h))); }
    public required init(gval: GVal) { self.h = NonnullHandle(bitPattern: Swift.Int(truncatingIfNeeded: gval))!; }
    public required init(hndl: NonnullHandle) { self.h = hndl; }
    public func get_handle() -> NonnullHandle { return self.h; }

    deinit { __drop_handle(self.h); }

    // void SinglePhaseCommit(System.Transactions.SinglePhaseEnlistment)
// docid: M:System.Transactions.ISinglePhaseNotification.SinglePhaseCommit(System.Transactions.SinglePhaseEnlistment)
    /**
    Represents the resource manager's implementation of the callback for the single phase commit optimization.

    - Parameter singlePhaseEnlistment: A  used to send a response to the transaction manager.
    */
    open func SinglePhaseCommit(singlePhaseEnlistment : dotnet.System.Transactions.SinglePhaseEnlistment) throws {
        var __thrown : NullableHandle = nil;
        System_Transactions_ISinglePhaseNotification_void__SinglePhaseCommit_0__1__SinglePhaseEnlistment(&__thrown, self.get_handle(), singlePhaseEnlistment.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
            return;
        }
    }
} // ISinglePhaseNotification


// type: System.Transactions.ITransactionPromoter
    /**
    Describes a delegated transaction for an existing transaction that can be escalated to be managed by the MSDTC when needed.

    */
open class ITransactionPromoter
    :
    SGBridgeGenericValue,
    System_Transactions_ITransactionPromoter
{
    open class func get_type_handle() -> TypeHandle {
        return System_Transactions_ITransactionPromoter_get_type_handle();
    }
    let h : NonnullHandle;
    public func to_gval() -> GVal { return GVal(Swift.Int(bitPattern: self.h)); }
    public func dup_gval() -> GVal { return GVal(Swift.Int(bitPattern: __copy_handle(self.h))); }
    public required init(gval: GVal) { self.h = NonnullHandle(bitPattern: Swift.Int(truncatingIfNeeded: gval))!; }
    public required init(hndl: NonnullHandle) { self.h = hndl; }
    public func get_handle() -> NonnullHandle { return self.h; }

    deinit { __drop_handle(self.h); }

    // System.Byte[] Promote()
// docid: M:System.Transactions.ITransactionPromoter.Promote
    /**
    Notifies an enlisted object that an escalation of the delegated transaction has been requested.

    - Returns: A transmitter/receiver propagation token that marshals a distributed transaction. For more information, see .

    */
    open func Promote() throws -> Optional<dotnet.System_Arr<Swift.UInt8>> {
        var __thrown : NullableHandle = nil;
        let __return = System_Transactions_ITransactionPromoter_u8Array__Promote_0__0(&__thrown, self.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        if let __ret_unwrapped = __return {
            return dotnet.System_Arr<Swift.UInt8>(hndl : __ret_unwrapped);
        } else {
            return nil;
        }
        }
    }
} // ITransactionPromoter


// type: System.Transactions.IsolationLevel
    /**
    Specifies the isolation level of a transaction.

    */
public struct IsolationLevel : SGBridgeGenericValue {
    let v : Swift.Int32;
    public init(val: Swift.Int32) { self.v = val; }
    public func get_value() -> Swift.Int32 { return self.v; }
    public static func get_type_handle() -> TypeHandle {
        return System_Transactions_IsolationLevel_get_type_handle();
    }
    public func to_gval() -> GVal { return GVal(self.v); }
    public func dup_gval() -> GVal { return to_gval(); }
    public init(gval: GVal) { self.v = Swift.Int32(gval); }
    // static field: System.Transactions.IsolationLevel Serializable
    /**
    Volatile data can be read but not modified, and no new data can be added during the transaction.

    */
    public static var Serializable : dotnet.System.Transactions.IsolationLevel {
        get {
        let __return = dotnet.System.Transactions.IsolationLevel(val: System_Transactions_IsolationLevel_get_Serializable());
            return __return;
        }
    }
    // static field: System.Transactions.IsolationLevel RepeatableRead
    /**
    Volatile data can be read but not modified during the transaction. New data can be added during the transaction.

    */
    public static var RepeatableRead : dotnet.System.Transactions.IsolationLevel {
        get {
        let __return = dotnet.System.Transactions.IsolationLevel(val: System_Transactions_IsolationLevel_get_RepeatableRead());
            return __return;
        }
    }
    // static field: System.Transactions.IsolationLevel ReadCommitted
    /**
    Volatile data cannot be read during the transaction, but can be modified.

    */
    public static var ReadCommitted : dotnet.System.Transactions.IsolationLevel {
        get {
        let __return = dotnet.System.Transactions.IsolationLevel(val: System_Transactions_IsolationLevel_get_ReadCommitted());
            return __return;
        }
    }
    // static field: System.Transactions.IsolationLevel ReadUncommitted
    /**
    Volatile data can be read and modified during the transaction.

    */
    public static var ReadUncommitted : dotnet.System.Transactions.IsolationLevel {
        get {
        let __return = dotnet.System.Transactions.IsolationLevel(val: System_Transactions_IsolationLevel_get_ReadUncommitted());
            return __return;
        }
    }
    // static field: System.Transactions.IsolationLevel Snapshot
    /**
    
        Volatile data can be read. Before a transaction modifies data, it verifies if another transaction has changed the data after it was initially read. If the data has been updated, an error is raised. This allows a transaction to get to the previously committed value of the data.
        When you try to promote a transaction that was created with the  isolation level, an  is thrown with the error message "Transactions with IsolationLevel Snapshot cannot be promoted".
      

    */
    public static var Snapshot : dotnet.System.Transactions.IsolationLevel {
        get {
        let __return = dotnet.System.Transactions.IsolationLevel(val: System_Transactions_IsolationLevel_get_Snapshot());
            return __return;
        }
    }
    // static field: System.Transactions.IsolationLevel Chaos
    /**
    The pending changes from more highly isolated transactions cannot be overwritten.

    */
    public static var Chaos : dotnet.System.Transactions.IsolationLevel {
        get {
        let __return = dotnet.System.Transactions.IsolationLevel(val: System_Transactions_IsolationLevel_get_Chaos());
            return __return;
        }
    }
    // static field: System.Transactions.IsolationLevel Unspecified
    /**
    A different isolation level than the one specified is being used, but the level cannot be determined. An exception is thrown if this value is set.

    */
    public static var Unspecified : dotnet.System.Transactions.IsolationLevel {
        get {
        let __return = dotnet.System.Transactions.IsolationLevel(val: System_Transactions_IsolationLevel_get_Unspecified());
            return __return;
        }
    }
} // IsolationLevel


// type: System.Transactions.PreparingEnlistment
    /**
    Facilitates communication between an enlisted transaction participant and the transaction manager during the Prepare phase of the transaction.

    */
open class PreparingEnlistment
    :
    dotnet.System.Transactions.Enlistment
{
    open class override func get_type_handle() -> TypeHandle {
        return System_Transactions_PreparingEnlistment_get_type_handle();
    }
    public required init(hndl: NonnullHandle) { super.init(hndl: hndl); }
    public required init(gval: GVal) { super.init(gval: gval); }
    // void ForceRollback()
// docid: M:System.Transactions.PreparingEnlistment.ForceRollback
    /**
    Indicates that the transaction should be rolled back.

    */
    open func ForceRollback() throws {
        var __thrown : NullableHandle = nil;
        System_Transactions_PreparingEnlistment_void__ForceRollback_0__0(&__thrown, self.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
            return;
        }
    }
    // void ForceRollback(System.Exception)
// docid: M:System.Transactions.PreparingEnlistment.ForceRollback(System.Exception)
    /**
    Indicates that the transaction should be rolled back.

    - Parameter e: An explanation of why a rollback is triggered.
    */
    open func ForceRollback(e : Optional<dotnet.System.Exception>) throws {
        var __thrown : NullableHandle = nil;
        System_Transactions_PreparingEnlistment_void__ForceRollback_0__1__Exception(&__thrown, self.get_handle(), e?.get_handle() ?? nil);
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
            return;
        }
    }
    // void Prepared()
// docid: M:System.Transactions.PreparingEnlistment.Prepared
    /**
    Indicates that the transaction can be committed.

    */
    open func Prepared() throws {
        var __thrown : NullableHandle = nil;
        System_Transactions_PreparingEnlistment_void__Prepared_0__0(&__thrown, self.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
            return;
        }
    }
    // System.Byte[] RecoveryInformation()
// docid: M:System.Transactions.PreparingEnlistment.RecoveryInformation
    /**
    Gets the recovery information of an enlistment.

    - Returns: The recovery information of an enlistment.

    */
    open func RecoveryInformation() throws -> dotnet.System_Arr<Swift.UInt8> {
        var __thrown : NullableHandle = nil;
        let __return = System_Transactions_PreparingEnlistment_u8Array__RecoveryInformation_0__0(&__thrown, self.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return dotnet.System_Arr<Swift.UInt8>(hndl : __return);
        }
    }
} // PreparingEnlistment


// type: System.Transactions.SinglePhaseEnlistment
    /**
    Provides a set of callbacks that facilitate communication between a participant enlisted for Single Phase Commit and the transaction manager when the  notification is received.

    */
open class SinglePhaseEnlistment
    :
    dotnet.System.Transactions.Enlistment
{
    open class override func get_type_handle() -> TypeHandle {
        return System_Transactions_SinglePhaseEnlistment_get_type_handle();
    }
    public required init(hndl: NonnullHandle) { super.init(hndl: hndl); }
    public required init(gval: GVal) { super.init(gval: gval); }
    // void Aborted()
// docid: M:System.Transactions.SinglePhaseEnlistment.Aborted
    /**
    Represents a callback that is used to indicate to the transaction manager that the transaction should be rolled back.

    */
    open func Aborted() throws {
        var __thrown : NullableHandle = nil;
        System_Transactions_SinglePhaseEnlistment_void__Aborted_0__0(&__thrown, self.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
            return;
        }
    }
    // void Aborted(System.Exception)
// docid: M:System.Transactions.SinglePhaseEnlistment.Aborted(System.Exception)
    /**
    Represents a callback that is used to indicate to the transaction manager that the transaction should be rolled back, and provides an explanation.

    - Parameter e: An explanation of why a rollback is initiated.
    */
    open func Aborted(e : Optional<dotnet.System.Exception>) throws {
        var __thrown : NullableHandle = nil;
        System_Transactions_SinglePhaseEnlistment_void__Aborted_0__1__Exception(&__thrown, self.get_handle(), e?.get_handle() ?? nil);
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
            return;
        }
    }
    // void Committed()
// docid: M:System.Transactions.SinglePhaseEnlistment.Committed
    /**
    Represents a callback that is used to indicate to the transaction manager that the SinglePhaseCommit was successful.

    */
    open func Committed() throws {
        var __thrown : NullableHandle = nil;
        System_Transactions_SinglePhaseEnlistment_void__Committed_0__0(&__thrown, self.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
            return;
        }
    }
    // void InDoubt()
// docid: M:System.Transactions.SinglePhaseEnlistment.InDoubt
    /**
    Represents a callback that is used to indicate to the transaction manager that the status of the transaction is in doubt.

    */
    open func InDoubt() throws {
        var __thrown : NullableHandle = nil;
        System_Transactions_SinglePhaseEnlistment_void__InDoubt_0__0(&__thrown, self.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
            return;
        }
    }
    // void InDoubt(System.Exception)
// docid: M:System.Transactions.SinglePhaseEnlistment.InDoubt(System.Exception)
    /**
    Represents a callback that is used to indicate to the transaction manager that the status of the transaction is in doubt, and provides an explanation.

    - Parameter e: An explanation of why the transaction is in doubt.
    */
    open func InDoubt(e : Optional<dotnet.System.Exception>) throws {
        var __thrown : NullableHandle = nil;
        System_Transactions_SinglePhaseEnlistment_void__InDoubt_0__1__Exception(&__thrown, self.get_handle(), e?.get_handle() ?? nil);
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
            return;
        }
    }
} // SinglePhaseEnlistment


// type: System.Transactions.SubordinateTransaction
    /**
    Represents a non-rooted transaction that can be delegated. This class cannot be inherited.

    */
public final class SubordinateTransaction
    :
    dotnet.System.Transactions.Transaction
{
    public class override func get_type_handle() -> TypeHandle {
        return System_Transactions_SubordinateTransaction_get_type_handle();
    }
    public required init(hndl: NonnullHandle) { super.init(hndl: hndl); }
    public required init(gval: GVal) { super.init(gval: gval); }
    // .ctor(System.Transactions.IsolationLevel, System.Transactions.ISimpleTransactionSuperior)
// docid: M:System.Transactions.SubordinateTransaction.#ctor(System.Transactions.IsolationLevel,System.Transactions.ISimpleTransactionSuperior)
    /**
    Initializes a new instance of the  class.

    - Parameter isoLevel: The isolation level of the transaction
    - Parameter superior: A 
    */
    public init(isoLevel : dotnet.System.Transactions.IsolationLevel, superior : dotnet.System.Transactions.ISimpleTransactionSuperior) throws {
        var __thrown : NullableHandle = nil;
        let h = System_Transactions_SubordinateTransaction_ctor_0__2__IsolationLevel_ISimpleTransactionSuperior(&__thrown, isoLevel.get_value(), superior.get_handle());
        if let __ex = __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
            super.init(hndl: h);
        }
    }
} // SubordinateTransaction


// type: System.Transactions.Transaction
    /**
    Represents a transaction.

    */
open class Transaction
    :
    dotnet.System.Object,
    System_IDisposable,
    System_Runtime_Serialization_ISerializable
{
    open class override func get_type_handle() -> TypeHandle {
        return System_Transactions_Transaction_get_type_handle();
    }
    public required init(hndl: NonnullHandle) { super.init(hndl: hndl); }
    public required init(gval: GVal) { super.init(gval: gval); }
    // System.Transactions.Transaction Clone()
// docid: M:System.Transactions.Transaction.Clone
    /**
    Creates a clone of the transaction.

    - Returns: A  that is a copy of the current transaction object.

    */
    open func Clone() throws -> dotnet.System.Transactions.Transaction {
        var __thrown : NullableHandle = nil;
        let __return = System_Transactions_Transaction_Transaction__Clone_0__0(&__thrown, self.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return dotnet.System.Transactions.Transaction(hndl : __return);
        }
    }
    // System.Transactions.DependentTransaction DependentClone(System.Transactions.DependentCloneOption)
// docid: M:System.Transactions.Transaction.DependentClone(System.Transactions.DependentCloneOption)
    /**
    Creates a dependent clone of the transaction.

    - Parameter cloneOption: A  that controls what kind of dependent transaction to create.
    - Returns: A  that represents the dependent clone.

    */
    open func DependentClone(cloneOption : dotnet.System.Transactions.DependentCloneOption) throws -> dotnet.System.Transactions.DependentTransaction {
        var __thrown : NullableHandle = nil;
        let __return = System_Transactions_Transaction_DependentTransaction__DependentClone_0__1__DependentCloneOption(&__thrown, self.get_handle(), cloneOption.get_value());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return dotnet.System.Transactions.DependentTransaction(hndl : __return);
        }
    }
    // void Dispose()
// docid: M:System.Transactions.Transaction.Dispose
    /**
    Releases the resources that are held by the object.

    */
    open /* method final */ func Dispose() throws {
        var __thrown : NullableHandle = nil;
        System_Transactions_Transaction_void__Dispose_0__0(&__thrown, self.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
            return;
        }
    }
    // System.Transactions.Enlistment EnlistDurable(System.Guid, System.Transactions.IEnlistmentNotification, System.Transactions.EnlistmentOptions)
// docid: M:System.Transactions.Transaction.EnlistDurable(System.Guid,System.Transactions.IEnlistmentNotification,System.Transactions.EnlistmentOptions)
    /**
    Enlists a durable resource manager that supports two phase commit to participate in a transaction.

    - Parameter resourceManagerIdentifier: A unique identifier for a resource manager, which should persist across resource manager failure or reboot.
    - Parameter enlistmentNotification: An object that implements the  interface to receive two phase commit notifications.
    - Parameter enlistmentOptions: 
         if the resource manager wants to perform additional work during the prepare phase.
    - Returns: An  object that describes the enlistment.

    */
    open func EnlistDurable(resourceManagerIdentifier : dotnet.System.Guid, enlistmentNotification : dotnet.System.Transactions.IEnlistmentNotification, enlistmentOptions : dotnet.System.Transactions.EnlistmentOptions) throws -> dotnet.System.Transactions.Enlistment {
        var __thrown : NullableHandle = nil;
        let __return = System_Transactions_Transaction_Enlistment__EnlistDurable_0__3__Guid_IEnlistmentNotification_EnlistmentOptions(&__thrown, self.get_handle(), resourceManagerIdentifier.get_handle(), enlistmentNotification.get_handle(), enlistmentOptions.get_value());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return dotnet.System.Transactions.Enlistment(hndl : __return);
        }
    }
    // System.Transactions.Enlistment EnlistDurable(System.Guid, System.Transactions.ISinglePhaseNotification, System.Transactions.EnlistmentOptions)
// docid: M:System.Transactions.Transaction.EnlistDurable(System.Guid,System.Transactions.ISinglePhaseNotification,System.Transactions.EnlistmentOptions)
    /**
    Enlists a durable resource manager that supports single phase commit optimization to participate in a transaction.

    - Parameter resourceManagerIdentifier: A unique identifier for a resource manager, which should persist across resource manager failure or reboot.
    - Parameter singlePhaseNotification: An object that implements the  interface that must be able to receive single phase commit and two phase commit notifications.
    - Parameter enlistmentOptions: 
         if the resource manager wants to perform additional work during the prepare phase.
    - Returns: An  object that describes the enlistment.

    */
    open func EnlistDurable(resourceManagerIdentifier : dotnet.System.Guid, singlePhaseNotification : dotnet.System.Transactions.ISinglePhaseNotification, enlistmentOptions : dotnet.System.Transactions.EnlistmentOptions) throws -> dotnet.System.Transactions.Enlistment {
        var __thrown : NullableHandle = nil;
        let __return = System_Transactions_Transaction_Enlistment__EnlistDurable_0__3__Guid_ISinglePhaseNotification_EnlistmentOptions(&__thrown, self.get_handle(), resourceManagerIdentifier.get_handle(), singlePhaseNotification.get_handle(), enlistmentOptions.get_value());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return dotnet.System.Transactions.Enlistment(hndl : __return);
        }
    }
    // bool EnlistPromotableSinglePhase(System.Transactions.IPromotableSinglePhaseNotification)
// docid: M:System.Transactions.Transaction.EnlistPromotableSinglePhase(System.Transactions.IPromotableSinglePhaseNotification)
    /**
    Enlists a resource manager that has an internal transaction using a promotable single phase enlistment (PSPE).

    - Parameter promotableSinglePhaseNotification: A  interface implemented by the participant.
    - Returns: A  interface implementation that describes the enlistment.

    */
    open func EnlistPromotableSinglePhase(promotableSinglePhaseNotification : dotnet.System.Transactions.IPromotableSinglePhaseNotification) throws -> Bool {
        var __thrown : NullableHandle = nil;
        let __return = System_Transactions_Transaction_bool__EnlistPromotableSinglePhase_0__1__IPromotableSinglePhaseNotification(&__thrown, self.get_handle(), promotableSinglePhaseNotification.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return (__return) != 0;
        }
    }
    // bool EnlistPromotableSinglePhase(System.Transactions.IPromotableSinglePhaseNotification, System.Guid)
// docid: M:System.Transactions.Transaction.EnlistPromotableSinglePhase(System.Transactions.IPromotableSinglePhaseNotification,System.Guid)
    /**
    Enlists a resource manager that has an internal transaction using a promotable single phase enlistment (PSPE).

    - Parameter promotableSinglePhaseNotification: A  interface implemented by the participant.
    - Parameter promoterType: The type of the distributed transaction processor.
    - Returns: A  interface implementation that describes the enlistment.

    */
    open func EnlistPromotableSinglePhase(promotableSinglePhaseNotification : dotnet.System.Transactions.IPromotableSinglePhaseNotification, promoterType : dotnet.System.Guid) throws -> Bool {
        var __thrown : NullableHandle = nil;
        let __return = System_Transactions_Transaction_bool__EnlistPromotableSinglePhase_0__2__IPromotableSinglePhaseNotification_Guid(&__thrown, self.get_handle(), promotableSinglePhaseNotification.get_handle(), promoterType.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return (__return) != 0;
        }
    }
    // System.Transactions.Enlistment EnlistVolatile(System.Transactions.IEnlistmentNotification, System.Transactions.EnlistmentOptions)
// docid: M:System.Transactions.Transaction.EnlistVolatile(System.Transactions.IEnlistmentNotification,System.Transactions.EnlistmentOptions)
    /**
    Enlists a volatile resource manager that supports two phase commit to participate in a transaction.

    - Parameter enlistmentNotification: An object that implements the  interface to receive two-phase commit notifications.
    - Parameter enlistmentOptions: 
         if the resource manager wants to perform additional work during the prepare phase.
    - Returns: An  object that describes the enlistment.

    */
    open func EnlistVolatile(enlistmentNotification : dotnet.System.Transactions.IEnlistmentNotification, enlistmentOptions : dotnet.System.Transactions.EnlistmentOptions) throws -> dotnet.System.Transactions.Enlistment {
        var __thrown : NullableHandle = nil;
        let __return = System_Transactions_Transaction_Enlistment__EnlistVolatile_0__2__IEnlistmentNotification_EnlistmentOptions(&__thrown, self.get_handle(), enlistmentNotification.get_handle(), enlistmentOptions.get_value());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return dotnet.System.Transactions.Enlistment(hndl : __return);
        }
    }
    // System.Transactions.Enlistment EnlistVolatile(System.Transactions.ISinglePhaseNotification, System.Transactions.EnlistmentOptions)
// docid: M:System.Transactions.Transaction.EnlistVolatile(System.Transactions.ISinglePhaseNotification,System.Transactions.EnlistmentOptions)
    /**
    Enlists a volatile resource manager that supports single phase commit optimization to participate in a transaction.

    - Parameter singlePhaseNotification: An object that implements the  interface that must be able to receive single phase commit and two phase commit notifications.
    - Parameter enlistmentOptions: 
         if the resource manager wants to perform additional work during the prepare phase.
    - Returns: An  object that describes the enlistment.

    */
    open func EnlistVolatile(singlePhaseNotification : dotnet.System.Transactions.ISinglePhaseNotification, enlistmentOptions : dotnet.System.Transactions.EnlistmentOptions) throws -> dotnet.System.Transactions.Enlistment {
        var __thrown : NullableHandle = nil;
        let __return = System_Transactions_Transaction_Enlistment__EnlistVolatile_0__2__ISinglePhaseNotification_EnlistmentOptions(&__thrown, self.get_handle(), singlePhaseNotification.get_handle(), enlistmentOptions.get_value());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return dotnet.System.Transactions.Enlistment(hndl : __return);
        }
    }
    // bool Equals(System.Object)
// docid: M:System.Transactions.Transaction.Equals(System.Object)
    /**
    Determines whether this transaction and the specified object are equal.

    - Parameter obj: The object to compare with this instance.
    - Returns: 
         if  and this transaction are identical; otherwise, .

    */
    open override func Equals(obj : Optional<dotnet.System.Object>) throws -> Bool {
        var __thrown : NullableHandle = nil;
        let __return = System_Transactions_Transaction_bool__Equals_0__1__Object(&__thrown, self.get_handle(), obj?.get_handle() ?? nil);
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return (__return) != 0;
        }
    }
    // System.Int32 GetHashCode()
// docid: M:System.Transactions.Transaction.GetHashCode
    /**
    Returns the hash code for this instance.

    - Returns: A 32-bit signed integer hash code.

    */
    open override func GetHashCode() throws -> Swift.Int32 {
        var __thrown : NullableHandle = nil;
        let __return = System_Transactions_Transaction_i32__GetHashCode_0__0(&__thrown, self.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return __return;
        }
    }
    // System.Byte[] GetPromotedToken()
// docid: M:System.Transactions.Transaction.GetPromotedToken
    /**
    Gets the  byte[] returned by the Promote method when the transaction is promoted.

    - Returns: The  byte[] returned by the Promote method when the transaction is promoted.

    */
    open func GetPromotedToken() throws -> dotnet.System_Arr<Swift.UInt8> {
        var __thrown : NullableHandle = nil;
        let __return = System_Transactions_Transaction_u8Array__GetPromotedToken_0__0(&__thrown, self.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return dotnet.System_Arr<Swift.UInt8>(hndl : __return);
        }
    }
    // [IsSpecialName] bool op_Equality(System.Transactions.Transaction, System.Transactions.Transaction)
// docid: M:System.Transactions.Transaction.op_Equality(System.Transactions.Transaction,System.Transactions.Transaction)
    /**
    Tests whether two specified  instances are equivalent.

    - Parameter x: The  instance that is to the left of the equality operator.
    - Parameter y: The  instance that is to the right of the equality operator.
    - Returns: 
         if  and  are equal; otherwise, .

    */
    open class func op_Equality(x : Optional<dotnet.System.Transactions.Transaction>, y : Optional<dotnet.System.Transactions.Transaction>) throws -> Bool {
        var __thrown : NullableHandle = nil;
        let __return = System_Transactions_Transaction_bool__op_Equality_0__2__Transaction_Transaction(&__thrown, x?.get_handle() ?? nil, y?.get_handle() ?? nil);
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return (__return) != 0;
        }
    }
    // [IsSpecialName] bool op_Inequality(System.Transactions.Transaction, System.Transactions.Transaction)
// docid: M:System.Transactions.Transaction.op_Inequality(System.Transactions.Transaction,System.Transactions.Transaction)
    /**
    Returns a value that indicates whether two  instances are not equal.

    - Parameter x: The  instance that is to the left of the inequality operator.
    - Parameter y: The  instance that is to the right of the inequality operator.
    - Returns: 
         if  and  are not equal; otherwise, .

    */
    open class func op_Inequality(x : Optional<dotnet.System.Transactions.Transaction>, y : Optional<dotnet.System.Transactions.Transaction>) throws -> Bool {
        var __thrown : NullableHandle = nil;
        let __return = System_Transactions_Transaction_bool__op_Inequality_0__2__Transaction_Transaction(&__thrown, x?.get_handle() ?? nil, y?.get_handle() ?? nil);
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return (__return) != 0;
        }
    }
    // System.Transactions.Enlistment PromoteAndEnlistDurable(System.Guid, System.Transactions.IPromotableSinglePhaseNotification, System.Transactions.ISinglePhaseNotification, System.Transactions.EnlistmentOptions)
// docid: M:System.Transactions.Transaction.PromoteAndEnlistDurable(System.Guid,System.Transactions.IPromotableSinglePhaseNotification,System.Transactions.ISinglePhaseNotification,System.Transactions.EnlistmentOptions)
    /**
    Promotes and enlists a durable resource manager that supports two phase commit to participate in a transaction.

    - Parameter resourceManagerIdentifier: A unique identifier for a resource manager, which should persist across resource manager failure or reboot.
    - Parameter promotableNotification: An object that acts as a commit delegate for a non-distributed transaction internal to a resource manager.
    - Parameter enlistmentNotification: An object that implements the  interface to receive two phase commit notifications.
    - Parameter enlistmentOptions: 
         if the resource manager wants to perform additional work during the prepare phase.
    */
    open func PromoteAndEnlistDurable(resourceManagerIdentifier : dotnet.System.Guid, promotableNotification : dotnet.System.Transactions.IPromotableSinglePhaseNotification, enlistmentNotification : dotnet.System.Transactions.ISinglePhaseNotification, enlistmentOptions : dotnet.System.Transactions.EnlistmentOptions) throws -> dotnet.System.Transactions.Enlistment {
        var __thrown : NullableHandle = nil;
        let __return = System_Transactions_Transaction_Enlistment__PromoteAndEnlistDurable_0__4__Guid_IPromotableSinglePhaseNotification_ISinglePhaseNotification_EnlistmentOptions(&__thrown, self.get_handle(), resourceManagerIdentifier.get_handle(), promotableNotification.get_handle(), enlistmentNotification.get_handle(), enlistmentOptions.get_value());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return dotnet.System.Transactions.Enlistment(hndl : __return);
        }
    }
    // void Rollback()
// docid: M:System.Transactions.Transaction.Rollback
    /**
    Rolls back (aborts) the transaction.

    */
    open func Rollback() throws {
        var __thrown : NullableHandle = nil;
        System_Transactions_Transaction_void__Rollback_0__0(&__thrown, self.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
            return;
        }
    }
    // void Rollback(System.Exception)
// docid: M:System.Transactions.Transaction.Rollback(System.Exception)
    /**
    Rolls back (aborts) the transaction.

    - Parameter e: An explanation of why a rollback occurred.
    */
    open func Rollback(e : Optional<dotnet.System.Exception>) throws {
        var __thrown : NullableHandle = nil;
        System_Transactions_Transaction_void__Rollback_0__1__Exception(&__thrown, self.get_handle(), e?.get_handle() ?? nil);
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
            return;
        }
    }
    // void SetDistributedTransactionIdentifier(System.Transactions.IPromotableSinglePhaseNotification, System.Guid)
// docid: M:System.Transactions.Transaction.SetDistributedTransactionIdentifier(System.Transactions.IPromotableSinglePhaseNotification,System.Guid)
    /**
    Sets the distributed transaction identifier generated by the non-MSDTC promoter.

    - Parameter promotableNotification: A  interface implemented by the participant.
    - Parameter distributedTransactionIdentifier: The identifier for the transaction used by the distributed transaction manager.
    */
    open func SetDistributedTransactionIdentifier(promotableNotification : dotnet.System.Transactions.IPromotableSinglePhaseNotification, distributedTransactionIdentifier : dotnet.System.Guid) throws {
        var __thrown : NullableHandle = nil;
        System_Transactions_Transaction_void__SetDistributedTransactionIdentifier_0__2__IPromotableSinglePhaseNotification_Guid(&__thrown, self.get_handle(), promotableNotification.get_handle(), distributedTransactionIdentifier.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
            return;
        }
    }
    // [IsSpecialName] System.Transactions.Transaction get_Current()
// docid: M:System.Transactions.Transaction.get_Current
    open class func get_Current() throws -> Optional<dotnet.System.Transactions.Transaction> {
        var __thrown : NullableHandle = nil;
        let __return = System_Transactions_Transaction_Transaction__get_Current_0__0(&__thrown);
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        if let __ret_unwrapped = __return {
            return dotnet.System.Transactions.Transaction(hndl : __ret_unwrapped);
        } else {
            return nil;
        }
        }
    }
    // [IsSpecialName] void set_Current(System.Transactions.Transaction)
// docid: M:System.Transactions.Transaction.set_Current(System.Transactions.Transaction)
    open class func set_Current(value : Optional<dotnet.System.Transactions.Transaction>) throws {
        var __thrown : NullableHandle = nil;
        System_Transactions_Transaction_void__set_Current_0__1__Transaction(&__thrown, value?.get_handle() ?? nil);
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
            return;
        }
    }
    // [IsSpecialName] System.Transactions.IsolationLevel get_IsolationLevel()
// docid: M:System.Transactions.Transaction.get_IsolationLevel
    open func get_IsolationLevel() throws -> dotnet.System.Transactions.IsolationLevel {
        var __thrown : NullableHandle = nil;
        let __return = System_Transactions_Transaction_IsolationLevel__get_IsolationLevel_0__0(&__thrown, self.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return dotnet.System.Transactions.IsolationLevel(val: __return);
        }
    }
    // [IsSpecialName] System.Guid get_PromoterType()
// docid: M:System.Transactions.Transaction.get_PromoterType
    open func get_PromoterType() throws -> dotnet.System.Guid {
        var __thrown : NullableHandle = nil;
        let __return = System_Transactions_Transaction_Guid__get_PromoterType_0__0(&__thrown, self.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return dotnet.System.Guid(hndl : __return);
        }
    }
    // [IsSpecialName] System.Transactions.TransactionInformation get_TransactionInformation()
// docid: M:System.Transactions.Transaction.get_TransactionInformation
    open func get_TransactionInformation() throws -> dotnet.System.Transactions.TransactionInformation {
        var __thrown : NullableHandle = nil;
        let __return = System_Transactions_Transaction_TransactionInformation__get_TransactionInformation_0__0(&__thrown, self.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return dotnet.System.Transactions.TransactionInformation(hndl : __return);
        }
    }
    // [IsSpecialName] void add_TransactionCompleted(System.Transactions.TransactionCompletedEventHandler)
// docid: M:System.Transactions.Transaction.add_TransactionCompleted(System.Transactions.TransactionCompletedEventHandler)
    open func add_TransactionCompleted(value : Optional<dotnet.System.Transactions.TransactionCompletedEventHandler>) throws {
        var __thrown : NullableHandle = nil;
        System_Transactions_Transaction_void__add_TransactionCompleted_0__1__TransactionCompletedEventHandler(&__thrown, self.get_handle(), value?.get_handle() ?? nil);
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
            return;
        }
    }
    // delegate closure overload
    open func add_TransactionCompleted(value : @escaping (Optional<dotnet.System.Object>, dotnet.System.Transactions.TransactionEventArgs) throws -> Void) throws {
        let del_value = try dotnet.System.Transactions.TransactionCompletedEventHandler(value);
        return try add_TransactionCompleted(value: del_value);
    }
    // [IsSpecialName] void remove_TransactionCompleted(System.Transactions.TransactionCompletedEventHandler)
// docid: M:System.Transactions.Transaction.remove_TransactionCompleted(System.Transactions.TransactionCompletedEventHandler)
    open func remove_TransactionCompleted(value : Optional<dotnet.System.Transactions.TransactionCompletedEventHandler>) throws {
        var __thrown : NullableHandle = nil;
        System_Transactions_Transaction_void__remove_TransactionCompleted_0__1__TransactionCompletedEventHandler(&__thrown, self.get_handle(), value?.get_handle() ?? nil);
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
            return;
        }
    }
    // delegate closure overload
    open func remove_TransactionCompleted(value : @escaping (Optional<dotnet.System.Object>, dotnet.System.Transactions.TransactionEventArgs) throws -> Void) throws {
        let del_value = try dotnet.System.Transactions.TransactionCompletedEventHandler(value);
        return try remove_TransactionCompleted(value: del_value);
    }
    /**
    Gets or sets the ambient transaction.

    */
    public static var Current : Optional<dotnet.System.Transactions.Transaction> {
        get {
            return try! get_Current();
        }
        set(v) {
            return try! set_Current(value: v!);
        }
    }
    /**
    Gets the isolation level of the transaction.

    */
    open var IsolationLevel : dotnet.System.Transactions.IsolationLevel {
        get {
            return try! get_IsolationLevel();
        }
    }
    /**
    Uniquely identifies the format of the byte[] returned by the Promote method when the transaction is promoted.

    */
    open var PromoterType : dotnet.System.Guid {
        get {
            return try! get_PromoterType();
        }
    }
    /**
    Retrieves additional information about a transaction.

    */
    open var TransactionInformation : dotnet.System.Transactions.TransactionInformation {
        get {
            return try! get_TransactionInformation();
        }
    }
} // Transaction


// type: System.Transactions.TransactionAbortedException
    /**
    The exception that is thrown when an operation is attempted on a transaction that has already been rolled back, or an attempt is made to commit the transaction and the transaction aborts.

    */
open class TransactionAbortedException
    :
    dotnet.System.Transactions.TransactionException
{
    open class override func get_type_handle() -> TypeHandle {
        return System_Transactions_TransactionAbortedException_get_type_handle();
    }
    public required init(hndl: NonnullHandle) { super.init(hndl: hndl); }
    public required init(gval: GVal) { super.init(gval: gval); }
    // .ctor()
// docid: M:System.Transactions.TransactionAbortedException.#ctor
    /**
    Initializes a new instance of the  class.

    */
    public override init() throws {
        var __thrown : NullableHandle = nil;
        let h = System_Transactions_TransactionAbortedException_ctor_0__0(&__thrown);
        if let __ex = __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
            super.init(hndl: h);
        }
    }
    // .ctor(System.String)
// docid: M:System.Transactions.TransactionAbortedException.#ctor(System.String)
    /**
    Initializes a new instance of the  class with the specified message.

    - Parameter message: A  that contains a message that explains why the exception occurred.
    */
    public override init(message : Optional<dotnet.System.String>) throws {
        var __thrown : NullableHandle = nil;
        let h = System_Transactions_TransactionAbortedException_ctor_0__1__String(&__thrown, message?.get_handle() ?? nil);
        if let __ex = __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
            super.init(hndl: h);
        }
    }
    // .ctor(System.String, System.Exception)
// docid: M:System.Transactions.TransactionAbortedException.#ctor(System.String,System.Exception)
    /**
    Initializes a new instance of the  class with the specified message and inner exception.

    - Parameter message: A  that contains a message that explains why the exception occurred.
    - Parameter innerException: Gets the exception instance that causes the current exception. For more information, see the  property.
    */
    public override init(message : Optional<dotnet.System.String>, innerException : Optional<dotnet.System.Exception>) throws {
        var __thrown : NullableHandle = nil;
        let h = System_Transactions_TransactionAbortedException_ctor_0__2__String_Exception(&__thrown, message?.get_handle() ?? nil, innerException?.get_handle() ?? nil);
        if let __ex = __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
            super.init(hndl: h);
        }
    }
} // TransactionAbortedException


// type: System.Transactions.TransactionCompletedEventHandler
    /**
    Represents the method that handles the  event of a  class.

    */
public final class TransactionCompletedEventHandler
    :
    dotnet.System.Delegate
{
    public class override func get_type_handle() -> TypeHandle {
        return System_Transactions_TransactionCompletedEventHandler_get_type_handle();
    }
    public required init(hndl: NonnullHandle) { super.init(hndl: hndl); }
    public required init(gval: GVal) { super.init(gval: gval); }
    // void Invoke(System.Object, System.Transactions.TransactionEventArgs)
// docid: M:System.Transactions.TransactionCompletedEventHandler.Invoke(System.Object,System.Transactions.TransactionEventArgs)
    public func Invoke(sender : Optional<dotnet.System.Object>, e : dotnet.System.Transactions.TransactionEventArgs) throws {
        var __thrown : NullableHandle = nil;
        System_Transactions_TransactionCompletedEventHandler_void__Invoke_0__2__Object_TransactionEventArgs(&__thrown, self.get_handle(), sender?.get_handle() ?? nil, e.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
            return;
        }
    }
    // System.IAsyncResult BeginInvoke(System.Object, System.Transactions.TransactionEventArgs, System.AsyncCallback, System.Object)
// docid: M:System.Transactions.TransactionCompletedEventHandler.BeginInvoke(System.Object,System.Transactions.TransactionEventArgs,System.AsyncCallback,System.Object)
    public func BeginInvoke(sender : Optional<dotnet.System.Object>, e : dotnet.System.Transactions.TransactionEventArgs, callback : Optional<dotnet.System.AsyncCallback>, object : Optional<dotnet.System.Object>) throws -> Optional<dotnet.System.IAsyncResult> {
        var __thrown : NullableHandle = nil;
        let __return = System_Transactions_TransactionCompletedEventHandler_IAsyncResult__BeginInvoke_0__4__Object_TransactionEventArgs_AsyncCallback_Object(&__thrown, self.get_handle(), sender?.get_handle() ?? nil, e.get_handle(), callback?.get_handle() ?? nil, object?.get_handle() ?? nil);
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        if let __ret_unwrapped = __return {
            return dotnet.System.IAsyncResult(hndl : __ret_unwrapped);
        } else {
            return nil;
        }
        }
    }
    // void EndInvoke(System.IAsyncResult)
// docid: M:System.Transactions.TransactionCompletedEventHandler.EndInvoke(System.IAsyncResult)
    public func EndInvoke(result : Optional<dotnet.System.IAsyncResult>) throws {
        var __thrown : NullableHandle = nil;
        System_Transactions_TransactionCompletedEventHandler_void__EndInvoke_0__1__IAsyncResult(&__thrown, self.get_handle(), result?.get_handle() ?? nil);
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
            return;
        }
    }
    public init(_ callback : @escaping (Optional<dotnet.System.Object>, dotnet.System.Transactions.TransactionEventArgs) throws -> Void) throws
    {
        let __bridge : (UnsafeMutablePointer<NullableHandle>, NullableHandle, NonnullHandle) -> Void =
        {
            (thrown : UnsafeMutablePointer<NullableHandle>, sender : NullableHandle, e : NonnullHandle) -> Void in
            do
            {
                thrown.pointee = nil;
                try callback((sender != nil) ? (dotnet.System.Object(hndl: sender!)) : nil, dotnet.System.Transactions.TransactionEventArgs(hndl: e));
            }
            catch let e as dotnet.System.Exception
            {
                thrown.pointee = __copy_handle(e.get_handle());
            }
            catch
            {
                let e = try! dotnet.System.Exception(message: "TODO fail inside closure");
                thrown.pointee = __copy_handle(e.get_handle());
            }
        };
        let cbarg = UnsafeRawPointer(Unmanaged.passRetained(__bridge as AnyObject).toOpaque());
        func __cb(cb : UnsafeRawPointer?, thrown : UnsafeMutablePointer<NullableHandle>, sender : NullableHandle, e : NonnullHandle) -> Void
        {
            let f = Unmanaged<AnyObject>.fromOpaque(cb!).takeUnretainedValue() as! (UnsafeMutablePointer<NullableHandle>, NullableHandle, NonnullHandle) -> Void;
            f(thrown, sender, e);
        }
        var __thrown : NullableHandle = nil;
        let h = System_Transactions_TransactionCompletedEventHandler_create(
            &__thrown,
            cbarg,
            nil, // TODO deinit
            __cb
            );
            // TODO check thrown
        if let __ex = __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
            super.init(hndl: h);
        }
    }
    // void Invoke(System.Object, System.Transactions.TransactionEventArgs)
// docid: M:System.Transactions.TransactionCompletedEventHandler.Invoke(System.Object,System.Transactions.TransactionEventArgs)
    public func callAsFunction(sender : Optional<dotnet.System.Object>, e : dotnet.System.Transactions.TransactionEventArgs) throws {
        var __thrown : NullableHandle = nil;
        System_Transactions_TransactionCompletedEventHandler_void__Invoke_0__2__Object_TransactionEventArgs(&__thrown, self.get_handle(), sender?.get_handle() ?? nil, e.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
            return;
        }
    }
} // TransactionCompletedEventHandler


// type: System.Transactions.TransactionEventArgs
    /**
    Provides data for the following transaction events: , .

    */
open class TransactionEventArgs
    :
    dotnet.System.EventArgs
{
    open class override func get_type_handle() -> TypeHandle {
        return System_Transactions_TransactionEventArgs_get_type_handle();
    }
    public required init(hndl: NonnullHandle) { super.init(hndl: hndl); }
    public required init(gval: GVal) { super.init(gval: gval); }
    // .ctor()
// docid: M:System.Transactions.TransactionEventArgs.#ctor
    /**
    Initializes a new instance of the  class.

    */
    public override init() throws {
        var __thrown : NullableHandle = nil;
        let h = System_Transactions_TransactionEventArgs_ctor_0__0(&__thrown);
        if let __ex = __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
            super.init(hndl: h);
        }
    }
    // [IsSpecialName] System.Transactions.Transaction get_Transaction()
// docid: M:System.Transactions.TransactionEventArgs.get_Transaction
    open func get_Transaction() throws -> Optional<dotnet.System.Transactions.Transaction> {
        var __thrown : NullableHandle = nil;
        let __return = System_Transactions_TransactionEventArgs_Transaction__get_Transaction_0__0(&__thrown, self.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        if let __ret_unwrapped = __return {
            return dotnet.System.Transactions.Transaction(hndl : __ret_unwrapped);
        } else {
            return nil;
        }
        }
    }
    /**
    Gets the transaction for which event status is provided.

    */
    open var Transaction : Optional<dotnet.System.Transactions.Transaction> {
        get {
            return try! get_Transaction();
        }
    }
} // TransactionEventArgs


// type: System.Transactions.TransactionException
    /**
    The exception that is thrown when you attempt to do work on a transaction that cannot accept new work.

    */
open class TransactionException
    :
    dotnet.System.SystemException
{
    open class override func get_type_handle() -> TypeHandle {
        return System_Transactions_TransactionException_get_type_handle();
    }
    public required init(hndl: NonnullHandle) { super.init(hndl: hndl); }
    public required init(gval: GVal) { super.init(gval: gval); }
    // .ctor()
// docid: M:System.Transactions.TransactionException.#ctor
    /**
    Initializes a new instance of the  class.

    */
    public override init() throws {
        var __thrown : NullableHandle = nil;
        let h = System_Transactions_TransactionException_ctor_0__0(&__thrown);
        if let __ex = __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
            super.init(hndl: h);
        }
    }
    // .ctor(System.String)
// docid: M:System.Transactions.TransactionException.#ctor(System.String)
    /**
    Initializes a new instance of the  class with the specified message.

    - Parameter message: A  that contains a message that explains why the exception occurred.
    */
    public override init(message : Optional<dotnet.System.String>) throws {
        var __thrown : NullableHandle = nil;
        let h = System_Transactions_TransactionException_ctor_0__1__String(&__thrown, message?.get_handle() ?? nil);
        if let __ex = __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
            super.init(hndl: h);
        }
    }
    // .ctor(System.String, System.Exception)
// docid: M:System.Transactions.TransactionException.#ctor(System.String,System.Exception)
    /**
    Initializes a new instance of the  class with the specified message and inner exception.

    - Parameter message: A  that contains a message that explains why the exception occurred.
    - Parameter innerException: Gets the exception instance that causes the current exception. For more information, see the  property.
    */
    public override init(message : Optional<dotnet.System.String>, innerException : Optional<dotnet.System.Exception>) throws {
        var __thrown : NullableHandle = nil;
        let h = System_Transactions_TransactionException_ctor_0__2__String_Exception(&__thrown, message?.get_handle() ?? nil, innerException?.get_handle() ?? nil);
        if let __ex = __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
            super.init(hndl: h);
        }
    }
} // TransactionException


// type: System.Transactions.TransactionInDoubtException
    /**
    The exception that is thrown when an operation is attempted on a transaction that is in doubt, or an attempt is made to commit the transaction and the transaction becomes InDoubt.

    */
open class TransactionInDoubtException
    :
    dotnet.System.Transactions.TransactionException
{
    open class override func get_type_handle() -> TypeHandle {
        return System_Transactions_TransactionInDoubtException_get_type_handle();
    }
    public required init(hndl: NonnullHandle) { super.init(hndl: hndl); }
    public required init(gval: GVal) { super.init(gval: gval); }
    // .ctor()
// docid: M:System.Transactions.TransactionInDoubtException.#ctor
    /**
    Initializes a new instance of the  class.

    */
    public override init() throws {
        var __thrown : NullableHandle = nil;
        let h = System_Transactions_TransactionInDoubtException_ctor_0__0(&__thrown);
        if let __ex = __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
            super.init(hndl: h);
        }
    }
    // .ctor(System.String)
// docid: M:System.Transactions.TransactionInDoubtException.#ctor(System.String)
    /**
    Initializes a new instance of the  class with the specified message.

    - Parameter message: A  that contains a message that explains why the exception occurred.
    */
    public override init(message : Optional<dotnet.System.String>) throws {
        var __thrown : NullableHandle = nil;
        let h = System_Transactions_TransactionInDoubtException_ctor_0__1__String(&__thrown, message?.get_handle() ?? nil);
        if let __ex = __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
            super.init(hndl: h);
        }
    }
    // .ctor(System.String, System.Exception)
// docid: M:System.Transactions.TransactionInDoubtException.#ctor(System.String,System.Exception)
    /**
    Initializes a new instance of the  class with the specified message and inner exception.

    - Parameter message: A  that contains a message that explains why the exception occurred.
    - Parameter innerException: Gets the exception instance that causes the current exception. For more information, see the  property.
    */
    public override init(message : Optional<dotnet.System.String>, innerException : Optional<dotnet.System.Exception>) throws {
        var __thrown : NullableHandle = nil;
        let h = System_Transactions_TransactionInDoubtException_ctor_0__2__String_Exception(&__thrown, message?.get_handle() ?? nil, innerException?.get_handle() ?? nil);
        if let __ex = __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
            super.init(hndl: h);
        }
    }
} // TransactionInDoubtException


// type: System.Transactions.TransactionInformation
    /**
    Provides additional information regarding a transaction.

    */
open class TransactionInformation
    :
    dotnet.System.Object
{
    open class override func get_type_handle() -> TypeHandle {
        return System_Transactions_TransactionInformation_get_type_handle();
    }
    public required init(hndl: NonnullHandle) { super.init(hndl: hndl); }
    public required init(gval: GVal) { super.init(gval: gval); }
    // [IsSpecialName] System.DateTime get_CreationTime()
// docid: M:System.Transactions.TransactionInformation.get_CreationTime
    open func get_CreationTime() throws -> dotnet.System.DateTime {
        var __thrown : NullableHandle = nil;
        let __return = System_Transactions_TransactionInformation_DateTime__get_CreationTime_0__0(&__thrown, self.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return dotnet.System.DateTime(hndl : __return);
        }
    }
    // [IsSpecialName] System.Guid get_DistributedIdentifier()
// docid: M:System.Transactions.TransactionInformation.get_DistributedIdentifier
    open func get_DistributedIdentifier() throws -> dotnet.System.Guid {
        var __thrown : NullableHandle = nil;
        let __return = System_Transactions_TransactionInformation_Guid__get_DistributedIdentifier_0__0(&__thrown, self.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return dotnet.System.Guid(hndl : __return);
        }
    }
    // [IsSpecialName] System.String get_LocalIdentifier()
// docid: M:System.Transactions.TransactionInformation.get_LocalIdentifier
    open func get_LocalIdentifier() throws -> dotnet.System.String {
        var __thrown : NullableHandle = nil;
        let __return = System_Transactions_TransactionInformation_String__get_LocalIdentifier_0__0(&__thrown, self.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return dotnet.System.String(hndl : __return);
        }
    }
    // [IsSpecialName] System.Transactions.TransactionStatus get_Status()
// docid: M:System.Transactions.TransactionInformation.get_Status
    open func get_Status() throws -> dotnet.System.Transactions.TransactionStatus {
        var __thrown : NullableHandle = nil;
        let __return = System_Transactions_TransactionInformation_TransactionStatus__get_Status_0__0(&__thrown, self.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return dotnet.System.Transactions.TransactionStatus(val: __return);
        }
    }
    /**
    Gets the creation time of the transaction.

    */
    open var CreationTime : dotnet.System.DateTime {
        get {
            return try! get_CreationTime();
        }
    }
    /**
    Gets a unique identifier of the escalated transaction.

    */
    open var DistributedIdentifier : dotnet.System.Guid {
        get {
            return try! get_DistributedIdentifier();
        }
    }
    /**
    Gets a unique identifier of the transaction.

    */
    open var LocalIdentifier : dotnet.System.String {
        get {
            return try! get_LocalIdentifier();
        }
    }
    /**
    Gets the status of the transaction.

    */
    open var Status : dotnet.System.Transactions.TransactionStatus {
        get {
            return try! get_Status();
        }
    }
} // TransactionInformation


// type: System.Transactions.TransactionInterop
public struct TransactionInterop {
    // static field: System.Guid PromoterTypeDtc
    /**
    The type of the distributed transaction processor.

    */
    public static var PromoterTypeDtc : dotnet.System.Guid {
        get {
        let __return = dotnet.System.Guid(hndl: System_Transactions_TransactionInterop_get_PromoterTypeDtc());
            return __return;
        }
    }
    // System.Transactions.IDtcTransaction GetDtcTransaction(System.Transactions.Transaction)
// docid: M:System.Transactions.TransactionInterop.GetDtcTransaction(System.Transactions.Transaction)
    /**
    Gets an  instance that represents a .

    - Parameter transaction: A  instance to be marshaled.
    - Returns: An  instance that represents a .  The  instance is compatible with the unmanaged form of ITransaction used by MSDTC and with the Managed form of  used by .

    */
    public static func GetDtcTransaction(transaction : dotnet.System.Transactions.Transaction) throws -> dotnet.System.Transactions.IDtcTransaction {
        var __thrown : NullableHandle = nil;
        let __return = System_Transactions_TransactionInterop_IDtcTransaction__GetDtcTransaction_0__1__Transaction(&__thrown, transaction.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return dotnet.System.Transactions.IDtcTransaction(hndl : __return);
        }
    }
    // System.Byte[] GetExportCookie(System.Transactions.Transaction, System.Byte[])
// docid: M:System.Transactions.TransactionInterop.GetExportCookie(System.Transactions.Transaction,System.Byte[])
    /**
    Transforms a transaction object into an export transaction cookie.

    - Parameter transaction: The  object to be marshaled.
    - Parameter whereabouts: An address that describes the location of the destination transaction manager. This permits two transaction managers to communicate with one another and thereby propagate a transaction from one system to the other.
    - Returns: An export transaction cookie representing the specified  object.

    */
    public static func GetExportCookie(transaction : dotnet.System.Transactions.Transaction, whereabouts : dotnet.System_Arr<Swift.UInt8>) throws -> dotnet.System_Arr<Swift.UInt8> {
        var __thrown : NullableHandle = nil;
        let __return = System_Transactions_TransactionInterop_u8Array__GetExportCookie_0__2__Transaction_u8Array(&__thrown, transaction.get_handle(), whereabouts.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return dotnet.System_Arr<Swift.UInt8>(hndl : __return);
        }
    }
    // System.Transactions.Transaction GetTransactionFromDtcTransaction(System.Transactions.IDtcTransaction)
// docid: M:System.Transactions.TransactionInterop.GetTransactionFromDtcTransaction(System.Transactions.IDtcTransaction)
    /**
    Generates a  from a specified .

    - Parameter transactionNative: The  object to be marshaled.
    - Returns: A  instance that represents the given .

    */
    public static func GetTransactionFromDtcTransaction(transactionNative : dotnet.System.Transactions.IDtcTransaction) throws -> dotnet.System.Transactions.Transaction {
        var __thrown : NullableHandle = nil;
        let __return = System_Transactions_TransactionInterop_Transaction__GetTransactionFromDtcTransaction_0__1__IDtcTransaction(&__thrown, transactionNative.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return dotnet.System.Transactions.Transaction(hndl : __return);
        }
    }
    // System.Transactions.Transaction GetTransactionFromExportCookie(System.Byte[])
// docid: M:System.Transactions.TransactionInterop.GetTransactionFromExportCookie(System.Byte[])
    /**
    Generates a  from the specified an export cookie.

    - Parameter cookie: A marshaled form of the transaction object.
    - Returns: A  from the specified export cookie.

    */
    public static func GetTransactionFromExportCookie(cookie : dotnet.System_Arr<Swift.UInt8>) throws -> dotnet.System.Transactions.Transaction {
        var __thrown : NullableHandle = nil;
        let __return = System_Transactions_TransactionInterop_Transaction__GetTransactionFromExportCookie_0__1__u8Array(&__thrown, cookie.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return dotnet.System.Transactions.Transaction(hndl : __return);
        }
    }
    // System.Transactions.Transaction GetTransactionFromTransmitterPropagationToken(System.Byte[])
// docid: M:System.Transactions.TransactionInterop.GetTransactionFromTransmitterPropagationToken(System.Byte[])
    /**
    Generates a  instance from the specified transmitter propagation token.

    - Parameter propagationToken: A propagation token representing a transaction.
    - Returns: A  from the specified transmitter propagation token.

    */
    public static func GetTransactionFromTransmitterPropagationToken(propagationToken : dotnet.System_Arr<Swift.UInt8>) throws -> dotnet.System.Transactions.Transaction {
        var __thrown : NullableHandle = nil;
        let __return = System_Transactions_TransactionInterop_Transaction__GetTransactionFromTransmitterPropagationToken_0__1__u8Array(&__thrown, propagationToken.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return dotnet.System.Transactions.Transaction(hndl : __return);
        }
    }
    // System.Byte[] GetTransmitterPropagationToken(System.Transactions.Transaction)
// docid: M:System.Transactions.TransactionInterop.GetTransmitterPropagationToken(System.Transactions.Transaction)
    /**
    Generates a propagation token for the specified .

    - Parameter transaction: A transaction to be marshaled into a propagation token.
    - Returns: This method, together with the  method, provide functionality for Transmitter/Receiver propagation, in which the transaction is "pulled" from the remote machine when the latter is called to unmarshal the transaction.  
  
 For more information on different propagation models, see  class.

    */
    public static func GetTransmitterPropagationToken(transaction : dotnet.System.Transactions.Transaction) throws -> dotnet.System_Arr<Swift.UInt8> {
        var __thrown : NullableHandle = nil;
        let __return = System_Transactions_TransactionInterop_u8Array__GetTransmitterPropagationToken_0__1__Transaction(&__thrown, transaction.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return dotnet.System_Arr<Swift.UInt8>(hndl : __return);
        }
    }
    // System.Byte[] GetWhereabouts()
// docid: M:System.Transactions.TransactionInterop.GetWhereabouts
    /**
    Gets the Whereabouts of the distributed transaction manager that  uses.

    - Returns: The Whereabouts of the distributed transaction manager that  uses.

    */
    public static func GetWhereabouts() throws -> dotnet.System_Arr<Swift.UInt8> {
        var __thrown : NullableHandle = nil;
        let __return = System_Transactions_TransactionInterop_u8Array__GetWhereabouts_0__0(&__thrown);
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return dotnet.System_Arr<Swift.UInt8>(hndl : __return);
        }
    }
} // TransactionInterop


// type: System.Transactions.TransactionManager
public struct TransactionManager {
    // void RecoveryComplete(System.Guid)
// docid: M:System.Transactions.TransactionManager.RecoveryComplete(System.Guid)
    /**
    Notifies the transaction manager that a resource manager recovering from failure has finished reenlisting in all unresolved transactions.

    - Parameter resourceManagerIdentifier: A  that uniquely identifies the resource to be recovered from.
    */
    public static func RecoveryComplete(resourceManagerIdentifier : dotnet.System.Guid) throws {
        var __thrown : NullableHandle = nil;
        System_Transactions_TransactionManager_void__RecoveryComplete_0__1__Guid(&__thrown, resourceManagerIdentifier.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
            return;
        }
    }
    // System.Transactions.Enlistment Reenlist(System.Guid, System.Byte[], System.Transactions.IEnlistmentNotification)
// docid: M:System.Transactions.TransactionManager.Reenlist(System.Guid,System.Byte[],System.Transactions.IEnlistmentNotification)
    /**
    Reenlists a durable participant in a transaction.

    - Parameter resourceManagerIdentifier: A  that uniquely identifies the resource manager.
    - Parameter recoveryInformation: Contains additional information of recovery information.
    - Parameter enlistmentNotification: A resource object that implements  to receive notifications.
    - Returns: An  that describes the enlistment.

    */
    public static func Reenlist(resourceManagerIdentifier : dotnet.System.Guid, recoveryInformation : dotnet.System_Arr<Swift.UInt8>, enlistmentNotification : dotnet.System.Transactions.IEnlistmentNotification) throws -> dotnet.System.Transactions.Enlistment {
        var __thrown : NullableHandle = nil;
        let __return = System_Transactions_TransactionManager_Enlistment__Reenlist_0__3__Guid_u8Array_IEnlistmentNotification(&__thrown, resourceManagerIdentifier.get_handle(), recoveryInformation.get_handle(), enlistmentNotification.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return dotnet.System.Transactions.Enlistment(hndl : __return);
        }
    }
    // [IsSpecialName] System.TimeSpan get_DefaultTimeout()
// docid: M:System.Transactions.TransactionManager.get_DefaultTimeout
    public static func get_DefaultTimeout() throws -> dotnet.System.TimeSpan {
        var __thrown : NullableHandle = nil;
        let __return = System_Transactions_TransactionManager_TimeSpan__get_DefaultTimeout_0__0(&__thrown);
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return dotnet.System.TimeSpan(hndl : __return);
        }
    }
    // [IsSpecialName] System.Transactions.HostCurrentTransactionCallback get_HostCurrentCallback()
// docid: M:System.Transactions.TransactionManager.get_HostCurrentCallback
    public static func get_HostCurrentCallback() throws -> Optional<dotnet.System.Transactions.HostCurrentTransactionCallback> {
        var __thrown : NullableHandle = nil;
        let __return = System_Transactions_TransactionManager_HostCurrentTransactionCallback__get_HostCurrentCallback_0__0(&__thrown);
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        if let __ret_unwrapped = __return {
            return dotnet.System.Transactions.HostCurrentTransactionCallback(hndl : __ret_unwrapped);
        } else {
            return nil;
        }
        }
    }
    // [IsSpecialName] void set_HostCurrentCallback(System.Transactions.HostCurrentTransactionCallback)
// docid: M:System.Transactions.TransactionManager.set_HostCurrentCallback(System.Transactions.HostCurrentTransactionCallback)
    public static func set_HostCurrentCallback(value : Optional<dotnet.System.Transactions.HostCurrentTransactionCallback>) throws {
        var __thrown : NullableHandle = nil;
        System_Transactions_TransactionManager_void__set_HostCurrentCallback_0__1__HostCurrentTransactionCallback(&__thrown, value?.get_handle() ?? nil);
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
            return;
        }
    }
    // delegate closure overload
    public static func set_HostCurrentCallback(value : @escaping () throws -> dotnet.System.Transactions.Transaction) throws {
        let del_value = try dotnet.System.Transactions.HostCurrentTransactionCallback(value);
        return try set_HostCurrentCallback(value: del_value);
    }
    // [IsSpecialName] System.TimeSpan get_MaximumTimeout()
// docid: M:System.Transactions.TransactionManager.get_MaximumTimeout
    public static func get_MaximumTimeout() throws -> dotnet.System.TimeSpan {
        var __thrown : NullableHandle = nil;
        let __return = System_Transactions_TransactionManager_TimeSpan__get_MaximumTimeout_0__0(&__thrown);
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return dotnet.System.TimeSpan(hndl : __return);
        }
    }
    // [IsSpecialName] void add_DistributedTransactionStarted(System.Transactions.TransactionStartedEventHandler)
// docid: M:System.Transactions.TransactionManager.add_DistributedTransactionStarted(System.Transactions.TransactionStartedEventHandler)
    public static func add_DistributedTransactionStarted(value : Optional<dotnet.System.Transactions.TransactionStartedEventHandler>) throws {
        var __thrown : NullableHandle = nil;
        System_Transactions_TransactionManager_void__add_DistributedTransactionStarted_0__1__TransactionStartedEventHandler(&__thrown, value?.get_handle() ?? nil);
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
            return;
        }
    }
    // delegate closure overload
    public static func add_DistributedTransactionStarted(value : @escaping (Optional<dotnet.System.Object>, dotnet.System.Transactions.TransactionEventArgs) throws -> Void) throws {
        let del_value = try dotnet.System.Transactions.TransactionStartedEventHandler(value);
        return try add_DistributedTransactionStarted(value: del_value);
    }
    // [IsSpecialName] void remove_DistributedTransactionStarted(System.Transactions.TransactionStartedEventHandler)
// docid: M:System.Transactions.TransactionManager.remove_DistributedTransactionStarted(System.Transactions.TransactionStartedEventHandler)
    public static func remove_DistributedTransactionStarted(value : Optional<dotnet.System.Transactions.TransactionStartedEventHandler>) throws {
        var __thrown : NullableHandle = nil;
        System_Transactions_TransactionManager_void__remove_DistributedTransactionStarted_0__1__TransactionStartedEventHandler(&__thrown, value?.get_handle() ?? nil);
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
            return;
        }
    }
    // delegate closure overload
    public static func remove_DistributedTransactionStarted(value : @escaping (Optional<dotnet.System.Object>, dotnet.System.Transactions.TransactionEventArgs) throws -> Void) throws {
        let del_value = try dotnet.System.Transactions.TransactionStartedEventHandler(value);
        return try remove_DistributedTransactionStarted(value: del_value);
    }
    /**
    Gets the default timeout interval for new transactions.

    */
    public static var DefaultTimeout : dotnet.System.TimeSpan {
        get {
            return try! get_DefaultTimeout();
        }
    }
    /**
    Gets or sets a custom transaction factory.

    */
    public static var HostCurrentCallback : Optional<dotnet.System.Transactions.HostCurrentTransactionCallback> {
        get {
            return try! get_HostCurrentCallback();
        }
        set(v) {
            return try! set_HostCurrentCallback(value: v!);
        }
    }
    /**
    Gets the default maximum timeout interval for new transactions.

    */
    public static var MaximumTimeout : dotnet.System.TimeSpan {
        get {
            return try! get_MaximumTimeout();
        }
    }
} // TransactionManager


// type: System.Transactions.TransactionManagerCommunicationException
    /**
    The exception that is thrown when a resource manager cannot communicate with the transaction manager.

    */
open class TransactionManagerCommunicationException
    :
    dotnet.System.Transactions.TransactionException
{
    open class override func get_type_handle() -> TypeHandle {
        return System_Transactions_TransactionManagerCommunicationException_get_type_handle();
    }
    public required init(hndl: NonnullHandle) { super.init(hndl: hndl); }
    public required init(gval: GVal) { super.init(gval: gval); }
    // .ctor()
// docid: M:System.Transactions.TransactionManagerCommunicationException.#ctor
    /**
    Initializes a new instance of the  class.

    */
    public override init() throws {
        var __thrown : NullableHandle = nil;
        let h = System_Transactions_TransactionManagerCommunicationException_ctor_0__0(&__thrown);
        if let __ex = __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
            super.init(hndl: h);
        }
    }
    // .ctor(System.String)
// docid: M:System.Transactions.TransactionManagerCommunicationException.#ctor(System.String)
    /**
    Initializes a new instance of the  class with the specified message.

    - Parameter message: A  that contains a message that explains why the exception occurred.
    */
    public override init(message : Optional<dotnet.System.String>) throws {
        var __thrown : NullableHandle = nil;
        let h = System_Transactions_TransactionManagerCommunicationException_ctor_0__1__String(&__thrown, message?.get_handle() ?? nil);
        if let __ex = __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
            super.init(hndl: h);
        }
    }
    // .ctor(System.String, System.Exception)
// docid: M:System.Transactions.TransactionManagerCommunicationException.#ctor(System.String,System.Exception)
    /**
    Initializes a new instance of the  class with the specified message and inner exception.

    - Parameter message: A  that contains a message that explains why the exception occurred.
    - Parameter innerException: Gets the exception instance that causes the current exception. For more information, see the  property.
    */
    public override init(message : Optional<dotnet.System.String>, innerException : Optional<dotnet.System.Exception>) throws {
        var __thrown : NullableHandle = nil;
        let h = System_Transactions_TransactionManagerCommunicationException_ctor_0__2__String_Exception(&__thrown, message?.get_handle() ?? nil, innerException?.get_handle() ?? nil);
        if let __ex = __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
            super.init(hndl: h);
        }
    }
} // TransactionManagerCommunicationException


// type: System.Transactions.TransactionOptions
// boxed value type
    /**
    Contains additional information that specifies transaction behaviors.

    */
public final class TransactionOptions
    :
    dotnet.System.Object
{
    public class override func get_type_handle() -> TypeHandle {
        return System_Transactions_TransactionOptions_get_type_handle();
    }
    public required init(hndl: NonnullHandle) { super.init(hndl: hndl); }
    public required init(gval: GVal) { super.init(gval: gval); }
    /**
    Gets or sets the isolation level of the transaction.

    */
    public var IsolationLevel : dotnet.System.Transactions.IsolationLevel {
        get {
            return try! get_IsolationLevel();
        }
        set(v) {
            return try! set_IsolationLevel(value: v);
        }
    }
    /**
    Gets or sets the timeout period for the transaction.

    */
    public var Timeout : dotnet.System.TimeSpan {
        get {
            return try! get_Timeout();
        }
// TODO COPE prop set (span) [IsSpecialName] void set_Timeout(System.TimeSpan)
    }
    public override init() {
        let h = System_Transactions_TransactionOptions_implicit_ctor();
            super.init(hndl: h);
    }
    // bool Equals(System.Object)
// docid: M:System.Transactions.TransactionOptions.Equals(System.Object)
    /**
    Determines whether this  instance and the specified object are equal.

    - Parameter obj: The object to compare with this instance.
    - Returns: 
         if  and this  instance are identical; otherwise, .

    */
    public override func Equals(obj : Optional<dotnet.System.Object>) throws -> Bool {
        var __thrown : NullableHandle = nil;
        let __return = System_Transactions_TransactionOptions_bool__Equals_0__1__Object(&__thrown, self.get_handle(), obj?.get_handle() ?? nil);
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return (__return) != 0;
        }
    }
    // System.Int32 GetHashCode()
// docid: M:System.Transactions.TransactionOptions.GetHashCode
    /**
    Returns the hash code for this instance.

    - Returns: A 32-bit signed integer hash code.

    */
    public override func GetHashCode() throws -> Swift.Int32 {
        var __thrown : NullableHandle = nil;
        let __return = System_Transactions_TransactionOptions_i32__GetHashCode_0__0(&__thrown, self.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return __return;
        }
    }
    // [IsSpecialName] bool op_Equality(System.Transactions.TransactionOptions, System.Transactions.TransactionOptions)
// docid: M:System.Transactions.TransactionOptions.op_Equality(System.Transactions.TransactionOptions,System.Transactions.TransactionOptions)
    /**
    Tests whether two specified  instances are equivalent.

    - Parameter x: The  instance that is to the left of the equality operator.
    - Parameter y: The  instance that is to the right of the equality operator.
    - Returns: 
         if  and  are equal; otherwise, .

    */
    public class func op_Equality(x : dotnet.System.Transactions.TransactionOptions, y : dotnet.System.Transactions.TransactionOptions) throws -> Bool {
        var __thrown : NullableHandle = nil;
        let __return = System_Transactions_TransactionOptions_bool__op_Equality_0__2__TransactionOptions_TransactionOptions(&__thrown, x.get_handle(), y.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return (__return) != 0;
        }
    }
    // [IsSpecialName] bool op_Inequality(System.Transactions.TransactionOptions, System.Transactions.TransactionOptions)
// docid: M:System.Transactions.TransactionOptions.op_Inequality(System.Transactions.TransactionOptions,System.Transactions.TransactionOptions)
    /**
    Returns a value that indicates whether two  instances are not equal.

    - Parameter x: The  instance that is to the left of the equality operator.
    - Parameter y: The  instance that is to the right of the equality operator.
    - Returns: 
         if  and  are not equal; otherwise, .

    */
    public class func op_Inequality(x : dotnet.System.Transactions.TransactionOptions, y : dotnet.System.Transactions.TransactionOptions) throws -> Bool {
        var __thrown : NullableHandle = nil;
        let __return = System_Transactions_TransactionOptions_bool__op_Inequality_0__2__TransactionOptions_TransactionOptions(&__thrown, x.get_handle(), y.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return (__return) != 0;
        }
    }
    // [IsSpecialName] System.Transactions.IsolationLevel get_IsolationLevel()
// docid: M:System.Transactions.TransactionOptions.get_IsolationLevel
    public func get_IsolationLevel() throws -> dotnet.System.Transactions.IsolationLevel {
        var __thrown : NullableHandle = nil;
        let __return = System_Transactions_TransactionOptions_IsolationLevel__get_IsolationLevel_0__0(&__thrown, self.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return dotnet.System.Transactions.IsolationLevel(val: __return);
        }
    }
    // [IsSpecialName] void set_IsolationLevel(System.Transactions.IsolationLevel)
// docid: M:System.Transactions.TransactionOptions.set_IsolationLevel(System.Transactions.IsolationLevel)
    public func set_IsolationLevel(value : dotnet.System.Transactions.IsolationLevel) throws {
        var __thrown : NullableHandle = nil;
        System_Transactions_TransactionOptions_void__set_IsolationLevel_0__1__IsolationLevel(&__thrown, self.get_handle(), value.get_value());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
            return;
        }
    }
    // [IsSpecialName] System.TimeSpan get_Timeout()
// docid: M:System.Transactions.TransactionOptions.get_Timeout
    public func get_Timeout() throws -> dotnet.System.TimeSpan {
        var __thrown : NullableHandle = nil;
        let __return = System_Transactions_TransactionOptions_TimeSpan__get_Timeout_0__0(&__thrown, self.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return dotnet.System.TimeSpan(hndl : __return);
        }
    }
// TODO COPE (write_all_methods) (span) [IsSpecialName] void set_Timeout(System.TimeSpan)
} // TransactionOptions


// type: System.Transactions.TransactionPromotionException
    /**
    The exception that is thrown when a promotion fails.

    */
open class TransactionPromotionException
    :
    dotnet.System.Transactions.TransactionException
{
    open class override func get_type_handle() -> TypeHandle {
        return System_Transactions_TransactionPromotionException_get_type_handle();
    }
    public required init(hndl: NonnullHandle) { super.init(hndl: hndl); }
    public required init(gval: GVal) { super.init(gval: gval); }
    // .ctor()
// docid: M:System.Transactions.TransactionPromotionException.#ctor
    /**
    Initializes a new instance of the  class.

    */
    public override init() throws {
        var __thrown : NullableHandle = nil;
        let h = System_Transactions_TransactionPromotionException_ctor_0__0(&__thrown);
        if let __ex = __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
            super.init(hndl: h);
        }
    }
    // .ctor(System.String)
// docid: M:System.Transactions.TransactionPromotionException.#ctor(System.String)
    /**
    Initializes a new instance of the  class with the specified message.

    - Parameter message: A  that contains a message that explains why the exception occurred.
    */
    public override init(message : Optional<dotnet.System.String>) throws {
        var __thrown : NullableHandle = nil;
        let h = System_Transactions_TransactionPromotionException_ctor_0__1__String(&__thrown, message?.get_handle() ?? nil);
        if let __ex = __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
            super.init(hndl: h);
        }
    }
    // .ctor(System.String, System.Exception)
// docid: M:System.Transactions.TransactionPromotionException.#ctor(System.String,System.Exception)
    /**
    Initializes a new instance of the  class with the specified message and inner exception.

    - Parameter message: A  that contains a message that explains why the exception occurred.
    - Parameter innerException: Gets the exception instance that causes the current exception. For more information, see the  property.
    */
    public override init(message : Optional<dotnet.System.String>, innerException : Optional<dotnet.System.Exception>) throws {
        var __thrown : NullableHandle = nil;
        let h = System_Transactions_TransactionPromotionException_ctor_0__2__String_Exception(&__thrown, message?.get_handle() ?? nil, innerException?.get_handle() ?? nil);
        if let __ex = __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
            super.init(hndl: h);
        }
    }
} // TransactionPromotionException


// type: System.Transactions.TransactionScope
    /**
    Makes a code block transactional. This class cannot be inherited.

    */
public final class TransactionScope
    :
    dotnet.System.Object,
    System_IDisposable
{
    public class override func get_type_handle() -> TypeHandle {
        return System_Transactions_TransactionScope_get_type_handle();
    }
    public required init(hndl: NonnullHandle) { super.init(hndl: hndl); }
    public required init(gval: GVal) { super.init(gval: gval); }
    // .ctor()
// docid: M:System.Transactions.TransactionScope.#ctor
    /**
    Initializes a new instance of the  class.

    */
    public override init() throws {
        var __thrown : NullableHandle = nil;
        let h = System_Transactions_TransactionScope_ctor_0__0(&__thrown);
        if let __ex = __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
            super.init(hndl: h);
        }
    }
    // .ctor(System.Transactions.Transaction)
// docid: M:System.Transactions.TransactionScope.#ctor(System.Transactions.Transaction)
    /**
    Initializes a new instance of the  class and sets the specified transaction as the ambient transaction, so that transactional work done inside the scope uses this transaction.

    - Parameter transactionToUse: The transaction to be set as the ambient transaction, so that transactional work done inside the scope uses this transaction.
    */
    public init(transactionToUse : dotnet.System.Transactions.Transaction) throws {
        var __thrown : NullableHandle = nil;
        let h = System_Transactions_TransactionScope_ctor_0__1__Transaction(&__thrown, transactionToUse.get_handle());
        if let __ex = __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
            super.init(hndl: h);
        }
    }
// TODO COPE ctor (span) .ctor(System.Transactions.Transaction, System.TimeSpan)
// TODO COPE ctor (span) .ctor(System.Transactions.Transaction, System.TimeSpan, System.Transactions.EnterpriseServicesInteropOption)
// TODO COPE ctor (span) .ctor(System.Transactions.Transaction, System.TimeSpan, System.Transactions.TransactionScopeAsyncFlowOption)
    // .ctor(System.Transactions.Transaction, System.Transactions.TransactionScopeAsyncFlowOption)
// docid: M:System.Transactions.TransactionScope.#ctor(System.Transactions.Transaction,System.Transactions.TransactionScopeAsyncFlowOption)
    /**
    [Supported in the .NET Framework 4.5.1 and later versions]  
  
 Initializes a new instance of the  class and sets the specified transaction as the ambient transaction, so that transactional work done inside the scope uses this transaction.

    - Parameter transactionToUse: The transaction to be set as the ambient transaction, so that transactional work done inside the scope uses this transaction.
    - Parameter asyncFlowOption: An instance of the  enumeration that describes whether the ambient transaction associated with the transaction scope will flow across thread continuations when using Task or async/await .NET async programming patterns.
    */
    public init(transactionToUse : dotnet.System.Transactions.Transaction, asyncFlowOption : dotnet.System.Transactions.TransactionScopeAsyncFlowOption) throws {
        var __thrown : NullableHandle = nil;
        let h = System_Transactions_TransactionScope_ctor_0__2__Transaction_TransactionScopeAsyncFlowOption(&__thrown, transactionToUse.get_handle(), asyncFlowOption.get_value());
        if let __ex = __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
            super.init(hndl: h);
        }
    }
    // .ctor(System.Transactions.TransactionScopeAsyncFlowOption)
// docid: M:System.Transactions.TransactionScope.#ctor(System.Transactions.TransactionScopeAsyncFlowOption)
    /**
    Initializes a new instance of the  class with the specified asynchronous flow option.

    - Parameter asyncFlowOption: An instance of the  enumeration that describes whether the ambient transaction associated with the transaction scope will flow across thread continuations when using Task or async/await .NET async programming patterns.
    */
    public init(asyncFlowOption : dotnet.System.Transactions.TransactionScopeAsyncFlowOption) throws {
        var __thrown : NullableHandle = nil;
        let h = System_Transactions_TransactionScope_ctor_0__1__TransactionScopeAsyncFlowOption(&__thrown, asyncFlowOption.get_value());
        if let __ex = __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
            super.init(hndl: h);
        }
    }
    // .ctor(System.Transactions.TransactionScopeOption)
// docid: M:System.Transactions.TransactionScope.#ctor(System.Transactions.TransactionScopeOption)
    /**
    Initializes a new instance of the  class with the specified requirements.

    - Parameter scopeOption: An instance of the  enumeration that describes the transaction requirements associated with this transaction scope.
    */
    public init(scopeOption : dotnet.System.Transactions.TransactionScopeOption) throws {
        var __thrown : NullableHandle = nil;
        let h = System_Transactions_TransactionScope_ctor_0__1__TransactionScopeOption(&__thrown, scopeOption.get_value());
        if let __ex = __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
            super.init(hndl: h);
        }
    }
// TODO COPE ctor (span) .ctor(System.Transactions.TransactionScopeOption, System.TimeSpan)
// TODO COPE ctor (span) .ctor(System.Transactions.TransactionScopeOption, System.TimeSpan, System.Transactions.TransactionScopeAsyncFlowOption)
    // .ctor(System.Transactions.TransactionScopeOption, System.Transactions.TransactionOptions)
// docid: M:System.Transactions.TransactionScope.#ctor(System.Transactions.TransactionScopeOption,System.Transactions.TransactionOptions)
    /**
    Initializes a new instance of the  class with the specified requirements.

    - Parameter scopeOption: An instance of the  enumeration that describes the transaction requirements associated with this transaction scope.
    - Parameter transactionOptions: A  structure that describes the transaction options to use if a new transaction is created. If an existing transaction is used, the timeout value in this parameter applies to the transaction scope. If that time expires before the scope is disposed, the transaction is aborted.
    */
    public init(scopeOption : dotnet.System.Transactions.TransactionScopeOption, transactionOptions : dotnet.System.Transactions.TransactionOptions) throws {
        var __thrown : NullableHandle = nil;
        let h = System_Transactions_TransactionScope_ctor_0__2__TransactionScopeOption_TransactionOptions(&__thrown, scopeOption.get_value(), transactionOptions.get_handle());
        if let __ex = __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
            super.init(hndl: h);
        }
    }
    // .ctor(System.Transactions.TransactionScopeOption, System.Transactions.TransactionOptions, System.Transactions.EnterpriseServicesInteropOption)
// docid: M:System.Transactions.TransactionScope.#ctor(System.Transactions.TransactionScopeOption,System.Transactions.TransactionOptions,System.Transactions.EnterpriseServicesInteropOption)
    /**
    Initializes a new instance of the  class with the specified scope and COM+ interoperability requirements, and transaction options.

    - Parameter scopeOption: An instance of the  enumeration that describes the transaction requirements associated with this transaction scope.
    - Parameter transactionOptions: A  structure that describes the transaction options to use if a new transaction is created. If an existing transaction is used, the timeout value in this parameter applies to the transaction scope. If that time expires before the scope is disposed, the transaction is aborted.
    - Parameter interopOption: An instance of the  enumeration that describes how the associated transaction interacts with COM+ transactions.
    */
    public init(scopeOption : dotnet.System.Transactions.TransactionScopeOption, transactionOptions : dotnet.System.Transactions.TransactionOptions, interopOption : dotnet.System.Transactions.EnterpriseServicesInteropOption) throws {
        var __thrown : NullableHandle = nil;
        let h = System_Transactions_TransactionScope_ctor_0__3__TransactionScopeOption_TransactionOptions_EnterpriseServicesInteropOption(&__thrown, scopeOption.get_value(), transactionOptions.get_handle(), interopOption.get_value());
        if let __ex = __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
            super.init(hndl: h);
        }
    }
    // .ctor(System.Transactions.TransactionScopeOption, System.Transactions.TransactionOptions, System.Transactions.TransactionScopeAsyncFlowOption)
// docid: M:System.Transactions.TransactionScope.#ctor(System.Transactions.TransactionScopeOption,System.Transactions.TransactionOptions,System.Transactions.TransactionScopeAsyncFlowOption)
    /**
    [Supported in the .NET Framework 4.5.1 and later versions]  
  
 Initializes a new instance of the  class with the specified requirements and asynchronous flow option.

    - Parameter scopeOption: An instance of the  enumeration that describes the transaction requirements associated with this transaction scope.
    - Parameter transactionOptions: A  structure that describes the transaction options to use if a new transaction is created. If an existing transaction is used, the timeout value in this parameter applies to the transaction scope. If that time expires before the scope is disposed, the transaction is aborted.
    - Parameter asyncFlowOption: An instance of the  enumeration that describes whether the ambient transaction associated with the transaction scope will flow across thread continuations when using Task or async/await .NET async programming patterns.
    */
    public init(scopeOption : dotnet.System.Transactions.TransactionScopeOption, transactionOptions : dotnet.System.Transactions.TransactionOptions, asyncFlowOption : dotnet.System.Transactions.TransactionScopeAsyncFlowOption) throws {
        var __thrown : NullableHandle = nil;
        let h = System_Transactions_TransactionScope_ctor_0__3__TransactionScopeOption_TransactionOptions_TransactionScopeAsyncFlowOption(&__thrown, scopeOption.get_value(), transactionOptions.get_handle(), asyncFlowOption.get_value());
        if let __ex = __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
            super.init(hndl: h);
        }
    }
    // .ctor(System.Transactions.TransactionScopeOption, System.Transactions.TransactionScopeAsyncFlowOption)
// docid: M:System.Transactions.TransactionScope.#ctor(System.Transactions.TransactionScopeOption,System.Transactions.TransactionScopeAsyncFlowOption)
    /**
    Initializes a new instance of the  class with the specified requirements and asynchronous flow option.

    - Parameter scopeOption: An instance of the  enumeration that describes the transaction requirements associated with this transaction scope.
    - Parameter asyncFlowOption: An instance of the  enumeration that describes whether the ambient transaction associated with the transaction scope will flow across thread continuations when using Task or async/await .NET async programming patterns.
    */
    public init(scopeOption : dotnet.System.Transactions.TransactionScopeOption, asyncFlowOption : dotnet.System.Transactions.TransactionScopeAsyncFlowOption) throws {
        var __thrown : NullableHandle = nil;
        let h = System_Transactions_TransactionScope_ctor_0__2__TransactionScopeOption_TransactionScopeAsyncFlowOption(&__thrown, scopeOption.get_value(), asyncFlowOption.get_value());
        if let __ex = __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
            super.init(hndl: h);
        }
    }
    // void Complete()
// docid: M:System.Transactions.TransactionScope.Complete
    /**
    Indicates that all operations within the scope are completed successfully.

    */
    public func Complete() throws {
        var __thrown : NullableHandle = nil;
        System_Transactions_TransactionScope_void__Complete_0__0(&__thrown, self.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
            return;
        }
    }
    // void Dispose()
// docid: M:System.Transactions.TransactionScope.Dispose
    /**
    Ends the transaction scope.

    */
    public func Dispose() throws {
        var __thrown : NullableHandle = nil;
        System_Transactions_TransactionScope_void__Dispose_0__0(&__thrown, self.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
            return;
        }
    }
} // TransactionScope


// type: System.Transactions.TransactionScopeAsyncFlowOption
    /**
    Specifies whether transaction flow across thread continuations is enabled for .

    */
public struct TransactionScopeAsyncFlowOption : SGBridgeGenericValue {
    let v : Swift.Int32;
    public init(val: Swift.Int32) { self.v = val; }
    public func get_value() -> Swift.Int32 { return self.v; }
    public static func get_type_handle() -> TypeHandle {
        return System_Transactions_TransactionScopeAsyncFlowOption_get_type_handle();
    }
    public func to_gval() -> GVal { return GVal(self.v); }
    public func dup_gval() -> GVal { return to_gval(); }
    public init(gval: GVal) { self.v = Swift.Int32(gval); }
    // static field: System.Transactions.TransactionScopeAsyncFlowOption Suppress
    /**
    Specifies that transaction flow across thread continuations is suppressed. This is the default setting if no  is specified in the  constructor.

    */
    public static var Suppress : dotnet.System.Transactions.TransactionScopeAsyncFlowOption {
        get {
        let __return = dotnet.System.Transactions.TransactionScopeAsyncFlowOption(val: System_Transactions_TransactionScopeAsyncFlowOption_get_Suppress());
            return __return;
        }
    }
    // static field: System.Transactions.TransactionScopeAsyncFlowOption Enabled
    /**
    Specifies that transaction flow across thread continuations is enabled.

    */
    public static var Enabled : dotnet.System.Transactions.TransactionScopeAsyncFlowOption {
        get {
        let __return = dotnet.System.Transactions.TransactionScopeAsyncFlowOption(val: System_Transactions_TransactionScopeAsyncFlowOption_get_Enabled());
            return __return;
        }
    }
} // TransactionScopeAsyncFlowOption


// type: System.Transactions.TransactionScopeOption
    /**
    Provides additional options for creating a transaction scope.

    */
public struct TransactionScopeOption : SGBridgeGenericValue {
    let v : Swift.Int32;
    public init(val: Swift.Int32) { self.v = val; }
    public func get_value() -> Swift.Int32 { return self.v; }
    public static func get_type_handle() -> TypeHandle {
        return System_Transactions_TransactionScopeOption_get_type_handle();
    }
    public func to_gval() -> GVal { return GVal(self.v); }
    public func dup_gval() -> GVal { return to_gval(); }
    public init(gval: GVal) { self.v = Swift.Int32(gval); }
    // static field: System.Transactions.TransactionScopeOption Required
    /**
    A transaction is required by the scope. It uses an ambient transaction if one already exists. Otherwise, it creates a new transaction before entering the scope. This is the default value.

    */
    public static var Required : dotnet.System.Transactions.TransactionScopeOption {
        get {
        let __return = dotnet.System.Transactions.TransactionScopeOption(val: System_Transactions_TransactionScopeOption_get_Required());
            return __return;
        }
    }
    // static field: System.Transactions.TransactionScopeOption RequiresNew
    /**
    A new transaction is always created for the scope.

    */
    public static var RequiresNew : dotnet.System.Transactions.TransactionScopeOption {
        get {
        let __return = dotnet.System.Transactions.TransactionScopeOption(val: System_Transactions_TransactionScopeOption_get_RequiresNew());
            return __return;
        }
    }
    // static field: System.Transactions.TransactionScopeOption Suppress
    /**
    The ambient transaction context is suppressed when creating the scope. All operations within the scope are done without an ambient transaction context.

    */
    public static var Suppress : dotnet.System.Transactions.TransactionScopeOption {
        get {
        let __return = dotnet.System.Transactions.TransactionScopeOption(val: System_Transactions_TransactionScopeOption_get_Suppress());
            return __return;
        }
    }
} // TransactionScopeOption


// type: System.Transactions.TransactionStartedEventHandler
    /**
    Represents the method that will handle the  event of a  class.

    */
public final class TransactionStartedEventHandler
    :
    dotnet.System.Delegate
{
    public class override func get_type_handle() -> TypeHandle {
        return System_Transactions_TransactionStartedEventHandler_get_type_handle();
    }
    public required init(hndl: NonnullHandle) { super.init(hndl: hndl); }
    public required init(gval: GVal) { super.init(gval: gval); }
    // void Invoke(System.Object, System.Transactions.TransactionEventArgs)
// docid: M:System.Transactions.TransactionStartedEventHandler.Invoke(System.Object,System.Transactions.TransactionEventArgs)
    public func Invoke(sender : Optional<dotnet.System.Object>, e : dotnet.System.Transactions.TransactionEventArgs) throws {
        var __thrown : NullableHandle = nil;
        System_Transactions_TransactionStartedEventHandler_void__Invoke_0__2__Object_TransactionEventArgs(&__thrown, self.get_handle(), sender?.get_handle() ?? nil, e.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
            return;
        }
    }
    // System.IAsyncResult BeginInvoke(System.Object, System.Transactions.TransactionEventArgs, System.AsyncCallback, System.Object)
// docid: M:System.Transactions.TransactionStartedEventHandler.BeginInvoke(System.Object,System.Transactions.TransactionEventArgs,System.AsyncCallback,System.Object)
    public func BeginInvoke(sender : Optional<dotnet.System.Object>, e : dotnet.System.Transactions.TransactionEventArgs, callback : Optional<dotnet.System.AsyncCallback>, object : Optional<dotnet.System.Object>) throws -> Optional<dotnet.System.IAsyncResult> {
        var __thrown : NullableHandle = nil;
        let __return = System_Transactions_TransactionStartedEventHandler_IAsyncResult__BeginInvoke_0__4__Object_TransactionEventArgs_AsyncCallback_Object(&__thrown, self.get_handle(), sender?.get_handle() ?? nil, e.get_handle(), callback?.get_handle() ?? nil, object?.get_handle() ?? nil);
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        if let __ret_unwrapped = __return {
            return dotnet.System.IAsyncResult(hndl : __ret_unwrapped);
        } else {
            return nil;
        }
        }
    }
    // void EndInvoke(System.IAsyncResult)
// docid: M:System.Transactions.TransactionStartedEventHandler.EndInvoke(System.IAsyncResult)
    public func EndInvoke(result : Optional<dotnet.System.IAsyncResult>) throws {
        var __thrown : NullableHandle = nil;
        System_Transactions_TransactionStartedEventHandler_void__EndInvoke_0__1__IAsyncResult(&__thrown, self.get_handle(), result?.get_handle() ?? nil);
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
            return;
        }
    }
    public init(_ callback : @escaping (Optional<dotnet.System.Object>, dotnet.System.Transactions.TransactionEventArgs) throws -> Void) throws
    {
        let __bridge : (UnsafeMutablePointer<NullableHandle>, NullableHandle, NonnullHandle) -> Void =
        {
            (thrown : UnsafeMutablePointer<NullableHandle>, sender : NullableHandle, e : NonnullHandle) -> Void in
            do
            {
                thrown.pointee = nil;
                try callback((sender != nil) ? (dotnet.System.Object(hndl: sender!)) : nil, dotnet.System.Transactions.TransactionEventArgs(hndl: e));
            }
            catch let e as dotnet.System.Exception
            {
                thrown.pointee = __copy_handle(e.get_handle());
            }
            catch
            {
                let e = try! dotnet.System.Exception(message: "TODO fail inside closure");
                thrown.pointee = __copy_handle(e.get_handle());
            }
        };
        let cbarg = UnsafeRawPointer(Unmanaged.passRetained(__bridge as AnyObject).toOpaque());
        func __cb(cb : UnsafeRawPointer?, thrown : UnsafeMutablePointer<NullableHandle>, sender : NullableHandle, e : NonnullHandle) -> Void
        {
            let f = Unmanaged<AnyObject>.fromOpaque(cb!).takeUnretainedValue() as! (UnsafeMutablePointer<NullableHandle>, NullableHandle, NonnullHandle) -> Void;
            f(thrown, sender, e);
        }
        var __thrown : NullableHandle = nil;
        let h = System_Transactions_TransactionStartedEventHandler_create(
            &__thrown,
            cbarg,
            nil, // TODO deinit
            __cb
            );
            // TODO check thrown
        if let __ex = __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
            super.init(hndl: h);
        }
    }
    // void Invoke(System.Object, System.Transactions.TransactionEventArgs)
// docid: M:System.Transactions.TransactionStartedEventHandler.Invoke(System.Object,System.Transactions.TransactionEventArgs)
    public func callAsFunction(sender : Optional<dotnet.System.Object>, e : dotnet.System.Transactions.TransactionEventArgs) throws {
        var __thrown : NullableHandle = nil;
        System_Transactions_TransactionStartedEventHandler_void__Invoke_0__2__Object_TransactionEventArgs(&__thrown, self.get_handle(), sender?.get_handle() ?? nil, e.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
            return;
        }
    }
} // TransactionStartedEventHandler


// type: System.Transactions.TransactionStatus
    /**
    Describes the current status of a distributed transaction.

    */
public struct TransactionStatus : SGBridgeGenericValue {
    let v : Swift.Int32;
    public init(val: Swift.Int32) { self.v = val; }
    public func get_value() -> Swift.Int32 { return self.v; }
    public static func get_type_handle() -> TypeHandle {
        return System_Transactions_TransactionStatus_get_type_handle();
    }
    public func to_gval() -> GVal { return GVal(self.v); }
    public func dup_gval() -> GVal { return to_gval(); }
    public init(gval: GVal) { self.v = Swift.Int32(gval); }
    // static field: System.Transactions.TransactionStatus Active
    /**
    The status of the transaction is unknown, because some participants must still be polled.

    */
    public static var Active : dotnet.System.Transactions.TransactionStatus {
        get {
        let __return = dotnet.System.Transactions.TransactionStatus(val: System_Transactions_TransactionStatus_get_Active());
            return __return;
        }
    }
    // static field: System.Transactions.TransactionStatus Committed
    /**
    The transaction has been committed.

    */
    public static var Committed : dotnet.System.Transactions.TransactionStatus {
        get {
        let __return = dotnet.System.Transactions.TransactionStatus(val: System_Transactions_TransactionStatus_get_Committed());
            return __return;
        }
    }
    // static field: System.Transactions.TransactionStatus Aborted
    /**
    The transaction has been rolled back.

    */
    public static var Aborted : dotnet.System.Transactions.TransactionStatus {
        get {
        let __return = dotnet.System.Transactions.TransactionStatus(val: System_Transactions_TransactionStatus_get_Aborted());
            return __return;
        }
    }
    // static field: System.Transactions.TransactionStatus InDoubt
    /**
    The status of the transaction is unknown.

    */
    public static var InDoubt : dotnet.System.Transactions.TransactionStatus {
        get {
        let __return = dotnet.System.Transactions.TransactionStatus(val: System_Transactions_TransactionStatus_get_InDoubt());
            return __return;
        }
    }
} // TransactionStatus


}


public protocol System_Transactions_IDtcTransaction
    :
    SGBridgeGetHandle
{
}

public protocol System_Transactions_IEnlistmentNotification
    :
    SGBridgeGetHandle
{
}

public protocol System_Transactions_IPromotableSinglePhaseNotification
    :
    System_Transactions_ITransactionPromoter
{
}

public protocol System_Transactions_ISimpleTransactionSuperior
    :
    System_Transactions_ITransactionPromoter
{
}

public protocol System_Transactions_ISinglePhaseNotification
    :
    System_Transactions_IEnlistmentNotification
{
}

public protocol System_Transactions_ITransactionPromoter
    :
    SGBridgeGetHandle
{
}

