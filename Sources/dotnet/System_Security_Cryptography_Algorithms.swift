// this file is automatically generated
// Copyright 2021 SourceGear

import jumptable_dotnet;

// System
// System.Security
// System.Security.Cryptography
extension System.Security.Cryptography {
// type: System.Security.Cryptography.Aes
    /**
    Represents the abstract base class from which all implementations of the Advanced Encryption Standard (AES) must inherit.

    */
open class Aes
    :
    dotnet.System.Security.Cryptography.SymmetricAlgorithm
{
    open class override func get_type_handle() -> TypeHandle {
        return System_Security_Cryptography_Aes_get_type_handle();
    }
    public required init(hndl: NonnullHandle) { super.init(hndl: hndl); }
    public required init(gval: GVal) { super.init(gval: gval); }
    // System.Security.Cryptography.Aes Create()
// docid: M:System.Security.Cryptography.Aes.Create
    /**
    Creates a cryptographic object that is used to perform the symmetric algorithm.

    - Returns: A cryptographic object that is used to perform the symmetric algorithm.

    */
    open class override func Create() throws -> dotnet.System.Security.Cryptography.Aes {
        var __thrown : NullableHandle = nil;
        let __return = System_Security_Cryptography_Aes_Aes__Create_0__0(&__thrown);
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return dotnet.System.Security.Cryptography.Aes(hndl : __return);
        }
    }
    // System.Security.Cryptography.Aes Create(System.String)
// docid: M:System.Security.Cryptography.Aes.Create(System.String)
    /**
    Creates a cryptographic object that specifies the implementation of AES to use to perform the symmetric algorithm.

    - Parameter algorithmName: The name of the specific implementation of AES to use.
    - Returns: A cryptographic object that is used to perform the symmetric algorithm.

    */
    open class func Create(algorithmName : dotnet.System.String) throws -> Optional<dotnet.System.Security.Cryptography.Aes> {
        var __thrown : NullableHandle = nil;
        let __return = System_Security_Cryptography_Aes_Aes__Create_0__1__String(&__thrown, algorithmName.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        if let __ret_unwrapped = __return {
            return dotnet.System.Security.Cryptography.Aes(hndl : __ret_unwrapped);
        } else {
            return nil;
        }
        }
    }
} // Aes


// type: System.Security.Cryptography.AesCcm
    /**
    Represents an Advanced Encryption Standard (AES) key to be used with the Counter with CBC-MAC (CCM) mode of operation.

    */
public final class AesCcm
    :
    dotnet.System.Object,
    System_IDisposable
{
    public class override func get_type_handle() -> TypeHandle {
        return System_Security_Cryptography_AesCcm_get_type_handle();
    }
    public required init(hndl: NonnullHandle) { super.init(hndl: hndl); }
    public required init(gval: GVal) { super.init(gval: gval); }
    // .ctor(System.Byte[])
// docid: M:System.Security.Cryptography.AesCcm.#ctor(System.Byte[])
    /**
    Initializes a new instance of the  class with a provided key.

    - Parameter key: The secret key to use for this instance.
    */
    public init(key : dotnet.System_Arr<Swift.UInt8>) throws {
        var __thrown : NullableHandle = nil;
        let h = System_Security_Cryptography_AesCcm_ctor_0__1__u8Array(&__thrown, key.get_handle());
        if let __ex = __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
            super.init(hndl: h);
        }
    }
// TODO COPE ctor (span) .ctor(System.ReadOnlySpan<System.Byte>)
    // void Decrypt(System.Byte[], System.Byte[], System.Byte[], System.Byte[], System.Byte[])
// docid: M:System.Security.Cryptography.AesCcm.Decrypt(System.Byte[],System.Byte[],System.Byte[],System.Byte[],System.Byte[])
    /**
    Decrypts the ciphertext into the provided destination buffer if the authentication tag can be validated.

    - Parameter nonce: The nonce associated with this message, which must match the value provided during encryption.
    - Parameter ciphertext: The encrypted content to decrypt.
    - Parameter tag: The authentication tag produced for this message during encryption.
    - Parameter plaintext: The byte array to receive the decrypted contents.
    - Parameter associatedData: Extra data associated with this message, which must match the value provided during encryption.
    */
    public func Decrypt(nonce : dotnet.System_Arr<Swift.UInt8>, ciphertext : dotnet.System_Arr<Swift.UInt8>, tag : dotnet.System_Arr<Swift.UInt8>, plaintext : dotnet.System_Arr<Swift.UInt8>, associatedData : Optional<dotnet.System_Arr<Swift.UInt8>> = nil) throws {
        var __thrown : NullableHandle = nil;
        System_Security_Cryptography_AesCcm_void__Decrypt_0__5__u8Array_u8Array_u8Array_u8Array_u8Array(&__thrown, self.get_handle(), nonce.get_handle(), ciphertext.get_handle(), tag.get_handle(), plaintext.get_handle(), (associatedData?.get_handle()));
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
            return;
        }
    }
// TODO COPE (write_all_methods) (span) void Decrypt(System.ReadOnlySpan<System.Byte>, System.ReadOnlySpan<System.Byte>, System.ReadOnlySpan<System.Byte>, System.Span<System.Byte>, System.ReadOnlySpan<System.Byte>)
    // void Dispose()
// docid: M:System.Security.Cryptography.AesCcm.Dispose
    /**
    Releases the resources used by the current instance of the  class.

    */
    public func Dispose() throws {
        var __thrown : NullableHandle = nil;
        System_Security_Cryptography_AesCcm_void__Dispose_0__0(&__thrown, self.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
            return;
        }
    }
    // void Encrypt(System.Byte[], System.Byte[], System.Byte[], System.Byte[], System.Byte[])
// docid: M:System.Security.Cryptography.AesCcm.Encrypt(System.Byte[],System.Byte[],System.Byte[],System.Byte[],System.Byte[])
    /**
    Encrypts the plaintext into the ciphertext destination buffer and generates the authentication tag into a separate buffer.

    - Parameter nonce: The nonce associated with this message, which should be a unique value for every operation with the same key.
    - Parameter plaintext: The content to encrypt.
    - Parameter ciphertext: The byte array to receive the encrypted contents.
    - Parameter tag: The byte array to receive the generated authentication tag.
    - Parameter associatedData: Extra data associated with this message, which must also be provided during decryption.
    */
    public func Encrypt(nonce : dotnet.System_Arr<Swift.UInt8>, plaintext : dotnet.System_Arr<Swift.UInt8>, ciphertext : dotnet.System_Arr<Swift.UInt8>, tag : dotnet.System_Arr<Swift.UInt8>, associatedData : Optional<dotnet.System_Arr<Swift.UInt8>> = nil) throws {
        var __thrown : NullableHandle = nil;
        System_Security_Cryptography_AesCcm_void__Encrypt_0__5__u8Array_u8Array_u8Array_u8Array_u8Array(&__thrown, self.get_handle(), nonce.get_handle(), plaintext.get_handle(), ciphertext.get_handle(), tag.get_handle(), (associatedData?.get_handle()));
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
            return;
        }
    }
// TODO COPE (write_all_methods) (span) void Encrypt(System.ReadOnlySpan<System.Byte>, System.ReadOnlySpan<System.Byte>, System.Span<System.Byte>, System.Span<System.Byte>, System.ReadOnlySpan<System.Byte>)
    // [IsSpecialName] bool get_IsSupported()
// docid: M:System.Security.Cryptography.AesCcm.get_IsSupported
    public class func get_IsSupported() throws -> Bool {
        var __thrown : NullableHandle = nil;
        let __return = System_Security_Cryptography_AesCcm_bool__get_IsSupported_0__0(&__thrown);
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return (__return) != 0;
        }
    }
    // [IsSpecialName] System.Security.Cryptography.KeySizes get_NonceByteSizes()
// docid: M:System.Security.Cryptography.AesCcm.get_NonceByteSizes
    public class func get_NonceByteSizes() throws -> dotnet.System.Security.Cryptography.KeySizes {
        var __thrown : NullableHandle = nil;
        let __return = System_Security_Cryptography_AesCcm_KeySizes__get_NonceByteSizes_0__0(&__thrown);
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return dotnet.System.Security.Cryptography.KeySizes(hndl : __return);
        }
    }
    // [IsSpecialName] System.Security.Cryptography.KeySizes get_TagByteSizes()
// docid: M:System.Security.Cryptography.AesCcm.get_TagByteSizes
    public class func get_TagByteSizes() throws -> dotnet.System.Security.Cryptography.KeySizes {
        var __thrown : NullableHandle = nil;
        let __return = System_Security_Cryptography_AesCcm_KeySizes__get_TagByteSizes_0__0(&__thrown);
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return dotnet.System.Security.Cryptography.KeySizes(hndl : __return);
        }
    }
    public static var IsSupported : Bool {
        get {
            return try! get_IsSupported();
        }
    }
    /**
    Gets the nonce sizes, in bytes, supported by this instance.

    */
    public static var NonceByteSizes : dotnet.System.Security.Cryptography.KeySizes {
        get {
            return try! get_NonceByteSizes();
        }
    }
    /**
    Gets the tag sizes, in bytes, supported by this instance.

    */
    public static var TagByteSizes : dotnet.System.Security.Cryptography.KeySizes {
        get {
            return try! get_TagByteSizes();
        }
    }
} // AesCcm


// type: System.Security.Cryptography.AesGcm
    /**
    Represents an Advanced Encryption Standard (AES) key to be used with the Galois/Counter Mode (GCM) mode of operation.

    */
public final class AesGcm
    :
    dotnet.System.Object,
    System_IDisposable
{
    public class override func get_type_handle() -> TypeHandle {
        return System_Security_Cryptography_AesGcm_get_type_handle();
    }
    public required init(hndl: NonnullHandle) { super.init(hndl: hndl); }
    public required init(gval: GVal) { super.init(gval: gval); }
    // .ctor(System.Byte[])
// docid: M:System.Security.Cryptography.AesGcm.#ctor(System.Byte[])
    /**
    Initializes a new instance of the  class with a provided key.

    - Parameter key: The secret key to use for this instance.
    */
    public init(key : dotnet.System_Arr<Swift.UInt8>) throws {
        var __thrown : NullableHandle = nil;
        let h = System_Security_Cryptography_AesGcm_ctor_0__1__u8Array(&__thrown, key.get_handle());
        if let __ex = __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
            super.init(hndl: h);
        }
    }
// TODO COPE ctor (span) .ctor(System.ReadOnlySpan<System.Byte>)
    // void Decrypt(System.Byte[], System.Byte[], System.Byte[], System.Byte[], System.Byte[])
// docid: M:System.Security.Cryptography.AesGcm.Decrypt(System.Byte[],System.Byte[],System.Byte[],System.Byte[],System.Byte[])
    /**
    Decrypts the ciphertext into the provided destination buffer if the authentication tag can be validated.

    - Parameter nonce: The nonce associated with this message, which must match the value provided during encryption.
    - Parameter ciphertext: The encrypted content to decrypt.
    - Parameter tag: The authentication tag produced for this message during encryption.
    - Parameter plaintext: The byte array to receive the decrypted contents.
    - Parameter associatedData: Extra data associated with this message, which must match the value provided during encryption.
    */
    public func Decrypt(nonce : dotnet.System_Arr<Swift.UInt8>, ciphertext : dotnet.System_Arr<Swift.UInt8>, tag : dotnet.System_Arr<Swift.UInt8>, plaintext : dotnet.System_Arr<Swift.UInt8>, associatedData : Optional<dotnet.System_Arr<Swift.UInt8>> = nil) throws {
        var __thrown : NullableHandle = nil;
        System_Security_Cryptography_AesGcm_void__Decrypt_0__5__u8Array_u8Array_u8Array_u8Array_u8Array(&__thrown, self.get_handle(), nonce.get_handle(), ciphertext.get_handle(), tag.get_handle(), plaintext.get_handle(), (associatedData?.get_handle()));
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
            return;
        }
    }
// TODO COPE (write_all_methods) (span) void Decrypt(System.ReadOnlySpan<System.Byte>, System.ReadOnlySpan<System.Byte>, System.ReadOnlySpan<System.Byte>, System.Span<System.Byte>, System.ReadOnlySpan<System.Byte>)
    // void Dispose()
// docid: M:System.Security.Cryptography.AesGcm.Dispose
    /**
    Releases the resources used by the current instance of the  class.

    */
    public func Dispose() throws {
        var __thrown : NullableHandle = nil;
        System_Security_Cryptography_AesGcm_void__Dispose_0__0(&__thrown, self.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
            return;
        }
    }
    // void Encrypt(System.Byte[], System.Byte[], System.Byte[], System.Byte[], System.Byte[])
// docid: M:System.Security.Cryptography.AesGcm.Encrypt(System.Byte[],System.Byte[],System.Byte[],System.Byte[],System.Byte[])
    /**
    Encrypts the plaintext into the ciphertext destination buffer and generates the authentication tag into a separate buffer.

    - Parameter nonce: The nonce associated with this message, which should be a unique value for every operation with the same key.
    - Parameter plaintext: The content to encrypt.
    - Parameter ciphertext: The byte array to receive the encrypted contents.
    - Parameter tag: The byte array to receive the generated authentication tag.
    - Parameter associatedData: Extra data associated with this message, which must also be provided during decryption.
    */
    public func Encrypt(nonce : dotnet.System_Arr<Swift.UInt8>, plaintext : dotnet.System_Arr<Swift.UInt8>, ciphertext : dotnet.System_Arr<Swift.UInt8>, tag : dotnet.System_Arr<Swift.UInt8>, associatedData : Optional<dotnet.System_Arr<Swift.UInt8>> = nil) throws {
        var __thrown : NullableHandle = nil;
        System_Security_Cryptography_AesGcm_void__Encrypt_0__5__u8Array_u8Array_u8Array_u8Array_u8Array(&__thrown, self.get_handle(), nonce.get_handle(), plaintext.get_handle(), ciphertext.get_handle(), tag.get_handle(), (associatedData?.get_handle()));
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
            return;
        }
    }
// TODO COPE (write_all_methods) (span) void Encrypt(System.ReadOnlySpan<System.Byte>, System.ReadOnlySpan<System.Byte>, System.Span<System.Byte>, System.Span<System.Byte>, System.ReadOnlySpan<System.Byte>)
    // [IsSpecialName] bool get_IsSupported()
// docid: M:System.Security.Cryptography.AesGcm.get_IsSupported
    public class func get_IsSupported() throws -> Bool {
        var __thrown : NullableHandle = nil;
        let __return = System_Security_Cryptography_AesGcm_bool__get_IsSupported_0__0(&__thrown);
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return (__return) != 0;
        }
    }
    // [IsSpecialName] System.Security.Cryptography.KeySizes get_NonceByteSizes()
// docid: M:System.Security.Cryptography.AesGcm.get_NonceByteSizes
    public class func get_NonceByteSizes() throws -> dotnet.System.Security.Cryptography.KeySizes {
        var __thrown : NullableHandle = nil;
        let __return = System_Security_Cryptography_AesGcm_KeySizes__get_NonceByteSizes_0__0(&__thrown);
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return dotnet.System.Security.Cryptography.KeySizes(hndl : __return);
        }
    }
    // [IsSpecialName] System.Security.Cryptography.KeySizes get_TagByteSizes()
// docid: M:System.Security.Cryptography.AesGcm.get_TagByteSizes
    public class func get_TagByteSizes() throws -> dotnet.System.Security.Cryptography.KeySizes {
        var __thrown : NullableHandle = nil;
        let __return = System_Security_Cryptography_AesGcm_KeySizes__get_TagByteSizes_0__0(&__thrown);
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return dotnet.System.Security.Cryptography.KeySizes(hndl : __return);
        }
    }
    public static var IsSupported : Bool {
        get {
            return try! get_IsSupported();
        }
    }
    /**
    Gets the nonce sizes, in bytes, supported by this instance.

    */
    public static var NonceByteSizes : dotnet.System.Security.Cryptography.KeySizes {
        get {
            return try! get_NonceByteSizes();
        }
    }
    /**
    Gets the tag sizes, in bytes, supported by this instance.

    */
    public static var TagByteSizes : dotnet.System.Security.Cryptography.KeySizes {
        get {
            return try! get_TagByteSizes();
        }
    }
} // AesGcm


// type: System.Security.Cryptography.AesManaged
    /**
    Provides a managed implementation of the Advanced Encryption Standard (AES) symmetric algorithm.

    */
public final class AesManaged
    :
    dotnet.System.Security.Cryptography.Aes
{
    public class override func get_type_handle() -> TypeHandle {
        return System_Security_Cryptography_AesManaged_get_type_handle();
    }
    public required init(hndl: NonnullHandle) { super.init(hndl: hndl); }
    public required init(gval: GVal) { super.init(gval: gval); }
    // .ctor()
// docid: M:System.Security.Cryptography.AesManaged.#ctor
    /**
    Initializes a new instance of the  class.

    */
    public init() throws {
        var __thrown : NullableHandle = nil;
        let h = System_Security_Cryptography_AesManaged_ctor_0__0(&__thrown);
        if let __ex = __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
            super.init(hndl: h);
        }
    }
    // System.Security.Cryptography.ICryptoTransform CreateDecryptor()
// docid: M:System.Security.Cryptography.AesManaged.CreateDecryptor
    /**
    Creates a symmetric decryptor object using the current key and initialization vector (IV).

    - Returns: A symmetric decryptor object.

    */
    public override func CreateDecryptor() throws -> dotnet.System.Security.Cryptography.ICryptoTransform {
        var __thrown : NullableHandle = nil;
        let __return = System_Security_Cryptography_AesManaged_ICryptoTransform__CreateDecryptor_0__0(&__thrown, self.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return dotnet.System.Security.Cryptography.ICryptoTransform(hndl : __return);
        }
    }
    // System.Security.Cryptography.ICryptoTransform CreateDecryptor(System.Byte[], System.Byte[])
// docid: M:System.Security.Cryptography.AesManaged.CreateDecryptor(System.Byte[],System.Byte[])
    /**
    Creates a symmetric decryptor object using the specified key and initialization vector (IV).

    - Parameter rgbKey: The secret key to use for the symmetric algorithm.
    - Parameter rgbIV: The initialization vector to use for the symmetric algorithm.
    - Returns: A symmetric decryptor object.

    */
    public override func CreateDecryptor(rgbKey : dotnet.System_Arr<Swift.UInt8>, rgbIV : Optional<dotnet.System_Arr<Swift.UInt8>>) throws -> dotnet.System.Security.Cryptography.ICryptoTransform {
        var __thrown : NullableHandle = nil;
        let __return = System_Security_Cryptography_AesManaged_ICryptoTransform__CreateDecryptor_0__2__u8Array_u8Array(&__thrown, self.get_handle(), rgbKey.get_handle(), (rgbIV?.get_handle()));
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return dotnet.System.Security.Cryptography.ICryptoTransform(hndl : __return);
        }
    }
    // System.Security.Cryptography.ICryptoTransform CreateEncryptor()
// docid: M:System.Security.Cryptography.AesManaged.CreateEncryptor
    /**
    Creates a symmetric encryptor object using the current key and initialization vector (IV).

    - Returns: A symmetric encryptor object.

    */
    public override func CreateEncryptor() throws -> dotnet.System.Security.Cryptography.ICryptoTransform {
        var __thrown : NullableHandle = nil;
        let __return = System_Security_Cryptography_AesManaged_ICryptoTransform__CreateEncryptor_0__0(&__thrown, self.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return dotnet.System.Security.Cryptography.ICryptoTransform(hndl : __return);
        }
    }
    // System.Security.Cryptography.ICryptoTransform CreateEncryptor(System.Byte[], System.Byte[])
// docid: M:System.Security.Cryptography.AesManaged.CreateEncryptor(System.Byte[],System.Byte[])
    /**
    Creates a symmetric encryptor object using the specified key and initialization vector (IV).

    - Parameter rgbKey: The secret key to use for the symmetric algorithm.
    - Parameter rgbIV: The initialization vector to use for the symmetric algorithm.
    - Returns: A symmetric encryptor object.

    */
    public override func CreateEncryptor(rgbKey : dotnet.System_Arr<Swift.UInt8>, rgbIV : Optional<dotnet.System_Arr<Swift.UInt8>>) throws -> dotnet.System.Security.Cryptography.ICryptoTransform {
        var __thrown : NullableHandle = nil;
        let __return = System_Security_Cryptography_AesManaged_ICryptoTransform__CreateEncryptor_0__2__u8Array_u8Array(&__thrown, self.get_handle(), rgbKey.get_handle(), (rgbIV?.get_handle()));
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return dotnet.System.Security.Cryptography.ICryptoTransform(hndl : __return);
        }
    }
    // void GenerateIV()
// docid: M:System.Security.Cryptography.AesManaged.GenerateIV
    /**
    Generates a random initialization vector (IV) to use for the symmetric algorithm.

    */
    public override func GenerateIV() throws {
        var __thrown : NullableHandle = nil;
        System_Security_Cryptography_AesManaged_void__GenerateIV_0__0(&__thrown, self.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
            return;
        }
    }
    // void GenerateKey()
// docid: M:System.Security.Cryptography.AesManaged.GenerateKey
    /**
    Generates a random key to use for the symmetric algorithm.

    */
    public override func GenerateKey() throws {
        var __thrown : NullableHandle = nil;
        System_Security_Cryptography_AesManaged_void__GenerateKey_0__0(&__thrown, self.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
            return;
        }
    }
    // [IsSpecialName] System.Int32 get_BlockSize()
// docid: M:System.Security.Cryptography.AesManaged.get_BlockSize
    public override func get_BlockSize() throws -> Swift.Int32 {
        var __thrown : NullableHandle = nil;
        let __return = System_Security_Cryptography_AesManaged_i32__get_BlockSize_0__0(&__thrown, self.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return __return;
        }
    }
    // [IsSpecialName] void set_BlockSize(System.Int32)
// docid: M:System.Security.Cryptography.AesManaged.set_BlockSize(System.Int32)
    public override func set_BlockSize(value : Swift.Int32) throws {
        var __thrown : NullableHandle = nil;
        System_Security_Cryptography_AesManaged_void__set_BlockSize_0__1__i32(&__thrown, self.get_handle(), value);
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
            return;
        }
    }
    // [IsSpecialName] System.Int32 get_FeedbackSize()
// docid: M:System.Security.Cryptography.AesManaged.get_FeedbackSize
    public override func get_FeedbackSize() throws -> Swift.Int32 {
        var __thrown : NullableHandle = nil;
        let __return = System_Security_Cryptography_AesManaged_i32__get_FeedbackSize_0__0(&__thrown, self.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return __return;
        }
    }
    // [IsSpecialName] void set_FeedbackSize(System.Int32)
// docid: M:System.Security.Cryptography.AesManaged.set_FeedbackSize(System.Int32)
    public override func set_FeedbackSize(value : Swift.Int32) throws {
        var __thrown : NullableHandle = nil;
        System_Security_Cryptography_AesManaged_void__set_FeedbackSize_0__1__i32(&__thrown, self.get_handle(), value);
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
            return;
        }
    }
    // [IsSpecialName] System.Byte[] get_IV()
// docid: M:System.Security.Cryptography.AesManaged.get_IV
    public override func get_IV() throws -> dotnet.System_Arr<Swift.UInt8> {
        var __thrown : NullableHandle = nil;
        let __return = System_Security_Cryptography_AesManaged_u8Array__get_IV_0__0(&__thrown, self.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return dotnet.System_Arr<Swift.UInt8>(hndl : __return);
        }
    }
    // [IsSpecialName] void set_IV(System.Byte[])
// docid: M:System.Security.Cryptography.AesManaged.set_IV(System.Byte[])
    public override func set_IV(value : dotnet.System_Arr<Swift.UInt8>) throws {
        var __thrown : NullableHandle = nil;
        System_Security_Cryptography_AesManaged_void__set_IV_0__1__u8Array(&__thrown, self.get_handle(), value.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
            return;
        }
    }
    // [IsSpecialName] System.Byte[] get_Key()
// docid: M:System.Security.Cryptography.AesManaged.get_Key
    public override func get_Key() throws -> dotnet.System_Arr<Swift.UInt8> {
        var __thrown : NullableHandle = nil;
        let __return = System_Security_Cryptography_AesManaged_u8Array__get_Key_0__0(&__thrown, self.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return dotnet.System_Arr<Swift.UInt8>(hndl : __return);
        }
    }
    // [IsSpecialName] void set_Key(System.Byte[])
// docid: M:System.Security.Cryptography.AesManaged.set_Key(System.Byte[])
    public override func set_Key(value : dotnet.System_Arr<Swift.UInt8>) throws {
        var __thrown : NullableHandle = nil;
        System_Security_Cryptography_AesManaged_void__set_Key_0__1__u8Array(&__thrown, self.get_handle(), value.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
            return;
        }
    }
    // [IsSpecialName] System.Int32 get_KeySize()
// docid: M:System.Security.Cryptography.AesManaged.get_KeySize
    public override func get_KeySize() throws -> Swift.Int32 {
        var __thrown : NullableHandle = nil;
        let __return = System_Security_Cryptography_AesManaged_i32__get_KeySize_0__0(&__thrown, self.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return __return;
        }
    }
    // [IsSpecialName] void set_KeySize(System.Int32)
// docid: M:System.Security.Cryptography.AesManaged.set_KeySize(System.Int32)
    public override func set_KeySize(value : Swift.Int32) throws {
        var __thrown : NullableHandle = nil;
        System_Security_Cryptography_AesManaged_void__set_KeySize_0__1__i32(&__thrown, self.get_handle(), value);
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
            return;
        }
    }
    // [IsSpecialName] System.Security.Cryptography.KeySizes[] get_LegalBlockSizes()
// docid: M:System.Security.Cryptography.AesManaged.get_LegalBlockSizes
    public override func get_LegalBlockSizes() throws -> dotnet.System_Arr<dotnet.System.Security.Cryptography.KeySizes> {
        var __thrown : NullableHandle = nil;
        let __return = System_Security_Cryptography_AesManaged_KeySizesArray__get_LegalBlockSizes_0__0(&__thrown, self.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return dotnet.System_Arr<dotnet.System.Security.Cryptography.KeySizes>(hndl : __return);
        }
    }
    // [IsSpecialName] System.Security.Cryptography.KeySizes[] get_LegalKeySizes()
// docid: M:System.Security.Cryptography.AesManaged.get_LegalKeySizes
    public override func get_LegalKeySizes() throws -> dotnet.System_Arr<dotnet.System.Security.Cryptography.KeySizes> {
        var __thrown : NullableHandle = nil;
        let __return = System_Security_Cryptography_AesManaged_KeySizesArray__get_LegalKeySizes_0__0(&__thrown, self.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return dotnet.System_Arr<dotnet.System.Security.Cryptography.KeySizes>(hndl : __return);
        }
    }
    // [IsSpecialName] System.Security.Cryptography.CipherMode get_Mode()
// docid: M:System.Security.Cryptography.AesManaged.get_Mode
    public override func get_Mode() throws -> dotnet.System.Security.Cryptography.CipherMode {
        var __thrown : NullableHandle = nil;
        let __return = System_Security_Cryptography_AesManaged_CipherMode__get_Mode_0__0(&__thrown, self.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return dotnet.System.Security.Cryptography.CipherMode(val: __return);
        }
    }
    // [IsSpecialName] void set_Mode(System.Security.Cryptography.CipherMode)
// docid: M:System.Security.Cryptography.AesManaged.set_Mode(System.Security.Cryptography.CipherMode)
    public override func set_Mode(value : dotnet.System.Security.Cryptography.CipherMode) throws {
        var __thrown : NullableHandle = nil;
        System_Security_Cryptography_AesManaged_void__set_Mode_0__1__CipherMode(&__thrown, self.get_handle(), value.get_value());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
            return;
        }
    }
    // [IsSpecialName] System.Security.Cryptography.PaddingMode get_Padding()
// docid: M:System.Security.Cryptography.AesManaged.get_Padding
    public override func get_Padding() throws -> dotnet.System.Security.Cryptography.PaddingMode {
        var __thrown : NullableHandle = nil;
        let __return = System_Security_Cryptography_AesManaged_PaddingMode__get_Padding_0__0(&__thrown, self.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return dotnet.System.Security.Cryptography.PaddingMode(val: __return);
        }
    }
    // [IsSpecialName] void set_Padding(System.Security.Cryptography.PaddingMode)
// docid: M:System.Security.Cryptography.AesManaged.set_Padding(System.Security.Cryptography.PaddingMode)
    public override func set_Padding(value : dotnet.System.Security.Cryptography.PaddingMode) throws {
        var __thrown : NullableHandle = nil;
        System_Security_Cryptography_AesManaged_void__set_Padding_0__1__PaddingMode(&__thrown, self.get_handle(), value.get_value());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
            return;
        }
    }
    /**
    Gets or sets the block size, in bits, of the cryptographic operation.

    */
    public override var BlockSize : Swift.Int32 {
        get {
            return try! get_BlockSize();
        }
        set(v) {
            return try! set_BlockSize(value: v);
        }
    }
    /**
    Gets or sets the number of bits to use as feedback.

    */
    public override var FeedbackSize : Swift.Int32 {
        get {
            return try! get_FeedbackSize();
        }
        set(v) {
            return try! set_FeedbackSize(value: v);
        }
    }
    /**
    Gets or sets the initialization vector (IV) to use for the symmetric algorithm.

    */
    public override var IV : dotnet.System_Arr<Swift.UInt8> {
        get {
            return try! get_IV();
        }
        set(v) {
            return try! set_IV(value: v);
        }
    }
    /**
    Gets or sets the secret key used for the symmetric algorithm.

    */
    public override var Key : dotnet.System_Arr<Swift.UInt8> {
        get {
            return try! get_Key();
        }
        set(v) {
            return try! set_Key(value: v);
        }
    }
    /**
    Gets or sets the size, in bits, of the secret key used for the symmetric algorithm.

    */
    public override var KeySize : Swift.Int32 {
        get {
            return try! get_KeySize();
        }
        set(v) {
            return try! set_KeySize(value: v);
        }
    }
    /**
    Gets the block sizes, in bits, that are supported by the symmetric algorithm.

    */
    public override var LegalBlockSizes : dotnet.System_Arr<dotnet.System.Security.Cryptography.KeySizes> {
        get {
            return try! get_LegalBlockSizes();
        }
    }
    /**
    Gets the key sizes, in bits, that are supported by the symmetric algorithm.

    */
    public override var LegalKeySizes : dotnet.System_Arr<dotnet.System.Security.Cryptography.KeySizes> {
        get {
            return try! get_LegalKeySizes();
        }
    }
    /**
    Gets or sets the mode for operation of the symmetric algorithm.

    */
    public override var Mode : dotnet.System.Security.Cryptography.CipherMode {
        get {
            return try! get_Mode();
        }
        set(v) {
            return try! set_Mode(value: v);
        }
    }
    /**
    Gets or sets the padding mode used in the symmetric algorithm.

    */
    public override var Padding : dotnet.System.Security.Cryptography.PaddingMode {
        get {
            return try! get_Padding();
        }
        set(v) {
            return try! set_Padding(value: v);
        }
    }
} // AesManaged


// type: System.Security.Cryptography.AsymmetricKeyExchangeDeformatter
    /**
    Represents the base class from which all asymmetric key exchange deformatters derive.

    */
open class AsymmetricKeyExchangeDeformatter
    :
    dotnet.System.Object
{
    open class override func get_type_handle() -> TypeHandle {
        return System_Security_Cryptography_AsymmetricKeyExchangeDeformatter_get_type_handle();
    }
    public required init(hndl: NonnullHandle) { super.init(hndl: hndl); }
    public required init(gval: GVal) { super.init(gval: gval); }
    // System.Byte[] DecryptKeyExchange(System.Byte[])
// docid: M:System.Security.Cryptography.AsymmetricKeyExchangeDeformatter.DecryptKeyExchange(System.Byte[])
    /**
    When overridden in a derived class, extracts secret information from the encrypted key exchange data.

    - Parameter rgb: The key exchange data within which the secret information is hidden.
    - Returns: The secret information derived from the key exchange data.

    */
    open func DecryptKeyExchange(rgb : dotnet.System_Arr<Swift.UInt8>) throws -> dotnet.System_Arr<Swift.UInt8> {
        var __thrown : NullableHandle = nil;
        let __return = System_Security_Cryptography_AsymmetricKeyExchangeDeformatter_u8Array__DecryptKeyExchange_0__1__u8Array(&__thrown, self.get_handle(), rgb.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return dotnet.System_Arr<Swift.UInt8>(hndl : __return);
        }
    }
    // void SetKey(System.Security.Cryptography.AsymmetricAlgorithm)
// docid: M:System.Security.Cryptography.AsymmetricKeyExchangeDeformatter.SetKey(System.Security.Cryptography.AsymmetricAlgorithm)
    /**
    When overridden in a derived class, sets the private key to use for decrypting the secret information.

    - Parameter key: The instance of the implementation of  that holds the private key.
    */
    open func SetKey(key : dotnet.System.Security.Cryptography.AsymmetricAlgorithm) throws {
        var __thrown : NullableHandle = nil;
        System_Security_Cryptography_AsymmetricKeyExchangeDeformatter_void__SetKey_0__1__AsymmetricAlgorithm(&__thrown, self.get_handle(), key.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
            return;
        }
    }
    // [IsSpecialName] System.String get_Parameters()
// docid: M:System.Security.Cryptography.AsymmetricKeyExchangeDeformatter.get_Parameters
    open func get_Parameters() throws -> Optional<dotnet.System.String> {
        var __thrown : NullableHandle = nil;
        let __return = System_Security_Cryptography_AsymmetricKeyExchangeDeformatter_String__get_Parameters_0__0(&__thrown, self.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        if let __ret_unwrapped = __return {
            return dotnet.System.String(hndl : __ret_unwrapped);
        } else {
            return nil;
        }
        }
    }
    // [IsSpecialName] void set_Parameters(System.String)
// docid: M:System.Security.Cryptography.AsymmetricKeyExchangeDeformatter.set_Parameters(System.String)
    open func set_Parameters(value : Optional<dotnet.System.String>) throws {
        var __thrown : NullableHandle = nil;
        System_Security_Cryptography_AsymmetricKeyExchangeDeformatter_void__set_Parameters_0__1__String(&__thrown, self.get_handle(), value?.get_handle() ?? nil);
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
            return;
        }
    }
    /**
    When overridden in a derived class, gets or sets the parameters for the asymmetric key exchange.

    */
    open var Parameters : Optional<dotnet.System.String> {
        get {
            return try! get_Parameters();
        }
        set(v) {
            return try! set_Parameters(value: v!);
        }
    }
} // AsymmetricKeyExchangeDeformatter


// type: System.Security.Cryptography.AsymmetricKeyExchangeFormatter
    /**
    Represents the base class from which all asymmetric key exchange formatters derive.

    */
open class AsymmetricKeyExchangeFormatter
    :
    dotnet.System.Object
{
    open class override func get_type_handle() -> TypeHandle {
        return System_Security_Cryptography_AsymmetricKeyExchangeFormatter_get_type_handle();
    }
    public required init(hndl: NonnullHandle) { super.init(hndl: hndl); }
    public required init(gval: GVal) { super.init(gval: gval); }
    // System.Byte[] CreateKeyExchange(System.Byte[])
// docid: M:System.Security.Cryptography.AsymmetricKeyExchangeFormatter.CreateKeyExchange(System.Byte[])
    /**
    When overridden in a derived class, creates the encrypted key exchange data from the specified input data.

    - Parameter data: The secret information to be passed in the key exchange.
    - Returns: The encrypted key exchange data to be sent to the intended recipient.

    */
    open func CreateKeyExchange(data : dotnet.System_Arr<Swift.UInt8>) throws -> dotnet.System_Arr<Swift.UInt8> {
        var __thrown : NullableHandle = nil;
        let __return = System_Security_Cryptography_AsymmetricKeyExchangeFormatter_u8Array__CreateKeyExchange_0__1__u8Array(&__thrown, self.get_handle(), data.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return dotnet.System_Arr<Swift.UInt8>(hndl : __return);
        }
    }
    // System.Byte[] CreateKeyExchange(System.Byte[], System.Type)
// docid: M:System.Security.Cryptography.AsymmetricKeyExchangeFormatter.CreateKeyExchange(System.Byte[],System.Type)
    /**
    When overridden in a derived class, creates the encrypted key exchange data from the specified input data.

    - Parameter data: The secret information to be passed in the key exchange.
    - Parameter symAlgType: This parameter is not used in the current version.
    - Returns: The encrypted key exchange data to be sent to the intended recipient.

    */
    open func CreateKeyExchange(data : dotnet.System_Arr<Swift.UInt8>, symAlgType : Optional<dotnet.System.Type_>) throws -> dotnet.System_Arr<Swift.UInt8> {
        var __thrown : NullableHandle = nil;
        let __return = System_Security_Cryptography_AsymmetricKeyExchangeFormatter_u8Array__CreateKeyExchange_0__2__u8Array_Type(&__thrown, self.get_handle(), data.get_handle(), symAlgType?.get_handle() ?? nil);
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return dotnet.System_Arr<Swift.UInt8>(hndl : __return);
        }
    }
    // void SetKey(System.Security.Cryptography.AsymmetricAlgorithm)
// docid: M:System.Security.Cryptography.AsymmetricKeyExchangeFormatter.SetKey(System.Security.Cryptography.AsymmetricAlgorithm)
    /**
    When overridden in a derived class, sets the public key to use for encrypting the secret information.

    - Parameter key: The instance of the implementation of  that holds the public key.
    */
    open func SetKey(key : dotnet.System.Security.Cryptography.AsymmetricAlgorithm) throws {
        var __thrown : NullableHandle = nil;
        System_Security_Cryptography_AsymmetricKeyExchangeFormatter_void__SetKey_0__1__AsymmetricAlgorithm(&__thrown, self.get_handle(), key.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
            return;
        }
    }
    // [IsSpecialName] System.String get_Parameters()
// docid: M:System.Security.Cryptography.AsymmetricKeyExchangeFormatter.get_Parameters
    open func get_Parameters() throws -> Optional<dotnet.System.String> {
        var __thrown : NullableHandle = nil;
        let __return = System_Security_Cryptography_AsymmetricKeyExchangeFormatter_String__get_Parameters_0__0(&__thrown, self.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        if let __ret_unwrapped = __return {
            return dotnet.System.String(hndl : __ret_unwrapped);
        } else {
            return nil;
        }
        }
    }
    /**
    When overridden in a derived class, gets the parameters for the asymmetric key exchange.

    */
    open var Parameters : Optional<dotnet.System.String> {
        get {
            return try! get_Parameters();
        }
    }
} // AsymmetricKeyExchangeFormatter


// type: System.Security.Cryptography.AsymmetricSignatureDeformatter
    /**
    Represents the abstract base class from which all implementations of asymmetric signature deformatters derive.

    */
open class AsymmetricSignatureDeformatter
    :
    dotnet.System.Object
{
    open class override func get_type_handle() -> TypeHandle {
        return System_Security_Cryptography_AsymmetricSignatureDeformatter_get_type_handle();
    }
    public required init(hndl: NonnullHandle) { super.init(hndl: hndl); }
    public required init(gval: GVal) { super.init(gval: gval); }
    // void SetHashAlgorithm(System.String)
// docid: M:System.Security.Cryptography.AsymmetricSignatureDeformatter.SetHashAlgorithm(System.String)
    /**
    When overridden in a derived class, sets the hash algorithm to use for verifying the signature.

    - Parameter strName: The name of the hash algorithm to use for verifying the signature.
    */
    open func SetHashAlgorithm(strName : dotnet.System.String) throws {
        var __thrown : NullableHandle = nil;
        System_Security_Cryptography_AsymmetricSignatureDeformatter_void__SetHashAlgorithm_0__1__String(&__thrown, self.get_handle(), strName.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
            return;
        }
    }
    // void SetKey(System.Security.Cryptography.AsymmetricAlgorithm)
// docid: M:System.Security.Cryptography.AsymmetricSignatureDeformatter.SetKey(System.Security.Cryptography.AsymmetricAlgorithm)
    /**
    When overridden in a derived class, sets the public key to use for verifying the signature.

    - Parameter key: The instance of an implementation of  that holds the public key.
    */
    open func SetKey(key : dotnet.System.Security.Cryptography.AsymmetricAlgorithm) throws {
        var __thrown : NullableHandle = nil;
        System_Security_Cryptography_AsymmetricSignatureDeformatter_void__SetKey_0__1__AsymmetricAlgorithm(&__thrown, self.get_handle(), key.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
            return;
        }
    }
    // bool VerifySignature(System.Byte[], System.Byte[])
// docid: M:System.Security.Cryptography.AsymmetricSignatureDeformatter.VerifySignature(System.Byte[],System.Byte[])
    /**
    When overridden in a derived class, verifies the signature for the specified data.

    - Parameter rgbHash: The data signed with .
    - Parameter rgbSignature: The signature to be verified for .
    - Returns: 
         if  matches the signature computed using the specified hash algorithm and key on ; otherwise, .

    */
    open func VerifySignature(rgbHash : dotnet.System_Arr<Swift.UInt8>, rgbSignature : dotnet.System_Arr<Swift.UInt8>) throws -> Bool {
        var __thrown : NullableHandle = nil;
        let __return = System_Security_Cryptography_AsymmetricSignatureDeformatter_bool__VerifySignature_0__2__u8Array_u8Array(&__thrown, self.get_handle(), rgbHash.get_handle(), rgbSignature.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return (__return) != 0;
        }
    }
    // bool VerifySignature(System.Security.Cryptography.HashAlgorithm, System.Byte[])
// docid: M:System.Security.Cryptography.AsymmetricSignatureDeformatter.VerifySignature(System.Security.Cryptography.HashAlgorithm,System.Byte[])
    /**
    Verifies the signature from the specified hash value.

    - Parameter hash: The hash algorithm to use to verify the signature.
    - Parameter rgbSignature: The signature to be verified.
    - Returns: 
         if the signature is valid for the hash; otherwise, .

    */
    open func VerifySignature(hash : dotnet.System.Security.Cryptography.HashAlgorithm, rgbSignature : dotnet.System_Arr<Swift.UInt8>) throws -> Bool {
        var __thrown : NullableHandle = nil;
        let __return = System_Security_Cryptography_AsymmetricSignatureDeformatter_bool__VerifySignature_0__2__HashAlgorithm_u8Array(&__thrown, self.get_handle(), hash.get_handle(), rgbSignature.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return (__return) != 0;
        }
    }
} // AsymmetricSignatureDeformatter


// type: System.Security.Cryptography.AsymmetricSignatureFormatter
    /**
    Represents the base class from which all implementations of asymmetric signature formatters derive.

    */
open class AsymmetricSignatureFormatter
    :
    dotnet.System.Object
{
    open class override func get_type_handle() -> TypeHandle {
        return System_Security_Cryptography_AsymmetricSignatureFormatter_get_type_handle();
    }
    public required init(hndl: NonnullHandle) { super.init(hndl: hndl); }
    public required init(gval: GVal) { super.init(gval: gval); }
    // System.Byte[] CreateSignature(System.Byte[])
// docid: M:System.Security.Cryptography.AsymmetricSignatureFormatter.CreateSignature(System.Byte[])
    /**
    When overridden in a derived class, creates the signature for the specified data.

    - Parameter rgbHash: The data to be signed.
    - Returns: The digital signature for the  parameter.

    */
    open func CreateSignature(rgbHash : dotnet.System_Arr<Swift.UInt8>) throws -> dotnet.System_Arr<Swift.UInt8> {
        var __thrown : NullableHandle = nil;
        let __return = System_Security_Cryptography_AsymmetricSignatureFormatter_u8Array__CreateSignature_0__1__u8Array(&__thrown, self.get_handle(), rgbHash.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return dotnet.System_Arr<Swift.UInt8>(hndl : __return);
        }
    }
    // System.Byte[] CreateSignature(System.Security.Cryptography.HashAlgorithm)
// docid: M:System.Security.Cryptography.AsymmetricSignatureFormatter.CreateSignature(System.Security.Cryptography.HashAlgorithm)
    /**
    Creates the signature from the specified hash value.

    - Parameter hash: The hash algorithm to use to create the signature.
    - Returns: The signature for the specified hash value.

    */
    open func CreateSignature(hash : dotnet.System.Security.Cryptography.HashAlgorithm) throws -> dotnet.System_Arr<Swift.UInt8> {
        var __thrown : NullableHandle = nil;
        let __return = System_Security_Cryptography_AsymmetricSignatureFormatter_u8Array__CreateSignature_0__1__HashAlgorithm(&__thrown, self.get_handle(), hash.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return dotnet.System_Arr<Swift.UInt8>(hndl : __return);
        }
    }
    // void SetHashAlgorithm(System.String)
// docid: M:System.Security.Cryptography.AsymmetricSignatureFormatter.SetHashAlgorithm(System.String)
    /**
    When overridden in a derived class, sets the hash algorithm to use for creating the signature.

    - Parameter strName: The name of the hash algorithm to use for creating the signature.
    */
    open func SetHashAlgorithm(strName : dotnet.System.String) throws {
        var __thrown : NullableHandle = nil;
        System_Security_Cryptography_AsymmetricSignatureFormatter_void__SetHashAlgorithm_0__1__String(&__thrown, self.get_handle(), strName.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
            return;
        }
    }
    // void SetKey(System.Security.Cryptography.AsymmetricAlgorithm)
// docid: M:System.Security.Cryptography.AsymmetricSignatureFormatter.SetKey(System.Security.Cryptography.AsymmetricAlgorithm)
    /**
    When overridden in a derived class, sets the asymmetric algorithm to use to create the signature.

    - Parameter key: The instance of the implementation of  to use to create the signature.
    */
    open func SetKey(key : dotnet.System.Security.Cryptography.AsymmetricAlgorithm) throws {
        var __thrown : NullableHandle = nil;
        System_Security_Cryptography_AsymmetricSignatureFormatter_void__SetKey_0__1__AsymmetricAlgorithm(&__thrown, self.get_handle(), key.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
            return;
        }
    }
} // AsymmetricSignatureFormatter


// type: System.Security.Cryptography.ChaCha20Poly1305
public final class ChaCha20Poly1305
    :
    dotnet.System.Object,
    System_IDisposable
{
    public class override func get_type_handle() -> TypeHandle {
        return System_Security_Cryptography_ChaCha20Poly1305_get_type_handle();
    }
    public required init(hndl: NonnullHandle) { super.init(hndl: hndl); }
    public required init(gval: GVal) { super.init(gval: gval); }
    // .ctor(System.Byte[])
// docid: M:System.Security.Cryptography.ChaCha20Poly1305.#ctor(System.Byte[])
    public init(key : dotnet.System_Arr<Swift.UInt8>) throws {
        var __thrown : NullableHandle = nil;
        let h = System_Security_Cryptography_ChaCha20Poly1305_ctor_0__1__u8Array(&__thrown, key.get_handle());
        if let __ex = __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
            super.init(hndl: h);
        }
    }
// TODO COPE ctor (span) .ctor(System.ReadOnlySpan<System.Byte>)
    // void Decrypt(System.Byte[], System.Byte[], System.Byte[], System.Byte[], System.Byte[])
// docid: M:System.Security.Cryptography.ChaCha20Poly1305.Decrypt(System.Byte[],System.Byte[],System.Byte[],System.Byte[],System.Byte[])
    public func Decrypt(nonce : dotnet.System_Arr<Swift.UInt8>, ciphertext : dotnet.System_Arr<Swift.UInt8>, tag : dotnet.System_Arr<Swift.UInt8>, plaintext : dotnet.System_Arr<Swift.UInt8>, associatedData : Optional<dotnet.System_Arr<Swift.UInt8>> = nil) throws {
        var __thrown : NullableHandle = nil;
        System_Security_Cryptography_ChaCha20Poly1305_void__Decrypt_0__5__u8Array_u8Array_u8Array_u8Array_u8Array(&__thrown, self.get_handle(), nonce.get_handle(), ciphertext.get_handle(), tag.get_handle(), plaintext.get_handle(), (associatedData?.get_handle()));
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
            return;
        }
    }
// TODO COPE (write_all_methods) (span) void Decrypt(System.ReadOnlySpan<System.Byte>, System.ReadOnlySpan<System.Byte>, System.ReadOnlySpan<System.Byte>, System.Span<System.Byte>, System.ReadOnlySpan<System.Byte>)
    // void Dispose()
// docid: M:System.Security.Cryptography.ChaCha20Poly1305.Dispose
    public func Dispose() throws {
        var __thrown : NullableHandle = nil;
        System_Security_Cryptography_ChaCha20Poly1305_void__Dispose_0__0(&__thrown, self.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
            return;
        }
    }
    // void Encrypt(System.Byte[], System.Byte[], System.Byte[], System.Byte[], System.Byte[])
// docid: M:System.Security.Cryptography.ChaCha20Poly1305.Encrypt(System.Byte[],System.Byte[],System.Byte[],System.Byte[],System.Byte[])
    public func Encrypt(nonce : dotnet.System_Arr<Swift.UInt8>, plaintext : dotnet.System_Arr<Swift.UInt8>, ciphertext : dotnet.System_Arr<Swift.UInt8>, tag : dotnet.System_Arr<Swift.UInt8>, associatedData : Optional<dotnet.System_Arr<Swift.UInt8>> = nil) throws {
        var __thrown : NullableHandle = nil;
        System_Security_Cryptography_ChaCha20Poly1305_void__Encrypt_0__5__u8Array_u8Array_u8Array_u8Array_u8Array(&__thrown, self.get_handle(), nonce.get_handle(), plaintext.get_handle(), ciphertext.get_handle(), tag.get_handle(), (associatedData?.get_handle()));
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
            return;
        }
    }
// TODO COPE (write_all_methods) (span) void Encrypt(System.ReadOnlySpan<System.Byte>, System.ReadOnlySpan<System.Byte>, System.Span<System.Byte>, System.Span<System.Byte>, System.ReadOnlySpan<System.Byte>)
    // [IsSpecialName] bool get_IsSupported()
// docid: M:System.Security.Cryptography.ChaCha20Poly1305.get_IsSupported
    public class func get_IsSupported() throws -> Bool {
        var __thrown : NullableHandle = nil;
        let __return = System_Security_Cryptography_ChaCha20Poly1305_bool__get_IsSupported_0__0(&__thrown);
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return (__return) != 0;
        }
    }
    public static var IsSupported : Bool {
        get {
            return try! get_IsSupported();
        }
    }
} // ChaCha20Poly1305


// type: System.Security.Cryptography.CryptoConfig
    /**
    Accesses the cryptography configuration information.

    */
open class CryptoConfig
    :
    dotnet.System.Object
{
    open class override func get_type_handle() -> TypeHandle {
        return System_Security_Cryptography_CryptoConfig_get_type_handle();
    }
    public required init(hndl: NonnullHandle) { super.init(hndl: hndl); }
    public required init(gval: GVal) { super.init(gval: gval); }
    // .ctor()
// docid: M:System.Security.Cryptography.CryptoConfig.#ctor
    /**
    Initializes a new instance of the  class.

    */
    public override init() throws {
        var __thrown : NullableHandle = nil;
        let h = System_Security_Cryptography_CryptoConfig_ctor_0__0(&__thrown);
        if let __ex = __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
            super.init(hndl: h);
        }
    }
    // void AddAlgorithm(System.Type, System.String[])
// docid: M:System.Security.Cryptography.CryptoConfig.AddAlgorithm(System.Type,System.String[])
    /**
    Adds a set of names to algorithm mappings to be used for the current application domain.

    - Parameter algorithm: The algorithm to map to.
    - Parameter names: An array of names to map to the algorithm.
    */
    open class func AddAlgorithm(algorithm : dotnet.System.Type_, names : dotnet.System_Arr<dotnet.System.String>) throws {
        var __thrown : NullableHandle = nil;
        System_Security_Cryptography_CryptoConfig_void__AddAlgorithm_0__2__Type_StringArray(&__thrown, algorithm.get_handle(), names.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
            return;
        }
    }
    // void AddOID(System.String, System.String[])
// docid: M:System.Security.Cryptography.CryptoConfig.AddOID(System.String,System.String[])
    /**
    Adds a set of names to object identifier (OID) mappings to be used for the current application domain.

    - Parameter oid: The object identifier (OID) to map to.
    - Parameter names: An array of names to map to the OID.
    */
    open class func AddOID(oid : dotnet.System.String, names : dotnet.System_Arr<dotnet.System.String>) throws {
        var __thrown : NullableHandle = nil;
        System_Security_Cryptography_CryptoConfig_void__AddOID_0__2__String_StringArray(&__thrown, oid.get_handle(), names.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
            return;
        }
    }
    // System.Object CreateFromName(System.String)
// docid: M:System.Security.Cryptography.CryptoConfig.CreateFromName(System.String)
    /**
    Creates a new instance of the specified cryptographic object.

    - Parameter name: The simple name of the cryptographic object of which to create an instance.
    - Returns: A new instance of the specified cryptographic object.

    */
    open class func CreateFromName(name : dotnet.System.String) throws -> Optional<dotnet.System.Object> {
        var __thrown : NullableHandle = nil;
        let __return = System_Security_Cryptography_CryptoConfig_Object__CreateFromName_0__1__String(&__thrown, name.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        if let __ret_unwrapped = __return {
            return dotnet.System.Object(hndl : __ret_unwrapped);
        } else {
            return nil;
        }
        }
    }
    // System.Object CreateFromName(System.String, System.Object[])
// docid: M:System.Security.Cryptography.CryptoConfig.CreateFromName(System.String,System.Object[])
    /**
    Creates a new instance of the specified cryptographic object with the specified arguments.

    - Parameter name: The simple name of the cryptographic object of which to create an instance.
    - Parameter args: The arguments used to create the specified cryptographic object.
    - Returns: A new instance of the specified cryptographic object.

    */
    open class func CreateFromName(name : dotnet.System.String, args : Optional<dotnet.System_Arr<dotnet.System.Object>>) throws -> Optional<dotnet.System.Object> {
        var __thrown : NullableHandle = nil;
        let __return = System_Security_Cryptography_CryptoConfig_Object__CreateFromName_0__2__String_ObjectArray(&__thrown, name.get_handle(), (args?.get_handle()));
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        if let __ret_unwrapped = __return {
            return dotnet.System.Object(hndl : __ret_unwrapped);
        } else {
            return nil;
        }
        }
    }
    // System.Byte[] EncodeOID(System.String)
// docid: M:System.Security.Cryptography.CryptoConfig.EncodeOID(System.String)
    /**
    Encodes the specified object identifier (OID).

    - Parameter str: The OID to encode.
    - Returns: A byte array containing the encoded OID.

    */
    open class func EncodeOID(str : dotnet.System.String) throws -> dotnet.System_Arr<Swift.UInt8> {
        var __thrown : NullableHandle = nil;
        let __return = System_Security_Cryptography_CryptoConfig_u8Array__EncodeOID_0__1__String(&__thrown, str.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return dotnet.System_Arr<Swift.UInt8>(hndl : __return);
        }
    }
    // System.String MapNameToOID(System.String)
// docid: M:System.Security.Cryptography.CryptoConfig.MapNameToOID(System.String)
    /**
    Gets the object identifier (OID) of the algorithm corresponding to the specified simple name.

    - Parameter name: The simple name of the algorithm for which to get the OID.
    - Returns: The OID of the specified algorithm.

    */
    open class func MapNameToOID(name : dotnet.System.String) throws -> Optional<dotnet.System.String> {
        var __thrown : NullableHandle = nil;
        let __return = System_Security_Cryptography_CryptoConfig_String__MapNameToOID_0__1__String(&__thrown, name.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        if let __ret_unwrapped = __return {
            return dotnet.System.String(hndl : __ret_unwrapped);
        } else {
            return nil;
        }
        }
    }
    // [IsSpecialName] bool get_AllowOnlyFipsAlgorithms()
// docid: M:System.Security.Cryptography.CryptoConfig.get_AllowOnlyFipsAlgorithms
    open class func get_AllowOnlyFipsAlgorithms() throws -> Bool {
        var __thrown : NullableHandle = nil;
        let __return = System_Security_Cryptography_CryptoConfig_bool__get_AllowOnlyFipsAlgorithms_0__0(&__thrown);
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return (__return) != 0;
        }
    }
    /**
    Indicates whether the runtime should enforce the policy to create only Federal Information Processing Standard (FIPS) certified algorithms.

    */
    public static var AllowOnlyFipsAlgorithms : Bool {
        get {
            return try! get_AllowOnlyFipsAlgorithms();
        }
    }
} // CryptoConfig


// type: System.Security.Cryptography.DES
    /**
    Represents the base class for the Data Encryption Standard (DES) algorithm from which all  implementations must derive.

    */
open class DES
    :
    dotnet.System.Security.Cryptography.SymmetricAlgorithm
{
    open class override func get_type_handle() -> TypeHandle {
        return System_Security_Cryptography_DES_get_type_handle();
    }
    public required init(hndl: NonnullHandle) { super.init(hndl: hndl); }
    public required init(gval: GVal) { super.init(gval: gval); }
    // System.Security.Cryptography.DES Create()
// docid: M:System.Security.Cryptography.DES.Create
    /**
    Creates an instance of a cryptographic object to perform the Data Encryption Standard () algorithm.

    - Returns: A cryptographic object.

    */
    open class override func Create() throws -> dotnet.System.Security.Cryptography.DES {
        var __thrown : NullableHandle = nil;
        let __return = System_Security_Cryptography_DES_DES__Create_0__0(&__thrown);
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return dotnet.System.Security.Cryptography.DES(hndl : __return);
        }
    }
    // System.Security.Cryptography.DES Create(System.String)
// docid: M:System.Security.Cryptography.DES.Create(System.String)
    /**
    Creates an instance of a cryptographic object to perform the specified implementation of the Data Encryption Standard () algorithm.

    - Parameter algName: The name of the specific implementation of  to use.
    - Returns: A cryptographic object.

    */
    open class override func Create(algName : dotnet.System.String) throws -> Optional<dotnet.System.Security.Cryptography.DES> {
        var __thrown : NullableHandle = nil;
        let __return = System_Security_Cryptography_DES_DES__Create_0__1__String(&__thrown, algName.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        if let __ret_unwrapped = __return {
            return dotnet.System.Security.Cryptography.DES(hndl : __ret_unwrapped);
        } else {
            return nil;
        }
        }
    }
    // bool IsSemiWeakKey(System.Byte[])
// docid: M:System.Security.Cryptography.DES.IsSemiWeakKey(System.Byte[])
    /**
    Determines whether the specified key is semi-weak.

    - Parameter rgbKey: The secret key to test for semi-weakness.
    - Returns: 
         if the key is semi-weak; otherwise, .

    */
    open class func IsSemiWeakKey(rgbKey : dotnet.System_Arr<Swift.UInt8>) throws -> Bool {
        var __thrown : NullableHandle = nil;
        let __return = System_Security_Cryptography_DES_bool__IsSemiWeakKey_0__1__u8Array(&__thrown, rgbKey.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return (__return) != 0;
        }
    }
    // bool IsWeakKey(System.Byte[])
// docid: M:System.Security.Cryptography.DES.IsWeakKey(System.Byte[])
    /**
    Determines whether the specified key is weak.

    - Parameter rgbKey: The secret key to test for weakness.
    - Returns: 
         if the key is weak; otherwise, .

    */
    open class func IsWeakKey(rgbKey : dotnet.System_Arr<Swift.UInt8>) throws -> Bool {
        var __thrown : NullableHandle = nil;
        let __return = System_Security_Cryptography_DES_bool__IsWeakKey_0__1__u8Array(&__thrown, rgbKey.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return (__return) != 0;
        }
    }
    // [IsSpecialName] System.Byte[] get_Key()
// docid: M:System.Security.Cryptography.DES.get_Key
    open override func get_Key() throws -> dotnet.System_Arr<Swift.UInt8> {
        var __thrown : NullableHandle = nil;
        let __return = System_Security_Cryptography_DES_u8Array__get_Key_0__0(&__thrown, self.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return dotnet.System_Arr<Swift.UInt8>(hndl : __return);
        }
    }
    // [IsSpecialName] void set_Key(System.Byte[])
// docid: M:System.Security.Cryptography.DES.set_Key(System.Byte[])
    open override func set_Key(value : dotnet.System_Arr<Swift.UInt8>) throws {
        var __thrown : NullableHandle = nil;
        System_Security_Cryptography_DES_void__set_Key_0__1__u8Array(&__thrown, self.get_handle(), value.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
            return;
        }
    }
    /**
    Gets or sets the secret key for the Data Encryption Standard () algorithm.

    */
    open override var Key : dotnet.System_Arr<Swift.UInt8> {
        get {
            return try! get_Key();
        }
        set(v) {
            return try! set_Key(value: v);
        }
    }
} // DES


// type: System.Security.Cryptography.DSA
    /**
    Represents the abstract base class from which all implementations of the Digital Signature Algorithm () must inherit.

    */
open class DSA
    :
    dotnet.System.Security.Cryptography.AsymmetricAlgorithm
{
    open class override func get_type_handle() -> TypeHandle {
        return System_Security_Cryptography_DSA_get_type_handle();
    }
    public required init(hndl: NonnullHandle) { super.init(hndl: hndl); }
    public required init(gval: GVal) { super.init(gval: gval); }
    // System.Security.Cryptography.DSA Create()
// docid: M:System.Security.Cryptography.DSA.Create
    /**
    Creates the default cryptographic object used to perform the asymmetric algorithm.

    - Returns: A cryptographic object used to perform the asymmetric algorithm.

    */
    open class override func Create() throws -> dotnet.System.Security.Cryptography.DSA {
        var __thrown : NullableHandle = nil;
        let __return = System_Security_Cryptography_DSA_DSA__Create_0__0(&__thrown);
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return dotnet.System.Security.Cryptography.DSA(hndl : __return);
        }
    }
    // System.Security.Cryptography.DSA Create(System.Int32)
// docid: M:System.Security.Cryptography.DSA.Create(System.Int32)
    /**
    Creates a new ephemeral DSA key with the specified key size.

    - Parameter keySizeInBits: The key size, in bits.
    - Returns: A new ephemeral DSA key with the specified key size.

    */
    open class func Create(keySizeInBits : Swift.Int32) throws -> dotnet.System.Security.Cryptography.DSA {
        var __thrown : NullableHandle = nil;
        let __return = System_Security_Cryptography_DSA_DSA__Create_0__1__i32(&__thrown, keySizeInBits);
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return dotnet.System.Security.Cryptography.DSA(hndl : __return);
        }
    }
    // System.Security.Cryptography.DSA Create(System.Security.Cryptography.DSAParameters)
// docid: M:System.Security.Cryptography.DSA.Create(System.Security.Cryptography.DSAParameters)
    /**
    Creates a new ephemeral DSA key with the specified DSA key parameters.

    - Parameter parameters: The parameters for the  algorithm.
    - Returns: A new ephemeral DSA key.

    */
    open class func Create(parameters : dotnet.System.Security.Cryptography.DSAParameters) throws -> dotnet.System.Security.Cryptography.DSA {
        var __thrown : NullableHandle = nil;
        let __return = System_Security_Cryptography_DSA_DSA__Create_0__1__DSAParameters(&__thrown, parameters.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return dotnet.System.Security.Cryptography.DSA(hndl : __return);
        }
    }
    // System.Security.Cryptography.DSA Create(System.String)
// docid: M:System.Security.Cryptography.DSA.Create(System.String)
    /**
    Creates the specified cryptographic object used to perform the asymmetric algorithm.

    - Parameter algName: The name of the specific implementation of  to use.
    - Returns: A cryptographic object used to perform the asymmetric algorithm.

    */
    open class override func Create(algName : dotnet.System.String) throws -> Optional<dotnet.System.Security.Cryptography.DSA> {
        var __thrown : NullableHandle = nil;
        let __return = System_Security_Cryptography_DSA_DSA__Create_0__1__String(&__thrown, algName.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        if let __ret_unwrapped = __return {
            return dotnet.System.Security.Cryptography.DSA(hndl : __ret_unwrapped);
        } else {
            return nil;
        }
        }
    }
    // System.Byte[] CreateSignature(System.Byte[])
// docid: M:System.Security.Cryptography.DSA.CreateSignature(System.Byte[])
    /**
    When overridden in a derived class, creates the  signature for the specified hash value.

    - Parameter rgbHash: The hash value to be signed.
    - Returns: The digital signature for the specified hash value.

    */
    open func CreateSignature(rgbHash : dotnet.System_Arr<Swift.UInt8>) throws -> dotnet.System_Arr<Swift.UInt8> {
        var __thrown : NullableHandle = nil;
        let __return = System_Security_Cryptography_DSA_u8Array__CreateSignature_0__1__u8Array(&__thrown, self.get_handle(), rgbHash.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return dotnet.System_Arr<Swift.UInt8>(hndl : __return);
        }
    }
    // System.Byte[] CreateSignature(System.Byte[], System.Security.Cryptography.DSASignatureFormat)
// docid: M:System.Security.Cryptography.DSA.CreateSignature(System.Byte[],System.Security.Cryptography.DSASignatureFormat)
    /**
    Creates the DSA signature for the specified hash value in the indicated format.

    - Parameter rgbHash: The hash value to sign.
    - Parameter signatureFormat: The encoding format to use for the signature.
    - Returns: The DSA signature for the specified data.

    */
    open func CreateSignature(rgbHash : dotnet.System_Arr<Swift.UInt8>, signatureFormat : dotnet.System.Security.Cryptography.DSASignatureFormat) throws -> dotnet.System_Arr<Swift.UInt8> {
        var __thrown : NullableHandle = nil;
        let __return = System_Security_Cryptography_DSA_u8Array__CreateSignature_0__2__u8Array_DSASignatureFormat(&__thrown, self.get_handle(), rgbHash.get_handle(), signatureFormat.get_value());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return dotnet.System_Arr<Swift.UInt8>(hndl : __return);
        }
    }
    // System.Security.Cryptography.DSAParameters ExportParameters(bool)
// docid: M:System.Security.Cryptography.DSA.ExportParameters(System.Boolean)
    /**
    When overridden in a derived class, exports the .

    - Parameter includePrivateParameters: 
         to include private parameters; otherwise, .
    - Returns: The parameters for .

    */
    open func ExportParameters(includePrivateParameters : Bool) throws -> dotnet.System.Security.Cryptography.DSAParameters {
        var __thrown : NullableHandle = nil;
        let __return = System_Security_Cryptography_DSA_DSAParameters__ExportParameters_0__1__bool(&__thrown, self.get_handle(), Swift.Int32(includePrivateParameters ? 1 : 0));
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return dotnet.System.Security.Cryptography.DSAParameters(hndl : __return);
        }
    }
    // void FromXmlString(System.String)
// docid: M:System.Security.Cryptography.DSA.FromXmlString(System.String)
    /**
    Reconstructs a  object from an XML string.

    - Parameter xmlString: The XML string to use to reconstruct the  object.
    */
    open override func FromXmlString(xmlString : dotnet.System.String) throws {
        var __thrown : NullableHandle = nil;
        System_Security_Cryptography_DSA_void__FromXmlString_0__1__String(&__thrown, self.get_handle(), xmlString.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
            return;
        }
    }
    // System.Int32 GetMaxSignatureSize(System.Security.Cryptography.DSASignatureFormat)
// docid: M:System.Security.Cryptography.DSA.GetMaxSignatureSize(System.Security.Cryptography.DSASignatureFormat)
    /**
    Gets the largest size, in bytes, for a signature produced by this key in the indicated format.

    - Parameter signatureFormat: The encoding format for a signature.
    - Returns: The largest size, in bytes, for a signature produced by this key in the indicated format.

    */
    open func GetMaxSignatureSize(signatureFormat : dotnet.System.Security.Cryptography.DSASignatureFormat) throws -> Swift.Int32 {
        var __thrown : NullableHandle = nil;
        let __return = System_Security_Cryptography_DSA_i32__GetMaxSignatureSize_0__1__DSASignatureFormat(&__thrown, self.get_handle(), signatureFormat.get_value());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return __return;
        }
    }
// TODO COPE (write_all_methods) (span) void ImportEncryptedPkcs8PrivateKey(System.ReadOnlySpan<System.Byte>, System.ReadOnlySpan<System.Byte>, ref System.Int32)
// TODO COPE (write_all_methods) (span) void ImportEncryptedPkcs8PrivateKey(System.ReadOnlySpan<System.Char>, System.ReadOnlySpan<System.Byte>, ref System.Int32)
// TODO COPE (write_all_methods) (span) void ImportFromEncryptedPem(System.ReadOnlySpan<System.Char>, System.ReadOnlySpan<System.Byte>)
// TODO COPE (write_all_methods) (span) void ImportFromEncryptedPem(System.ReadOnlySpan<System.Char>, System.ReadOnlySpan<System.Char>)
// TODO COPE (write_all_methods) (span) void ImportFromPem(System.ReadOnlySpan<System.Char>)
    // void ImportParameters(System.Security.Cryptography.DSAParameters)
// docid: M:System.Security.Cryptography.DSA.ImportParameters(System.Security.Cryptography.DSAParameters)
    /**
    When overridden in a derived class, imports the specified .

    - Parameter parameters: The parameters for .
    */
    open func ImportParameters(parameters : dotnet.System.Security.Cryptography.DSAParameters) throws {
        var __thrown : NullableHandle = nil;
        System_Security_Cryptography_DSA_void__ImportParameters_0__1__DSAParameters(&__thrown, self.get_handle(), parameters.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
            return;
        }
    }
// TODO COPE (write_all_methods) (span) void ImportPkcs8PrivateKey(System.ReadOnlySpan<System.Byte>, ref System.Int32)
// TODO COPE (write_all_methods) (span) void ImportSubjectPublicKeyInfo(System.ReadOnlySpan<System.Byte>, ref System.Int32)
    // System.Byte[] SignData(System.Byte[], System.Int32, System.Int32, System.Security.Cryptography.HashAlgorithmName)
// docid: M:System.Security.Cryptography.DSA.SignData(System.Byte[],System.Int32,System.Int32,System.Security.Cryptography.HashAlgorithmName)
    /**
    Computes the hash value of a portion of the specified byte array using the specified hash algorithm and signs the resulting hash value.

    - Parameter data: The input data for which to compute the hash.
    - Parameter offset: The offset into the array at which to begin using data.
    - Parameter count: The number of bytes in the array to use as data.
    - Parameter hashAlgorithm: The hash algorithm to use to create the hash value.
    - Returns: The DSA signature for the specified data.

    */
    open func SignData(data : dotnet.System_Arr<Swift.UInt8>, offset : Swift.Int32, count : Swift.Int32, hashAlgorithm : dotnet.System.Security.Cryptography.HashAlgorithmName) throws -> dotnet.System_Arr<Swift.UInt8> {
        var __thrown : NullableHandle = nil;
        let __return = System_Security_Cryptography_DSA_u8Array__SignData_0__4__u8Array_i32_i32_HashAlgorithmName(&__thrown, self.get_handle(), data.get_handle(), offset, count, hashAlgorithm.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return dotnet.System_Arr<Swift.UInt8>(hndl : __return);
        }
    }
    // System.Byte[] SignData(System.Byte[], System.Int32, System.Int32, System.Security.Cryptography.HashAlgorithmName, System.Security.Cryptography.DSASignatureFormat)
// docid: M:System.Security.Cryptography.DSA.SignData(System.Byte[],System.Int32,System.Int32,System.Security.Cryptography.HashAlgorithmName,System.Security.Cryptography.DSASignatureFormat)
    /**
    Computes the hash value of the specified data and signs it using the specified signature format.

    - Parameter data: The data to sign.
    - Parameter offset: The offset into  at which to begin hashing.
    - Parameter count: The number of bytes to read from .
    - Parameter hashAlgorithm: The hash algorithm to use to create the hash value.
    - Parameter signatureFormat: The encoding format to use for the signature.
    - Returns: The DSA signature for the specified data.

    */
    open func SignData(data : dotnet.System_Arr<Swift.UInt8>, offset : Swift.Int32, count : Swift.Int32, hashAlgorithm : dotnet.System.Security.Cryptography.HashAlgorithmName, signatureFormat : dotnet.System.Security.Cryptography.DSASignatureFormat) throws -> dotnet.System_Arr<Swift.UInt8> {
        var __thrown : NullableHandle = nil;
        let __return = System_Security_Cryptography_DSA_u8Array__SignData_0__5__u8Array_i32_i32_HashAlgorithmName_DSASignatureFormat(&__thrown, self.get_handle(), data.get_handle(), offset, count, hashAlgorithm.get_handle(), signatureFormat.get_value());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return dotnet.System_Arr<Swift.UInt8>(hndl : __return);
        }
    }
    // System.Byte[] SignData(System.Byte[], System.Security.Cryptography.HashAlgorithmName)
// docid: M:System.Security.Cryptography.DSA.SignData(System.Byte[],System.Security.Cryptography.HashAlgorithmName)
    /**
    Computes the hash value of the specified byte array using the specified hash algorithm and signs the resulting hash value.

    - Parameter data: The input data for which to compute the hash.
    - Parameter hashAlgorithm: The hash algorithm to use to create the hash value.
    - Returns: The DSA signature for the specified data.

    */
    open func SignData(data : dotnet.System_Arr<Swift.UInt8>, hashAlgorithm : dotnet.System.Security.Cryptography.HashAlgorithmName) throws -> dotnet.System_Arr<Swift.UInt8> {
        var __thrown : NullableHandle = nil;
        let __return = System_Security_Cryptography_DSA_u8Array__SignData_0__2__u8Array_HashAlgorithmName(&__thrown, self.get_handle(), data.get_handle(), hashAlgorithm.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return dotnet.System_Arr<Swift.UInt8>(hndl : __return);
        }
    }
    // System.Byte[] SignData(System.Byte[], System.Security.Cryptography.HashAlgorithmName, System.Security.Cryptography.DSASignatureFormat)
// docid: M:System.Security.Cryptography.DSA.SignData(System.Byte[],System.Security.Cryptography.HashAlgorithmName,System.Security.Cryptography.DSASignatureFormat)
    /**
    Computes the hash value of the specified data and signs it using the specified signature format.

    - Parameter data: The data to sign.
    - Parameter hashAlgorithm: The hash algorithm to use to create the hash value.
    - Parameter signatureFormat: The encoding format to use for the signature.
    - Returns: The DSA signature for the specified data.

    */
    open func SignData(data : dotnet.System_Arr<Swift.UInt8>, hashAlgorithm : dotnet.System.Security.Cryptography.HashAlgorithmName, signatureFormat : dotnet.System.Security.Cryptography.DSASignatureFormat) throws -> dotnet.System_Arr<Swift.UInt8> {
        var __thrown : NullableHandle = nil;
        let __return = System_Security_Cryptography_DSA_u8Array__SignData_0__3__u8Array_HashAlgorithmName_DSASignatureFormat(&__thrown, self.get_handle(), data.get_handle(), hashAlgorithm.get_handle(), signatureFormat.get_value());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return dotnet.System_Arr<Swift.UInt8>(hndl : __return);
        }
    }
    // System.Byte[] SignData(System.IO.Stream, System.Security.Cryptography.HashAlgorithmName)
// docid: M:System.Security.Cryptography.DSA.SignData(System.IO.Stream,System.Security.Cryptography.HashAlgorithmName)
    /**
    Computes the hash value of the specified stream using the specified hash algorithm and signs the resulting hash value.

    - Parameter data: The input stream for which to compute the hash.
    - Parameter hashAlgorithm: The hash algorithm to use to create the hash value.
    - Returns: The DSA signature for the specified data.

    */
    open func SignData(data : dotnet.System.IO.Stream, hashAlgorithm : dotnet.System.Security.Cryptography.HashAlgorithmName) throws -> dotnet.System_Arr<Swift.UInt8> {
        var __thrown : NullableHandle = nil;
        let __return = System_Security_Cryptography_DSA_u8Array__SignData_0__2__Stream_HashAlgorithmName(&__thrown, self.get_handle(), data.get_handle(), hashAlgorithm.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return dotnet.System_Arr<Swift.UInt8>(hndl : __return);
        }
    }
    // System.Byte[] SignData(System.IO.Stream, System.Security.Cryptography.HashAlgorithmName, System.Security.Cryptography.DSASignatureFormat)
// docid: M:System.Security.Cryptography.DSA.SignData(System.IO.Stream,System.Security.Cryptography.HashAlgorithmName,System.Security.Cryptography.DSASignatureFormat)
    /**
    Computes the hash value of the specified data and signs it using the specified signature format.

    - Parameter data: The data to sign.
    - Parameter hashAlgorithm: The hash algorithm to use to create the hash value.
    - Parameter signatureFormat: The encoding format to use for the signature.
    - Returns: The DSA signature for the specified data.

    */
    open func SignData(data : dotnet.System.IO.Stream, hashAlgorithm : dotnet.System.Security.Cryptography.HashAlgorithmName, signatureFormat : dotnet.System.Security.Cryptography.DSASignatureFormat) throws -> dotnet.System_Arr<Swift.UInt8> {
        var __thrown : NullableHandle = nil;
        let __return = System_Security_Cryptography_DSA_u8Array__SignData_0__3__Stream_HashAlgorithmName_DSASignatureFormat(&__thrown, self.get_handle(), data.get_handle(), hashAlgorithm.get_handle(), signatureFormat.get_value());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return dotnet.System_Arr<Swift.UInt8>(hndl : __return);
        }
    }
    // System.String ToXmlString(bool)
// docid: M:System.Security.Cryptography.DSA.ToXmlString(System.Boolean)
    /**
    Creates and returns an XML string representation of the current  object.

    - Parameter includePrivateParameters: 
         to include private parameters; otherwise, .
    - Returns: An XML string encoding of the current  object.

    */
    open override func ToXmlString(includePrivateParameters : Bool) throws -> dotnet.System.String {
        var __thrown : NullableHandle = nil;
        let __return = System_Security_Cryptography_DSA_String__ToXmlString_0__1__bool(&__thrown, self.get_handle(), Swift.Int32(includePrivateParameters ? 1 : 0));
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return dotnet.System.String(hndl : __return);
        }
    }
// TODO COPE (write_all_methods) (span) bool TryCreateSignature(System.ReadOnlySpan<System.Byte>, System.Span<System.Byte>, ref System.Int32)
// TODO COPE (write_all_methods) (span) bool TryCreateSignature(System.ReadOnlySpan<System.Byte>, System.Span<System.Byte>, System.Security.Cryptography.DSASignatureFormat, ref System.Int32)
// TODO COPE (write_all_methods) (span) bool TryExportEncryptedPkcs8PrivateKey(System.ReadOnlySpan<System.Byte>, System.Security.Cryptography.PbeParameters, System.Span<System.Byte>, ref System.Int32)
// TODO COPE (write_all_methods) (span) bool TryExportEncryptedPkcs8PrivateKey(System.ReadOnlySpan<System.Char>, System.Security.Cryptography.PbeParameters, System.Span<System.Byte>, ref System.Int32)
// TODO COPE (write_all_methods) (span) bool TryExportPkcs8PrivateKey(System.Span<System.Byte>, ref System.Int32)
// TODO COPE (write_all_methods) (span) bool TryExportSubjectPublicKeyInfo(System.Span<System.Byte>, ref System.Int32)
// TODO COPE (write_all_methods) (span) bool TrySignData(System.ReadOnlySpan<System.Byte>, System.Span<System.Byte>, System.Security.Cryptography.HashAlgorithmName, ref System.Int32)
// TODO COPE (write_all_methods) (span) bool TrySignData(System.ReadOnlySpan<System.Byte>, System.Span<System.Byte>, System.Security.Cryptography.HashAlgorithmName, System.Security.Cryptography.DSASignatureFormat, ref System.Int32)
    // bool VerifyData(System.Byte[], System.Byte[], System.Security.Cryptography.HashAlgorithmName)
// docid: M:System.Security.Cryptography.DSA.VerifyData(System.Byte[],System.Byte[],System.Security.Cryptography.HashAlgorithmName)
    /**
    Verifies that a digital signature is valid by calculating the hash value of the specified data using the specified hash algorithm and comparing it to the provided signature.

    - Parameter data: The signed data.
    - Parameter signature: The signature data to be verified.
    - Parameter hashAlgorithm: The hash algorithm used to create the hash value of the data.
    - Returns: 
         if the digital signature is valid; otherwise, .

    */
    open func VerifyData(data : dotnet.System_Arr<Swift.UInt8>, signature : dotnet.System_Arr<Swift.UInt8>, hashAlgorithm : dotnet.System.Security.Cryptography.HashAlgorithmName) throws -> Bool {
        var __thrown : NullableHandle = nil;
        let __return = System_Security_Cryptography_DSA_bool__VerifyData_0__3__u8Array_u8Array_HashAlgorithmName(&__thrown, self.get_handle(), data.get_handle(), signature.get_handle(), hashAlgorithm.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return (__return) != 0;
        }
    }
    // bool VerifyData(System.Byte[], System.Byte[], System.Security.Cryptography.HashAlgorithmName, System.Security.Cryptography.DSASignatureFormat)
// docid: M:System.Security.Cryptography.DSA.VerifyData(System.Byte[],System.Byte[],System.Security.Cryptography.HashAlgorithmName,System.Security.Cryptography.DSASignatureFormat)
    /**
    Verifies that a digital signature is valid for the provided data.

    - Parameter data: The signed data.
    - Parameter signature: The signature to verify.
    - Parameter hashAlgorithm: The hash algorithm used to hash the data for the verification process.
    - Parameter signatureFormat: The encoding format for .
    - Returns: 
         if the digital signature is valid for the provided data; otherwise, .

    */
    open func VerifyData(data : dotnet.System_Arr<Swift.UInt8>, signature : dotnet.System_Arr<Swift.UInt8>, hashAlgorithm : dotnet.System.Security.Cryptography.HashAlgorithmName, signatureFormat : dotnet.System.Security.Cryptography.DSASignatureFormat) throws -> Bool {
        var __thrown : NullableHandle = nil;
        let __return = System_Security_Cryptography_DSA_bool__VerifyData_0__4__u8Array_u8Array_HashAlgorithmName_DSASignatureFormat(&__thrown, self.get_handle(), data.get_handle(), signature.get_handle(), hashAlgorithm.get_handle(), signatureFormat.get_value());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return (__return) != 0;
        }
    }
    // bool VerifyData(System.Byte[], System.Int32, System.Int32, System.Byte[], System.Security.Cryptography.HashAlgorithmName)
// docid: M:System.Security.Cryptography.DSA.VerifyData(System.Byte[],System.Int32,System.Int32,System.Byte[],System.Security.Cryptography.HashAlgorithmName)
    /**
    Verifies that a digital signature is valid by calculating the hash value of the data in a portion of a byte array using the specified hash algorithm and comparing it to the provided signature.

    - Parameter data: The signed data.
    - Parameter offset: The starting index at which to compute the hash.
    - Parameter count: The number of bytes to hash.
    - Parameter signature: The signature data to be verified.
    - Parameter hashAlgorithm: The hash algorithm used to create the hash value of the data.
    - Returns: 
         if the digital signature is valid; otherwise, .

    */
    open func VerifyData(data : dotnet.System_Arr<Swift.UInt8>, offset : Swift.Int32, count : Swift.Int32, signature : dotnet.System_Arr<Swift.UInt8>, hashAlgorithm : dotnet.System.Security.Cryptography.HashAlgorithmName) throws -> Bool {
        var __thrown : NullableHandle = nil;
        let __return = System_Security_Cryptography_DSA_bool__VerifyData_0__5__u8Array_i32_i32_u8Array_HashAlgorithmName(&__thrown, self.get_handle(), data.get_handle(), offset, count, signature.get_handle(), hashAlgorithm.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return (__return) != 0;
        }
    }
    // bool VerifyData(System.Byte[], System.Int32, System.Int32, System.Byte[], System.Security.Cryptography.HashAlgorithmName, System.Security.Cryptography.DSASignatureFormat)
// docid: M:System.Security.Cryptography.DSA.VerifyData(System.Byte[],System.Int32,System.Int32,System.Byte[],System.Security.Cryptography.HashAlgorithmName,System.Security.Cryptography.DSASignatureFormat)
    /**
    Verifies that a digital signature is valid for the provided data.

    - Parameter data: An array that contains the signed data.
    - Parameter offset: The starting index of the signed portion of .
    - Parameter count: The number of bytes in  that were signed.
    - Parameter signature: The signature to verify.
    - Parameter hashAlgorithm: The hash algorithm used to hash the data for the verification process.
    - Parameter signatureFormat: The encoding format for .
    - Returns: 
         if the digital signature is valid for the provided data; otherwise, .

    */
    open func VerifyData(data : dotnet.System_Arr<Swift.UInt8>, offset : Swift.Int32, count : Swift.Int32, signature : dotnet.System_Arr<Swift.UInt8>, hashAlgorithm : dotnet.System.Security.Cryptography.HashAlgorithmName, signatureFormat : dotnet.System.Security.Cryptography.DSASignatureFormat) throws -> Bool {
        var __thrown : NullableHandle = nil;
        let __return = System_Security_Cryptography_DSA_bool__VerifyData_0__6__u8Array_i32_i32_u8Array_HashAlgorithmName_DSASignatureFormat(&__thrown, self.get_handle(), data.get_handle(), offset, count, signature.get_handle(), hashAlgorithm.get_handle(), signatureFormat.get_value());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return (__return) != 0;
        }
    }
    // bool VerifyData(System.IO.Stream, System.Byte[], System.Security.Cryptography.HashAlgorithmName)
// docid: M:System.Security.Cryptography.DSA.VerifyData(System.IO.Stream,System.Byte[],System.Security.Cryptography.HashAlgorithmName)
    /**
    Verifies that a digital signature is valid by calculating the hash value of the specified stream using the specified hash algorithm and comparing it to the provided signature.

    - Parameter data: The signed data.
    - Parameter signature: The signature data to be verified.
    - Parameter hashAlgorithm: The hash algorithm used to create the hash value of the data.
    - Returns: 
         if the digital signature is valid; otherwise, .

    */
    open func VerifyData(data : dotnet.System.IO.Stream, signature : dotnet.System_Arr<Swift.UInt8>, hashAlgorithm : dotnet.System.Security.Cryptography.HashAlgorithmName) throws -> Bool {
        var __thrown : NullableHandle = nil;
        let __return = System_Security_Cryptography_DSA_bool__VerifyData_0__3__Stream_u8Array_HashAlgorithmName(&__thrown, self.get_handle(), data.get_handle(), signature.get_handle(), hashAlgorithm.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return (__return) != 0;
        }
    }
    // bool VerifyData(System.IO.Stream, System.Byte[], System.Security.Cryptography.HashAlgorithmName, System.Security.Cryptography.DSASignatureFormat)
// docid: M:System.Security.Cryptography.DSA.VerifyData(System.IO.Stream,System.Byte[],System.Security.Cryptography.HashAlgorithmName,System.Security.Cryptography.DSASignatureFormat)
    /**
    Verifies that a digital signature is valid for the provided data.

    - Parameter data: The signed data.
    - Parameter signature: The signature to verify.
    - Parameter hashAlgorithm: The hash algorithm used to hash the data for the verification process.
    - Parameter signatureFormat: The encoding format for .
    - Returns: 
         if the digital signature is valid for the provided data; otherwise, .

    */
    open func VerifyData(data : dotnet.System.IO.Stream, signature : dotnet.System_Arr<Swift.UInt8>, hashAlgorithm : dotnet.System.Security.Cryptography.HashAlgorithmName, signatureFormat : dotnet.System.Security.Cryptography.DSASignatureFormat) throws -> Bool {
        var __thrown : NullableHandle = nil;
        let __return = System_Security_Cryptography_DSA_bool__VerifyData_0__4__Stream_u8Array_HashAlgorithmName_DSASignatureFormat(&__thrown, self.get_handle(), data.get_handle(), signature.get_handle(), hashAlgorithm.get_handle(), signatureFormat.get_value());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return (__return) != 0;
        }
    }
// TODO COPE (write_all_methods) (span) bool VerifyData(System.ReadOnlySpan<System.Byte>, System.ReadOnlySpan<System.Byte>, System.Security.Cryptography.HashAlgorithmName)
// TODO COPE (write_all_methods) (span) bool VerifyData(System.ReadOnlySpan<System.Byte>, System.ReadOnlySpan<System.Byte>, System.Security.Cryptography.HashAlgorithmName, System.Security.Cryptography.DSASignatureFormat)
    // bool VerifySignature(System.Byte[], System.Byte[])
// docid: M:System.Security.Cryptography.DSA.VerifySignature(System.Byte[],System.Byte[])
    /**
    When overridden in a derived class, verifies the  signature for the specified data.

    - Parameter rgbHash: The hash of the data signed with .
    - Parameter rgbSignature: The signature to be verified for rgbData.
    - Returns: 
         if  matches the signature computed using the specified hash algorithm and key on ; otherwise, .

    */
    open func VerifySignature(rgbHash : dotnet.System_Arr<Swift.UInt8>, rgbSignature : dotnet.System_Arr<Swift.UInt8>) throws -> Bool {
        var __thrown : NullableHandle = nil;
        let __return = System_Security_Cryptography_DSA_bool__VerifySignature_0__2__u8Array_u8Array(&__thrown, self.get_handle(), rgbHash.get_handle(), rgbSignature.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return (__return) != 0;
        }
    }
    // bool VerifySignature(System.Byte[], System.Byte[], System.Security.Cryptography.DSASignatureFormat)
// docid: M:System.Security.Cryptography.DSA.VerifySignature(System.Byte[],System.Byte[],System.Security.Cryptography.DSASignatureFormat)
    /**
    Verifies that a digital signature is valid for the provided hash.

    - Parameter rgbHash: The signed hash.
    - Parameter rgbSignature: The signature to verify.
    - Parameter signatureFormat: The encoding format for .
    - Returns: 
         if the digital signature is valid for the provided data; otherwise, .

    */
    open func VerifySignature(rgbHash : dotnet.System_Arr<Swift.UInt8>, rgbSignature : dotnet.System_Arr<Swift.UInt8>, signatureFormat : dotnet.System.Security.Cryptography.DSASignatureFormat) throws -> Bool {
        var __thrown : NullableHandle = nil;
        let __return = System_Security_Cryptography_DSA_bool__VerifySignature_0__3__u8Array_u8Array_DSASignatureFormat(&__thrown, self.get_handle(), rgbHash.get_handle(), rgbSignature.get_handle(), signatureFormat.get_value());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return (__return) != 0;
        }
    }
// TODO COPE (write_all_methods) (span) bool VerifySignature(System.ReadOnlySpan<System.Byte>, System.ReadOnlySpan<System.Byte>)
// TODO COPE (write_all_methods) (span) bool VerifySignature(System.ReadOnlySpan<System.Byte>, System.ReadOnlySpan<System.Byte>, System.Security.Cryptography.DSASignatureFormat)
} // DSA


// type: System.Security.Cryptography.DSAParameters
// boxed value type
    /**
    Contains the typical parameters for the  algorithm.

    */
public final class DSAParameters
    :
    dotnet.System.Object
{
    public class override func get_type_handle() -> TypeHandle {
        return System_Security_Cryptography_DSAParameters_get_type_handle();
    }
    public required init(hndl: NonnullHandle) { super.init(hndl: hndl); }
    public required init(gval: GVal) { super.init(gval: gval); }
    public override init() {
        let h = System_Security_Cryptography_DSAParameters_implicit_ctor();
            super.init(hndl: h);
    }
} // DSAParameters


// type: System.Security.Cryptography.DSASignatureDeformatter
    /**
    Verifies a Digital Signature Algorithm () PKCS#1 v1.5 signature.

    */
open class DSASignatureDeformatter
    :
    dotnet.System.Security.Cryptography.AsymmetricSignatureDeformatter
{
    open class override func get_type_handle() -> TypeHandle {
        return System_Security_Cryptography_DSASignatureDeformatter_get_type_handle();
    }
    public required init(hndl: NonnullHandle) { super.init(hndl: hndl); }
    public required init(gval: GVal) { super.init(gval: gval); }
    // .ctor()
// docid: M:System.Security.Cryptography.DSASignatureDeformatter.#ctor
    /**
    Initializes a new instance of the  class.

    */
    public init() throws {
        var __thrown : NullableHandle = nil;
        let h = System_Security_Cryptography_DSASignatureDeformatter_ctor_0__0(&__thrown);
        if let __ex = __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
            super.init(hndl: h);
        }
    }
    // .ctor(System.Security.Cryptography.AsymmetricAlgorithm)
// docid: M:System.Security.Cryptography.DSASignatureDeformatter.#ctor(System.Security.Cryptography.AsymmetricAlgorithm)
    /**
    Initializes a new instance of the  class with the specified key.

    - Parameter key: The instance of Digital Signature Algorithm () that holds the key.
    */
    public init(key : dotnet.System.Security.Cryptography.AsymmetricAlgorithm) throws {
        var __thrown : NullableHandle = nil;
        let h = System_Security_Cryptography_DSASignatureDeformatter_ctor_0__1__AsymmetricAlgorithm(&__thrown, key.get_handle());
        if let __ex = __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
            super.init(hndl: h);
        }
    }
    // void SetHashAlgorithm(System.String)
// docid: M:System.Security.Cryptography.DSASignatureDeformatter.SetHashAlgorithm(System.String)
    /**
    Specifies the hash algorithm for the Digital Signature Algorithm () signature deformatter.

    - Parameter strName: The name of the hash algorithm to use for the signature deformatter.
    */
    open override func SetHashAlgorithm(strName : dotnet.System.String) throws {
        var __thrown : NullableHandle = nil;
        System_Security_Cryptography_DSASignatureDeformatter_void__SetHashAlgorithm_0__1__String(&__thrown, self.get_handle(), strName.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
            return;
        }
    }
    // void SetKey(System.Security.Cryptography.AsymmetricAlgorithm)
// docid: M:System.Security.Cryptography.DSASignatureDeformatter.SetKey(System.Security.Cryptography.AsymmetricAlgorithm)
    /**
    Specifies the key to be used for the Digital Signature Algorithm () signature deformatter.

    - Parameter key: The instance of  that holds the key.
    */
    open override func SetKey(key : dotnet.System.Security.Cryptography.AsymmetricAlgorithm) throws {
        var __thrown : NullableHandle = nil;
        System_Security_Cryptography_DSASignatureDeformatter_void__SetKey_0__1__AsymmetricAlgorithm(&__thrown, self.get_handle(), key.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
            return;
        }
    }
    // bool VerifySignature(System.Byte[], System.Byte[])
// docid: M:System.Security.Cryptography.DSASignatureDeformatter.VerifySignature(System.Byte[],System.Byte[])
    /**
    Verifies the Digital Signature Algorithm () signature on the data.

    - Parameter rgbHash: The data signed with .
    - Parameter rgbSignature: The signature to be verified for .
    - Returns: 
         if the signature is valid for the data; otherwise, .

    */
    open override func VerifySignature(rgbHash : dotnet.System_Arr<Swift.UInt8>, rgbSignature : dotnet.System_Arr<Swift.UInt8>) throws -> Bool {
        var __thrown : NullableHandle = nil;
        let __return = System_Security_Cryptography_DSASignatureDeformatter_bool__VerifySignature_0__2__u8Array_u8Array(&__thrown, self.get_handle(), rgbHash.get_handle(), rgbSignature.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return (__return) != 0;
        }
    }
} // DSASignatureDeformatter


// type: System.Security.Cryptography.DSASignatureFormat
    /**
    Specifies the data format for signatures with the DSA family of algorithms.

    */
public struct DSASignatureFormat : SGBridgeGenericValue {
    let v : Swift.Int32;
    public init(val: Swift.Int32) { self.v = val; }
    public func get_value() -> Swift.Int32 { return self.v; }
    public static func get_type_handle() -> TypeHandle {
        return System_Security_Cryptography_DSASignatureFormat_get_type_handle();
    }
    public func to_gval() -> GVal { return GVal(self.v); }
    public func dup_gval() -> GVal { return to_gval(); }
    public init(gval: GVal) { self.v = Swift.Int32(gval); }
    // static field: System.Security.Cryptography.DSASignatureFormat IeeeP1363FixedFieldConcatenation
    /**
    The signature format from IEEE P1363, which produces a fixed size signature for a given key.

    */
    public static var IeeeP1363FixedFieldConcatenation : dotnet.System.Security.Cryptography.DSASignatureFormat {
        get {
        let __return = dotnet.System.Security.Cryptography.DSASignatureFormat(val: System_Security_Cryptography_DSASignatureFormat_get_IeeeP1363FixedFieldConcatenation());
            return __return;
        }
    }
    // static field: System.Security.Cryptography.DSASignatureFormat Rfc3279DerSequence
    /**
    The signature format from IETF RFC 3279, which produces a variably-sized signature.

    */
    public static var Rfc3279DerSequence : dotnet.System.Security.Cryptography.DSASignatureFormat {
        get {
        let __return = dotnet.System.Security.Cryptography.DSASignatureFormat(val: System_Security_Cryptography_DSASignatureFormat_get_Rfc3279DerSequence());
            return __return;
        }
    }
} // DSASignatureFormat


// type: System.Security.Cryptography.DSASignatureFormatter
    /**
    Creates a Digital Signature Algorithm () signature.

    */
open class DSASignatureFormatter
    :
    dotnet.System.Security.Cryptography.AsymmetricSignatureFormatter
{
    open class override func get_type_handle() -> TypeHandle {
        return System_Security_Cryptography_DSASignatureFormatter_get_type_handle();
    }
    public required init(hndl: NonnullHandle) { super.init(hndl: hndl); }
    public required init(gval: GVal) { super.init(gval: gval); }
    // .ctor()
// docid: M:System.Security.Cryptography.DSASignatureFormatter.#ctor
    /**
    Initializes a new instance of the  class.

    */
    public init() throws {
        var __thrown : NullableHandle = nil;
        let h = System_Security_Cryptography_DSASignatureFormatter_ctor_0__0(&__thrown);
        if let __ex = __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
            super.init(hndl: h);
        }
    }
    // .ctor(System.Security.Cryptography.AsymmetricAlgorithm)
// docid: M:System.Security.Cryptography.DSASignatureFormatter.#ctor(System.Security.Cryptography.AsymmetricAlgorithm)
    /**
    Initializes a new instance of the  class with the specified key.

    - Parameter key: The instance of the Digital Signature Algorithm () that holds the key.
    */
    public init(key : dotnet.System.Security.Cryptography.AsymmetricAlgorithm) throws {
        var __thrown : NullableHandle = nil;
        let h = System_Security_Cryptography_DSASignatureFormatter_ctor_0__1__AsymmetricAlgorithm(&__thrown, key.get_handle());
        if let __ex = __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
            super.init(hndl: h);
        }
    }
    // System.Byte[] CreateSignature(System.Byte[])
// docid: M:System.Security.Cryptography.DSASignatureFormatter.CreateSignature(System.Byte[])
    /**
    Creates the Digital Signature Algorithm () PKCS #1 signature for the specified data.

    - Parameter rgbHash: The data to be signed.
    - Returns: The digital signature for the specified data.

    */
    open override func CreateSignature(rgbHash : dotnet.System_Arr<Swift.UInt8>) throws -> dotnet.System_Arr<Swift.UInt8> {
        var __thrown : NullableHandle = nil;
        let __return = System_Security_Cryptography_DSASignatureFormatter_u8Array__CreateSignature_0__1__u8Array(&__thrown, self.get_handle(), rgbHash.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return dotnet.System_Arr<Swift.UInt8>(hndl : __return);
        }
    }
    // void SetHashAlgorithm(System.String)
// docid: M:System.Security.Cryptography.DSASignatureFormatter.SetHashAlgorithm(System.String)
    /**
    Specifies the hash algorithm for the Digital Signature Algorithm () signature formatter.

    - Parameter strName: The name of the hash algorithm to use for the signature formatter.
    */
    open override func SetHashAlgorithm(strName : dotnet.System.String) throws {
        var __thrown : NullableHandle = nil;
        System_Security_Cryptography_DSASignatureFormatter_void__SetHashAlgorithm_0__1__String(&__thrown, self.get_handle(), strName.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
            return;
        }
    }
    // void SetKey(System.Security.Cryptography.AsymmetricAlgorithm)
// docid: M:System.Security.Cryptography.DSASignatureFormatter.SetKey(System.Security.Cryptography.AsymmetricAlgorithm)
    /**
    Specifies the key to be used for the Digital Signature Algorithm () signature formatter.

    - Parameter key: The instance of  that holds the key.
    */
    open override func SetKey(key : dotnet.System.Security.Cryptography.AsymmetricAlgorithm) throws {
        var __thrown : NullableHandle = nil;
        System_Security_Cryptography_DSASignatureFormatter_void__SetKey_0__1__AsymmetricAlgorithm(&__thrown, self.get_handle(), key.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
            return;
        }
    }
} // DSASignatureFormatter


// type: System.Security.Cryptography.DeriveBytes
    /**
    Represents the abstract base class from which all classes that derive byte sequences of a specified length inherit.

    */
open class DeriveBytes
    :
    dotnet.System.Object,
    System_IDisposable
{
    open class override func get_type_handle() -> TypeHandle {
        return System_Security_Cryptography_DeriveBytes_get_type_handle();
    }
    public required init(hndl: NonnullHandle) { super.init(hndl: hndl); }
    public required init(gval: GVal) { super.init(gval: gval); }
    // void Dispose()
// docid: M:System.Security.Cryptography.DeriveBytes.Dispose
    /**
    When overridden in a derived class, releases all resources used by the current instance of the  class.

    */
    open /* method final */ func Dispose() throws {
        var __thrown : NullableHandle = nil;
        System_Security_Cryptography_DeriveBytes_void__Dispose_0__0(&__thrown, self.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
            return;
        }
    }
    // System.Byte[] GetBytes(System.Int32)
// docid: M:System.Security.Cryptography.DeriveBytes.GetBytes(System.Int32)
    /**
    When overridden in a derived class, returns pseudo-random key bytes.

    - Parameter cb: The number of pseudo-random key bytes to generate.
    - Returns: A byte array filled with pseudo-random key bytes.

    */
    open func GetBytes(cb : Swift.Int32) throws -> dotnet.System_Arr<Swift.UInt8> {
        var __thrown : NullableHandle = nil;
        let __return = System_Security_Cryptography_DeriveBytes_u8Array__GetBytes_0__1__i32(&__thrown, self.get_handle(), cb);
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return dotnet.System_Arr<Swift.UInt8>(hndl : __return);
        }
    }
    // void Reset()
// docid: M:System.Security.Cryptography.DeriveBytes.Reset
    /**
    When overridden in a derived class, resets the state of the operation.

    */
    open func Reset() throws {
        var __thrown : NullableHandle = nil;
        System_Security_Cryptography_DeriveBytes_void__Reset_0__0(&__thrown, self.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
            return;
        }
    }
} // DeriveBytes


// type: System.Security.Cryptography.ECCurve
// boxed value type
    /**
    Represents an elliptic curve.

    */
public final class ECCurve
    :
    dotnet.System.Object
{
    public class override func get_type_handle() -> TypeHandle {
        return System_Security_Cryptography_ECCurve_get_type_handle();
    }
    public required init(hndl: NonnullHandle) { super.init(hndl: hndl); }
    public required init(gval: GVal) { super.init(gval: gval); }
    /**
    Gets a value that indicates whether the curve type indicates an explicit characteristic 2 curve.

    */
    public var IsCharacteristic2 : Bool {
        get {
            return try! get_IsCharacteristic2();
        }
    }
    /**
    Gets a value that indicates whether the curve type indicates an explicit curve (either prime or characteristic 2).

    */
    public var IsExplicit : Bool {
        get {
            return try! get_IsExplicit();
        }
    }
    /**
    Gets a value that indicates whether the curve type indicates a named curve.

    */
    public var IsNamed : Bool {
        get {
            return try! get_IsNamed();
        }
    }
    /**
    Gets a value that indicates whether the curve type indicates an explicit prime curve.

    */
    public var IsPrime : Bool {
        get {
            return try! get_IsPrime();
        }
    }
    /**
    Gets the identifier of a named curve.

    */
    public var Oid : dotnet.System.Security.Cryptography.Oid {
        get {
            return try! get_Oid();
        }
    }
    public override init() {
        let h = System_Security_Cryptography_ECCurve_implicit_ctor();
            super.init(hndl: h);
    }
    // System.Security.Cryptography.ECCurve CreateFromFriendlyName(System.String)
// docid: M:System.Security.Cryptography.ECCurve.CreateFromFriendlyName(System.String)
    /**
    Creates a named curve using the specified friendly name of the identifier.

    - Parameter oidFriendlyName: The friendly name of the identifier.
    - Returns: An object representing the named curve.

    */
    public class func CreateFromFriendlyName(oidFriendlyName : dotnet.System.String) throws -> dotnet.System.Security.Cryptography.ECCurve {
        var __thrown : NullableHandle = nil;
        let __return = System_Security_Cryptography_ECCurve_ECCurve__CreateFromFriendlyName_0__1__String(&__thrown, oidFriendlyName.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return dotnet.System.Security.Cryptography.ECCurve(hndl : __return);
        }
    }
    // System.Security.Cryptography.ECCurve CreateFromOid(System.Security.Cryptography.Oid)
// docid: M:System.Security.Cryptography.ECCurve.CreateFromOid(System.Security.Cryptography.Oid)
    /**
    Creates a named curve using the specified  object.

    - Parameter curveOid: The object identifier to use.
    - Returns: An object representing the named curve.

    */
    public class func CreateFromOid(curveOid : dotnet.System.Security.Cryptography.Oid) throws -> dotnet.System.Security.Cryptography.ECCurve {
        var __thrown : NullableHandle = nil;
        let __return = System_Security_Cryptography_ECCurve_ECCurve__CreateFromOid_0__1__Oid(&__thrown, curveOid.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return dotnet.System.Security.Cryptography.ECCurve(hndl : __return);
        }
    }
    // System.Security.Cryptography.ECCurve CreateFromValue(System.String)
// docid: M:System.Security.Cryptography.ECCurve.CreateFromValue(System.String)
    /**
    Creates a named curve using the specified dotted-decimal representation of the identifier.

    - Parameter oidValue: The dotted number of the identifier.
    - Returns: An object representing the named curve.

    */
    public class func CreateFromValue(oidValue : dotnet.System.String) throws -> dotnet.System.Security.Cryptography.ECCurve {
        var __thrown : NullableHandle = nil;
        let __return = System_Security_Cryptography_ECCurve_ECCurve__CreateFromValue_0__1__String(&__thrown, oidValue.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return dotnet.System.Security.Cryptography.ECCurve(hndl : __return);
        }
    }
    // void Validate()
// docid: M:System.Security.Cryptography.ECCurve.Validate
    /**
    Validates the integrity of the current curve. Throws a  exception if the structure is not valid.

    */
    public func Validate() throws {
        var __thrown : NullableHandle = nil;
        System_Security_Cryptography_ECCurve_void__Validate_0__0(&__thrown, self.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
            return;
        }
    }
    // [IsSpecialName] bool get_IsCharacteristic2()
// docid: M:System.Security.Cryptography.ECCurve.get_IsCharacteristic2
    public func get_IsCharacteristic2() throws -> Bool {
        var __thrown : NullableHandle = nil;
        let __return = System_Security_Cryptography_ECCurve_bool__get_IsCharacteristic2_0__0(&__thrown, self.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return (__return) != 0;
        }
    }
    // [IsSpecialName] bool get_IsExplicit()
// docid: M:System.Security.Cryptography.ECCurve.get_IsExplicit
    public func get_IsExplicit() throws -> Bool {
        var __thrown : NullableHandle = nil;
        let __return = System_Security_Cryptography_ECCurve_bool__get_IsExplicit_0__0(&__thrown, self.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return (__return) != 0;
        }
    }
    // [IsSpecialName] bool get_IsNamed()
// docid: M:System.Security.Cryptography.ECCurve.get_IsNamed
    public func get_IsNamed() throws -> Bool {
        var __thrown : NullableHandle = nil;
        let __return = System_Security_Cryptography_ECCurve_bool__get_IsNamed_0__0(&__thrown, self.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return (__return) != 0;
        }
    }
    // [IsSpecialName] bool get_IsPrime()
// docid: M:System.Security.Cryptography.ECCurve.get_IsPrime
    public func get_IsPrime() throws -> Bool {
        var __thrown : NullableHandle = nil;
        let __return = System_Security_Cryptography_ECCurve_bool__get_IsPrime_0__0(&__thrown, self.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return (__return) != 0;
        }
    }
    // [IsSpecialName] System.Security.Cryptography.Oid get_Oid()
// docid: M:System.Security.Cryptography.ECCurve.get_Oid
    public func get_Oid() throws -> dotnet.System.Security.Cryptography.Oid {
        var __thrown : NullableHandle = nil;
        let __return = System_Security_Cryptography_ECCurve_Oid__get_Oid_0__0(&__thrown, self.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return dotnet.System.Security.Cryptography.Oid(hndl : __return);
        }
    }
} // ECCurve


// type: System.Security.Cryptography.ECCurve+ECCurveType
    /**
    Indicates how to interpret the data contained in an  object.

    */
public struct ECCurve_ECCurveType : SGBridgeGenericValue {
    let v : Swift.Int32;
    public init(val: Swift.Int32) { self.v = val; }
    public func get_value() -> Swift.Int32 { return self.v; }
    public static func get_type_handle() -> TypeHandle {
        return System_Security_Cryptography_ECCurve_ECCurveType_get_type_handle();
    }
    public func to_gval() -> GVal { return GVal(self.v); }
    public func dup_gval() -> GVal { return to_gval(); }
    public init(gval: GVal) { self.v = Swift.Int32(gval); }
    // static field: System.Security.Cryptography.ECCurve+ECCurveType Implicit
    /**
    No curve data is interpreted. The caller is assumed to know what the curve is.

    */
    public static var Implicit : dotnet.System.Security.Cryptography.ECCurve_ECCurveType {
        get {
        let __return = dotnet.System.Security.Cryptography.ECCurve_ECCurveType(val: System_Security_Cryptography_ECCurve_ECCurveType_get_Implicit());
            return __return;
        }
    }
    // static field: System.Security.Cryptography.ECCurve+ECCurveType PrimeShortWeierstrass
    /**
    The curve parameters represent a prime curve with the formula y^2 = x^3 + A(ASTERISK)x + B in the prime field P.

    */
    public static var PrimeShortWeierstrass : dotnet.System.Security.Cryptography.ECCurve_ECCurveType {
        get {
        let __return = dotnet.System.Security.Cryptography.ECCurve_ECCurveType(val: System_Security_Cryptography_ECCurve_ECCurveType_get_PrimeShortWeierstrass());
            return __return;
        }
    }
    // static field: System.Security.Cryptography.ECCurve+ECCurveType PrimeTwistedEdwards
    /**
    The curve parameters represent a prime curve with the formula A(ASTERISK)x^2 + y^2 = 1 + B(ASTERISK)x^2(ASTERISK)y^2 in the prime field P.

    */
    public static var PrimeTwistedEdwards : dotnet.System.Security.Cryptography.ECCurve_ECCurveType {
        get {
        let __return = dotnet.System.Security.Cryptography.ECCurve_ECCurveType(val: System_Security_Cryptography_ECCurve_ECCurveType_get_PrimeTwistedEdwards());
            return __return;
        }
    }
    // static field: System.Security.Cryptography.ECCurve+ECCurveType PrimeMontgomery
    /**
    The curve parameters represent a prime curve with the formula B(ASTERISK)y^2 = x^3 + A(ASTERISK)x^2 + x.

    */
    public static var PrimeMontgomery : dotnet.System.Security.Cryptography.ECCurve_ECCurveType {
        get {
        let __return = dotnet.System.Security.Cryptography.ECCurve_ECCurveType(val: System_Security_Cryptography_ECCurve_ECCurveType_get_PrimeMontgomery());
            return __return;
        }
    }
    // static field: System.Security.Cryptography.ECCurve+ECCurveType Characteristic2
    /**
    The curve parameters represent a characteristic 2 curve.

    */
    public static var Characteristic2 : dotnet.System.Security.Cryptography.ECCurve_ECCurveType {
        get {
        let __return = dotnet.System.Security.Cryptography.ECCurve_ECCurveType(val: System_Security_Cryptography_ECCurve_ECCurveType_get_Characteristic2());
            return __return;
        }
    }
    // static field: System.Security.Cryptography.ECCurve+ECCurveType Named
    /**
    The curve parameters represent a named curve.

    */
    public static var Named : dotnet.System.Security.Cryptography.ECCurve_ECCurveType {
        get {
        let __return = dotnet.System.Security.Cryptography.ECCurve_ECCurveType(val: System_Security_Cryptography_ECCurve_ECCurveType_get_Named());
            return __return;
        }
    }
} // ECCurve_ECCurveType


// type: System.Security.Cryptography.ECCurve+NamedCurves
public struct ECCurve_NamedCurves {
    // [IsSpecialName] System.Security.Cryptography.ECCurve get_brainpoolP160r1()
// docid: M:System.Security.Cryptography.ECCurve.NamedCurves.get_brainpoolP160r1
    public static func get_brainpoolP160r1() throws -> dotnet.System.Security.Cryptography.ECCurve {
        var __thrown : NullableHandle = nil;
        let __return = System_Security_Cryptography_ECCurve_NamedCurves_ECCurve__get_brainpoolP160r1_0__0(&__thrown);
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return dotnet.System.Security.Cryptography.ECCurve(hndl : __return);
        }
    }
    // [IsSpecialName] System.Security.Cryptography.ECCurve get_brainpoolP160t1()
// docid: M:System.Security.Cryptography.ECCurve.NamedCurves.get_brainpoolP160t1
    public static func get_brainpoolP160t1() throws -> dotnet.System.Security.Cryptography.ECCurve {
        var __thrown : NullableHandle = nil;
        let __return = System_Security_Cryptography_ECCurve_NamedCurves_ECCurve__get_brainpoolP160t1_0__0(&__thrown);
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return dotnet.System.Security.Cryptography.ECCurve(hndl : __return);
        }
    }
    // [IsSpecialName] System.Security.Cryptography.ECCurve get_brainpoolP192r1()
// docid: M:System.Security.Cryptography.ECCurve.NamedCurves.get_brainpoolP192r1
    public static func get_brainpoolP192r1() throws -> dotnet.System.Security.Cryptography.ECCurve {
        var __thrown : NullableHandle = nil;
        let __return = System_Security_Cryptography_ECCurve_NamedCurves_ECCurve__get_brainpoolP192r1_0__0(&__thrown);
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return dotnet.System.Security.Cryptography.ECCurve(hndl : __return);
        }
    }
    // [IsSpecialName] System.Security.Cryptography.ECCurve get_brainpoolP192t1()
// docid: M:System.Security.Cryptography.ECCurve.NamedCurves.get_brainpoolP192t1
    public static func get_brainpoolP192t1() throws -> dotnet.System.Security.Cryptography.ECCurve {
        var __thrown : NullableHandle = nil;
        let __return = System_Security_Cryptography_ECCurve_NamedCurves_ECCurve__get_brainpoolP192t1_0__0(&__thrown);
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return dotnet.System.Security.Cryptography.ECCurve(hndl : __return);
        }
    }
    // [IsSpecialName] System.Security.Cryptography.ECCurve get_brainpoolP224r1()
// docid: M:System.Security.Cryptography.ECCurve.NamedCurves.get_brainpoolP224r1
    public static func get_brainpoolP224r1() throws -> dotnet.System.Security.Cryptography.ECCurve {
        var __thrown : NullableHandle = nil;
        let __return = System_Security_Cryptography_ECCurve_NamedCurves_ECCurve__get_brainpoolP224r1_0__0(&__thrown);
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return dotnet.System.Security.Cryptography.ECCurve(hndl : __return);
        }
    }
    // [IsSpecialName] System.Security.Cryptography.ECCurve get_brainpoolP224t1()
// docid: M:System.Security.Cryptography.ECCurve.NamedCurves.get_brainpoolP224t1
    public static func get_brainpoolP224t1() throws -> dotnet.System.Security.Cryptography.ECCurve {
        var __thrown : NullableHandle = nil;
        let __return = System_Security_Cryptography_ECCurve_NamedCurves_ECCurve__get_brainpoolP224t1_0__0(&__thrown);
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return dotnet.System.Security.Cryptography.ECCurve(hndl : __return);
        }
    }
    // [IsSpecialName] System.Security.Cryptography.ECCurve get_brainpoolP256r1()
// docid: M:System.Security.Cryptography.ECCurve.NamedCurves.get_brainpoolP256r1
    public static func get_brainpoolP256r1() throws -> dotnet.System.Security.Cryptography.ECCurve {
        var __thrown : NullableHandle = nil;
        let __return = System_Security_Cryptography_ECCurve_NamedCurves_ECCurve__get_brainpoolP256r1_0__0(&__thrown);
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return dotnet.System.Security.Cryptography.ECCurve(hndl : __return);
        }
    }
    // [IsSpecialName] System.Security.Cryptography.ECCurve get_brainpoolP256t1()
// docid: M:System.Security.Cryptography.ECCurve.NamedCurves.get_brainpoolP256t1
    public static func get_brainpoolP256t1() throws -> dotnet.System.Security.Cryptography.ECCurve {
        var __thrown : NullableHandle = nil;
        let __return = System_Security_Cryptography_ECCurve_NamedCurves_ECCurve__get_brainpoolP256t1_0__0(&__thrown);
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return dotnet.System.Security.Cryptography.ECCurve(hndl : __return);
        }
    }
    // [IsSpecialName] System.Security.Cryptography.ECCurve get_brainpoolP320r1()
// docid: M:System.Security.Cryptography.ECCurve.NamedCurves.get_brainpoolP320r1
    public static func get_brainpoolP320r1() throws -> dotnet.System.Security.Cryptography.ECCurve {
        var __thrown : NullableHandle = nil;
        let __return = System_Security_Cryptography_ECCurve_NamedCurves_ECCurve__get_brainpoolP320r1_0__0(&__thrown);
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return dotnet.System.Security.Cryptography.ECCurve(hndl : __return);
        }
    }
    // [IsSpecialName] System.Security.Cryptography.ECCurve get_brainpoolP320t1()
// docid: M:System.Security.Cryptography.ECCurve.NamedCurves.get_brainpoolP320t1
    public static func get_brainpoolP320t1() throws -> dotnet.System.Security.Cryptography.ECCurve {
        var __thrown : NullableHandle = nil;
        let __return = System_Security_Cryptography_ECCurve_NamedCurves_ECCurve__get_brainpoolP320t1_0__0(&__thrown);
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return dotnet.System.Security.Cryptography.ECCurve(hndl : __return);
        }
    }
    // [IsSpecialName] System.Security.Cryptography.ECCurve get_brainpoolP384r1()
// docid: M:System.Security.Cryptography.ECCurve.NamedCurves.get_brainpoolP384r1
    public static func get_brainpoolP384r1() throws -> dotnet.System.Security.Cryptography.ECCurve {
        var __thrown : NullableHandle = nil;
        let __return = System_Security_Cryptography_ECCurve_NamedCurves_ECCurve__get_brainpoolP384r1_0__0(&__thrown);
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return dotnet.System.Security.Cryptography.ECCurve(hndl : __return);
        }
    }
    // [IsSpecialName] System.Security.Cryptography.ECCurve get_brainpoolP384t1()
// docid: M:System.Security.Cryptography.ECCurve.NamedCurves.get_brainpoolP384t1
    public static func get_brainpoolP384t1() throws -> dotnet.System.Security.Cryptography.ECCurve {
        var __thrown : NullableHandle = nil;
        let __return = System_Security_Cryptography_ECCurve_NamedCurves_ECCurve__get_brainpoolP384t1_0__0(&__thrown);
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return dotnet.System.Security.Cryptography.ECCurve(hndl : __return);
        }
    }
    // [IsSpecialName] System.Security.Cryptography.ECCurve get_brainpoolP512r1()
// docid: M:System.Security.Cryptography.ECCurve.NamedCurves.get_brainpoolP512r1
    public static func get_brainpoolP512r1() throws -> dotnet.System.Security.Cryptography.ECCurve {
        var __thrown : NullableHandle = nil;
        let __return = System_Security_Cryptography_ECCurve_NamedCurves_ECCurve__get_brainpoolP512r1_0__0(&__thrown);
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return dotnet.System.Security.Cryptography.ECCurve(hndl : __return);
        }
    }
    // [IsSpecialName] System.Security.Cryptography.ECCurve get_brainpoolP512t1()
// docid: M:System.Security.Cryptography.ECCurve.NamedCurves.get_brainpoolP512t1
    public static func get_brainpoolP512t1() throws -> dotnet.System.Security.Cryptography.ECCurve {
        var __thrown : NullableHandle = nil;
        let __return = System_Security_Cryptography_ECCurve_NamedCurves_ECCurve__get_brainpoolP512t1_0__0(&__thrown);
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return dotnet.System.Security.Cryptography.ECCurve(hndl : __return);
        }
    }
    // [IsSpecialName] System.Security.Cryptography.ECCurve get_nistP256()
// docid: M:System.Security.Cryptography.ECCurve.NamedCurves.get_nistP256
    public static func get_nistP256() throws -> dotnet.System.Security.Cryptography.ECCurve {
        var __thrown : NullableHandle = nil;
        let __return = System_Security_Cryptography_ECCurve_NamedCurves_ECCurve__get_nistP256_0__0(&__thrown);
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return dotnet.System.Security.Cryptography.ECCurve(hndl : __return);
        }
    }
    // [IsSpecialName] System.Security.Cryptography.ECCurve get_nistP384()
// docid: M:System.Security.Cryptography.ECCurve.NamedCurves.get_nistP384
    public static func get_nistP384() throws -> dotnet.System.Security.Cryptography.ECCurve {
        var __thrown : NullableHandle = nil;
        let __return = System_Security_Cryptography_ECCurve_NamedCurves_ECCurve__get_nistP384_0__0(&__thrown);
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return dotnet.System.Security.Cryptography.ECCurve(hndl : __return);
        }
    }
    // [IsSpecialName] System.Security.Cryptography.ECCurve get_nistP521()
// docid: M:System.Security.Cryptography.ECCurve.NamedCurves.get_nistP521
    public static func get_nistP521() throws -> dotnet.System.Security.Cryptography.ECCurve {
        var __thrown : NullableHandle = nil;
        let __return = System_Security_Cryptography_ECCurve_NamedCurves_ECCurve__get_nistP521_0__0(&__thrown);
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return dotnet.System.Security.Cryptography.ECCurve(hndl : __return);
        }
    }
    /**
    Gets a brainpoolP160r1 named curve.

    */
    public static var brainpoolP160r1 : dotnet.System.Security.Cryptography.ECCurve {
        get {
            return try! get_brainpoolP160r1();
        }
    }
    /**
    Gets a brainpoolP160t1 named curve.

    */
    public static var brainpoolP160t1 : dotnet.System.Security.Cryptography.ECCurve {
        get {
            return try! get_brainpoolP160t1();
        }
    }
    /**
    Gets a brainpoolP192r1 named curve.

    */
    public static var brainpoolP192r1 : dotnet.System.Security.Cryptography.ECCurve {
        get {
            return try! get_brainpoolP192r1();
        }
    }
    /**
    Gets a brainpoolP192t1 named curve.

    */
    public static var brainpoolP192t1 : dotnet.System.Security.Cryptography.ECCurve {
        get {
            return try! get_brainpoolP192t1();
        }
    }
    /**
    Gets a brainpoolP224r1 named curve.

    */
    public static var brainpoolP224r1 : dotnet.System.Security.Cryptography.ECCurve {
        get {
            return try! get_brainpoolP224r1();
        }
    }
    /**
    Gets a brainpoolP224t1 named curve.

    */
    public static var brainpoolP224t1 : dotnet.System.Security.Cryptography.ECCurve {
        get {
            return try! get_brainpoolP224t1();
        }
    }
    /**
    Gets a brainpoolP256r1 named curve.

    */
    public static var brainpoolP256r1 : dotnet.System.Security.Cryptography.ECCurve {
        get {
            return try! get_brainpoolP256r1();
        }
    }
    /**
    Gets a brainpoolP256t1 named curve.

    */
    public static var brainpoolP256t1 : dotnet.System.Security.Cryptography.ECCurve {
        get {
            return try! get_brainpoolP256t1();
        }
    }
    /**
    Gets a brainpoolP320r1 named curve.

    */
    public static var brainpoolP320r1 : dotnet.System.Security.Cryptography.ECCurve {
        get {
            return try! get_brainpoolP320r1();
        }
    }
    /**
    Gets a brainpoolP320t1 named curve.

    */
    public static var brainpoolP320t1 : dotnet.System.Security.Cryptography.ECCurve {
        get {
            return try! get_brainpoolP320t1();
        }
    }
    /**
    Gets a brainpoolP384r1 named curve.

    */
    public static var brainpoolP384r1 : dotnet.System.Security.Cryptography.ECCurve {
        get {
            return try! get_brainpoolP384r1();
        }
    }
    /**
    Gets a brainpoolP384t1 named curve.

    */
    public static var brainpoolP384t1 : dotnet.System.Security.Cryptography.ECCurve {
        get {
            return try! get_brainpoolP384t1();
        }
    }
    /**
    Gets a brainpoolP512r1 named curve.

    */
    public static var brainpoolP512r1 : dotnet.System.Security.Cryptography.ECCurve {
        get {
            return try! get_brainpoolP512r1();
        }
    }
    /**
    Gets a brainpoolP512t1 named curve.

    */
    public static var brainpoolP512t1 : dotnet.System.Security.Cryptography.ECCurve {
        get {
            return try! get_brainpoolP512t1();
        }
    }
    /**
    Gets a nistP256 named curve.

    */
    public static var nistP256 : dotnet.System.Security.Cryptography.ECCurve {
        get {
            return try! get_nistP256();
        }
    }
    /**
    Gets a nistP384 named curve.

    */
    public static var nistP384 : dotnet.System.Security.Cryptography.ECCurve {
        get {
            return try! get_nistP384();
        }
    }
    /**
    Gets a nistP521 named curve.

    */
    public static var nistP521 : dotnet.System.Security.Cryptography.ECCurve {
        get {
            return try! get_nistP521();
        }
    }
} // ECCurve_NamedCurves


// type: System.Security.Cryptography.ECDiffieHellman
    /**
    Provides an abstract base class that Elliptic Curve Diffie-Hellman (ECDH) algorithm implementations can derive from. This class provides the basic set of operations that all ECDH implementations must support.

    */
open class ECDiffieHellman
    :
    dotnet.System.Security.Cryptography.AsymmetricAlgorithm
{
    open class override func get_type_handle() -> TypeHandle {
        return System_Security_Cryptography_ECDiffieHellman_get_type_handle();
    }
    public required init(hndl: NonnullHandle) { super.init(hndl: hndl); }
    public required init(gval: GVal) { super.init(gval: gval); }
    // System.Security.Cryptography.ECDiffieHellman Create()
// docid: M:System.Security.Cryptography.ECDiffieHellman.Create
    /**
    Creates a new instance of the default implementation of the Elliptic Curve Diffie-Hellman (ECDH) algorithm.

    - Returns: A new instance of the default implementation of this class.

    */
    open class override func Create() throws -> dotnet.System.Security.Cryptography.ECDiffieHellman {
        var __thrown : NullableHandle = nil;
        let __return = System_Security_Cryptography_ECDiffieHellman_ECDiffieHellman__Create_0__0(&__thrown);
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return dotnet.System.Security.Cryptography.ECDiffieHellman(hndl : __return);
        }
    }
    // System.Security.Cryptography.ECDiffieHellman Create(System.Security.Cryptography.ECCurve)
// docid: M:System.Security.Cryptography.ECDiffieHellman.Create(System.Security.Cryptography.ECCurve)
    /**
    Creates a new instance of the default implementation of the Elliptic Curve Diffie-Hellman (ECDH) algorithm with a new public/private key-pair generated over the specified curve.

    - Parameter curve: The curve to use to generate a new public/private key-pair.
    - Returns: A new instance of the default implementation of the Elliptic Curve Diffie-Hellman (ECDH) algorithm.

    */
    open class func Create(curve : dotnet.System.Security.Cryptography.ECCurve) throws -> dotnet.System.Security.Cryptography.ECDiffieHellman {
        var __thrown : NullableHandle = nil;
        let __return = System_Security_Cryptography_ECDiffieHellman_ECDiffieHellman__Create_0__1__ECCurve(&__thrown, curve.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return dotnet.System.Security.Cryptography.ECDiffieHellman(hndl : __return);
        }
    }
    // System.Security.Cryptography.ECDiffieHellman Create(System.Security.Cryptography.ECParameters)
// docid: M:System.Security.Cryptography.ECDiffieHellman.Create(System.Security.Cryptography.ECParameters)
    /**
    Creates a new instance of the default implementation of the Elliptic Curve Diffie-Hellman (ECDH) algorithm with the key described by the specified   object.

    - Parameter parameters: The parameters  for the elliptic curve cryptography (ECC) algorithm.
    - Returns: A new instance of the default implementation of the Elliptic Curve Diffie-Hellman (ECDH) algorithm.

    */
    open class func Create(parameters : dotnet.System.Security.Cryptography.ECParameters) throws -> dotnet.System.Security.Cryptography.ECDiffieHellman {
        var __thrown : NullableHandle = nil;
        let __return = System_Security_Cryptography_ECDiffieHellman_ECDiffieHellman__Create_0__1__ECParameters(&__thrown, parameters.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return dotnet.System.Security.Cryptography.ECDiffieHellman(hndl : __return);
        }
    }
    // System.Security.Cryptography.ECDiffieHellman Create(System.String)
// docid: M:System.Security.Cryptography.ECDiffieHellman.Create(System.String)
    /**
    Creates a new instance of the specified implementation of the Elliptic Curve Diffie-Hellman (ECDH) algorithm.

    - Parameter algorithm: The name of an implementation of the ECDH algorithm.
    - Returns: A new instance of the specified implementation of this class. If the specified algorithm name does not map to an ECDH implementation, this method returns .

    */
    open class func Create(algorithm : dotnet.System.String) throws -> Optional<dotnet.System.Security.Cryptography.ECDiffieHellman> {
        var __thrown : NullableHandle = nil;
        let __return = System_Security_Cryptography_ECDiffieHellman_ECDiffieHellman__Create_0__1__String(&__thrown, algorithm.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        if let __ret_unwrapped = __return {
            return dotnet.System.Security.Cryptography.ECDiffieHellman(hndl : __ret_unwrapped);
        } else {
            return nil;
        }
        }
    }
    // System.Byte[] DeriveKeyFromHash(System.Security.Cryptography.ECDiffieHellmanPublicKey, System.Security.Cryptography.HashAlgorithmName)
// docid: M:System.Security.Cryptography.ECDiffieHellman.DeriveKeyFromHash(System.Security.Cryptography.ECDiffieHellmanPublicKey,System.Security.Cryptography.HashAlgorithmName)
    /**
    Performs key derivation using a specified hash algorithm.

    - Parameter otherPartyPublicKey: The other party's public key.
    - Parameter hashAlgorithm: The hash algorithm to use to derive the key material.
    - Returns: The hash of the shared secret.

    */
    open func DeriveKeyFromHash(otherPartyPublicKey : dotnet.System.Security.Cryptography.ECDiffieHellmanPublicKey, hashAlgorithm : dotnet.System.Security.Cryptography.HashAlgorithmName) throws -> dotnet.System_Arr<Swift.UInt8> {
        var __thrown : NullableHandle = nil;
        let __return = System_Security_Cryptography_ECDiffieHellman_u8Array__DeriveKeyFromHash_0__2__ECDiffieHellmanPublicKey_HashAlgorithmName(&__thrown, self.get_handle(), otherPartyPublicKey.get_handle(), hashAlgorithm.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return dotnet.System_Arr<Swift.UInt8>(hndl : __return);
        }
    }
    // System.Byte[] DeriveKeyFromHash(System.Security.Cryptography.ECDiffieHellmanPublicKey, System.Security.Cryptography.HashAlgorithmName, System.Byte[], System.Byte[])
// docid: M:System.Security.Cryptography.ECDiffieHellman.DeriveKeyFromHash(System.Security.Cryptography.ECDiffieHellmanPublicKey,System.Security.Cryptography.HashAlgorithmName,System.Byte[],System.Byte[])
    /**
    When implemented in a derived class, performs key derivation using a specified hash algorithm with optional prepended or appended data.

    - Parameter otherPartyPublicKey: The other party's public key.
    - Parameter hashAlgorithm: The hash algorithm to use to derive the key material.
    - Parameter secretPrepend: A value to prepend to the derived secret before hashing.
    - Parameter secretAppend: A value to append to the derived secret before hashing.
    - Returns: The hash of the shared secret after prepending or appending data as requested.

    */
    open func DeriveKeyFromHash(otherPartyPublicKey : dotnet.System.Security.Cryptography.ECDiffieHellmanPublicKey, hashAlgorithm : dotnet.System.Security.Cryptography.HashAlgorithmName, secretPrepend : Optional<dotnet.System_Arr<Swift.UInt8>>, secretAppend : Optional<dotnet.System_Arr<Swift.UInt8>>) throws -> dotnet.System_Arr<Swift.UInt8> {
        var __thrown : NullableHandle = nil;
        let __return = System_Security_Cryptography_ECDiffieHellman_u8Array__DeriveKeyFromHash_0__4__ECDiffieHellmanPublicKey_HashAlgorithmName_u8Array_u8Array(&__thrown, self.get_handle(), otherPartyPublicKey.get_handle(), hashAlgorithm.get_handle(), (secretPrepend?.get_handle()), (secretAppend?.get_handle()));
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return dotnet.System_Arr<Swift.UInt8>(hndl : __return);
        }
    }
    // System.Byte[] DeriveKeyFromHmac(System.Security.Cryptography.ECDiffieHellmanPublicKey, System.Security.Cryptography.HashAlgorithmName, System.Byte[])
// docid: M:System.Security.Cryptography.ECDiffieHellman.DeriveKeyFromHmac(System.Security.Cryptography.ECDiffieHellmanPublicKey,System.Security.Cryptography.HashAlgorithmName,System.Byte[])
    /**
    Performs key derivation using a specified HMAC (Hash-based Message Authentication Code) algorithm.

    - Parameter otherPartyPublicKey: The other party's public key.
    - Parameter hashAlgorithm: The hash algorithm to use to derive the key material.
    - Parameter hmacKey: The key for the HMAC.
    - Returns: The HMAC of the shared secret.

    */
    open func DeriveKeyFromHmac(otherPartyPublicKey : dotnet.System.Security.Cryptography.ECDiffieHellmanPublicKey, hashAlgorithm : dotnet.System.Security.Cryptography.HashAlgorithmName, hmacKey : Optional<dotnet.System_Arr<Swift.UInt8>>) throws -> dotnet.System_Arr<Swift.UInt8> {
        var __thrown : NullableHandle = nil;
        let __return = System_Security_Cryptography_ECDiffieHellman_u8Array__DeriveKeyFromHmac_0__3__ECDiffieHellmanPublicKey_HashAlgorithmName_u8Array(&__thrown, self.get_handle(), otherPartyPublicKey.get_handle(), hashAlgorithm.get_handle(), (hmacKey?.get_handle()));
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return dotnet.System_Arr<Swift.UInt8>(hndl : __return);
        }
    }
    // System.Byte[] DeriveKeyFromHmac(System.Security.Cryptography.ECDiffieHellmanPublicKey, System.Security.Cryptography.HashAlgorithmName, System.Byte[], System.Byte[], System.Byte[])
// docid: M:System.Security.Cryptography.ECDiffieHellman.DeriveKeyFromHmac(System.Security.Cryptography.ECDiffieHellmanPublicKey,System.Security.Cryptography.HashAlgorithmName,System.Byte[],System.Byte[],System.Byte[])
    /**
    When implemented in a derived class, performs key derivation using a specified HMAC (Hash-based Message Authentication Code) algorithm with optional prepended or appended data.

    - Parameter otherPartyPublicKey: The other party's public key.
    - Parameter hashAlgorithm: The hash algorithm to use to derive the key material.
    - Parameter hmacKey: The key for the HMAC.
    - Parameter secretPrepend: A value to prepend to the derived secret before hashing.
    - Parameter secretAppend: A value to append to the derived secret before hashing.
    - Returns: The HMAC of the shared secret after prepending or appending data as requested.

    */
    open func DeriveKeyFromHmac(otherPartyPublicKey : dotnet.System.Security.Cryptography.ECDiffieHellmanPublicKey, hashAlgorithm : dotnet.System.Security.Cryptography.HashAlgorithmName, hmacKey : Optional<dotnet.System_Arr<Swift.UInt8>>, secretPrepend : Optional<dotnet.System_Arr<Swift.UInt8>>, secretAppend : Optional<dotnet.System_Arr<Swift.UInt8>>) throws -> dotnet.System_Arr<Swift.UInt8> {
        var __thrown : NullableHandle = nil;
        let __return = System_Security_Cryptography_ECDiffieHellman_u8Array__DeriveKeyFromHmac_0__5__ECDiffieHellmanPublicKey_HashAlgorithmName_u8Array_u8Array_u8Array(&__thrown, self.get_handle(), otherPartyPublicKey.get_handle(), hashAlgorithm.get_handle(), (hmacKey?.get_handle()), (secretPrepend?.get_handle()), (secretAppend?.get_handle()));
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return dotnet.System_Arr<Swift.UInt8>(hndl : __return);
        }
    }
    // System.Byte[] DeriveKeyMaterial(System.Security.Cryptography.ECDiffieHellmanPublicKey)
// docid: M:System.Security.Cryptography.ECDiffieHellman.DeriveKeyMaterial(System.Security.Cryptography.ECDiffieHellmanPublicKey)
    /**
    When implemented in a derived class, performs a key derivation on the shared secret.

    - Parameter otherPartyPublicKey: The other party's public key.
    - Returns: The result of the key derivation function, using the shared secret as an input.

    */
    open func DeriveKeyMaterial(otherPartyPublicKey : dotnet.System.Security.Cryptography.ECDiffieHellmanPublicKey) throws -> dotnet.System_Arr<Swift.UInt8> {
        var __thrown : NullableHandle = nil;
        let __return = System_Security_Cryptography_ECDiffieHellman_u8Array__DeriveKeyMaterial_0__1__ECDiffieHellmanPublicKey(&__thrown, self.get_handle(), otherPartyPublicKey.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return dotnet.System_Arr<Swift.UInt8>(hndl : __return);
        }
    }
    // System.Byte[] DeriveKeyTls(System.Security.Cryptography.ECDiffieHellmanPublicKey, System.Byte[], System.Byte[])
// docid: M:System.Security.Cryptography.ECDiffieHellman.DeriveKeyTls(System.Security.Cryptography.ECDiffieHellmanPublicKey,System.Byte[],System.Byte[])
    /**
    When implemented in a derived class, performs key derivation using the TLS (Transport Layer Security) 1.1 PRF (Pseudo-Random Function).

    - Parameter otherPartyPublicKey: The other party's public key.
    - Parameter prfLabel: The ASCII-encoded PRF label.
    - Parameter prfSeed: The 64-byte PRF seed.
    - Returns: The first 48 bytes from the TLS 1.1 PRF, using the shared secret as the key.

    */
    open func DeriveKeyTls(otherPartyPublicKey : dotnet.System.Security.Cryptography.ECDiffieHellmanPublicKey, prfLabel : dotnet.System_Arr<Swift.UInt8>, prfSeed : dotnet.System_Arr<Swift.UInt8>) throws -> dotnet.System_Arr<Swift.UInt8> {
        var __thrown : NullableHandle = nil;
        let __return = System_Security_Cryptography_ECDiffieHellman_u8Array__DeriveKeyTls_0__3__ECDiffieHellmanPublicKey_u8Array_u8Array(&__thrown, self.get_handle(), otherPartyPublicKey.get_handle(), prfLabel.get_handle(), prfSeed.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return dotnet.System_Arr<Swift.UInt8>(hndl : __return);
        }
    }
    // System.Byte[] ExportECPrivateKey()
// docid: M:System.Security.Cryptography.ECDiffieHellman.ExportECPrivateKey
    /**
    Exports the current key in the ECPrivateKey format.

    - Returns: A byte array containing the ECPrivateKey representation of this key.

    */
    open func ExportECPrivateKey() throws -> dotnet.System_Arr<Swift.UInt8> {
        var __thrown : NullableHandle = nil;
        let __return = System_Security_Cryptography_ECDiffieHellman_u8Array__ExportECPrivateKey_0__0(&__thrown, self.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return dotnet.System_Arr<Swift.UInt8>(hndl : __return);
        }
    }
    // System.Security.Cryptography.ECParameters ExportExplicitParameters(bool)
// docid: M:System.Security.Cryptography.ECDiffieHellman.ExportExplicitParameters(System.Boolean)
    /**
    When overridden in a derived class, exports either the public or the public and private key information using the explicit curve form from a working  key to an  structure so that it can be passed to the  method.

    - Parameter includePrivateParameters: 
         to include private parameters; otherwise, .
    - Returns: An object that represents the point on the curve for this key, using the explicit curve format.

    */
    open func ExportExplicitParameters(includePrivateParameters : Bool) throws -> dotnet.System.Security.Cryptography.ECParameters {
        var __thrown : NullableHandle = nil;
        let __return = System_Security_Cryptography_ECDiffieHellman_ECParameters__ExportExplicitParameters_0__1__bool(&__thrown, self.get_handle(), Swift.Int32(includePrivateParameters ? 1 : 0));
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return dotnet.System.Security.Cryptography.ECParameters(hndl : __return);
        }
    }
    // System.Security.Cryptography.ECParameters ExportParameters(bool)
// docid: M:System.Security.Cryptography.ECDiffieHellman.ExportParameters(System.Boolean)
    /**
    When overridden in a derived class, exports either the public or the public and private key information from a working  key to an  structure so that it can be passed to the  method.

    - Parameter includePrivateParameters: 
         to include private parameters; otherwise,  to include public parameters only.
    - Returns: An object that represents the point on the curve for this key. It can be passed to the  method.

    */
    open func ExportParameters(includePrivateParameters : Bool) throws -> dotnet.System.Security.Cryptography.ECParameters {
        var __thrown : NullableHandle = nil;
        let __return = System_Security_Cryptography_ECDiffieHellman_ECParameters__ExportParameters_0__1__bool(&__thrown, self.get_handle(), Swift.Int32(includePrivateParameters ? 1 : 0));
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return dotnet.System.Security.Cryptography.ECParameters(hndl : __return);
        }
    }
    // void FromXmlString(System.String)
// docid: M:System.Security.Cryptography.ECDiffieHellman.FromXmlString(System.String)
    /**
    This method throws in all cases.

    - Parameter xmlString: The XML string to use to reconstruct the  object.
    */
    open override func FromXmlString(xmlString : dotnet.System.String) throws {
        var __thrown : NullableHandle = nil;
        System_Security_Cryptography_ECDiffieHellman_void__FromXmlString_0__1__String(&__thrown, self.get_handle(), xmlString.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
            return;
        }
    }
    // void GenerateKey(System.Security.Cryptography.ECCurve)
// docid: M:System.Security.Cryptography.ECDiffieHellman.GenerateKey(System.Security.Cryptography.ECCurve)
    /**
    When overridden in a derived class, generates a new ephemeral public/private key pair for the specified curve.

    - Parameter curve: The curve used to generate an ephemeral public/private key pair.
    */
    open func GenerateKey(curve : dotnet.System.Security.Cryptography.ECCurve) throws {
        var __thrown : NullableHandle = nil;
        System_Security_Cryptography_ECDiffieHellman_void__GenerateKey_0__1__ECCurve(&__thrown, self.get_handle(), curve.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
            return;
        }
    }
// TODO COPE (write_all_methods) (span) void ImportECPrivateKey(System.ReadOnlySpan<System.Byte>, ref System.Int32)
// TODO COPE (write_all_methods) (span) void ImportEncryptedPkcs8PrivateKey(System.ReadOnlySpan<System.Byte>, System.ReadOnlySpan<System.Byte>, ref System.Int32)
// TODO COPE (write_all_methods) (span) void ImportEncryptedPkcs8PrivateKey(System.ReadOnlySpan<System.Char>, System.ReadOnlySpan<System.Byte>, ref System.Int32)
// TODO COPE (write_all_methods) (span) void ImportFromEncryptedPem(System.ReadOnlySpan<System.Char>, System.ReadOnlySpan<System.Byte>)
// TODO COPE (write_all_methods) (span) void ImportFromEncryptedPem(System.ReadOnlySpan<System.Char>, System.ReadOnlySpan<System.Char>)
// TODO COPE (write_all_methods) (span) void ImportFromPem(System.ReadOnlySpan<System.Char>)
    // void ImportParameters(System.Security.Cryptography.ECParameters)
// docid: M:System.Security.Cryptography.ECDiffieHellman.ImportParameters(System.Security.Cryptography.ECParameters)
    /**
    When overridden in a derived class, imports the specified parameters for an  as an ephemeral key into the current  object.

    - Parameter parameters: The curve's parameters to import.
    */
    open func ImportParameters(parameters : dotnet.System.Security.Cryptography.ECParameters) throws {
        var __thrown : NullableHandle = nil;
        System_Security_Cryptography_ECDiffieHellman_void__ImportParameters_0__1__ECParameters(&__thrown, self.get_handle(), parameters.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
            return;
        }
    }
// TODO COPE (write_all_methods) (span) void ImportPkcs8PrivateKey(System.ReadOnlySpan<System.Byte>, ref System.Int32)
// TODO COPE (write_all_methods) (span) void ImportSubjectPublicKeyInfo(System.ReadOnlySpan<System.Byte>, ref System.Int32)
    // System.String ToXmlString(bool)
// docid: M:System.Security.Cryptography.ECDiffieHellman.ToXmlString(System.Boolean)
    /**
    This method throws in all cases.

    - Parameter includePrivateParameters: 
         to include private parameters; otherwise, .
    - Returns: This method does not return a value.

    */
    open override func ToXmlString(includePrivateParameters : Bool) throws -> dotnet.System.String {
        var __thrown : NullableHandle = nil;
        let __return = System_Security_Cryptography_ECDiffieHellman_String__ToXmlString_0__1__bool(&__thrown, self.get_handle(), Swift.Int32(includePrivateParameters ? 1 : 0));
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return dotnet.System.String(hndl : __return);
        }
    }
// TODO COPE (write_all_methods) (span) bool TryExportECPrivateKey(System.Span<System.Byte>, ref System.Int32)
// TODO COPE (write_all_methods) (span) bool TryExportEncryptedPkcs8PrivateKey(System.ReadOnlySpan<System.Byte>, System.Security.Cryptography.PbeParameters, System.Span<System.Byte>, ref System.Int32)
// TODO COPE (write_all_methods) (span) bool TryExportEncryptedPkcs8PrivateKey(System.ReadOnlySpan<System.Char>, System.Security.Cryptography.PbeParameters, System.Span<System.Byte>, ref System.Int32)
// TODO COPE (write_all_methods) (span) bool TryExportPkcs8PrivateKey(System.Span<System.Byte>, ref System.Int32)
// TODO COPE (write_all_methods) (span) bool TryExportSubjectPublicKeyInfo(System.Span<System.Byte>, ref System.Int32)
    // [IsSpecialName] System.String get_KeyExchangeAlgorithm()
// docid: M:System.Security.Cryptography.ECDiffieHellman.get_KeyExchangeAlgorithm
    open override func get_KeyExchangeAlgorithm() throws -> dotnet.System.String {
        var __thrown : NullableHandle = nil;
        let __return = System_Security_Cryptography_ECDiffieHellman_String__get_KeyExchangeAlgorithm_0__0(&__thrown, self.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return dotnet.System.String(hndl : __return);
        }
    }
    // [IsSpecialName] System.Security.Cryptography.ECDiffieHellmanPublicKey get_PublicKey()
// docid: M:System.Security.Cryptography.ECDiffieHellman.get_PublicKey
    open func get_PublicKey() throws -> dotnet.System.Security.Cryptography.ECDiffieHellmanPublicKey {
        var __thrown : NullableHandle = nil;
        let __return = System_Security_Cryptography_ECDiffieHellman_ECDiffieHellmanPublicKey__get_PublicKey_0__0(&__thrown, self.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return dotnet.System.Security.Cryptography.ECDiffieHellmanPublicKey(hndl : __return);
        }
    }
    // [IsSpecialName] System.String get_SignatureAlgorithm()
// docid: M:System.Security.Cryptography.ECDiffieHellman.get_SignatureAlgorithm
    open override func get_SignatureAlgorithm() throws -> Optional<dotnet.System.String> {
        var __thrown : NullableHandle = nil;
        let __return = System_Security_Cryptography_ECDiffieHellman_String__get_SignatureAlgorithm_0__0(&__thrown, self.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        if let __ret_unwrapped = __return {
            return dotnet.System.String(hndl : __ret_unwrapped);
        } else {
            return nil;
        }
        }
    }
    /**
    Gets the name of the key exchange algorithm.

    */
    open override var KeyExchangeAlgorithm : dotnet.System.String {
        get {
            return try! get_KeyExchangeAlgorithm();
        }
    }
    /**
    Gets the public key that is being used by the current Elliptic Curve Diffie-Hellman (ECDH) instance.

    */
    open var PublicKey : dotnet.System.Security.Cryptography.ECDiffieHellmanPublicKey {
        get {
            return try! get_PublicKey();
        }
    }
    /**
    Gets the name of the signature algorithm.

    */
    open override var SignatureAlgorithm : Optional<dotnet.System.String> {
        get {
            return try! get_SignatureAlgorithm();
        }
    }
} // ECDiffieHellman


// type: System.Security.Cryptography.ECDiffieHellmanPublicKey
    /**
    Provides an abstract base class from which all  implementations must inherit.

    */
open class ECDiffieHellmanPublicKey
    :
    dotnet.System.Object,
    System_IDisposable
{
    open class override func get_type_handle() -> TypeHandle {
        return System_Security_Cryptography_ECDiffieHellmanPublicKey_get_type_handle();
    }
    public required init(hndl: NonnullHandle) { super.init(hndl: hndl); }
    public required init(gval: GVal) { super.init(gval: gval); }
    // void Dispose()
// docid: M:System.Security.Cryptography.ECDiffieHellmanPublicKey.Dispose
    /**
    Releases all resources used by the current instance of the  class.

    */
    open /* method final */ func Dispose() throws {
        var __thrown : NullableHandle = nil;
        System_Security_Cryptography_ECDiffieHellmanPublicKey_void__Dispose_0__0(&__thrown, self.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
            return;
        }
    }
    // System.Security.Cryptography.ECParameters ExportExplicitParameters()
// docid: M:System.Security.Cryptography.ECDiffieHellmanPublicKey.ExportExplicitParameters
    /**
    When overridden in a derived class, exports the explicit  for an  object.

    - Returns: An object that represents the point on the curve for this key, using the explicit curve format.

    */
    open func ExportExplicitParameters() throws -> dotnet.System.Security.Cryptography.ECParameters {
        var __thrown : NullableHandle = nil;
        let __return = System_Security_Cryptography_ECDiffieHellmanPublicKey_ECParameters__ExportExplicitParameters_0__0(&__thrown, self.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return dotnet.System.Security.Cryptography.ECParameters(hndl : __return);
        }
    }
    // System.Security.Cryptography.ECParameters ExportParameters()
// docid: M:System.Security.Cryptography.ECDiffieHellmanPublicKey.ExportParameters
    /**
    When overridden in a derived class, exports the named or explicit  for an  object.

    - Returns: An object that represents the point on the curve for this key.

    */
    open func ExportParameters() throws -> dotnet.System.Security.Cryptography.ECParameters {
        var __thrown : NullableHandle = nil;
        let __return = System_Security_Cryptography_ECDiffieHellmanPublicKey_ECParameters__ExportParameters_0__0(&__thrown, self.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return dotnet.System.Security.Cryptography.ECParameters(hndl : __return);
        }
    }
    // System.Byte[] ExportSubjectPublicKeyInfo()
// docid: M:System.Security.Cryptography.ECDiffieHellmanPublicKey.ExportSubjectPublicKeyInfo
    open func ExportSubjectPublicKeyInfo() throws -> dotnet.System_Arr<Swift.UInt8> {
        var __thrown : NullableHandle = nil;
        let __return = System_Security_Cryptography_ECDiffieHellmanPublicKey_u8Array__ExportSubjectPublicKeyInfo_0__0(&__thrown, self.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return dotnet.System_Arr<Swift.UInt8>(hndl : __return);
        }
    }
    // System.Byte[] ToByteArray()
// docid: M:System.Security.Cryptography.ECDiffieHellmanPublicKey.ToByteArray
    /**
    Serializes the  key BLOB to a byte array.

    - Returns: A byte array that contains the serialized Elliptic Curve Diffie-Hellman (ECDH) public key.

    */
    open func ToByteArray() throws -> dotnet.System_Arr<Swift.UInt8> {
        var __thrown : NullableHandle = nil;
        let __return = System_Security_Cryptography_ECDiffieHellmanPublicKey_u8Array__ToByteArray_0__0(&__thrown, self.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return dotnet.System_Arr<Swift.UInt8>(hndl : __return);
        }
    }
    // System.String ToXmlString()
// docid: M:System.Security.Cryptography.ECDiffieHellmanPublicKey.ToXmlString
    /**
    Serializes the  public key to an XML string.

    - Returns: An XML string that contains the serialized Elliptic Curve Diffie-Hellman (ECDH) public key.

    */
    open func ToXmlString() throws -> dotnet.System.String {
        var __thrown : NullableHandle = nil;
        let __return = System_Security_Cryptography_ECDiffieHellmanPublicKey_String__ToXmlString_0__0(&__thrown, self.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return dotnet.System.String(hndl : __return);
        }
    }
// TODO COPE (write_all_methods) (span) bool TryExportSubjectPublicKeyInfo(System.Span<System.Byte>, ref System.Int32)
} // ECDiffieHellmanPublicKey


// type: System.Security.Cryptography.ECDsa
    /**
    Provides an abstract base class that encapsulates the Elliptic Curve Digital Signature Algorithm (ECDSA).

    */
open class ECDsa
    :
    dotnet.System.Security.Cryptography.AsymmetricAlgorithm
{
    open class override func get_type_handle() -> TypeHandle {
        return System_Security_Cryptography_ECDsa_get_type_handle();
    }
    public required init(hndl: NonnullHandle) { super.init(hndl: hndl); }
    public required init(gval: GVal) { super.init(gval: gval); }
    // System.Security.Cryptography.ECDsa Create()
// docid: M:System.Security.Cryptography.ECDsa.Create
    /**
    Creates a new instance of the default implementation of the Elliptic Curve Digital Signature Algorithm (ECDSA).

    - Returns: A new instance of the default implementation () of this class.

    */
    open class override func Create() throws -> dotnet.System.Security.Cryptography.ECDsa {
        var __thrown : NullableHandle = nil;
        let __return = System_Security_Cryptography_ECDsa_ECDsa__Create_0__0(&__thrown);
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return dotnet.System.Security.Cryptography.ECDsa(hndl : __return);
        }
    }
    // System.Security.Cryptography.ECDsa Create(System.Security.Cryptography.ECCurve)
// docid: M:System.Security.Cryptography.ECDsa.Create(System.Security.Cryptography.ECCurve)
    /**
    Creates a new instance of the default implementation of the Elliptic Curve Digital Signature Algorithm (ECDSA) with a newly generated key over the specified curve.

    - Parameter curve: The curve to use for key generation.
    - Returns: A new instance of the default implementation () of this class.

    */
    open class func Create(curve : dotnet.System.Security.Cryptography.ECCurve) throws -> dotnet.System.Security.Cryptography.ECDsa {
        var __thrown : NullableHandle = nil;
        let __return = System_Security_Cryptography_ECDsa_ECDsa__Create_0__1__ECCurve(&__thrown, curve.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return dotnet.System.Security.Cryptography.ECDsa(hndl : __return);
        }
    }
    // System.Security.Cryptography.ECDsa Create(System.Security.Cryptography.ECParameters)
// docid: M:System.Security.Cryptography.ECDsa.Create(System.Security.Cryptography.ECParameters)
    /**
    Creates a new instance of the default implementation of the Elliptic Curve Digital Signature Algorithm (ECDSA) using the specified parameters as the key.

    - Parameter parameters: The parameters representing the key to use.
    - Returns: A new instance of the default implementation () of this class.

    */
    open class func Create(parameters : dotnet.System.Security.Cryptography.ECParameters) throws -> dotnet.System.Security.Cryptography.ECDsa {
        var __thrown : NullableHandle = nil;
        let __return = System_Security_Cryptography_ECDsa_ECDsa__Create_0__1__ECParameters(&__thrown, parameters.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return dotnet.System.Security.Cryptography.ECDsa(hndl : __return);
        }
    }
    // System.Security.Cryptography.ECDsa Create(System.String)
// docid: M:System.Security.Cryptography.ECDsa.Create(System.String)
    /**
    Creates a new instance of the specified implementation of the Elliptic Curve Digital Signature Algorithm (ECDSA).

    - Parameter algorithm: The name of an ECDSA implementation. The following strings all refer to the same implementation, which is the only implementation currently supported in the .NET Framework:  
  
- "ECDsa"  
  
- "ECDsaCng"  
  
- "System.Security.Cryptography.ECDsaCng"  
  
 You can also provide the name of a custom ECDSA implementation.
    - Returns: A new instance of the specified implementation of this class. If the specified algorithm name does not map to an ECDSA implementation, this method returns .

    */
    open class func Create(algorithm : dotnet.System.String) throws -> Optional<dotnet.System.Security.Cryptography.ECDsa> {
        var __thrown : NullableHandle = nil;
        let __return = System_Security_Cryptography_ECDsa_ECDsa__Create_0__1__String(&__thrown, algorithm.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        if let __ret_unwrapped = __return {
            return dotnet.System.Security.Cryptography.ECDsa(hndl : __ret_unwrapped);
        } else {
            return nil;
        }
        }
    }
    // System.Byte[] ExportECPrivateKey()
// docid: M:System.Security.Cryptography.ECDsa.ExportECPrivateKey
    /**
    Exports the current key in the ECPrivateKey format.

    - Returns: A byte array containing the ECPrivateKey representation of this key.

    */
    open func ExportECPrivateKey() throws -> dotnet.System_Arr<Swift.UInt8> {
        var __thrown : NullableHandle = nil;
        let __return = System_Security_Cryptography_ECDsa_u8Array__ExportECPrivateKey_0__0(&__thrown, self.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return dotnet.System_Arr<Swift.UInt8>(hndl : __return);
        }
    }
    // System.Security.Cryptography.ECParameters ExportExplicitParameters(bool)
// docid: M:System.Security.Cryptography.ECDsa.ExportExplicitParameters(System.Boolean)
    /**
    When overridden in a derived class, exports the explicit parameters for an elliptic curve.

    - Parameter includePrivateParameters: 
         to include private parameters; otherwise, .
    - Returns: The parameters representing the point on the curve for this key, using the explicit curve format.

    */
    open func ExportExplicitParameters(includePrivateParameters : Bool) throws -> dotnet.System.Security.Cryptography.ECParameters {
        var __thrown : NullableHandle = nil;
        let __return = System_Security_Cryptography_ECDsa_ECParameters__ExportExplicitParameters_0__1__bool(&__thrown, self.get_handle(), Swift.Int32(includePrivateParameters ? 1 : 0));
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return dotnet.System.Security.Cryptography.ECParameters(hndl : __return);
        }
    }
    // System.Security.Cryptography.ECParameters ExportParameters(bool)
// docid: M:System.Security.Cryptography.ECDsa.ExportParameters(System.Boolean)
    /**
    When overridden in a derived class, exports the named or explicit parameters for an elliptic curve. If the curve has a name, the  field contains named curve parameters, otherwise it         contains explicit parameters.

    - Parameter includePrivateParameters: 
         to include private parameters; otherwise, .
    - Returns: The parameters representing the point on the curve for this key.

    */
    open func ExportParameters(includePrivateParameters : Bool) throws -> dotnet.System.Security.Cryptography.ECParameters {
        var __thrown : NullableHandle = nil;
        let __return = System_Security_Cryptography_ECDsa_ECParameters__ExportParameters_0__1__bool(&__thrown, self.get_handle(), Swift.Int32(includePrivateParameters ? 1 : 0));
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return dotnet.System.Security.Cryptography.ECParameters(hndl : __return);
        }
    }
    // void FromXmlString(System.String)
// docid: M:System.Security.Cryptography.ECDsa.FromXmlString(System.String)
    /**
    This method throws in all cases.

    - Parameter xmlString: The XML string to use to reconstruct the  object.
    */
    open override func FromXmlString(xmlString : dotnet.System.String) throws {
        var __thrown : NullableHandle = nil;
        System_Security_Cryptography_ECDsa_void__FromXmlString_0__1__String(&__thrown, self.get_handle(), xmlString.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
            return;
        }
    }
    // void GenerateKey(System.Security.Cryptography.ECCurve)
// docid: M:System.Security.Cryptography.ECDsa.GenerateKey(System.Security.Cryptography.ECCurve)
    /**
    When overridden in a derived class, generates a new ephemeral public/private key pair for the specified curve, replacing the current key.

    - Parameter curve: The curve to use to generate the key.
    */
    open func GenerateKey(curve : dotnet.System.Security.Cryptography.ECCurve) throws {
        var __thrown : NullableHandle = nil;
        System_Security_Cryptography_ECDsa_void__GenerateKey_0__1__ECCurve(&__thrown, self.get_handle(), curve.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
            return;
        }
    }
    // System.Int32 GetMaxSignatureSize(System.Security.Cryptography.DSASignatureFormat)
// docid: M:System.Security.Cryptography.ECDsa.GetMaxSignatureSize(System.Security.Cryptography.DSASignatureFormat)
    /**
    Gets the largest size, in bytes, for a signature produced by this key in the indicated format.

    - Parameter signatureFormat: The encoding format for a signature.
    - Returns: The largest size, in bytes, for a signature produced by this key in the indicated format.

    */
    open func GetMaxSignatureSize(signatureFormat : dotnet.System.Security.Cryptography.DSASignatureFormat) throws -> Swift.Int32 {
        var __thrown : NullableHandle = nil;
        let __return = System_Security_Cryptography_ECDsa_i32__GetMaxSignatureSize_0__1__DSASignatureFormat(&__thrown, self.get_handle(), signatureFormat.get_value());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return __return;
        }
    }
// TODO COPE (write_all_methods) (span) void ImportECPrivateKey(System.ReadOnlySpan<System.Byte>, ref System.Int32)
// TODO COPE (write_all_methods) (span) void ImportEncryptedPkcs8PrivateKey(System.ReadOnlySpan<System.Byte>, System.ReadOnlySpan<System.Byte>, ref System.Int32)
// TODO COPE (write_all_methods) (span) void ImportEncryptedPkcs8PrivateKey(System.ReadOnlySpan<System.Char>, System.ReadOnlySpan<System.Byte>, ref System.Int32)
// TODO COPE (write_all_methods) (span) void ImportFromEncryptedPem(System.ReadOnlySpan<System.Char>, System.ReadOnlySpan<System.Byte>)
// TODO COPE (write_all_methods) (span) void ImportFromEncryptedPem(System.ReadOnlySpan<System.Char>, System.ReadOnlySpan<System.Char>)
// TODO COPE (write_all_methods) (span) void ImportFromPem(System.ReadOnlySpan<System.Char>)
    // void ImportParameters(System.Security.Cryptography.ECParameters)
// docid: M:System.Security.Cryptography.ECDsa.ImportParameters(System.Security.Cryptography.ECParameters)
    /**
    When overridden in a derived class, imports the specified parameters.

    - Parameter parameters: The curve parameters.
    */
    open func ImportParameters(parameters : dotnet.System.Security.Cryptography.ECParameters) throws {
        var __thrown : NullableHandle = nil;
        System_Security_Cryptography_ECDsa_void__ImportParameters_0__1__ECParameters(&__thrown, self.get_handle(), parameters.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
            return;
        }
    }
// TODO COPE (write_all_methods) (span) void ImportPkcs8PrivateKey(System.ReadOnlySpan<System.Byte>, ref System.Int32)
// TODO COPE (write_all_methods) (span) void ImportSubjectPublicKeyInfo(System.ReadOnlySpan<System.Byte>, ref System.Int32)
    // System.Byte[] SignData(System.Byte[], System.Int32, System.Int32, System.Security.Cryptography.HashAlgorithmName)
// docid: M:System.Security.Cryptography.ECDsa.SignData(System.Byte[],System.Int32,System.Int32,System.Security.Cryptography.HashAlgorithmName)
    /**
    Computes the hash value of a portion of the specified byte array using the specified hash algorithm and signs the resulting hash value.

    - Parameter data: The input data for which to compute the hash.
    - Parameter offset: The offset into the array at which to begin using data.
    - Parameter count: The number of bytes in the array to use as data.
    - Parameter hashAlgorithm: The hash algorithm to use to create the hash value.
    - Returns: The ECDSA signature for the specified data.

    */
    open func SignData(data : dotnet.System_Arr<Swift.UInt8>, offset : Swift.Int32, count : Swift.Int32, hashAlgorithm : dotnet.System.Security.Cryptography.HashAlgorithmName) throws -> dotnet.System_Arr<Swift.UInt8> {
        var __thrown : NullableHandle = nil;
        let __return = System_Security_Cryptography_ECDsa_u8Array__SignData_0__4__u8Array_i32_i32_HashAlgorithmName(&__thrown, self.get_handle(), data.get_handle(), offset, count, hashAlgorithm.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return dotnet.System_Arr<Swift.UInt8>(hndl : __return);
        }
    }
    // System.Byte[] SignData(System.Byte[], System.Int32, System.Int32, System.Security.Cryptography.HashAlgorithmName, System.Security.Cryptography.DSASignatureFormat)
// docid: M:System.Security.Cryptography.ECDsa.SignData(System.Byte[],System.Int32,System.Int32,System.Security.Cryptography.HashAlgorithmName,System.Security.Cryptography.DSASignatureFormat)
    /**
    Computes the hash value of the specified data and signs it using the specified signature format.

    - Parameter data: The data to sign.
    - Parameter offset: The offset into  at which to begin hashing.
    - Parameter count: The number of bytes to read from .
    - Parameter hashAlgorithm: The hash algorithm to use to create the hash value.
    - Parameter signatureFormat: The encoding format to use for the signature.
    - Returns: The ECDSA signature for the specified data.

    */
    open func SignData(data : dotnet.System_Arr<Swift.UInt8>, offset : Swift.Int32, count : Swift.Int32, hashAlgorithm : dotnet.System.Security.Cryptography.HashAlgorithmName, signatureFormat : dotnet.System.Security.Cryptography.DSASignatureFormat) throws -> dotnet.System_Arr<Swift.UInt8> {
        var __thrown : NullableHandle = nil;
        let __return = System_Security_Cryptography_ECDsa_u8Array__SignData_0__5__u8Array_i32_i32_HashAlgorithmName_DSASignatureFormat(&__thrown, self.get_handle(), data.get_handle(), offset, count, hashAlgorithm.get_handle(), signatureFormat.get_value());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return dotnet.System_Arr<Swift.UInt8>(hndl : __return);
        }
    }
    // System.Byte[] SignData(System.Byte[], System.Security.Cryptography.HashAlgorithmName)
// docid: M:System.Security.Cryptography.ECDsa.SignData(System.Byte[],System.Security.Cryptography.HashAlgorithmName)
    /**
    Computes the hash value of the specified byte array using the specified hash algorithm and signs the resulting hash value.

    - Parameter data: The input data for which to compute the hash.
    - Parameter hashAlgorithm: The hash algorithm to use to create the hash value.
    - Returns: The ECDSA signature for the specified data.

    */
    open func SignData(data : dotnet.System_Arr<Swift.UInt8>, hashAlgorithm : dotnet.System.Security.Cryptography.HashAlgorithmName) throws -> dotnet.System_Arr<Swift.UInt8> {
        var __thrown : NullableHandle = nil;
        let __return = System_Security_Cryptography_ECDsa_u8Array__SignData_0__2__u8Array_HashAlgorithmName(&__thrown, self.get_handle(), data.get_handle(), hashAlgorithm.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return dotnet.System_Arr<Swift.UInt8>(hndl : __return);
        }
    }
    // System.Byte[] SignData(System.Byte[], System.Security.Cryptography.HashAlgorithmName, System.Security.Cryptography.DSASignatureFormat)
// docid: M:System.Security.Cryptography.ECDsa.SignData(System.Byte[],System.Security.Cryptography.HashAlgorithmName,System.Security.Cryptography.DSASignatureFormat)
    /**
    Computes the hash value of the specified data and signs it using the specified signature format.

    - Parameter data: The data to sign.
    - Parameter hashAlgorithm: The hash algorithm to use to create the hash value.
    - Parameter signatureFormat: The encoding format to use for the signature.
    - Returns: The ECDSA signature for the specified data.

    */
    open func SignData(data : dotnet.System_Arr<Swift.UInt8>, hashAlgorithm : dotnet.System.Security.Cryptography.HashAlgorithmName, signatureFormat : dotnet.System.Security.Cryptography.DSASignatureFormat) throws -> dotnet.System_Arr<Swift.UInt8> {
        var __thrown : NullableHandle = nil;
        let __return = System_Security_Cryptography_ECDsa_u8Array__SignData_0__3__u8Array_HashAlgorithmName_DSASignatureFormat(&__thrown, self.get_handle(), data.get_handle(), hashAlgorithm.get_handle(), signatureFormat.get_value());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return dotnet.System_Arr<Swift.UInt8>(hndl : __return);
        }
    }
    // System.Byte[] SignData(System.IO.Stream, System.Security.Cryptography.HashAlgorithmName)
// docid: M:System.Security.Cryptography.ECDsa.SignData(System.IO.Stream,System.Security.Cryptography.HashAlgorithmName)
    /**
    Computes the hash value of the specified stream using the specified hash algorithm and signs the resulting hash value.

    - Parameter data: The input stream for which to compute the hash.
    - Parameter hashAlgorithm: The hash algorithm to use to create the hash value.
    - Returns: The ECDSA signature for the specified data.

    */
    open func SignData(data : dotnet.System.IO.Stream, hashAlgorithm : dotnet.System.Security.Cryptography.HashAlgorithmName) throws -> dotnet.System_Arr<Swift.UInt8> {
        var __thrown : NullableHandle = nil;
        let __return = System_Security_Cryptography_ECDsa_u8Array__SignData_0__2__Stream_HashAlgorithmName(&__thrown, self.get_handle(), data.get_handle(), hashAlgorithm.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return dotnet.System_Arr<Swift.UInt8>(hndl : __return);
        }
    }
    // System.Byte[] SignData(System.IO.Stream, System.Security.Cryptography.HashAlgorithmName, System.Security.Cryptography.DSASignatureFormat)
// docid: M:System.Security.Cryptography.ECDsa.SignData(System.IO.Stream,System.Security.Cryptography.HashAlgorithmName,System.Security.Cryptography.DSASignatureFormat)
    /**
    Computes the hash value of the specified data and signs it using the specified signature format.

    - Parameter data: The data to sign.
    - Parameter hashAlgorithm: The hash algorithm to use to create the hash value.
    - Parameter signatureFormat: The encoding format to use for the signature.
    - Returns: The ECDSA signature for the specified data.

    */
    open func SignData(data : dotnet.System.IO.Stream, hashAlgorithm : dotnet.System.Security.Cryptography.HashAlgorithmName, signatureFormat : dotnet.System.Security.Cryptography.DSASignatureFormat) throws -> dotnet.System_Arr<Swift.UInt8> {
        var __thrown : NullableHandle = nil;
        let __return = System_Security_Cryptography_ECDsa_u8Array__SignData_0__3__Stream_HashAlgorithmName_DSASignatureFormat(&__thrown, self.get_handle(), data.get_handle(), hashAlgorithm.get_handle(), signatureFormat.get_value());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return dotnet.System_Arr<Swift.UInt8>(hndl : __return);
        }
    }
    // System.Byte[] SignHash(System.Byte[])
// docid: M:System.Security.Cryptography.ECDsa.SignHash(System.Byte[])
    /**
    Generates a digital signature for the specified hash value.

    - Parameter hash: The hash value of the data that is being signed.
    - Returns: A digital signature for the specified hash value.

    */
    open func SignHash(hash : dotnet.System_Arr<Swift.UInt8>) throws -> dotnet.System_Arr<Swift.UInt8> {
        var __thrown : NullableHandle = nil;
        let __return = System_Security_Cryptography_ECDsa_u8Array__SignHash_0__1__u8Array(&__thrown, self.get_handle(), hash.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return dotnet.System_Arr<Swift.UInt8>(hndl : __return);
        }
    }
    // System.Byte[] SignHash(System.Byte[], System.Security.Cryptography.DSASignatureFormat)
// docid: M:System.Security.Cryptography.ECDsa.SignHash(System.Byte[],System.Security.Cryptography.DSASignatureFormat)
    /**
    Computes the ECDSA signature for the specified hash value in the indicated format.

    - Parameter hash: The hash value to sign.
    - Parameter signatureFormat: The encoding format to use for the signature.
    - Returns: The ECDSA signature for the specified data.

    */
    open func SignHash(hash : dotnet.System_Arr<Swift.UInt8>, signatureFormat : dotnet.System.Security.Cryptography.DSASignatureFormat) throws -> dotnet.System_Arr<Swift.UInt8> {
        var __thrown : NullableHandle = nil;
        let __return = System_Security_Cryptography_ECDsa_u8Array__SignHash_0__2__u8Array_DSASignatureFormat(&__thrown, self.get_handle(), hash.get_handle(), signatureFormat.get_value());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return dotnet.System_Arr<Swift.UInt8>(hndl : __return);
        }
    }
    // System.String ToXmlString(bool)
// docid: M:System.Security.Cryptography.ECDsa.ToXmlString(System.Boolean)
    /**
    This method throws in all cases.

    - Parameter includePrivateParameters: 
         to include private parameters; otherwise, .
    - Returns: This method does not return a value.

    */
    open override func ToXmlString(includePrivateParameters : Bool) throws -> dotnet.System.String {
        var __thrown : NullableHandle = nil;
        let __return = System_Security_Cryptography_ECDsa_String__ToXmlString_0__1__bool(&__thrown, self.get_handle(), Swift.Int32(includePrivateParameters ? 1 : 0));
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return dotnet.System.String(hndl : __return);
        }
    }
// TODO COPE (write_all_methods) (span) bool TryExportECPrivateKey(System.Span<System.Byte>, ref System.Int32)
// TODO COPE (write_all_methods) (span) bool TryExportEncryptedPkcs8PrivateKey(System.ReadOnlySpan<System.Byte>, System.Security.Cryptography.PbeParameters, System.Span<System.Byte>, ref System.Int32)
// TODO COPE (write_all_methods) (span) bool TryExportEncryptedPkcs8PrivateKey(System.ReadOnlySpan<System.Char>, System.Security.Cryptography.PbeParameters, System.Span<System.Byte>, ref System.Int32)
// TODO COPE (write_all_methods) (span) bool TryExportPkcs8PrivateKey(System.Span<System.Byte>, ref System.Int32)
// TODO COPE (write_all_methods) (span) bool TryExportSubjectPublicKeyInfo(System.Span<System.Byte>, ref System.Int32)
// TODO COPE (write_all_methods) (span) bool TrySignData(System.ReadOnlySpan<System.Byte>, System.Span<System.Byte>, System.Security.Cryptography.HashAlgorithmName, ref System.Int32)
// TODO COPE (write_all_methods) (span) bool TrySignData(System.ReadOnlySpan<System.Byte>, System.Span<System.Byte>, System.Security.Cryptography.HashAlgorithmName, System.Security.Cryptography.DSASignatureFormat, ref System.Int32)
// TODO COPE (write_all_methods) (span) bool TrySignHash(System.ReadOnlySpan<System.Byte>, System.Span<System.Byte>, ref System.Int32)
// TODO COPE (write_all_methods) (span) bool TrySignHash(System.ReadOnlySpan<System.Byte>, System.Span<System.Byte>, System.Security.Cryptography.DSASignatureFormat, ref System.Int32)
    // bool VerifyData(System.Byte[], System.Byte[], System.Security.Cryptography.HashAlgorithmName)
// docid: M:System.Security.Cryptography.ECDsa.VerifyData(System.Byte[],System.Byte[],System.Security.Cryptography.HashAlgorithmName)
    /**
    Verifies that a digital signature is appropriate for the current key and provided data with a specified hash algorithm.

    - Parameter data: The signed data.
    - Parameter signature: The signature data to be verified.
    - Parameter hashAlgorithm: The hash algorithm used to create the hash value of the data.
    - Returns: 
         if the signature is valid; otherwise, .

    */
    open func VerifyData(data : dotnet.System_Arr<Swift.UInt8>, signature : dotnet.System_Arr<Swift.UInt8>, hashAlgorithm : dotnet.System.Security.Cryptography.HashAlgorithmName) throws -> Bool {
        var __thrown : NullableHandle = nil;
        let __return = System_Security_Cryptography_ECDsa_bool__VerifyData_0__3__u8Array_u8Array_HashAlgorithmName(&__thrown, self.get_handle(), data.get_handle(), signature.get_handle(), hashAlgorithm.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return (__return) != 0;
        }
    }
    // bool VerifyData(System.Byte[], System.Byte[], System.Security.Cryptography.HashAlgorithmName, System.Security.Cryptography.DSASignatureFormat)
// docid: M:System.Security.Cryptography.ECDsa.VerifyData(System.Byte[],System.Byte[],System.Security.Cryptography.HashAlgorithmName,System.Security.Cryptography.DSASignatureFormat)
    /**
    Verifies that a digital signature is valid for the provided data.

    - Parameter data: The signed data.
    - Parameter signature: The signature to verify.
    - Parameter hashAlgorithm: The hash algorithm used to hash the data for the verification process.
    - Parameter signatureFormat: The encoding format for .
    - Returns: 
         if the digital signature is valid for the provided data; otherwise, .

    */
    open func VerifyData(data : dotnet.System_Arr<Swift.UInt8>, signature : dotnet.System_Arr<Swift.UInt8>, hashAlgorithm : dotnet.System.Security.Cryptography.HashAlgorithmName, signatureFormat : dotnet.System.Security.Cryptography.DSASignatureFormat) throws -> Bool {
        var __thrown : NullableHandle = nil;
        let __return = System_Security_Cryptography_ECDsa_bool__VerifyData_0__4__u8Array_u8Array_HashAlgorithmName_DSASignatureFormat(&__thrown, self.get_handle(), data.get_handle(), signature.get_handle(), hashAlgorithm.get_handle(), signatureFormat.get_value());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return (__return) != 0;
        }
    }
    // bool VerifyData(System.Byte[], System.Int32, System.Int32, System.Byte[], System.Security.Cryptography.HashAlgorithmName)
// docid: M:System.Security.Cryptography.ECDsa.VerifyData(System.Byte[],System.Int32,System.Int32,System.Byte[],System.Security.Cryptography.HashAlgorithmName)
    /**
    Verifies that a digital signature is appropriate for the current key and provided portion of data with a specified hash algorithm.

    - Parameter data: The signed data.
    - Parameter offset: The starting index at which to compute the hash.
    - Parameter count: The number of bytes to hash.
    - Parameter signature: The signature data to be verified.
    - Parameter hashAlgorithm: The hash algorithm used to create the hash value of the data.
    - Returns: 
         if the signature is valid; otherwise, .

    */
    open func VerifyData(data : dotnet.System_Arr<Swift.UInt8>, offset : Swift.Int32, count : Swift.Int32, signature : dotnet.System_Arr<Swift.UInt8>, hashAlgorithm : dotnet.System.Security.Cryptography.HashAlgorithmName) throws -> Bool {
        var __thrown : NullableHandle = nil;
        let __return = System_Security_Cryptography_ECDsa_bool__VerifyData_0__5__u8Array_i32_i32_u8Array_HashAlgorithmName(&__thrown, self.get_handle(), data.get_handle(), offset, count, signature.get_handle(), hashAlgorithm.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return (__return) != 0;
        }
    }
    // bool VerifyData(System.Byte[], System.Int32, System.Int32, System.Byte[], System.Security.Cryptography.HashAlgorithmName, System.Security.Cryptography.DSASignatureFormat)
// docid: M:System.Security.Cryptography.ECDsa.VerifyData(System.Byte[],System.Int32,System.Int32,System.Byte[],System.Security.Cryptography.HashAlgorithmName,System.Security.Cryptography.DSASignatureFormat)
    /**
    Verifies that a digital signature is valid for the provided data.

    - Parameter data: An array that contains the signed data.
    - Parameter offset: The starting index of the signed portion of .
    - Parameter count: The number of bytes in  that were signed.
    - Parameter signature: The signature to verify.
    - Parameter hashAlgorithm: The hash algorithm used to hash the data for the verification process.
    - Parameter signatureFormat: The encoding format for .
    - Returns: 
         if the digital signature is valid for the provided data; otherwise, .

    */
    open func VerifyData(data : dotnet.System_Arr<Swift.UInt8>, offset : Swift.Int32, count : Swift.Int32, signature : dotnet.System_Arr<Swift.UInt8>, hashAlgorithm : dotnet.System.Security.Cryptography.HashAlgorithmName, signatureFormat : dotnet.System.Security.Cryptography.DSASignatureFormat) throws -> Bool {
        var __thrown : NullableHandle = nil;
        let __return = System_Security_Cryptography_ECDsa_bool__VerifyData_0__6__u8Array_i32_i32_u8Array_HashAlgorithmName_DSASignatureFormat(&__thrown, self.get_handle(), data.get_handle(), offset, count, signature.get_handle(), hashAlgorithm.get_handle(), signatureFormat.get_value());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return (__return) != 0;
        }
    }
    // bool VerifyData(System.IO.Stream, System.Byte[], System.Security.Cryptography.HashAlgorithmName)
// docid: M:System.Security.Cryptography.ECDsa.VerifyData(System.IO.Stream,System.Byte[],System.Security.Cryptography.HashAlgorithmName)
    /**
    Verifies that a digital signature is appropriate for the current key and provided data with a specified hash algorithm.

    - Parameter data: The signed data.
    - Parameter signature: The signature data to be verified.
    - Parameter hashAlgorithm: The hash algorithm used to create the hash value of the data.
    - Returns: 
         if the signature is valid; otherwise, .

    */
    open func VerifyData(data : dotnet.System.IO.Stream, signature : dotnet.System_Arr<Swift.UInt8>, hashAlgorithm : dotnet.System.Security.Cryptography.HashAlgorithmName) throws -> Bool {
        var __thrown : NullableHandle = nil;
        let __return = System_Security_Cryptography_ECDsa_bool__VerifyData_0__3__Stream_u8Array_HashAlgorithmName(&__thrown, self.get_handle(), data.get_handle(), signature.get_handle(), hashAlgorithm.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return (__return) != 0;
        }
    }
    // bool VerifyData(System.IO.Stream, System.Byte[], System.Security.Cryptography.HashAlgorithmName, System.Security.Cryptography.DSASignatureFormat)
// docid: M:System.Security.Cryptography.ECDsa.VerifyData(System.IO.Stream,System.Byte[],System.Security.Cryptography.HashAlgorithmName,System.Security.Cryptography.DSASignatureFormat)
    /**
    Verifies that a digital signature is valid for the provided data.

    - Parameter data: The signed data.
    - Parameter signature: The signature to verify.
    - Parameter hashAlgorithm: The hash algorithm used to hash the data for the verification process.
    - Parameter signatureFormat: The encoding format for .
    - Returns: 
         if the digital signature is valid for the provided data; otherwise, .

    */
    open func VerifyData(data : dotnet.System.IO.Stream, signature : dotnet.System_Arr<Swift.UInt8>, hashAlgorithm : dotnet.System.Security.Cryptography.HashAlgorithmName, signatureFormat : dotnet.System.Security.Cryptography.DSASignatureFormat) throws -> Bool {
        var __thrown : NullableHandle = nil;
        let __return = System_Security_Cryptography_ECDsa_bool__VerifyData_0__4__Stream_u8Array_HashAlgorithmName_DSASignatureFormat(&__thrown, self.get_handle(), data.get_handle(), signature.get_handle(), hashAlgorithm.get_handle(), signatureFormat.get_value());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return (__return) != 0;
        }
    }
// TODO COPE (write_all_methods) (span) bool VerifyData(System.ReadOnlySpan<System.Byte>, System.ReadOnlySpan<System.Byte>, System.Security.Cryptography.HashAlgorithmName)
// TODO COPE (write_all_methods) (span) bool VerifyData(System.ReadOnlySpan<System.Byte>, System.ReadOnlySpan<System.Byte>, System.Security.Cryptography.HashAlgorithmName, System.Security.Cryptography.DSASignatureFormat)
    // bool VerifyHash(System.Byte[], System.Byte[])
// docid: M:System.Security.Cryptography.ECDsa.VerifyHash(System.Byte[],System.Byte[])
    /**
    Verifies that a digital signature is appropriate for the current key and provided data hash.

    - Parameter hash: The hash value of the data to be verified.
    - Parameter signature: The digital signature of the data to be verified against the hash value.
    - Returns: 
         if the signature is valid; otherwise, .

    */
    open func VerifyHash(hash : dotnet.System_Arr<Swift.UInt8>, signature : dotnet.System_Arr<Swift.UInt8>) throws -> Bool {
        var __thrown : NullableHandle = nil;
        let __return = System_Security_Cryptography_ECDsa_bool__VerifyHash_0__2__u8Array_u8Array(&__thrown, self.get_handle(), hash.get_handle(), signature.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return (__return) != 0;
        }
    }
    // bool VerifyHash(System.Byte[], System.Byte[], System.Security.Cryptography.DSASignatureFormat)
// docid: M:System.Security.Cryptography.ECDsa.VerifyHash(System.Byte[],System.Byte[],System.Security.Cryptography.DSASignatureFormat)
    /**
    Verifies that a digital signature is valid for the provided hash.

    - Parameter hash: The signed hash.
    - Parameter signature: The signature to verify.
    - Parameter signatureFormat: The encoding format for .
    - Returns: 
         if the digital signature is valid for the provided data; otherwise, .

    */
    open func VerifyHash(hash : dotnet.System_Arr<Swift.UInt8>, signature : dotnet.System_Arr<Swift.UInt8>, signatureFormat : dotnet.System.Security.Cryptography.DSASignatureFormat) throws -> Bool {
        var __thrown : NullableHandle = nil;
        let __return = System_Security_Cryptography_ECDsa_bool__VerifyHash_0__3__u8Array_u8Array_DSASignatureFormat(&__thrown, self.get_handle(), hash.get_handle(), signature.get_handle(), signatureFormat.get_value());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return (__return) != 0;
        }
    }
// TODO COPE (write_all_methods) (span) bool VerifyHash(System.ReadOnlySpan<System.Byte>, System.ReadOnlySpan<System.Byte>)
// TODO COPE (write_all_methods) (span) bool VerifyHash(System.ReadOnlySpan<System.Byte>, System.ReadOnlySpan<System.Byte>, System.Security.Cryptography.DSASignatureFormat)
    // [IsSpecialName] System.String get_KeyExchangeAlgorithm()
// docid: M:System.Security.Cryptography.ECDsa.get_KeyExchangeAlgorithm
    open override func get_KeyExchangeAlgorithm() throws -> Optional<dotnet.System.String> {
        var __thrown : NullableHandle = nil;
        let __return = System_Security_Cryptography_ECDsa_String__get_KeyExchangeAlgorithm_0__0(&__thrown, self.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        if let __ret_unwrapped = __return {
            return dotnet.System.String(hndl : __ret_unwrapped);
        } else {
            return nil;
        }
        }
    }
    // [IsSpecialName] System.String get_SignatureAlgorithm()
// docid: M:System.Security.Cryptography.ECDsa.get_SignatureAlgorithm
    open override func get_SignatureAlgorithm() throws -> dotnet.System.String {
        var __thrown : NullableHandle = nil;
        let __return = System_Security_Cryptography_ECDsa_String__get_SignatureAlgorithm_0__0(&__thrown, self.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return dotnet.System.String(hndl : __return);
        }
    }
    /**
    Gets the name of the key exchange algorithm.

    */
    open override var KeyExchangeAlgorithm : Optional<dotnet.System.String> {
        get {
            return try! get_KeyExchangeAlgorithm();
        }
    }
    /**
    Gets the name of the signature algorithm.

    */
    open override var SignatureAlgorithm : dotnet.System.String {
        get {
            return try! get_SignatureAlgorithm();
        }
    }
} // ECDsa


// type: System.Security.Cryptography.ECParameters
// boxed value type
    /**
    Represents the standard parameters for the elliptic curve cryptography (ECC) algorithm.

    */
public final class ECParameters
    :
    dotnet.System.Object
{
    public class override func get_type_handle() -> TypeHandle {
        return System_Security_Cryptography_ECParameters_get_type_handle();
    }
    public required init(hndl: NonnullHandle) { super.init(hndl: hndl); }
    public required init(gval: GVal) { super.init(gval: gval); }
    public override init() {
        let h = System_Security_Cryptography_ECParameters_implicit_ctor();
            super.init(hndl: h);
    }
    // void Validate()
// docid: M:System.Security.Cryptography.ECParameters.Validate
    /**
    Validates the current object.

    */
    public func Validate() throws {
        var __thrown : NullableHandle = nil;
        System_Security_Cryptography_ECParameters_void__Validate_0__0(&__thrown, self.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
            return;
        }
    }
} // ECParameters


// type: System.Security.Cryptography.ECPoint
// boxed value type
    /**
    Represents a (X,Y) coordinate pair for elliptic curve cryptography (ECC) structures.

    */
public final class ECPoint
    :
    dotnet.System.Object
{
    public class override func get_type_handle() -> TypeHandle {
        return System_Security_Cryptography_ECPoint_get_type_handle();
    }
    public required init(hndl: NonnullHandle) { super.init(hndl: hndl); }
    public required init(gval: GVal) { super.init(gval: gval); }
    public override init() {
        let h = System_Security_Cryptography_ECPoint_implicit_ctor();
            super.init(hndl: h);
    }
} // ECPoint


// type: System.Security.Cryptography.HKDF
public struct HKDF {
    // System.Byte[] DeriveKey(System.Security.Cryptography.HashAlgorithmName, System.Byte[], System.Int32, System.Byte[], System.Byte[])
// docid: M:System.Security.Cryptography.HKDF.DeriveKey(System.Security.Cryptography.HashAlgorithmName,System.Byte[],System.Int32,System.Byte[],System.Byte[])
    /**
    Performs the key derivation HKDF Expand and Extract functions.

    - Parameter hashAlgorithmName: The hash algorithm used for HMAC operations.
    - Parameter ikm: The input keying material.
    - Parameter outputLength: The length of the output keying material.
    - Parameter salt: The optional salt value (a non-secret random value). If not provided, it defaults to a byte array of the same length as the output of the specified hash algorithm.
    - Parameter info: The optional context and application specific information.
    - Returns: The output keying material.

    */
    public static func DeriveKey(hashAlgorithmName : dotnet.System.Security.Cryptography.HashAlgorithmName, ikm : dotnet.System_Arr<Swift.UInt8>, outputLength : Swift.Int32, salt : Optional<dotnet.System_Arr<Swift.UInt8>> = nil, info : Optional<dotnet.System_Arr<Swift.UInt8>> = nil) throws -> dotnet.System_Arr<Swift.UInt8> {
        var __thrown : NullableHandle = nil;
        let __return = System_Security_Cryptography_HKDF_u8Array__DeriveKey_0__5__HashAlgorithmName_u8Array_i32_u8Array_u8Array(&__thrown, hashAlgorithmName.get_handle(), ikm.get_handle(), outputLength, (salt?.get_handle()), (info?.get_handle()));
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return dotnet.System_Arr<Swift.UInt8>(hndl : __return);
        }
    }
// TODO COPE (write_all_methods) (span) void DeriveKey(System.Security.Cryptography.HashAlgorithmName, System.ReadOnlySpan<System.Byte>, System.Span<System.Byte>, System.ReadOnlySpan<System.Byte>, System.ReadOnlySpan<System.Byte>)
    // System.Byte[] Expand(System.Security.Cryptography.HashAlgorithmName, System.Byte[], System.Int32, System.Byte[])
// docid: M:System.Security.Cryptography.HKDF.Expand(System.Security.Cryptography.HashAlgorithmName,System.Byte[],System.Int32,System.Byte[])
    /**
    Performs the HKDF-Expand function See section 2.3 of RFC5869.

    - Parameter hashAlgorithmName: The hash algorithm used for HMAC operations.
    - Parameter prk: The pseudorandom key that is at least as long as the output byte array of the specified hash algorithm (usually the output from Expand step).
    - Parameter outputLength: The length of the output keying material.
    - Parameter info: The optional context and application specific information.
    - Returns: The output keying material.

    */
    public static func Expand(hashAlgorithmName : dotnet.System.Security.Cryptography.HashAlgorithmName, prk : dotnet.System_Arr<Swift.UInt8>, outputLength : Swift.Int32, info : Optional<dotnet.System_Arr<Swift.UInt8>> = nil) throws -> dotnet.System_Arr<Swift.UInt8> {
        var __thrown : NullableHandle = nil;
        let __return = System_Security_Cryptography_HKDF_u8Array__Expand_0__4__HashAlgorithmName_u8Array_i32_u8Array(&__thrown, hashAlgorithmName.get_handle(), prk.get_handle(), outputLength, (info?.get_handle()));
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return dotnet.System_Arr<Swift.UInt8>(hndl : __return);
        }
    }
// TODO COPE (write_all_methods) (span) void Expand(System.Security.Cryptography.HashAlgorithmName, System.ReadOnlySpan<System.Byte>, System.Span<System.Byte>, System.ReadOnlySpan<System.Byte>)
    // System.Byte[] Extract(System.Security.Cryptography.HashAlgorithmName, System.Byte[], System.Byte[])
// docid: M:System.Security.Cryptography.HKDF.Extract(System.Security.Cryptography.HashAlgorithmName,System.Byte[],System.Byte[])
    /**
    Performs the HKDF-Extract function.
 See section 2.2 of RFC5869.

    - Parameter hashAlgorithmName: The hash algorithm used for HMAC operations.
    - Parameter ikm: The input keying material.
    - Parameter salt: The optional salt value (a non-secret random value). If not provided it defaults to a byte array of the same length as the output of the specified hash algorithm.
    - Returns: The pseudorandom key (prk).

    */
    public static func Extract(hashAlgorithmName : dotnet.System.Security.Cryptography.HashAlgorithmName, ikm : dotnet.System_Arr<Swift.UInt8>, salt : Optional<dotnet.System_Arr<Swift.UInt8>> = nil) throws -> dotnet.System_Arr<Swift.UInt8> {
        var __thrown : NullableHandle = nil;
        let __return = System_Security_Cryptography_HKDF_u8Array__Extract_0__3__HashAlgorithmName_u8Array_u8Array(&__thrown, hashAlgorithmName.get_handle(), ikm.get_handle(), (salt?.get_handle()));
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return dotnet.System_Arr<Swift.UInt8>(hndl : __return);
        }
    }
// TODO COPE (write_all_methods) (span) System.Int32 Extract(System.Security.Cryptography.HashAlgorithmName, System.ReadOnlySpan<System.Byte>, System.ReadOnlySpan<System.Byte>, System.Span<System.Byte>)
} // HKDF


// type: System.Security.Cryptography.HMACMD5
    /**
    Computes a Hash-based Message Authentication Code (HMAC) by using the  hash function.

    */
open class HMACMD5
    :
    dotnet.System.Security.Cryptography.HMAC
{
    open class override func get_type_handle() -> TypeHandle {
        return System_Security_Cryptography_HMACMD5_get_type_handle();
    }
    public required init(hndl: NonnullHandle) { super.init(hndl: hndl); }
    public required init(gval: GVal) { super.init(gval: gval); }
    // .ctor()
// docid: M:System.Security.Cryptography.HMACMD5.#ctor
    /**
    Initializes a new instance of the  class by using a randomly generated key.

    */
    public init() throws {
        var __thrown : NullableHandle = nil;
        let h = System_Security_Cryptography_HMACMD5_ctor_0__0(&__thrown);
        if let __ex = __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
            super.init(hndl: h);
        }
    }
    // .ctor(System.Byte[])
// docid: M:System.Security.Cryptography.HMACMD5.#ctor(System.Byte[])
    /**
    Initializes a new instance of the  class by using the specified key.

    - Parameter key: The secret key for  encryption. The key can be any length, but if it is more than 64 bytes long it will be hashed (using SHA-1) to derive a 64-byte key. Therefore, the recommended size of the secret key is 64 bytes.
    */
    public init(key : dotnet.System_Arr<Swift.UInt8>) throws {
        var __thrown : NullableHandle = nil;
        let h = System_Security_Cryptography_HMACMD5_ctor_0__1__u8Array(&__thrown, key.get_handle());
        if let __ex = __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
            super.init(hndl: h);
        }
    }
    // System.Byte[] HashData(System.Byte[], System.Byte[])
// docid: M:System.Security.Cryptography.HMACMD5.HashData(System.Byte[],System.Byte[])
    open class func HashData(key : dotnet.System_Arr<Swift.UInt8>, source : dotnet.System_Arr<Swift.UInt8>) throws -> dotnet.System_Arr<Swift.UInt8> {
        var __thrown : NullableHandle = nil;
        let __return = System_Security_Cryptography_HMACMD5_u8Array__HashData_0__2__u8Array_u8Array(&__thrown, key.get_handle(), source.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return dotnet.System_Arr<Swift.UInt8>(hndl : __return);
        }
    }
// TODO COPE (write_all_methods) (span) System.Byte[] HashData(System.ReadOnlySpan<System.Byte>, System.ReadOnlySpan<System.Byte>)
// TODO COPE (write_all_methods) (span) System.Int32 HashData(System.ReadOnlySpan<System.Byte>, System.ReadOnlySpan<System.Byte>, System.Span<System.Byte>)
    // void Initialize()
// docid: M:System.Security.Cryptography.HMACMD5.Initialize
    /**
    Resets the hash algorithm to its initial state.

    */
    open override func Initialize() throws {
        var __thrown : NullableHandle = nil;
        System_Security_Cryptography_HMACMD5_void__Initialize_0__0(&__thrown, self.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
            return;
        }
    }
// TODO COPE (write_all_methods) (span) bool TryHashData(System.ReadOnlySpan<System.Byte>, System.ReadOnlySpan<System.Byte>, System.Span<System.Byte>, ref System.Int32)
    // [IsSpecialName] System.Byte[] get_Key()
// docid: M:System.Security.Cryptography.HMACMD5.get_Key
    open override func get_Key() throws -> dotnet.System_Arr<Swift.UInt8> {
        var __thrown : NullableHandle = nil;
        let __return = System_Security_Cryptography_HMACMD5_u8Array__get_Key_0__0(&__thrown, self.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return dotnet.System_Arr<Swift.UInt8>(hndl : __return);
        }
    }
    // [IsSpecialName] void set_Key(System.Byte[])
// docid: M:System.Security.Cryptography.HMACMD5.set_Key(System.Byte[])
    open override func set_Key(value : dotnet.System_Arr<Swift.UInt8>) throws {
        var __thrown : NullableHandle = nil;
        System_Security_Cryptography_HMACMD5_void__set_Key_0__1__u8Array(&__thrown, self.get_handle(), value.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
            return;
        }
    }
    /**
    Gets or sets the key to use in the HMAC calculation.

    */
    open override var Key : dotnet.System_Arr<Swift.UInt8> {
        get {
            return try! get_Key();
        }
        set(v) {
            return try! set_Key(value: v);
        }
    }
} // HMACMD5


// type: System.Security.Cryptography.HMACSHA1
    /**
    Computes a Hash-based Message Authentication Code (HMAC) using the  hash function.

    */
open class HMACSHA1
    :
    dotnet.System.Security.Cryptography.HMAC
{
    open class override func get_type_handle() -> TypeHandle {
        return System_Security_Cryptography_HMACSHA1_get_type_handle();
    }
    public required init(hndl: NonnullHandle) { super.init(hndl: hndl); }
    public required init(gval: GVal) { super.init(gval: gval); }
    // .ctor()
// docid: M:System.Security.Cryptography.HMACSHA1.#ctor
    /**
    Initializes a new instance of the  class with a randomly generated key.

    */
    public init() throws {
        var __thrown : NullableHandle = nil;
        let h = System_Security_Cryptography_HMACSHA1_ctor_0__0(&__thrown);
        if let __ex = __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
            super.init(hndl: h);
        }
    }
    // .ctor(System.Byte[])
// docid: M:System.Security.Cryptography.HMACSHA1.#ctor(System.Byte[])
    /**
    Initializes a new instance of the  class with the specified key data.

    - Parameter key: The secret key for  encryption. The key can be any length, but if it is more than 64 bytes long it is hashed (using SHA-1) to derive a 64-byte key. Therefore, the recommended size of the secret key is 64 bytes.
    */
    public init(key : dotnet.System_Arr<Swift.UInt8>) throws {
        var __thrown : NullableHandle = nil;
        let h = System_Security_Cryptography_HMACSHA1_ctor_0__1__u8Array(&__thrown, key.get_handle());
        if let __ex = __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
            super.init(hndl: h);
        }
    }
    // .ctor(System.Byte[], bool)
// docid: M:System.Security.Cryptography.HMACSHA1.#ctor(System.Byte[],System.Boolean)
    /**
    Initializes a new instance of the  class with the specified key data and a value that specifies whether to use the managed version of the SHA1 algorithm.

    - Parameter key: The secret key for  encryption. The key can be any length, but if it is more than 64 bytes long, it is hashed (using SHA-1) to derive a 64-byte key. Therefore, the recommended size of the secret key is 64 bytes.
    - Parameter useManagedSha1: 
         to use the managed implementation of the SHA1 algorithm (the  class);  to use the unmanaged implementation (the  class).
    */
    public init(key : dotnet.System_Arr<Swift.UInt8>, useManagedSha1 : Bool) throws {
        var __thrown : NullableHandle = nil;
        let h = System_Security_Cryptography_HMACSHA1_ctor_0__2__u8Array_bool(&__thrown, key.get_handle(), Swift.Int32(useManagedSha1 ? 1 : 0));
        if let __ex = __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
            super.init(hndl: h);
        }
    }
    // System.Byte[] HashData(System.Byte[], System.Byte[])
// docid: M:System.Security.Cryptography.HMACSHA1.HashData(System.Byte[],System.Byte[])
    open class func HashData(key : dotnet.System_Arr<Swift.UInt8>, source : dotnet.System_Arr<Swift.UInt8>) throws -> dotnet.System_Arr<Swift.UInt8> {
        var __thrown : NullableHandle = nil;
        let __return = System_Security_Cryptography_HMACSHA1_u8Array__HashData_0__2__u8Array_u8Array(&__thrown, key.get_handle(), source.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return dotnet.System_Arr<Swift.UInt8>(hndl : __return);
        }
    }
// TODO COPE (write_all_methods) (span) System.Byte[] HashData(System.ReadOnlySpan<System.Byte>, System.ReadOnlySpan<System.Byte>)
// TODO COPE (write_all_methods) (span) System.Int32 HashData(System.ReadOnlySpan<System.Byte>, System.ReadOnlySpan<System.Byte>, System.Span<System.Byte>)
    // void Initialize()
// docid: M:System.Security.Cryptography.HMACSHA1.Initialize
    /**
    Resets the hash algorithm to its initial state.

    */
    open override func Initialize() throws {
        var __thrown : NullableHandle = nil;
        System_Security_Cryptography_HMACSHA1_void__Initialize_0__0(&__thrown, self.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
            return;
        }
    }
// TODO COPE (write_all_methods) (span) bool TryHashData(System.ReadOnlySpan<System.Byte>, System.ReadOnlySpan<System.Byte>, System.Span<System.Byte>, ref System.Int32)
    // [IsSpecialName] System.Byte[] get_Key()
// docid: M:System.Security.Cryptography.HMACSHA1.get_Key
    open override func get_Key() throws -> dotnet.System_Arr<Swift.UInt8> {
        var __thrown : NullableHandle = nil;
        let __return = System_Security_Cryptography_HMACSHA1_u8Array__get_Key_0__0(&__thrown, self.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return dotnet.System_Arr<Swift.UInt8>(hndl : __return);
        }
    }
    // [IsSpecialName] void set_Key(System.Byte[])
// docid: M:System.Security.Cryptography.HMACSHA1.set_Key(System.Byte[])
    open override func set_Key(value : dotnet.System_Arr<Swift.UInt8>) throws {
        var __thrown : NullableHandle = nil;
        System_Security_Cryptography_HMACSHA1_void__set_Key_0__1__u8Array(&__thrown, self.get_handle(), value.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
            return;
        }
    }
    /**
    Gets or sets the key to use in the hash algorithm.

    */
    open override var Key : dotnet.System_Arr<Swift.UInt8> {
        get {
            return try! get_Key();
        }
        set(v) {
            return try! set_Key(value: v);
        }
    }
} // HMACSHA1


// type: System.Security.Cryptography.HMACSHA256
    /**
    Computes a Hash-based Message Authentication Code (HMAC) by using the  hash function.

    */
open class HMACSHA256
    :
    dotnet.System.Security.Cryptography.HMAC
{
    open class override func get_type_handle() -> TypeHandle {
        return System_Security_Cryptography_HMACSHA256_get_type_handle();
    }
    public required init(hndl: NonnullHandle) { super.init(hndl: hndl); }
    public required init(gval: GVal) { super.init(gval: gval); }
    // .ctor()
// docid: M:System.Security.Cryptography.HMACSHA256.#ctor
    /**
    Initializes a new instance of the  class with a randomly generated key.

    */
    public init() throws {
        var __thrown : NullableHandle = nil;
        let h = System_Security_Cryptography_HMACSHA256_ctor_0__0(&__thrown);
        if let __ex = __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
            super.init(hndl: h);
        }
    }
    // .ctor(System.Byte[])
// docid: M:System.Security.Cryptography.HMACSHA256.#ctor(System.Byte[])
    /**
    Initializes a new instance of the  class with the specified key data.

    - Parameter key: The secret key for  encryption. The key can be any length. However, the recommended size is 64 bytes. If the key is more than 64 bytes long, it is hashed (using SHA-256) to derive a 64-byte key. If it is less than 64 bytes long, it is padded to 64 bytes.
    */
    public init(key : dotnet.System_Arr<Swift.UInt8>) throws {
        var __thrown : NullableHandle = nil;
        let h = System_Security_Cryptography_HMACSHA256_ctor_0__1__u8Array(&__thrown, key.get_handle());
        if let __ex = __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
            super.init(hndl: h);
        }
    }
    // System.Byte[] HashData(System.Byte[], System.Byte[])
// docid: M:System.Security.Cryptography.HMACSHA256.HashData(System.Byte[],System.Byte[])
    open class func HashData(key : dotnet.System_Arr<Swift.UInt8>, source : dotnet.System_Arr<Swift.UInt8>) throws -> dotnet.System_Arr<Swift.UInt8> {
        var __thrown : NullableHandle = nil;
        let __return = System_Security_Cryptography_HMACSHA256_u8Array__HashData_0__2__u8Array_u8Array(&__thrown, key.get_handle(), source.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return dotnet.System_Arr<Swift.UInt8>(hndl : __return);
        }
    }
// TODO COPE (write_all_methods) (span) System.Byte[] HashData(System.ReadOnlySpan<System.Byte>, System.ReadOnlySpan<System.Byte>)
// TODO COPE (write_all_methods) (span) System.Int32 HashData(System.ReadOnlySpan<System.Byte>, System.ReadOnlySpan<System.Byte>, System.Span<System.Byte>)
    // void Initialize()
// docid: M:System.Security.Cryptography.HMACSHA256.Initialize
    /**
    Resets the hash algorithm to its initial state.

    */
    open override func Initialize() throws {
        var __thrown : NullableHandle = nil;
        System_Security_Cryptography_HMACSHA256_void__Initialize_0__0(&__thrown, self.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
            return;
        }
    }
// TODO COPE (write_all_methods) (span) bool TryHashData(System.ReadOnlySpan<System.Byte>, System.ReadOnlySpan<System.Byte>, System.Span<System.Byte>, ref System.Int32)
    // [IsSpecialName] System.Byte[] get_Key()
// docid: M:System.Security.Cryptography.HMACSHA256.get_Key
    open override func get_Key() throws -> dotnet.System_Arr<Swift.UInt8> {
        var __thrown : NullableHandle = nil;
        let __return = System_Security_Cryptography_HMACSHA256_u8Array__get_Key_0__0(&__thrown, self.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return dotnet.System_Arr<Swift.UInt8>(hndl : __return);
        }
    }
    // [IsSpecialName] void set_Key(System.Byte[])
// docid: M:System.Security.Cryptography.HMACSHA256.set_Key(System.Byte[])
    open override func set_Key(value : dotnet.System_Arr<Swift.UInt8>) throws {
        var __thrown : NullableHandle = nil;
        System_Security_Cryptography_HMACSHA256_void__set_Key_0__1__u8Array(&__thrown, self.get_handle(), value.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
            return;
        }
    }
    /**
    Gets or sets the key to use in the HMAC calculation.

    */
    open override var Key : dotnet.System_Arr<Swift.UInt8> {
        get {
            return try! get_Key();
        }
        set(v) {
            return try! set_Key(value: v);
        }
    }
} // HMACSHA256


// type: System.Security.Cryptography.HMACSHA384
    /**
    Computes a Hash-based Message Authentication Code (HMAC) using the  hash function.

    */
open class HMACSHA384
    :
    dotnet.System.Security.Cryptography.HMAC
{
    open class override func get_type_handle() -> TypeHandle {
        return System_Security_Cryptography_HMACSHA384_get_type_handle();
    }
    public required init(hndl: NonnullHandle) { super.init(hndl: hndl); }
    public required init(gval: GVal) { super.init(gval: gval); }
    // .ctor()
// docid: M:System.Security.Cryptography.HMACSHA384.#ctor
    /**
    Initializes a new instance of the  class by using a randomly generated key.

    */
    public init() throws {
        var __thrown : NullableHandle = nil;
        let h = System_Security_Cryptography_HMACSHA384_ctor_0__0(&__thrown);
        if let __ex = __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
            super.init(hndl: h);
        }
    }
    // .ctor(System.Byte[])
// docid: M:System.Security.Cryptography.HMACSHA384.#ctor(System.Byte[])
    /**
    Initializes a new instance of the  class by using the specified key data.

    - Parameter key: The secret key for  encryption. The key can be any length. However, the recommended size is 128 bytes. If the key is more than 128 bytes long, it is hashed (using SHA-384) to derive a 128-byte key. If it is less than 128 bytes long, it is padded to 128 bytes.
    */
    public init(key : dotnet.System_Arr<Swift.UInt8>) throws {
        var __thrown : NullableHandle = nil;
        let h = System_Security_Cryptography_HMACSHA384_ctor_0__1__u8Array(&__thrown, key.get_handle());
        if let __ex = __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
            super.init(hndl: h);
        }
    }
    // System.Byte[] HashData(System.Byte[], System.Byte[])
// docid: M:System.Security.Cryptography.HMACSHA384.HashData(System.Byte[],System.Byte[])
    open class func HashData(key : dotnet.System_Arr<Swift.UInt8>, source : dotnet.System_Arr<Swift.UInt8>) throws -> dotnet.System_Arr<Swift.UInt8> {
        var __thrown : NullableHandle = nil;
        let __return = System_Security_Cryptography_HMACSHA384_u8Array__HashData_0__2__u8Array_u8Array(&__thrown, key.get_handle(), source.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return dotnet.System_Arr<Swift.UInt8>(hndl : __return);
        }
    }
// TODO COPE (write_all_methods) (span) System.Byte[] HashData(System.ReadOnlySpan<System.Byte>, System.ReadOnlySpan<System.Byte>)
// TODO COPE (write_all_methods) (span) System.Int32 HashData(System.ReadOnlySpan<System.Byte>, System.ReadOnlySpan<System.Byte>, System.Span<System.Byte>)
    // void Initialize()
// docid: M:System.Security.Cryptography.HMACSHA384.Initialize
    /**
    Resets the hash algorithm to its initial state.

    */
    open override func Initialize() throws {
        var __thrown : NullableHandle = nil;
        System_Security_Cryptography_HMACSHA384_void__Initialize_0__0(&__thrown, self.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
            return;
        }
    }
// TODO COPE (write_all_methods) (span) bool TryHashData(System.ReadOnlySpan<System.Byte>, System.ReadOnlySpan<System.Byte>, System.Span<System.Byte>, ref System.Int32)
    // [IsSpecialName] System.Byte[] get_Key()
// docid: M:System.Security.Cryptography.HMACSHA384.get_Key
    open override func get_Key() throws -> dotnet.System_Arr<Swift.UInt8> {
        var __thrown : NullableHandle = nil;
        let __return = System_Security_Cryptography_HMACSHA384_u8Array__get_Key_0__0(&__thrown, self.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return dotnet.System_Arr<Swift.UInt8>(hndl : __return);
        }
    }
    // [IsSpecialName] void set_Key(System.Byte[])
// docid: M:System.Security.Cryptography.HMACSHA384.set_Key(System.Byte[])
    open override func set_Key(value : dotnet.System_Arr<Swift.UInt8>) throws {
        var __thrown : NullableHandle = nil;
        System_Security_Cryptography_HMACSHA384_void__set_Key_0__1__u8Array(&__thrown, self.get_handle(), value.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
            return;
        }
    }
    // [IsSpecialName] bool get_ProduceLegacyHmacValues()
// docid: M:System.Security.Cryptography.HMACSHA384.get_ProduceLegacyHmacValues
    open func get_ProduceLegacyHmacValues() throws -> Bool {
        var __thrown : NullableHandle = nil;
        let __return = System_Security_Cryptography_HMACSHA384_bool__get_ProduceLegacyHmacValues_0__0(&__thrown, self.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return (__return) != 0;
        }
    }
    // [IsSpecialName] void set_ProduceLegacyHmacValues(bool)
// docid: M:System.Security.Cryptography.HMACSHA384.set_ProduceLegacyHmacValues(System.Boolean)
    open func set_ProduceLegacyHmacValues(value : Bool) throws {
        var __thrown : NullableHandle = nil;
        System_Security_Cryptography_HMACSHA384_void__set_ProduceLegacyHmacValues_0__1__bool(&__thrown, self.get_handle(), Swift.Int32(value ? 1 : 0));
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
            return;
        }
    }
    /**
    Gets or sets the key to use in the HMAC calculation.

    */
    open override var Key : dotnet.System_Arr<Swift.UInt8> {
        get {
            return try! get_Key();
        }
        set(v) {
            return try! set_Key(value: v);
        }
    }
    /**
    Provides a workaround for the .NET Framework 2.0 implementation of the  algorithm, which is inconsistent with the .NET Framework 2.0 Service Pack 1 implementation of the algorithm.

    */
    open var ProduceLegacyHmacValues : Bool {
        get {
            return try! get_ProduceLegacyHmacValues();
        }
        set(v) {
            return try! set_ProduceLegacyHmacValues(value: v);
        }
    }
} // HMACSHA384


// type: System.Security.Cryptography.HMACSHA512
    /**
    Computes a Hash-based Message Authentication Code (HMAC) using the  hash function.

    */
open class HMACSHA512
    :
    dotnet.System.Security.Cryptography.HMAC
{
    open class override func get_type_handle() -> TypeHandle {
        return System_Security_Cryptography_HMACSHA512_get_type_handle();
    }
    public required init(hndl: NonnullHandle) { super.init(hndl: hndl); }
    public required init(gval: GVal) { super.init(gval: gval); }
    // .ctor()
// docid: M:System.Security.Cryptography.HMACSHA512.#ctor
    /**
    Initializes a new instance of the  class with a randomly generated key.

    */
    public init() throws {
        var __thrown : NullableHandle = nil;
        let h = System_Security_Cryptography_HMACSHA512_ctor_0__0(&__thrown);
        if let __ex = __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
            super.init(hndl: h);
        }
    }
    // .ctor(System.Byte[])
// docid: M:System.Security.Cryptography.HMACSHA512.#ctor(System.Byte[])
    /**
    Initializes a new instance of the  class with the specified key data.

    - Parameter key: The secret key for  encryption. The key can be any length. However, the recommended size is 128 bytes. If the key is more than 128 bytes long, it is hashed (using SHA-512) to derive a 128-byte key. If it is less than 128 bytes long, it is padded to 128 bytes.
    */
    public init(key : dotnet.System_Arr<Swift.UInt8>) throws {
        var __thrown : NullableHandle = nil;
        let h = System_Security_Cryptography_HMACSHA512_ctor_0__1__u8Array(&__thrown, key.get_handle());
        if let __ex = __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
            super.init(hndl: h);
        }
    }
    // System.Byte[] HashData(System.Byte[], System.Byte[])
// docid: M:System.Security.Cryptography.HMACSHA512.HashData(System.Byte[],System.Byte[])
    open class func HashData(key : dotnet.System_Arr<Swift.UInt8>, source : dotnet.System_Arr<Swift.UInt8>) throws -> dotnet.System_Arr<Swift.UInt8> {
        var __thrown : NullableHandle = nil;
        let __return = System_Security_Cryptography_HMACSHA512_u8Array__HashData_0__2__u8Array_u8Array(&__thrown, key.get_handle(), source.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return dotnet.System_Arr<Swift.UInt8>(hndl : __return);
        }
    }
// TODO COPE (write_all_methods) (span) System.Byte[] HashData(System.ReadOnlySpan<System.Byte>, System.ReadOnlySpan<System.Byte>)
// TODO COPE (write_all_methods) (span) System.Int32 HashData(System.ReadOnlySpan<System.Byte>, System.ReadOnlySpan<System.Byte>, System.Span<System.Byte>)
    // void Initialize()
// docid: M:System.Security.Cryptography.HMACSHA512.Initialize
    /**
    Resets the hash algorithm to its initial state.

    */
    open override func Initialize() throws {
        var __thrown : NullableHandle = nil;
        System_Security_Cryptography_HMACSHA512_void__Initialize_0__0(&__thrown, self.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
            return;
        }
    }
// TODO COPE (write_all_methods) (span) bool TryHashData(System.ReadOnlySpan<System.Byte>, System.ReadOnlySpan<System.Byte>, System.Span<System.Byte>, ref System.Int32)
    // [IsSpecialName] System.Byte[] get_Key()
// docid: M:System.Security.Cryptography.HMACSHA512.get_Key
    open override func get_Key() throws -> dotnet.System_Arr<Swift.UInt8> {
        var __thrown : NullableHandle = nil;
        let __return = System_Security_Cryptography_HMACSHA512_u8Array__get_Key_0__0(&__thrown, self.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return dotnet.System_Arr<Swift.UInt8>(hndl : __return);
        }
    }
    // [IsSpecialName] void set_Key(System.Byte[])
// docid: M:System.Security.Cryptography.HMACSHA512.set_Key(System.Byte[])
    open override func set_Key(value : dotnet.System_Arr<Swift.UInt8>) throws {
        var __thrown : NullableHandle = nil;
        System_Security_Cryptography_HMACSHA512_void__set_Key_0__1__u8Array(&__thrown, self.get_handle(), value.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
            return;
        }
    }
    // [IsSpecialName] bool get_ProduceLegacyHmacValues()
// docid: M:System.Security.Cryptography.HMACSHA512.get_ProduceLegacyHmacValues
    open func get_ProduceLegacyHmacValues() throws -> Bool {
        var __thrown : NullableHandle = nil;
        let __return = System_Security_Cryptography_HMACSHA512_bool__get_ProduceLegacyHmacValues_0__0(&__thrown, self.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return (__return) != 0;
        }
    }
    // [IsSpecialName] void set_ProduceLegacyHmacValues(bool)
// docid: M:System.Security.Cryptography.HMACSHA512.set_ProduceLegacyHmacValues(System.Boolean)
    open func set_ProduceLegacyHmacValues(value : Bool) throws {
        var __thrown : NullableHandle = nil;
        System_Security_Cryptography_HMACSHA512_void__set_ProduceLegacyHmacValues_0__1__bool(&__thrown, self.get_handle(), Swift.Int32(value ? 1 : 0));
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
            return;
        }
    }
    /**
    Gets or sets the key to use in the HMAC calculation.

    */
    open override var Key : dotnet.System_Arr<Swift.UInt8> {
        get {
            return try! get_Key();
        }
        set(v) {
            return try! set_Key(value: v);
        }
    }
    /**
    Provides a workaround for the .NET Framework 2.0 implementation of the  algorithm, which is inconsistent with the .NET Framework 2.0 Service Pack 1 implementation.

    */
    open var ProduceLegacyHmacValues : Bool {
        get {
            return try! get_ProduceLegacyHmacValues();
        }
        set(v) {
            return try! set_ProduceLegacyHmacValues(value: v);
        }
    }
} // HMACSHA512


// type: System.Security.Cryptography.IncrementalHash
    /**
    Provides support for computing a hash or Hash-based Message Authentication Code (HMAC) value incrementally across several segments.

    */
public final class IncrementalHash
    :
    dotnet.System.Object,
    System_IDisposable
{
    public class override func get_type_handle() -> TypeHandle {
        return System_Security_Cryptography_IncrementalHash_get_type_handle();
    }
    public required init(hndl: NonnullHandle) { super.init(hndl: hndl); }
    public required init(gval: GVal) { super.init(gval: gval); }
    // void AppendData(System.Byte[])
// docid: M:System.Security.Cryptography.IncrementalHash.AppendData(System.Byte[])
    /**
    Appends the specified data to the data already processed in the hash or HMAC.

    - Parameter data: The data to process.
    */
    public func AppendData(data : dotnet.System_Arr<Swift.UInt8>) throws {
        var __thrown : NullableHandle = nil;
        System_Security_Cryptography_IncrementalHash_void__AppendData_0__1__u8Array(&__thrown, self.get_handle(), data.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
            return;
        }
    }
    // void AppendData(System.Byte[], System.Int32, System.Int32)
// docid: M:System.Security.Cryptography.IncrementalHash.AppendData(System.Byte[],System.Int32,System.Int32)
    /**
    Appends the specified number of bytes from the specified data, starting at the specified offset, to the data already processed in the hash or Hash-based Message Authentication Code (HMAC).

    - Parameter data: The data to process.
    - Parameter offset: The offset into the byte array from which to begin using data.
    - Parameter count: The number of bytes to use from .
    */
    public func AppendData(data : dotnet.System_Arr<Swift.UInt8>, offset : Swift.Int32, count : Swift.Int32) throws {
        var __thrown : NullableHandle = nil;
        System_Security_Cryptography_IncrementalHash_void__AppendData_0__3__u8Array_i32_i32(&__thrown, self.get_handle(), data.get_handle(), offset, count);
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
            return;
        }
    }
// TODO COPE (write_all_methods) (span) void AppendData(System.ReadOnlySpan<System.Byte>)
    // System.Security.Cryptography.IncrementalHash CreateHash(System.Security.Cryptography.HashAlgorithmName)
// docid: M:System.Security.Cryptography.IncrementalHash.CreateHash(System.Security.Cryptography.HashAlgorithmName)
    /**
    Creates an  for the specified algorithm.

    - Parameter hashAlgorithm: The name of the hash algorithm to perform.
    - Returns: An  instance ready to compute the hash algorithm specified by .

    */
    public class func CreateHash(hashAlgorithm : dotnet.System.Security.Cryptography.HashAlgorithmName) throws -> dotnet.System.Security.Cryptography.IncrementalHash {
        var __thrown : NullableHandle = nil;
        let __return = System_Security_Cryptography_IncrementalHash_IncrementalHash__CreateHash_0__1__HashAlgorithmName(&__thrown, hashAlgorithm.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return dotnet.System.Security.Cryptography.IncrementalHash(hndl : __return);
        }
    }
    // System.Security.Cryptography.IncrementalHash CreateHMAC(System.Security.Cryptography.HashAlgorithmName, System.Byte[])
// docid: M:System.Security.Cryptography.IncrementalHash.CreateHMAC(System.Security.Cryptography.HashAlgorithmName,System.Byte[])
    /**
    Creates an  for the Hash-based Message Authentication Code (HMAC) algorithm using the specified hash algorithm and key.

    - Parameter hashAlgorithm: The name of the hash algorithm to perform within the HMAC.
    - Parameter key: The secret key for the HMAC. The key can be of any length, but a key longer than the output size of the specified hash algorithm will be hashed to derive a correctly-sized key. Therefore, the recommended size of the secret key is the output size of the specified hash algorithm.
    - Returns: An instance of the  class ready to compute the specified hash algorithm.

    */
    public class func CreateHMAC(hashAlgorithm : dotnet.System.Security.Cryptography.HashAlgorithmName, key : dotnet.System_Arr<Swift.UInt8>) throws -> dotnet.System.Security.Cryptography.IncrementalHash {
        var __thrown : NullableHandle = nil;
        let __return = System_Security_Cryptography_IncrementalHash_IncrementalHash__CreateHMAC_0__2__HashAlgorithmName_u8Array(&__thrown, hashAlgorithm.get_handle(), key.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return dotnet.System.Security.Cryptography.IncrementalHash(hndl : __return);
        }
    }
// TODO COPE (write_all_methods) (span) System.Security.Cryptography.IncrementalHash CreateHMAC(System.Security.Cryptography.HashAlgorithmName, System.ReadOnlySpan<System.Byte>)
    // void Dispose()
// docid: M:System.Security.Cryptography.IncrementalHash.Dispose
    /**
    Releases the resources used by the current instance of the  class.

    */
    public func Dispose() throws {
        var __thrown : NullableHandle = nil;
        System_Security_Cryptography_IncrementalHash_void__Dispose_0__0(&__thrown, self.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
            return;
        }
    }
    // System.Byte[] GetCurrentHash()
// docid: M:System.Security.Cryptography.IncrementalHash.GetCurrentHash
    /**
    Retrieves the hash or Hash-based Message Authentication Code (HMAC) for the data accumulated from prior calls to the  methods, without resetting the object to its initial state.

    - Returns: The computed hash or HMAC.

    */
    public func GetCurrentHash() throws -> dotnet.System_Arr<Swift.UInt8> {
        var __thrown : NullableHandle = nil;
        let __return = System_Security_Cryptography_IncrementalHash_u8Array__GetCurrentHash_0__0(&__thrown, self.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return dotnet.System_Arr<Swift.UInt8>(hndl : __return);
        }
    }
// TODO COPE (write_all_methods) (span) System.Int32 GetCurrentHash(System.Span<System.Byte>)
    // System.Byte[] GetHashAndReset()
// docid: M:System.Security.Cryptography.IncrementalHash.GetHashAndReset
    /**
    Retrieves the hash or Hash-based Message Authentication Code (HMAC) for the data accumulated from prior calls to the  methods,  and resets the object to its initial state.

    - Returns: The computed hash or HMAC.

    */
    public func GetHashAndReset() throws -> dotnet.System_Arr<Swift.UInt8> {
        var __thrown : NullableHandle = nil;
        let __return = System_Security_Cryptography_IncrementalHash_u8Array__GetHashAndReset_0__0(&__thrown, self.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return dotnet.System_Arr<Swift.UInt8>(hndl : __return);
        }
    }
// TODO COPE (write_all_methods) (span) System.Int32 GetHashAndReset(System.Span<System.Byte>)
// TODO COPE (write_all_methods) (span) bool TryGetCurrentHash(System.Span<System.Byte>, ref System.Int32)
// TODO COPE (write_all_methods) (span) bool TryGetHashAndReset(System.Span<System.Byte>, ref System.Int32)
    // [IsSpecialName] System.Security.Cryptography.HashAlgorithmName get_AlgorithmName()
// docid: M:System.Security.Cryptography.IncrementalHash.get_AlgorithmName
    public func get_AlgorithmName() throws -> dotnet.System.Security.Cryptography.HashAlgorithmName {
        var __thrown : NullableHandle = nil;
        let __return = System_Security_Cryptography_IncrementalHash_HashAlgorithmName__get_AlgorithmName_0__0(&__thrown, self.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return dotnet.System.Security.Cryptography.HashAlgorithmName(hndl : __return);
        }
    }
    // [IsSpecialName] System.Int32 get_HashLengthInBytes()
// docid: M:System.Security.Cryptography.IncrementalHash.get_HashLengthInBytes
    public func get_HashLengthInBytes() throws -> Swift.Int32 {
        var __thrown : NullableHandle = nil;
        let __return = System_Security_Cryptography_IncrementalHash_i32__get_HashLengthInBytes_0__0(&__thrown, self.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return __return;
        }
    }
    /**
    Gets the name of the algorithm being performed. HMAC algorithms are prepended with "HMAC" to distinguish them from an unkeyed digest.

    */
    public var AlgorithmName : dotnet.System.Security.Cryptography.HashAlgorithmName {
        get {
            return try! get_AlgorithmName();
        }
    }
    /**
    Gets the output size of this hash or HMAC algorithm, in bytes.

    */
    public var HashLengthInBytes : Swift.Int32 {
        get {
            return try! get_HashLengthInBytes();
        }
    }
} // IncrementalHash


// type: System.Security.Cryptography.MD5
    /**
    Represents the abstract class from which all implementations of the  hash algorithm inherit.

    */
open class MD5
    :
    dotnet.System.Security.Cryptography.HashAlgorithm
{
    open class override func get_type_handle() -> TypeHandle {
        return System_Security_Cryptography_MD5_get_type_handle();
    }
    public required init(hndl: NonnullHandle) { super.init(hndl: hndl); }
    public required init(gval: GVal) { super.init(gval: gval); }
    // System.Security.Cryptography.MD5 Create()
// docid: M:System.Security.Cryptography.MD5.Create
    /**
    Creates an instance of the default implementation of the  hash algorithm.

    - Returns: A new instance of the  hash algorithm.

    */
    open class override func Create() throws -> dotnet.System.Security.Cryptography.MD5 {
        var __thrown : NullableHandle = nil;
        let __return = System_Security_Cryptography_MD5_MD5__Create_0__0(&__thrown);
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return dotnet.System.Security.Cryptography.MD5(hndl : __return);
        }
    }
    // System.Security.Cryptography.MD5 Create(System.String)
// docid: M:System.Security.Cryptography.MD5.Create(System.String)
    /**
    Creates an instance of the specified implementation of the  hash algorithm.

    - Parameter algName: The name of the specific implementation of  to use.
    - Returns: A new instance of the specified implementation of .

    */
    open class func Create(algName : dotnet.System.String) throws -> Optional<dotnet.System.Security.Cryptography.MD5> {
        var __thrown : NullableHandle = nil;
        let __return = System_Security_Cryptography_MD5_MD5__Create_0__1__String(&__thrown, algName.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        if let __ret_unwrapped = __return {
            return dotnet.System.Security.Cryptography.MD5(hndl : __ret_unwrapped);
        } else {
            return nil;
        }
        }
    }
    // System.Byte[] HashData(System.Byte[])
// docid: M:System.Security.Cryptography.MD5.HashData(System.Byte[])
    /**
    Computes the hash of data using the MD5 algorithm.

    - Parameter source: The data to hash.
    - Returns: The hash of the data.

    */
    open class func HashData(source : dotnet.System_Arr<Swift.UInt8>) throws -> dotnet.System_Arr<Swift.UInt8> {
        var __thrown : NullableHandle = nil;
        let __return = System_Security_Cryptography_MD5_u8Array__HashData_0__1__u8Array(&__thrown, source.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return dotnet.System_Arr<Swift.UInt8>(hndl : __return);
        }
    }
// TODO COPE (write_all_methods) (span) System.Byte[] HashData(System.ReadOnlySpan<System.Byte>)
// TODO COPE (write_all_methods) (span) System.Int32 HashData(System.ReadOnlySpan<System.Byte>, System.Span<System.Byte>)
// TODO COPE (write_all_methods) (span) bool TryHashData(System.ReadOnlySpan<System.Byte>, System.Span<System.Byte>, ref System.Int32)
} // MD5


// type: System.Security.Cryptography.MaskGenerationMethod
    /**
    Represents the abstract class from which all mask generator algorithms must derive.

    */
open class MaskGenerationMethod
    :
    dotnet.System.Object
{
    open class override func get_type_handle() -> TypeHandle {
        return System_Security_Cryptography_MaskGenerationMethod_get_type_handle();
    }
    public required init(hndl: NonnullHandle) { super.init(hndl: hndl); }
    public required init(gval: GVal) { super.init(gval: gval); }
    // System.Byte[] GenerateMask(System.Byte[], System.Int32)
// docid: M:System.Security.Cryptography.MaskGenerationMethod.GenerateMask(System.Byte[],System.Int32)
    /**
    When overridden in a derived class, generates a mask with the specified length using the specified random seed.

    - Parameter rgbSeed: The random seed to use to compute the mask.
    - Parameter cbReturn: The length of the generated mask in bytes.
    - Returns: A randomly generated mask whose length is equal to the  parameter.

    */
    open func GenerateMask(rgbSeed : dotnet.System_Arr<Swift.UInt8>, cbReturn : Swift.Int32) throws -> dotnet.System_Arr<Swift.UInt8> {
        var __thrown : NullableHandle = nil;
        let __return = System_Security_Cryptography_MaskGenerationMethod_u8Array__GenerateMask_0__2__u8Array_i32(&__thrown, self.get_handle(), rgbSeed.get_handle(), cbReturn);
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return dotnet.System_Arr<Swift.UInt8>(hndl : __return);
        }
    }
} // MaskGenerationMethod


// type: System.Security.Cryptography.PKCS1MaskGenerationMethod
    /**
    Computes masks according to PKCS #1 for use by key exchange algorithms.

    */
open class PKCS1MaskGenerationMethod
    :
    dotnet.System.Security.Cryptography.MaskGenerationMethod
{
    open class override func get_type_handle() -> TypeHandle {
        return System_Security_Cryptography_PKCS1MaskGenerationMethod_get_type_handle();
    }
    public required init(hndl: NonnullHandle) { super.init(hndl: hndl); }
    public required init(gval: GVal) { super.init(gval: gval); }
    // .ctor()
// docid: M:System.Security.Cryptography.PKCS1MaskGenerationMethod.#ctor
    /**
    Initializes a new instance of the  class.

    */
    public init() throws {
        var __thrown : NullableHandle = nil;
        let h = System_Security_Cryptography_PKCS1MaskGenerationMethod_ctor_0__0(&__thrown);
        if let __ex = __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
            super.init(hndl: h);
        }
    }
    // System.Byte[] GenerateMask(System.Byte[], System.Int32)
// docid: M:System.Security.Cryptography.PKCS1MaskGenerationMethod.GenerateMask(System.Byte[],System.Int32)
    /**
    Generates and returns a mask from the specified random seed of the specified length.

    - Parameter rgbSeed: The random seed to use for computing the mask.
    - Parameter cbReturn: The length of the generated mask in bytes.
    - Returns: A randomly generated mask whose length is equal to the  parameter.

    */
    open override func GenerateMask(rgbSeed : dotnet.System_Arr<Swift.UInt8>, cbReturn : Swift.Int32) throws -> dotnet.System_Arr<Swift.UInt8> {
        var __thrown : NullableHandle = nil;
        let __return = System_Security_Cryptography_PKCS1MaskGenerationMethod_u8Array__GenerateMask_0__2__u8Array_i32(&__thrown, self.get_handle(), rgbSeed.get_handle(), cbReturn);
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return dotnet.System_Arr<Swift.UInt8>(hndl : __return);
        }
    }
    // [IsSpecialName] System.String get_HashName()
// docid: M:System.Security.Cryptography.PKCS1MaskGenerationMethod.get_HashName
    open func get_HashName() throws -> dotnet.System.String {
        var __thrown : NullableHandle = nil;
        let __return = System_Security_Cryptography_PKCS1MaskGenerationMethod_String__get_HashName_0__0(&__thrown, self.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return dotnet.System.String(hndl : __return);
        }
    }
    // [IsSpecialName] void set_HashName(System.String)
// docid: M:System.Security.Cryptography.PKCS1MaskGenerationMethod.set_HashName(System.String)
    open func set_HashName(value : dotnet.System.String) throws {
        var __thrown : NullableHandle = nil;
        System_Security_Cryptography_PKCS1MaskGenerationMethod_void__set_HashName_0__1__String(&__thrown, self.get_handle(), value.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
            return;
        }
    }
    /**
    Gets or sets the name of the hash algorithm type to use for generating the mask.

    */
    open var HashName : dotnet.System.String {
        get {
            return try! get_HashName();
        }
        set(v) {
            return try! set_HashName(value: v);
        }
    }
} // PKCS1MaskGenerationMethod


// type: System.Security.Cryptography.RC2
    /**
    Represents the base class from which all implementations of the  algorithm must derive.

    */
open class RC2
    :
    dotnet.System.Security.Cryptography.SymmetricAlgorithm
{
    open class override func get_type_handle() -> TypeHandle {
        return System_Security_Cryptography_RC2_get_type_handle();
    }
    public required init(hndl: NonnullHandle) { super.init(hndl: hndl); }
    public required init(gval: GVal) { super.init(gval: gval); }
    // System.Security.Cryptography.RC2 Create()
// docid: M:System.Security.Cryptography.RC2.Create
    /**
    Creates an instance of a cryptographic object to perform the  algorithm.

    - Returns: An instance of a cryptographic object.

    */
    open class override func Create() throws -> dotnet.System.Security.Cryptography.RC2 {
        var __thrown : NullableHandle = nil;
        let __return = System_Security_Cryptography_RC2_RC2__Create_0__0(&__thrown);
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return dotnet.System.Security.Cryptography.RC2(hndl : __return);
        }
    }
    // System.Security.Cryptography.RC2 Create(System.String)
// docid: M:System.Security.Cryptography.RC2.Create(System.String)
    /**
    Creates an instance of a cryptographic object to perform the specified implementation of the  algorithm.

    - Parameter AlgName: The name of the specific implementation of  to use.
    - Returns: An instance of a cryptographic object.

    */
    open class func Create(AlgName : dotnet.System.String) throws -> Optional<dotnet.System.Security.Cryptography.RC2> {
        var __thrown : NullableHandle = nil;
        let __return = System_Security_Cryptography_RC2_RC2__Create_0__1__String(&__thrown, AlgName.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        if let __ret_unwrapped = __return {
            return dotnet.System.Security.Cryptography.RC2(hndl : __ret_unwrapped);
        } else {
            return nil;
        }
        }
    }
    // [IsSpecialName] System.Int32 get_EffectiveKeySize()
// docid: M:System.Security.Cryptography.RC2.get_EffectiveKeySize
    open func get_EffectiveKeySize() throws -> Swift.Int32 {
        var __thrown : NullableHandle = nil;
        let __return = System_Security_Cryptography_RC2_i32__get_EffectiveKeySize_0__0(&__thrown, self.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return __return;
        }
    }
    // [IsSpecialName] void set_EffectiveKeySize(System.Int32)
// docid: M:System.Security.Cryptography.RC2.set_EffectiveKeySize(System.Int32)
    open func set_EffectiveKeySize(value : Swift.Int32) throws {
        var __thrown : NullableHandle = nil;
        System_Security_Cryptography_RC2_void__set_EffectiveKeySize_0__1__i32(&__thrown, self.get_handle(), value);
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
            return;
        }
    }
    // [IsSpecialName] System.Int32 get_KeySize()
// docid: M:System.Security.Cryptography.RC2.get_KeySize
    open override func get_KeySize() throws -> Swift.Int32 {
        var __thrown : NullableHandle = nil;
        let __return = System_Security_Cryptography_RC2_i32__get_KeySize_0__0(&__thrown, self.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return __return;
        }
    }
    // [IsSpecialName] void set_KeySize(System.Int32)
// docid: M:System.Security.Cryptography.RC2.set_KeySize(System.Int32)
    open override func set_KeySize(value : Swift.Int32) throws {
        var __thrown : NullableHandle = nil;
        System_Security_Cryptography_RC2_void__set_KeySize_0__1__i32(&__thrown, self.get_handle(), value);
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
            return;
        }
    }
    /**
    Gets or sets the effective size of the secret key used by the  algorithm in bits.

    */
    open var EffectiveKeySize : Swift.Int32 {
        get {
            return try! get_EffectiveKeySize();
        }
        set(v) {
            return try! set_EffectiveKeySize(value: v);
        }
    }
    /**
    Gets or sets the size of the secret key used by the  algorithm in bits.

    */
    open override var KeySize : Swift.Int32 {
        get {
            return try! get_KeySize();
        }
        set(v) {
            return try! set_KeySize(value: v);
        }
    }
} // RC2


// type: System.Security.Cryptography.RSA
    /**
    Represents the base class from which all implementations of the  algorithm inherit.

    */
open class RSA
    :
    dotnet.System.Security.Cryptography.AsymmetricAlgorithm
{
    open class override func get_type_handle() -> TypeHandle {
        return System_Security_Cryptography_RSA_get_type_handle();
    }
    public required init(hndl: NonnullHandle) { super.init(hndl: hndl); }
    public required init(gval: GVal) { super.init(gval: gval); }
    // System.Security.Cryptography.RSA Create()
// docid: M:System.Security.Cryptography.RSA.Create
    /**
    Creates an instance of the default implementation of the  algorithm.

    - Returns: A new instance of the default implementation of .

    */
    open class override func Create() throws -> dotnet.System.Security.Cryptography.RSA {
        var __thrown : NullableHandle = nil;
        let __return = System_Security_Cryptography_RSA_RSA__Create_0__0(&__thrown);
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return dotnet.System.Security.Cryptography.RSA(hndl : __return);
        }
    }
    // System.Security.Cryptography.RSA Create(System.Int32)
// docid: M:System.Security.Cryptography.RSA.Create(System.Int32)
    /**
    Creates a new ephemeral RSA key with the specified key size.

    - Parameter keySizeInBits: The key size, in bits.
    - Returns: A new ephemeral RSA key with the specified key size.

    */
    open class func Create(keySizeInBits : Swift.Int32) throws -> dotnet.System.Security.Cryptography.RSA {
        var __thrown : NullableHandle = nil;
        let __return = System_Security_Cryptography_RSA_RSA__Create_0__1__i32(&__thrown, keySizeInBits);
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return dotnet.System.Security.Cryptography.RSA(hndl : __return);
        }
    }
    // System.Security.Cryptography.RSA Create(System.Security.Cryptography.RSAParameters)
// docid: M:System.Security.Cryptography.RSA.Create(System.Security.Cryptography.RSAParameters)
    /**
    Creates a new ephemeral RSA key with the specified RSA key parameters.

    - Parameter parameters: The parameters for the  algorithm.
    - Returns: A new ephemeral RSA key.

    */
    open class func Create(parameters : dotnet.System.Security.Cryptography.RSAParameters) throws -> dotnet.System.Security.Cryptography.RSA {
        var __thrown : NullableHandle = nil;
        let __return = System_Security_Cryptography_RSA_RSA__Create_0__1__RSAParameters(&__thrown, parameters.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return dotnet.System.Security.Cryptography.RSA(hndl : __return);
        }
    }
    // System.Security.Cryptography.RSA Create(System.String)
// docid: M:System.Security.Cryptography.RSA.Create(System.String)
    /**
    Creates an instance of the specified implementation of .

    - Parameter algName: The name of the implementation of  to use.
    - Returns: A new instance of the specified implementation of .

    */
    open class override func Create(algName : dotnet.System.String) throws -> Optional<dotnet.System.Security.Cryptography.RSA> {
        var __thrown : NullableHandle = nil;
        let __return = System_Security_Cryptography_RSA_RSA__Create_0__1__String(&__thrown, algName.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        if let __ret_unwrapped = __return {
            return dotnet.System.Security.Cryptography.RSA(hndl : __ret_unwrapped);
        } else {
            return nil;
        }
        }
    }
    // System.Byte[] Decrypt(System.Byte[], System.Security.Cryptography.RSAEncryptionPadding)
// docid: M:System.Security.Cryptography.RSA.Decrypt(System.Byte[],System.Security.Cryptography.RSAEncryptionPadding)
    /**
    When overridden in a derived class, decrypts the input data using the specified padding mode.

    - Parameter data: The data to decrypt.
    - Parameter padding: The padding mode.
    - Returns: The decrypted data.

    */
    open func Decrypt(data : dotnet.System_Arr<Swift.UInt8>, padding : dotnet.System.Security.Cryptography.RSAEncryptionPadding) throws -> dotnet.System_Arr<Swift.UInt8> {
        var __thrown : NullableHandle = nil;
        let __return = System_Security_Cryptography_RSA_u8Array__Decrypt_0__2__u8Array_RSAEncryptionPadding(&__thrown, self.get_handle(), data.get_handle(), padding.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return dotnet.System_Arr<Swift.UInt8>(hndl : __return);
        }
    }
    // System.Byte[] DecryptValue(System.Byte[])
// docid: M:System.Security.Cryptography.RSA.DecryptValue(System.Byte[])
    /**
    When overridden in a derived class, decrypts the input data using the private key.

    - Parameter rgb: The cipher text to be decrypted.
    - Returns: The resulting decryption of the  parameter in plain text.

    */
    open func DecryptValue(rgb : dotnet.System_Arr<Swift.UInt8>) throws -> dotnet.System_Arr<Swift.UInt8> {
        var __thrown : NullableHandle = nil;
        let __return = System_Security_Cryptography_RSA_u8Array__DecryptValue_0__1__u8Array(&__thrown, self.get_handle(), rgb.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return dotnet.System_Arr<Swift.UInt8>(hndl : __return);
        }
    }
    // System.Byte[] Encrypt(System.Byte[], System.Security.Cryptography.RSAEncryptionPadding)
// docid: M:System.Security.Cryptography.RSA.Encrypt(System.Byte[],System.Security.Cryptography.RSAEncryptionPadding)
    /**
    When overridden in a derived class, encrypts the input data using the specified padding mode.

    - Parameter data: The data to encrypt.
    - Parameter padding: The padding mode.
    - Returns: The encrypted data.

    */
    open func Encrypt(data : dotnet.System_Arr<Swift.UInt8>, padding : dotnet.System.Security.Cryptography.RSAEncryptionPadding) throws -> dotnet.System_Arr<Swift.UInt8> {
        var __thrown : NullableHandle = nil;
        let __return = System_Security_Cryptography_RSA_u8Array__Encrypt_0__2__u8Array_RSAEncryptionPadding(&__thrown, self.get_handle(), data.get_handle(), padding.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return dotnet.System_Arr<Swift.UInt8>(hndl : __return);
        }
    }
    // System.Byte[] EncryptValue(System.Byte[])
// docid: M:System.Security.Cryptography.RSA.EncryptValue(System.Byte[])
    /**
    When overridden in a derived class, encrypts the input data using the public key.

    - Parameter rgb: The plain text to be encrypted.
    - Returns: The resulting encryption of the  parameter as cipher text.

    */
    open func EncryptValue(rgb : dotnet.System_Arr<Swift.UInt8>) throws -> dotnet.System_Arr<Swift.UInt8> {
        var __thrown : NullableHandle = nil;
        let __return = System_Security_Cryptography_RSA_u8Array__EncryptValue_0__1__u8Array(&__thrown, self.get_handle(), rgb.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return dotnet.System_Arr<Swift.UInt8>(hndl : __return);
        }
    }
    // System.Security.Cryptography.RSAParameters ExportParameters(bool)
// docid: M:System.Security.Cryptography.RSA.ExportParameters(System.Boolean)
    /**
    When overridden in a derived class, exports the .

    - Parameter includePrivateParameters: 
         to include private parameters; otherwise, .
    - Returns: The parameters for .

    */
    open func ExportParameters(includePrivateParameters : Bool) throws -> dotnet.System.Security.Cryptography.RSAParameters {
        var __thrown : NullableHandle = nil;
        let __return = System_Security_Cryptography_RSA_RSAParameters__ExportParameters_0__1__bool(&__thrown, self.get_handle(), Swift.Int32(includePrivateParameters ? 1 : 0));
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return dotnet.System.Security.Cryptography.RSAParameters(hndl : __return);
        }
    }
    // System.Byte[] ExportRSAPrivateKey()
// docid: M:System.Security.Cryptography.RSA.ExportRSAPrivateKey
    /**
    Exports the current key in the PKCS#1 RSAPrivateKey format.

    - Returns: A byte array containing the PKCS#1 RSAPrivateKey representation of this key.

    */
    open func ExportRSAPrivateKey() throws -> dotnet.System_Arr<Swift.UInt8> {
        var __thrown : NullableHandle = nil;
        let __return = System_Security_Cryptography_RSA_u8Array__ExportRSAPrivateKey_0__0(&__thrown, self.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return dotnet.System_Arr<Swift.UInt8>(hndl : __return);
        }
    }
    // System.Byte[] ExportRSAPublicKey()
// docid: M:System.Security.Cryptography.RSA.ExportRSAPublicKey
    /**
    Exports the public-key portion of the current key in the PKCS#1 RSAPublicKey format.

    - Returns: A byte array containing the PKCS#1 RSAPublicKey representation of this key.

    */
    open func ExportRSAPublicKey() throws -> dotnet.System_Arr<Swift.UInt8> {
        var __thrown : NullableHandle = nil;
        let __return = System_Security_Cryptography_RSA_u8Array__ExportRSAPublicKey_0__0(&__thrown, self.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return dotnet.System_Arr<Swift.UInt8>(hndl : __return);
        }
    }
    // void FromXmlString(System.String)
// docid: M:System.Security.Cryptography.RSA.FromXmlString(System.String)
    /**
    Initializes an  object from the key information from an XML string.

    - Parameter xmlString: The XML string containing  key information.
    */
    open override func FromXmlString(xmlString : dotnet.System.String) throws {
        var __thrown : NullableHandle = nil;
        System_Security_Cryptography_RSA_void__FromXmlString_0__1__String(&__thrown, self.get_handle(), xmlString.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
            return;
        }
    }
// TODO COPE (write_all_methods) (span) void ImportEncryptedPkcs8PrivateKey(System.ReadOnlySpan<System.Byte>, System.ReadOnlySpan<System.Byte>, ref System.Int32)
// TODO COPE (write_all_methods) (span) void ImportEncryptedPkcs8PrivateKey(System.ReadOnlySpan<System.Char>, System.ReadOnlySpan<System.Byte>, ref System.Int32)
// TODO COPE (write_all_methods) (span) void ImportFromEncryptedPem(System.ReadOnlySpan<System.Char>, System.ReadOnlySpan<System.Byte>)
// TODO COPE (write_all_methods) (span) void ImportFromEncryptedPem(System.ReadOnlySpan<System.Char>, System.ReadOnlySpan<System.Char>)
// TODO COPE (write_all_methods) (span) void ImportFromPem(System.ReadOnlySpan<System.Char>)
    // void ImportParameters(System.Security.Cryptography.RSAParameters)
// docid: M:System.Security.Cryptography.RSA.ImportParameters(System.Security.Cryptography.RSAParameters)
    /**
    When overridden in a derived class, imports the specified .

    - Parameter parameters: The parameters for .
    */
    open func ImportParameters(parameters : dotnet.System.Security.Cryptography.RSAParameters) throws {
        var __thrown : NullableHandle = nil;
        System_Security_Cryptography_RSA_void__ImportParameters_0__1__RSAParameters(&__thrown, self.get_handle(), parameters.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
            return;
        }
    }
// TODO COPE (write_all_methods) (span) void ImportPkcs8PrivateKey(System.ReadOnlySpan<System.Byte>, ref System.Int32)
// TODO COPE (write_all_methods) (span) void ImportRSAPrivateKey(System.ReadOnlySpan<System.Byte>, ref System.Int32)
// TODO COPE (write_all_methods) (span) void ImportRSAPublicKey(System.ReadOnlySpan<System.Byte>, ref System.Int32)
// TODO COPE (write_all_methods) (span) void ImportSubjectPublicKeyInfo(System.ReadOnlySpan<System.Byte>, ref System.Int32)
    // System.Byte[] SignData(System.Byte[], System.Int32, System.Int32, System.Security.Cryptography.HashAlgorithmName, System.Security.Cryptography.RSASignaturePadding)
// docid: M:System.Security.Cryptography.RSA.SignData(System.Byte[],System.Int32,System.Int32,System.Security.Cryptography.HashAlgorithmName,System.Security.Cryptography.RSASignaturePadding)
    /**
    Computes the hash value of a portion of the specified byte array using the specified hash algorithm and padding mode, and signs the resulting hash value.

    - Parameter data: The input data to hash and sign.
    - Parameter offset: The offset into the array at which to begin using data.
    - Parameter count: The number of bytes in the array to use as data.
    - Parameter hashAlgorithm: The hash algorithm to use to create the hash value.
    - Parameter padding: The padding mode.
    - Returns: The RSA signature for the specified data.

    */
    open func SignData(data : dotnet.System_Arr<Swift.UInt8>, offset : Swift.Int32, count : Swift.Int32, hashAlgorithm : dotnet.System.Security.Cryptography.HashAlgorithmName, padding : dotnet.System.Security.Cryptography.RSASignaturePadding) throws -> dotnet.System_Arr<Swift.UInt8> {
        var __thrown : NullableHandle = nil;
        let __return = System_Security_Cryptography_RSA_u8Array__SignData_0__5__u8Array_i32_i32_HashAlgorithmName_RSASignaturePadding(&__thrown, self.get_handle(), data.get_handle(), offset, count, hashAlgorithm.get_handle(), padding.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return dotnet.System_Arr<Swift.UInt8>(hndl : __return);
        }
    }
    // System.Byte[] SignData(System.Byte[], System.Security.Cryptography.HashAlgorithmName, System.Security.Cryptography.RSASignaturePadding)
// docid: M:System.Security.Cryptography.RSA.SignData(System.Byte[],System.Security.Cryptography.HashAlgorithmName,System.Security.Cryptography.RSASignaturePadding)
    /**
    Computes the hash value of the specified byte array using the specified hash algorithm and padding mode, and signs the resulting hash value.

    - Parameter data: The input data to hash and sign.
    - Parameter hashAlgorithm: The hash algorithm to use to create the hash value.
    - Parameter padding: The padding mode.
    - Returns: The RSA signature for the specified data.

    */
    open func SignData(data : dotnet.System_Arr<Swift.UInt8>, hashAlgorithm : dotnet.System.Security.Cryptography.HashAlgorithmName, padding : dotnet.System.Security.Cryptography.RSASignaturePadding) throws -> dotnet.System_Arr<Swift.UInt8> {
        var __thrown : NullableHandle = nil;
        let __return = System_Security_Cryptography_RSA_u8Array__SignData_0__3__u8Array_HashAlgorithmName_RSASignaturePadding(&__thrown, self.get_handle(), data.get_handle(), hashAlgorithm.get_handle(), padding.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return dotnet.System_Arr<Swift.UInt8>(hndl : __return);
        }
    }
    // System.Byte[] SignData(System.IO.Stream, System.Security.Cryptography.HashAlgorithmName, System.Security.Cryptography.RSASignaturePadding)
// docid: M:System.Security.Cryptography.RSA.SignData(System.IO.Stream,System.Security.Cryptography.HashAlgorithmName,System.Security.Cryptography.RSASignaturePadding)
    /**
    Computes the hash value of the specified stream using the specified hash algorithm and padding mode, and signs the resulting hash value.

    - Parameter data: The input stream to hash and sign.
    - Parameter hashAlgorithm: The hash algorithm to use to create the hash value.
    - Parameter padding: The padding mode.
    - Returns: The RSA signature for the specified data.

    */
    open func SignData(data : dotnet.System.IO.Stream, hashAlgorithm : dotnet.System.Security.Cryptography.HashAlgorithmName, padding : dotnet.System.Security.Cryptography.RSASignaturePadding) throws -> dotnet.System_Arr<Swift.UInt8> {
        var __thrown : NullableHandle = nil;
        let __return = System_Security_Cryptography_RSA_u8Array__SignData_0__3__Stream_HashAlgorithmName_RSASignaturePadding(&__thrown, self.get_handle(), data.get_handle(), hashAlgorithm.get_handle(), padding.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return dotnet.System_Arr<Swift.UInt8>(hndl : __return);
        }
    }
    // System.Byte[] SignHash(System.Byte[], System.Security.Cryptography.HashAlgorithmName, System.Security.Cryptography.RSASignaturePadding)
// docid: M:System.Security.Cryptography.RSA.SignHash(System.Byte[],System.Security.Cryptography.HashAlgorithmName,System.Security.Cryptography.RSASignaturePadding)
    /**
    When overridden in a derived class, computes the signature for the specified hash value using the specified padding.

    - Parameter hash: The hash value of the data to be signed.
    - Parameter hashAlgorithm: The hash algorithm used to create the hash value of the data.
    - Parameter padding: The padding.
    - Returns: The RSA signature for the specified hash value.

    */
    open func SignHash(hash : dotnet.System_Arr<Swift.UInt8>, hashAlgorithm : dotnet.System.Security.Cryptography.HashAlgorithmName, padding : dotnet.System.Security.Cryptography.RSASignaturePadding) throws -> dotnet.System_Arr<Swift.UInt8> {
        var __thrown : NullableHandle = nil;
        let __return = System_Security_Cryptography_RSA_u8Array__SignHash_0__3__u8Array_HashAlgorithmName_RSASignaturePadding(&__thrown, self.get_handle(), hash.get_handle(), hashAlgorithm.get_handle(), padding.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return dotnet.System_Arr<Swift.UInt8>(hndl : __return);
        }
    }
    // System.String ToXmlString(bool)
// docid: M:System.Security.Cryptography.RSA.ToXmlString(System.Boolean)
    /**
    Creates and returns an XML string containing the key of the current  object.

    - Parameter includePrivateParameters: 
         to include a public and private RSA key;  to include only the public key.
    - Returns: An XML string containing the key of the current  object.

    */
    open override func ToXmlString(includePrivateParameters : Bool) throws -> dotnet.System.String {
        var __thrown : NullableHandle = nil;
        let __return = System_Security_Cryptography_RSA_String__ToXmlString_0__1__bool(&__thrown, self.get_handle(), Swift.Int32(includePrivateParameters ? 1 : 0));
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return dotnet.System.String(hndl : __return);
        }
    }
// TODO COPE (write_all_methods) (span) bool TryDecrypt(System.ReadOnlySpan<System.Byte>, System.Span<System.Byte>, System.Security.Cryptography.RSAEncryptionPadding, ref System.Int32)
// TODO COPE (write_all_methods) (span) bool TryEncrypt(System.ReadOnlySpan<System.Byte>, System.Span<System.Byte>, System.Security.Cryptography.RSAEncryptionPadding, ref System.Int32)
// TODO COPE (write_all_methods) (span) bool TryExportEncryptedPkcs8PrivateKey(System.ReadOnlySpan<System.Byte>, System.Security.Cryptography.PbeParameters, System.Span<System.Byte>, ref System.Int32)
// TODO COPE (write_all_methods) (span) bool TryExportEncryptedPkcs8PrivateKey(System.ReadOnlySpan<System.Char>, System.Security.Cryptography.PbeParameters, System.Span<System.Byte>, ref System.Int32)
// TODO COPE (write_all_methods) (span) bool TryExportPkcs8PrivateKey(System.Span<System.Byte>, ref System.Int32)
// TODO COPE (write_all_methods) (span) bool TryExportRSAPrivateKey(System.Span<System.Byte>, ref System.Int32)
// TODO COPE (write_all_methods) (span) bool TryExportRSAPublicKey(System.Span<System.Byte>, ref System.Int32)
// TODO COPE (write_all_methods) (span) bool TryExportSubjectPublicKeyInfo(System.Span<System.Byte>, ref System.Int32)
// TODO COPE (write_all_methods) (span) bool TrySignData(System.ReadOnlySpan<System.Byte>, System.Span<System.Byte>, System.Security.Cryptography.HashAlgorithmName, System.Security.Cryptography.RSASignaturePadding, ref System.Int32)
// TODO COPE (write_all_methods) (span) bool TrySignHash(System.ReadOnlySpan<System.Byte>, System.Span<System.Byte>, System.Security.Cryptography.HashAlgorithmName, System.Security.Cryptography.RSASignaturePadding, ref System.Int32)
    // bool VerifyData(System.Byte[], System.Byte[], System.Security.Cryptography.HashAlgorithmName, System.Security.Cryptography.RSASignaturePadding)
// docid: M:System.Security.Cryptography.RSA.VerifyData(System.Byte[],System.Byte[],System.Security.Cryptography.HashAlgorithmName,System.Security.Cryptography.RSASignaturePadding)
    /**
    Verifies that a digital signature is valid by calculating the hash value of the specified data using the specified hash algorithm and padding, and comparing it to the provided signature.

    - Parameter data: The signed data.
    - Parameter signature: The signature data to be verified.
    - Parameter hashAlgorithm: The hash algorithm used to create the hash value of the data.
    - Parameter padding: The padding mode.
    - Returns: 
         if the signature is valid; otherwise, .

    */
    open func VerifyData(data : dotnet.System_Arr<Swift.UInt8>, signature : dotnet.System_Arr<Swift.UInt8>, hashAlgorithm : dotnet.System.Security.Cryptography.HashAlgorithmName, padding : dotnet.System.Security.Cryptography.RSASignaturePadding) throws -> Bool {
        var __thrown : NullableHandle = nil;
        let __return = System_Security_Cryptography_RSA_bool__VerifyData_0__4__u8Array_u8Array_HashAlgorithmName_RSASignaturePadding(&__thrown, self.get_handle(), data.get_handle(), signature.get_handle(), hashAlgorithm.get_handle(), padding.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return (__return) != 0;
        }
    }
    // bool VerifyData(System.Byte[], System.Int32, System.Int32, System.Byte[], System.Security.Cryptography.HashAlgorithmName, System.Security.Cryptography.RSASignaturePadding)
// docid: M:System.Security.Cryptography.RSA.VerifyData(System.Byte[],System.Int32,System.Int32,System.Byte[],System.Security.Cryptography.HashAlgorithmName,System.Security.Cryptography.RSASignaturePadding)
    /**
    Verifies that a digital signature is valid by calculating the hash value of the data in a portion of a byte array using the specified hash algorithm and padding, and comparing it to the provided signature.

    - Parameter data: The signed data.
    - Parameter offset: The starting index at which to compute the hash.
    - Parameter count: The number of bytes to hash.
    - Parameter signature: The signature data to be verified.
    - Parameter hashAlgorithm: The hash algorithm used to create the hash value of the data.
    - Parameter padding: The padding mode.
    - Returns: 
         if the signature is valid; otherwise, .

    */
    open func VerifyData(data : dotnet.System_Arr<Swift.UInt8>, offset : Swift.Int32, count : Swift.Int32, signature : dotnet.System_Arr<Swift.UInt8>, hashAlgorithm : dotnet.System.Security.Cryptography.HashAlgorithmName, padding : dotnet.System.Security.Cryptography.RSASignaturePadding) throws -> Bool {
        var __thrown : NullableHandle = nil;
        let __return = System_Security_Cryptography_RSA_bool__VerifyData_0__6__u8Array_i32_i32_u8Array_HashAlgorithmName_RSASignaturePadding(&__thrown, self.get_handle(), data.get_handle(), offset, count, signature.get_handle(), hashAlgorithm.get_handle(), padding.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return (__return) != 0;
        }
    }
    // bool VerifyData(System.IO.Stream, System.Byte[], System.Security.Cryptography.HashAlgorithmName, System.Security.Cryptography.RSASignaturePadding)
// docid: M:System.Security.Cryptography.RSA.VerifyData(System.IO.Stream,System.Byte[],System.Security.Cryptography.HashAlgorithmName,System.Security.Cryptography.RSASignaturePadding)
    /**
    Verifies that a digital signature is valid by calculating the hash value of the specified stream using the specified hash algorithm and padding, and comparing it to the provided signature.

    - Parameter data: The signed data.
    - Parameter signature: The signature data to be verified.
    - Parameter hashAlgorithm: The hash algorithm used to create the hash value of the data.
    - Parameter padding: The padding mode.
    - Returns: 
         if the signature is valid; otherwise, .

    */
    open func VerifyData(data : dotnet.System.IO.Stream, signature : dotnet.System_Arr<Swift.UInt8>, hashAlgorithm : dotnet.System.Security.Cryptography.HashAlgorithmName, padding : dotnet.System.Security.Cryptography.RSASignaturePadding) throws -> Bool {
        var __thrown : NullableHandle = nil;
        let __return = System_Security_Cryptography_RSA_bool__VerifyData_0__4__Stream_u8Array_HashAlgorithmName_RSASignaturePadding(&__thrown, self.get_handle(), data.get_handle(), signature.get_handle(), hashAlgorithm.get_handle(), padding.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return (__return) != 0;
        }
    }
// TODO COPE (write_all_methods) (span) bool VerifyData(System.ReadOnlySpan<System.Byte>, System.ReadOnlySpan<System.Byte>, System.Security.Cryptography.HashAlgorithmName, System.Security.Cryptography.RSASignaturePadding)
    // bool VerifyHash(System.Byte[], System.Byte[], System.Security.Cryptography.HashAlgorithmName, System.Security.Cryptography.RSASignaturePadding)
// docid: M:System.Security.Cryptography.RSA.VerifyHash(System.Byte[],System.Byte[],System.Security.Cryptography.HashAlgorithmName,System.Security.Cryptography.RSASignaturePadding)
    /**
    Verifies that a digital signature is valid by determining the hash value in the signature using the specified hash algorithm and padding, and comparing it to the provided hash value.

    - Parameter hash: The hash value of the signed data.
    - Parameter signature: The signature data to be verified.
    - Parameter hashAlgorithm: The hash algorithm used to create the hash value.
    - Parameter padding: The padding mode.
    - Returns: 
         if the signature is valid; otherwise, .

    */
    open func VerifyHash(hash : dotnet.System_Arr<Swift.UInt8>, signature : dotnet.System_Arr<Swift.UInt8>, hashAlgorithm : dotnet.System.Security.Cryptography.HashAlgorithmName, padding : dotnet.System.Security.Cryptography.RSASignaturePadding) throws -> Bool {
        var __thrown : NullableHandle = nil;
        let __return = System_Security_Cryptography_RSA_bool__VerifyHash_0__4__u8Array_u8Array_HashAlgorithmName_RSASignaturePadding(&__thrown, self.get_handle(), hash.get_handle(), signature.get_handle(), hashAlgorithm.get_handle(), padding.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return (__return) != 0;
        }
    }
// TODO COPE (write_all_methods) (span) bool VerifyHash(System.ReadOnlySpan<System.Byte>, System.ReadOnlySpan<System.Byte>, System.Security.Cryptography.HashAlgorithmName, System.Security.Cryptography.RSASignaturePadding)
    // [IsSpecialName] System.String get_KeyExchangeAlgorithm()
// docid: M:System.Security.Cryptography.RSA.get_KeyExchangeAlgorithm
    open override func get_KeyExchangeAlgorithm() throws -> Optional<dotnet.System.String> {
        var __thrown : NullableHandle = nil;
        let __return = System_Security_Cryptography_RSA_String__get_KeyExchangeAlgorithm_0__0(&__thrown, self.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        if let __ret_unwrapped = __return {
            return dotnet.System.String(hndl : __ret_unwrapped);
        } else {
            return nil;
        }
        }
    }
    // [IsSpecialName] System.String get_SignatureAlgorithm()
// docid: M:System.Security.Cryptography.RSA.get_SignatureAlgorithm
    open override func get_SignatureAlgorithm() throws -> dotnet.System.String {
        var __thrown : NullableHandle = nil;
        let __return = System_Security_Cryptography_RSA_String__get_SignatureAlgorithm_0__0(&__thrown, self.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return dotnet.System.String(hndl : __return);
        }
    }
    /**
    Gets the name of the key exchange algorithm available with this implementation of .

    */
    open override var KeyExchangeAlgorithm : Optional<dotnet.System.String> {
        get {
            return try! get_KeyExchangeAlgorithm();
        }
    }
    /**
    Gets the name of the signature algorithm available with this implementation of .

    */
    open override var SignatureAlgorithm : dotnet.System.String {
        get {
            return try! get_SignatureAlgorithm();
        }
    }
} // RSA


// type: System.Security.Cryptography.RSAEncryptionPadding
    /**
    Specifies the padding mode and parameters to use with RSA encryption or decryption operations.

    */
public final class RSAEncryptionPadding
    :
    dotnet.System.Object
{
    public class override func get_type_handle() -> TypeHandle {
        return System_Security_Cryptography_RSAEncryptionPadding_get_type_handle();
    }
    public required init(hndl: NonnullHandle) { super.init(hndl: hndl); }
    public required init(gval: GVal) { super.init(gval: gval); }
    // System.Security.Cryptography.RSAEncryptionPadding CreateOaep(System.Security.Cryptography.HashAlgorithmName)
// docid: M:System.Security.Cryptography.RSAEncryptionPadding.CreateOaep(System.Security.Cryptography.HashAlgorithmName)
    /**
    Creates a new  instance whose  is  with the given hash algorithm.

    - Parameter hashAlgorithm: The hash algorithm.
    - Returns: An object whose mode is  is  with the hash algorithm specified by .

    */
    public class func CreateOaep(hashAlgorithm : dotnet.System.Security.Cryptography.HashAlgorithmName) throws -> dotnet.System.Security.Cryptography.RSAEncryptionPadding {
        var __thrown : NullableHandle = nil;
        let __return = System_Security_Cryptography_RSAEncryptionPadding_RSAEncryptionPadding__CreateOaep_0__1__HashAlgorithmName(&__thrown, hashAlgorithm.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return dotnet.System.Security.Cryptography.RSAEncryptionPadding(hndl : __return);
        }
    }
    // bool Equals(System.Object)
// docid: M:System.Security.Cryptography.RSAEncryptionPadding.Equals(System.Object)
    /**
    Determines whether the current instance is equal to the specified object.

    - Parameter obj: The object to compare.
    - Returns: 
         if  is equal to the current instance; otherwise, .

    */
    public override func Equals(obj : Optional<dotnet.System.Object>) throws -> Bool {
        var __thrown : NullableHandle = nil;
        let __return = System_Security_Cryptography_RSAEncryptionPadding_bool__Equals_0__1__Object(&__thrown, self.get_handle(), obj?.get_handle() ?? nil);
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return (__return) != 0;
        }
    }
    // bool Equals(System.Security.Cryptography.RSAEncryptionPadding)
// docid: M:System.Security.Cryptography.RSAEncryptionPadding.Equals(System.Security.Cryptography.RSAEncryptionPadding)
    /**
    Determines whether the current instance is equal to the specified  object.

    - Parameter other: The object to compare.
    - Returns: 
         if  is equal to the current instance; otherwise, .

    */
    public func Equals(other : Optional<dotnet.System.Security.Cryptography.RSAEncryptionPadding>) throws -> Bool {
        var __thrown : NullableHandle = nil;
        let __return = System_Security_Cryptography_RSAEncryptionPadding_bool__Equals_0__1__RSAEncryptionPadding(&__thrown, self.get_handle(), other?.get_handle() ?? nil);
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return (__return) != 0;
        }
    }
    // System.Int32 GetHashCode()
// docid: M:System.Security.Cryptography.RSAEncryptionPadding.GetHashCode
    /**
    Returns the hash code of this  object.

    - Returns: The hash code of this instance.

    */
    public override func GetHashCode() throws -> Swift.Int32 {
        var __thrown : NullableHandle = nil;
        let __return = System_Security_Cryptography_RSAEncryptionPadding_i32__GetHashCode_0__0(&__thrown, self.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return __return;
        }
    }
    // [IsSpecialName] bool op_Equality(System.Security.Cryptography.RSAEncryptionPadding, System.Security.Cryptography.RSAEncryptionPadding)
// docid: M:System.Security.Cryptography.RSAEncryptionPadding.op_Equality(System.Security.Cryptography.RSAEncryptionPadding,System.Security.Cryptography.RSAEncryptionPadding)
    /**
    Indicates whether two specified  objects are equal.

    - Parameter left: The first object to compare.
    - Parameter right: The second object to compare.
    - Returns: 
         if  and  are equal; otherwise, .

    */
    public class func op_Equality(left : Optional<dotnet.System.Security.Cryptography.RSAEncryptionPadding>, right : Optional<dotnet.System.Security.Cryptography.RSAEncryptionPadding>) throws -> Bool {
        var __thrown : NullableHandle = nil;
        let __return = System_Security_Cryptography_RSAEncryptionPadding_bool__op_Equality_0__2__RSAEncryptionPadding_RSAEncryptionPadding(&__thrown, left?.get_handle() ?? nil, right?.get_handle() ?? nil);
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return (__return) != 0;
        }
    }
    // [IsSpecialName] bool op_Inequality(System.Security.Cryptography.RSAEncryptionPadding, System.Security.Cryptography.RSAEncryptionPadding)
// docid: M:System.Security.Cryptography.RSAEncryptionPadding.op_Inequality(System.Security.Cryptography.RSAEncryptionPadding,System.Security.Cryptography.RSAEncryptionPadding)
    /**
    Indicates whether two specified  objects are unequal.

    - Parameter left: The first object to compare.
    - Parameter right: The second object to compare.
    - Returns: 
         if  and  are not equal; otherwise, .

    */
    public class func op_Inequality(left : Optional<dotnet.System.Security.Cryptography.RSAEncryptionPadding>, right : Optional<dotnet.System.Security.Cryptography.RSAEncryptionPadding>) throws -> Bool {
        var __thrown : NullableHandle = nil;
        let __return = System_Security_Cryptography_RSAEncryptionPadding_bool__op_Inequality_0__2__RSAEncryptionPadding_RSAEncryptionPadding(&__thrown, left?.get_handle() ?? nil, right?.get_handle() ?? nil);
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return (__return) != 0;
        }
    }
    // System.String ToString()
// docid: M:System.Security.Cryptography.RSAEncryptionPadding.ToString
    /**
    Returns the string representation of the current  instance.

    - Returns: The string representation of the current object.

    */
    public override func ToString() throws -> dotnet.System.String {
        var __thrown : NullableHandle = nil;
        let __return = System_Security_Cryptography_RSAEncryptionPadding_String__ToString_0__0(&__thrown, self.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return dotnet.System.String(hndl : __return);
        }
    }
    // [IsSpecialName] System.Security.Cryptography.RSAEncryptionPaddingMode get_Mode()
// docid: M:System.Security.Cryptography.RSAEncryptionPadding.get_Mode
    public func get_Mode() throws -> dotnet.System.Security.Cryptography.RSAEncryptionPaddingMode {
        var __thrown : NullableHandle = nil;
        let __return = System_Security_Cryptography_RSAEncryptionPadding_RSAEncryptionPaddingMode__get_Mode_0__0(&__thrown, self.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return dotnet.System.Security.Cryptography.RSAEncryptionPaddingMode(val: __return);
        }
    }
    // [IsSpecialName] System.Security.Cryptography.HashAlgorithmName get_OaepHashAlgorithm()
// docid: M:System.Security.Cryptography.RSAEncryptionPadding.get_OaepHashAlgorithm
    public func get_OaepHashAlgorithm() throws -> dotnet.System.Security.Cryptography.HashAlgorithmName {
        var __thrown : NullableHandle = nil;
        let __return = System_Security_Cryptography_RSAEncryptionPadding_HashAlgorithmName__get_OaepHashAlgorithm_0__0(&__thrown, self.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return dotnet.System.Security.Cryptography.HashAlgorithmName(hndl : __return);
        }
    }
    // [IsSpecialName] System.Security.Cryptography.RSAEncryptionPadding get_OaepSHA1()
// docid: M:System.Security.Cryptography.RSAEncryptionPadding.get_OaepSHA1
    public class func get_OaepSHA1() throws -> dotnet.System.Security.Cryptography.RSAEncryptionPadding {
        var __thrown : NullableHandle = nil;
        let __return = System_Security_Cryptography_RSAEncryptionPadding_RSAEncryptionPadding__get_OaepSHA1_0__0(&__thrown);
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return dotnet.System.Security.Cryptography.RSAEncryptionPadding(hndl : __return);
        }
    }
    // [IsSpecialName] System.Security.Cryptography.RSAEncryptionPadding get_OaepSHA256()
// docid: M:System.Security.Cryptography.RSAEncryptionPadding.get_OaepSHA256
    public class func get_OaepSHA256() throws -> dotnet.System.Security.Cryptography.RSAEncryptionPadding {
        var __thrown : NullableHandle = nil;
        let __return = System_Security_Cryptography_RSAEncryptionPadding_RSAEncryptionPadding__get_OaepSHA256_0__0(&__thrown);
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return dotnet.System.Security.Cryptography.RSAEncryptionPadding(hndl : __return);
        }
    }
    // [IsSpecialName] System.Security.Cryptography.RSAEncryptionPadding get_OaepSHA384()
// docid: M:System.Security.Cryptography.RSAEncryptionPadding.get_OaepSHA384
    public class func get_OaepSHA384() throws -> dotnet.System.Security.Cryptography.RSAEncryptionPadding {
        var __thrown : NullableHandle = nil;
        let __return = System_Security_Cryptography_RSAEncryptionPadding_RSAEncryptionPadding__get_OaepSHA384_0__0(&__thrown);
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return dotnet.System.Security.Cryptography.RSAEncryptionPadding(hndl : __return);
        }
    }
    // [IsSpecialName] System.Security.Cryptography.RSAEncryptionPadding get_OaepSHA512()
// docid: M:System.Security.Cryptography.RSAEncryptionPadding.get_OaepSHA512
    public class func get_OaepSHA512() throws -> dotnet.System.Security.Cryptography.RSAEncryptionPadding {
        var __thrown : NullableHandle = nil;
        let __return = System_Security_Cryptography_RSAEncryptionPadding_RSAEncryptionPadding__get_OaepSHA512_0__0(&__thrown);
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return dotnet.System.Security.Cryptography.RSAEncryptionPadding(hndl : __return);
        }
    }
    // [IsSpecialName] System.Security.Cryptography.RSAEncryptionPadding get_Pkcs1()
// docid: M:System.Security.Cryptography.RSAEncryptionPadding.get_Pkcs1
    public class func get_Pkcs1() throws -> dotnet.System.Security.Cryptography.RSAEncryptionPadding {
        var __thrown : NullableHandle = nil;
        let __return = System_Security_Cryptography_RSAEncryptionPadding_RSAEncryptionPadding__get_Pkcs1_0__0(&__thrown);
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return dotnet.System.Security.Cryptography.RSAEncryptionPadding(hndl : __return);
        }
    }
    /**
    Gets the padding mode represented by this  instance.

    */
    public var Mode : dotnet.System.Security.Cryptography.RSAEncryptionPaddingMode {
        get {
            return try! get_Mode();
        }
    }
    /**
    Gets the hash algorithm used in conjunction with the  padding mode.

    */
    public var OaepHashAlgorithm : dotnet.System.Security.Cryptography.HashAlgorithmName {
        get {
            return try! get_OaepHashAlgorithm();
        }
    }
    /**
    Gets an object that represents the Optimal Asymmetric Encryption Padding (OAEP) encryption standard with a SHA1 hash algorithm.

    */
    public static var OaepSHA1 : dotnet.System.Security.Cryptography.RSAEncryptionPadding {
        get {
            return try! get_OaepSHA1();
        }
    }
    /**
    Gets an object that represents the Optimal Asymmetric Encryption Padding (OAEP) encryption standard with a SHA256 hash algorithm.

    */
    public static var OaepSHA256 : dotnet.System.Security.Cryptography.RSAEncryptionPadding {
        get {
            return try! get_OaepSHA256();
        }
    }
    /**
    Gets an object that represents the Optimal Asymmetric Encryption Padding (OAEP) encryption standard with a SHA-384 hash algorithm.

    */
    public static var OaepSHA384 : dotnet.System.Security.Cryptography.RSAEncryptionPadding {
        get {
            return try! get_OaepSHA384();
        }
    }
    /**
    Gets an object that represents the Optimal Asymmetric Encryption Padding (OAEP) encryption standard with a SHA512 hash algorithm.

    */
    public static var OaepSHA512 : dotnet.System.Security.Cryptography.RSAEncryptionPadding {
        get {
            return try! get_OaepSHA512();
        }
    }
    /**
    Gets an object that represents the PKCS #1 encryption standard.

    */
    public static var Pkcs1 : dotnet.System.Security.Cryptography.RSAEncryptionPadding {
        get {
            return try! get_Pkcs1();
        }
    }
} // RSAEncryptionPadding


// type: System.Security.Cryptography.RSAEncryptionPaddingMode
    /**
    Specifies the padding mode to use with RSA encryption or decryption operations.

    */
public struct RSAEncryptionPaddingMode : SGBridgeGenericValue {
    let v : Swift.Int32;
    public init(val: Swift.Int32) { self.v = val; }
    public func get_value() -> Swift.Int32 { return self.v; }
    public static func get_type_handle() -> TypeHandle {
        return System_Security_Cryptography_RSAEncryptionPaddingMode_get_type_handle();
    }
    public func to_gval() -> GVal { return GVal(self.v); }
    public func dup_gval() -> GVal { return to_gval(); }
    public init(gval: GVal) { self.v = Swift.Int32(gval); }
    // static field: System.Security.Cryptography.RSAEncryptionPaddingMode Pkcs1
    /**
    PKCS #1 v1.5. It is supported for compatibility with existing applications.

    */
    public static var Pkcs1 : dotnet.System.Security.Cryptography.RSAEncryptionPaddingMode {
        get {
        let __return = dotnet.System.Security.Cryptography.RSAEncryptionPaddingMode(val: System_Security_Cryptography_RSAEncryptionPaddingMode_get_Pkcs1());
            return __return;
        }
    }
    // static field: System.Security.Cryptography.RSAEncryptionPaddingMode Oaep
    /**
    Optimal Asymmetric Encryption Padding. It is recommended for new applications.

    */
    public static var Oaep : dotnet.System.Security.Cryptography.RSAEncryptionPaddingMode {
        get {
        let __return = dotnet.System.Security.Cryptography.RSAEncryptionPaddingMode(val: System_Security_Cryptography_RSAEncryptionPaddingMode_get_Oaep());
            return __return;
        }
    }
} // RSAEncryptionPaddingMode


// type: System.Security.Cryptography.RSAOAEPKeyExchangeDeformatter
    /**
    Decrypts Optimal Asymmetric Encryption Padding (OAEP) key exchange data.

    */
open class RSAOAEPKeyExchangeDeformatter
    :
    dotnet.System.Security.Cryptography.AsymmetricKeyExchangeDeformatter
{
    open class override func get_type_handle() -> TypeHandle {
        return System_Security_Cryptography_RSAOAEPKeyExchangeDeformatter_get_type_handle();
    }
    public required init(hndl: NonnullHandle) { super.init(hndl: hndl); }
    public required init(gval: GVal) { super.init(gval: gval); }
    // .ctor()
// docid: M:System.Security.Cryptography.RSAOAEPKeyExchangeDeformatter.#ctor
    /**
    Initializes a new instance of the  class.

    */
    public init() throws {
        var __thrown : NullableHandle = nil;
        let h = System_Security_Cryptography_RSAOAEPKeyExchangeDeformatter_ctor_0__0(&__thrown);
        if let __ex = __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
            super.init(hndl: h);
        }
    }
    // .ctor(System.Security.Cryptography.AsymmetricAlgorithm)
// docid: M:System.Security.Cryptography.RSAOAEPKeyExchangeDeformatter.#ctor(System.Security.Cryptography.AsymmetricAlgorithm)
    /**
    Initializes a new instance of the  class with the specified key.

    - Parameter key: The instance of the  algorithm that holds the private key.
    */
    public init(key : dotnet.System.Security.Cryptography.AsymmetricAlgorithm) throws {
        var __thrown : NullableHandle = nil;
        let h = System_Security_Cryptography_RSAOAEPKeyExchangeDeformatter_ctor_0__1__AsymmetricAlgorithm(&__thrown, key.get_handle());
        if let __ex = __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
            super.init(hndl: h);
        }
    }
    // System.Byte[] DecryptKeyExchange(System.Byte[])
// docid: M:System.Security.Cryptography.RSAOAEPKeyExchangeDeformatter.DecryptKeyExchange(System.Byte[])
    /**
    Extracts secret information from the encrypted key exchange data.

    - Parameter rgbData: The key exchange data within which the secret information is hidden.
    - Returns: The secret information derived from the key exchange data.

    */
    open func DecryptKeyExchange(rgbData : dotnet.System_Arr<Swift.UInt8>) throws -> dotnet.System_Arr<Swift.UInt8> {
        var __thrown : NullableHandle = nil;
        let __return = System_Security_Cryptography_RSAOAEPKeyExchangeDeformatter_u8Array__DecryptKeyExchange_0__1__u8Array(&__thrown, self.get_handle(), rgbData.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return dotnet.System_Arr<Swift.UInt8>(hndl : __return);
        }
    }
    // void SetKey(System.Security.Cryptography.AsymmetricAlgorithm)
// docid: M:System.Security.Cryptography.RSAOAEPKeyExchangeDeformatter.SetKey(System.Security.Cryptography.AsymmetricAlgorithm)
    /**
    Sets the private key to use for decrypting the secret information.

    - Parameter key: The instance of the  algorithm that holds the private key.
    */
    open override func SetKey(key : dotnet.System.Security.Cryptography.AsymmetricAlgorithm) throws {
        var __thrown : NullableHandle = nil;
        System_Security_Cryptography_RSAOAEPKeyExchangeDeformatter_void__SetKey_0__1__AsymmetricAlgorithm(&__thrown, self.get_handle(), key.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
            return;
        }
    }
    // [IsSpecialName] System.String get_Parameters()
// docid: M:System.Security.Cryptography.RSAOAEPKeyExchangeDeformatter.get_Parameters
    open override func get_Parameters() throws -> Optional<dotnet.System.String> {
        var __thrown : NullableHandle = nil;
        let __return = System_Security_Cryptography_RSAOAEPKeyExchangeDeformatter_String__get_Parameters_0__0(&__thrown, self.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        if let __ret_unwrapped = __return {
            return dotnet.System.String(hndl : __ret_unwrapped);
        } else {
            return nil;
        }
        }
    }
    // [IsSpecialName] void set_Parameters(System.String)
// docid: M:System.Security.Cryptography.RSAOAEPKeyExchangeDeformatter.set_Parameters(System.String)
    open override func set_Parameters(value : Optional<dotnet.System.String>) throws {
        var __thrown : NullableHandle = nil;
        System_Security_Cryptography_RSAOAEPKeyExchangeDeformatter_void__set_Parameters_0__1__String(&__thrown, self.get_handle(), value?.get_handle() ?? nil);
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
            return;
        }
    }
    /**
    Gets the parameters for the Optimal Asymmetric Encryption Padding (OAEP) key exchange.

    */
    open override var Parameters : Optional<dotnet.System.String> {
        get {
            return try! get_Parameters();
        }
        set(v) {
            return try! set_Parameters(value: v!);
        }
    }
} // RSAOAEPKeyExchangeDeformatter


// type: System.Security.Cryptography.RSAOAEPKeyExchangeFormatter
    /**
    Creates Optimal Asymmetric Encryption Padding (OAEP) key exchange data using .

    */
open class RSAOAEPKeyExchangeFormatter
    :
    dotnet.System.Security.Cryptography.AsymmetricKeyExchangeFormatter
{
    open class override func get_type_handle() -> TypeHandle {
        return System_Security_Cryptography_RSAOAEPKeyExchangeFormatter_get_type_handle();
    }
    public required init(hndl: NonnullHandle) { super.init(hndl: hndl); }
    public required init(gval: GVal) { super.init(gval: gval); }
    // .ctor()
// docid: M:System.Security.Cryptography.RSAOAEPKeyExchangeFormatter.#ctor
    /**
    Initializes a new instance of the  class.

    */
    public init() throws {
        var __thrown : NullableHandle = nil;
        let h = System_Security_Cryptography_RSAOAEPKeyExchangeFormatter_ctor_0__0(&__thrown);
        if let __ex = __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
            super.init(hndl: h);
        }
    }
    // .ctor(System.Security.Cryptography.AsymmetricAlgorithm)
// docid: M:System.Security.Cryptography.RSAOAEPKeyExchangeFormatter.#ctor(System.Security.Cryptography.AsymmetricAlgorithm)
    /**
    Initializes a new instance of the  class with the specified key.

    - Parameter key: The instance of the  algorithm that holds the public key.
    */
    public init(key : dotnet.System.Security.Cryptography.AsymmetricAlgorithm) throws {
        var __thrown : NullableHandle = nil;
        let h = System_Security_Cryptography_RSAOAEPKeyExchangeFormatter_ctor_0__1__AsymmetricAlgorithm(&__thrown, key.get_handle());
        if let __ex = __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
            super.init(hndl: h);
        }
    }
    // System.Byte[] CreateKeyExchange(System.Byte[])
// docid: M:System.Security.Cryptography.RSAOAEPKeyExchangeFormatter.CreateKeyExchange(System.Byte[])
    /**
    Creates the encrypted key exchange data from the specified input data.

    - Parameter rgbData: The secret information to be passed in the key exchange.
    - Returns: The encrypted key exchange data to be sent to the intended recipient.

    */
    open func CreateKeyExchange(rgbData : dotnet.System_Arr<Swift.UInt8>) throws -> dotnet.System_Arr<Swift.UInt8> {
        var __thrown : NullableHandle = nil;
        let __return = System_Security_Cryptography_RSAOAEPKeyExchangeFormatter_u8Array__CreateKeyExchange_0__1__u8Array(&__thrown, self.get_handle(), rgbData.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return dotnet.System_Arr<Swift.UInt8>(hndl : __return);
        }
    }
    // System.Byte[] CreateKeyExchange(System.Byte[], System.Type)
// docid: M:System.Security.Cryptography.RSAOAEPKeyExchangeFormatter.CreateKeyExchange(System.Byte[],System.Type)
    /**
    Creates the encrypted key exchange data from the specified input data.

    - Parameter rgbData: The secret information to be passed in the key exchange.
    - Parameter symAlgType: This parameter is not used in the current version.
    - Returns: The encrypted key exchange data to be sent to the intended recipient.

    */
    open func CreateKeyExchange(rgbData : dotnet.System_Arr<Swift.UInt8>, symAlgType : Optional<dotnet.System.Type_>) throws -> dotnet.System_Arr<Swift.UInt8> {
        var __thrown : NullableHandle = nil;
        let __return = System_Security_Cryptography_RSAOAEPKeyExchangeFormatter_u8Array__CreateKeyExchange_0__2__u8Array_Type(&__thrown, self.get_handle(), rgbData.get_handle(), symAlgType?.get_handle() ?? nil);
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return dotnet.System_Arr<Swift.UInt8>(hndl : __return);
        }
    }
    // void SetKey(System.Security.Cryptography.AsymmetricAlgorithm)
// docid: M:System.Security.Cryptography.RSAOAEPKeyExchangeFormatter.SetKey(System.Security.Cryptography.AsymmetricAlgorithm)
    /**
    Sets the public key to use for encrypting the key exchange data.

    - Parameter key: The instance of the  algorithm that holds the public key.
    */
    open override func SetKey(key : dotnet.System.Security.Cryptography.AsymmetricAlgorithm) throws {
        var __thrown : NullableHandle = nil;
        System_Security_Cryptography_RSAOAEPKeyExchangeFormatter_void__SetKey_0__1__AsymmetricAlgorithm(&__thrown, self.get_handle(), key.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
            return;
        }
    }
    // [IsSpecialName] System.Byte[] get_Parameter()
// docid: M:System.Security.Cryptography.RSAOAEPKeyExchangeFormatter.get_Parameter
    open func get_Parameter() throws -> Optional<dotnet.System_Arr<Swift.UInt8>> {
        var __thrown : NullableHandle = nil;
        let __return = System_Security_Cryptography_RSAOAEPKeyExchangeFormatter_u8Array__get_Parameter_0__0(&__thrown, self.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        if let __ret_unwrapped = __return {
            return dotnet.System_Arr<Swift.UInt8>(hndl : __ret_unwrapped);
        } else {
            return nil;
        }
        }
    }
    // [IsSpecialName] void set_Parameter(System.Byte[])
// docid: M:System.Security.Cryptography.RSAOAEPKeyExchangeFormatter.set_Parameter(System.Byte[])
    open func set_Parameter(value : Optional<dotnet.System_Arr<Swift.UInt8>>) throws {
        var __thrown : NullableHandle = nil;
        System_Security_Cryptography_RSAOAEPKeyExchangeFormatter_void__set_Parameter_0__1__u8Array(&__thrown, self.get_handle(), (value?.get_handle()));
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
            return;
        }
    }
    // [IsSpecialName] System.String get_Parameters()
// docid: M:System.Security.Cryptography.RSAOAEPKeyExchangeFormatter.get_Parameters
    open override func get_Parameters() throws -> Optional<dotnet.System.String> {
        var __thrown : NullableHandle = nil;
        let __return = System_Security_Cryptography_RSAOAEPKeyExchangeFormatter_String__get_Parameters_0__0(&__thrown, self.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        if let __ret_unwrapped = __return {
            return dotnet.System.String(hndl : __ret_unwrapped);
        } else {
            return nil;
        }
        }
    }
    // [IsSpecialName] System.Security.Cryptography.RandomNumberGenerator get_Rng()
// docid: M:System.Security.Cryptography.RSAOAEPKeyExchangeFormatter.get_Rng
    open func get_Rng() throws -> Optional<dotnet.System.Security.Cryptography.RandomNumberGenerator> {
        var __thrown : NullableHandle = nil;
        let __return = System_Security_Cryptography_RSAOAEPKeyExchangeFormatter_RandomNumberGenerator__get_Rng_0__0(&__thrown, self.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        if let __ret_unwrapped = __return {
            return dotnet.System.Security.Cryptography.RandomNumberGenerator(hndl : __ret_unwrapped);
        } else {
            return nil;
        }
        }
    }
    // [IsSpecialName] void set_Rng(System.Security.Cryptography.RandomNumberGenerator)
// docid: M:System.Security.Cryptography.RSAOAEPKeyExchangeFormatter.set_Rng(System.Security.Cryptography.RandomNumberGenerator)
    open func set_Rng(value : Optional<dotnet.System.Security.Cryptography.RandomNumberGenerator>) throws {
        var __thrown : NullableHandle = nil;
        System_Security_Cryptography_RSAOAEPKeyExchangeFormatter_void__set_Rng_0__1__RandomNumberGenerator(&__thrown, self.get_handle(), value?.get_handle() ?? nil);
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
            return;
        }
    }
    /**
    Gets or sets the parameter used to create padding in the key exchange creation process.

    */
    open var Parameter : Optional<dotnet.System_Arr<Swift.UInt8>> {
        get {
            return try! get_Parameter();
        }
        set(v) {
            return try! set_Parameter(value: v!);
        }
    }
    /**
    Gets the parameters for the Optimal Asymmetric Encryption Padding (OAEP) key exchange.

    */
    open override var Parameters : Optional<dotnet.System.String> {
        get {
            return try! get_Parameters();
        }
    }
    /**
    Gets or sets the random number generator algorithm to use in the creation of the key exchange.

    */
    open var Rng : Optional<dotnet.System.Security.Cryptography.RandomNumberGenerator> {
        get {
            return try! get_Rng();
        }
        set(v) {
            return try! set_Rng(value: v!);
        }
    }
} // RSAOAEPKeyExchangeFormatter


// type: System.Security.Cryptography.RSAPKCS1KeyExchangeDeformatter
    /**
    Decrypts the PKCS #1 key exchange data.

    */
open class RSAPKCS1KeyExchangeDeformatter
    :
    dotnet.System.Security.Cryptography.AsymmetricKeyExchangeDeformatter
{
    open class override func get_type_handle() -> TypeHandle {
        return System_Security_Cryptography_RSAPKCS1KeyExchangeDeformatter_get_type_handle();
    }
    public required init(hndl: NonnullHandle) { super.init(hndl: hndl); }
    public required init(gval: GVal) { super.init(gval: gval); }
    // .ctor()
// docid: M:System.Security.Cryptography.RSAPKCS1KeyExchangeDeformatter.#ctor
    /**
    Initializes a new instance of the  class.

    */
    public init() throws {
        var __thrown : NullableHandle = nil;
        let h = System_Security_Cryptography_RSAPKCS1KeyExchangeDeformatter_ctor_0__0(&__thrown);
        if let __ex = __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
            super.init(hndl: h);
        }
    }
    // .ctor(System.Security.Cryptography.AsymmetricAlgorithm)
// docid: M:System.Security.Cryptography.RSAPKCS1KeyExchangeDeformatter.#ctor(System.Security.Cryptography.AsymmetricAlgorithm)
    /**
    Initializes a new instance of the  class with the specified key.

    - Parameter key: The instance of the  algorithm that holds the private key.
    */
    public init(key : dotnet.System.Security.Cryptography.AsymmetricAlgorithm) throws {
        var __thrown : NullableHandle = nil;
        let h = System_Security_Cryptography_RSAPKCS1KeyExchangeDeformatter_ctor_0__1__AsymmetricAlgorithm(&__thrown, key.get_handle());
        if let __ex = __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
            super.init(hndl: h);
        }
    }
    // System.Byte[] DecryptKeyExchange(System.Byte[])
// docid: M:System.Security.Cryptography.RSAPKCS1KeyExchangeDeformatter.DecryptKeyExchange(System.Byte[])
    /**
    Extracts secret information from the encrypted key exchange data.

    - Parameter rgbIn: The key exchange data within which the secret information is hidden.
    - Returns: The secret information derived from the key exchange data.

    */
    open func DecryptKeyExchange(rgbIn : dotnet.System_Arr<Swift.UInt8>) throws -> dotnet.System_Arr<Swift.UInt8> {
        var __thrown : NullableHandle = nil;
        let __return = System_Security_Cryptography_RSAPKCS1KeyExchangeDeformatter_u8Array__DecryptKeyExchange_0__1__u8Array(&__thrown, self.get_handle(), rgbIn.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return dotnet.System_Arr<Swift.UInt8>(hndl : __return);
        }
    }
    // void SetKey(System.Security.Cryptography.AsymmetricAlgorithm)
// docid: M:System.Security.Cryptography.RSAPKCS1KeyExchangeDeformatter.SetKey(System.Security.Cryptography.AsymmetricAlgorithm)
    /**
    Sets the private key to use for decrypting the secret information.

    - Parameter key: The instance of the  algorithm that holds the private key.
    */
    open override func SetKey(key : dotnet.System.Security.Cryptography.AsymmetricAlgorithm) throws {
        var __thrown : NullableHandle = nil;
        System_Security_Cryptography_RSAPKCS1KeyExchangeDeformatter_void__SetKey_0__1__AsymmetricAlgorithm(&__thrown, self.get_handle(), key.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
            return;
        }
    }
    // [IsSpecialName] System.String get_Parameters()
// docid: M:System.Security.Cryptography.RSAPKCS1KeyExchangeDeformatter.get_Parameters
    open override func get_Parameters() throws -> Optional<dotnet.System.String> {
        var __thrown : NullableHandle = nil;
        let __return = System_Security_Cryptography_RSAPKCS1KeyExchangeDeformatter_String__get_Parameters_0__0(&__thrown, self.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        if let __ret_unwrapped = __return {
            return dotnet.System.String(hndl : __ret_unwrapped);
        } else {
            return nil;
        }
        }
    }
    // [IsSpecialName] void set_Parameters(System.String)
// docid: M:System.Security.Cryptography.RSAPKCS1KeyExchangeDeformatter.set_Parameters(System.String)
    open override func set_Parameters(value : Optional<dotnet.System.String>) throws {
        var __thrown : NullableHandle = nil;
        System_Security_Cryptography_RSAPKCS1KeyExchangeDeformatter_void__set_Parameters_0__1__String(&__thrown, self.get_handle(), value?.get_handle() ?? nil);
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
            return;
        }
    }
    // [IsSpecialName] System.Security.Cryptography.RandomNumberGenerator get_RNG()
// docid: M:System.Security.Cryptography.RSAPKCS1KeyExchangeDeformatter.get_RNG
    open func get_RNG() throws -> Optional<dotnet.System.Security.Cryptography.RandomNumberGenerator> {
        var __thrown : NullableHandle = nil;
        let __return = System_Security_Cryptography_RSAPKCS1KeyExchangeDeformatter_RandomNumberGenerator__get_RNG_0__0(&__thrown, self.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        if let __ret_unwrapped = __return {
            return dotnet.System.Security.Cryptography.RandomNumberGenerator(hndl : __ret_unwrapped);
        } else {
            return nil;
        }
        }
    }
    // [IsSpecialName] void set_RNG(System.Security.Cryptography.RandomNumberGenerator)
// docid: M:System.Security.Cryptography.RSAPKCS1KeyExchangeDeformatter.set_RNG(System.Security.Cryptography.RandomNumberGenerator)
    open func set_RNG(value : Optional<dotnet.System.Security.Cryptography.RandomNumberGenerator>) throws {
        var __thrown : NullableHandle = nil;
        System_Security_Cryptography_RSAPKCS1KeyExchangeDeformatter_void__set_RNG_0__1__RandomNumberGenerator(&__thrown, self.get_handle(), value?.get_handle() ?? nil);
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
            return;
        }
    }
    /**
    Gets the parameters for the PKCS #1 key exchange.

    */
    open override var Parameters : Optional<dotnet.System.String> {
        get {
            return try! get_Parameters();
        }
        set(v) {
            return try! set_Parameters(value: v!);
        }
    }
    /**
    Gets or sets the random number generator algorithm to use in the creation of the key exchange.

    */
    open var RNG : Optional<dotnet.System.Security.Cryptography.RandomNumberGenerator> {
        get {
            return try! get_RNG();
        }
        set(v) {
            return try! set_RNG(value: v!);
        }
    }
} // RSAPKCS1KeyExchangeDeformatter


// type: System.Security.Cryptography.RSAPKCS1KeyExchangeFormatter
    /**
    Creates the PKCS#1 key exchange data using .

    */
open class RSAPKCS1KeyExchangeFormatter
    :
    dotnet.System.Security.Cryptography.AsymmetricKeyExchangeFormatter
{
    open class override func get_type_handle() -> TypeHandle {
        return System_Security_Cryptography_RSAPKCS1KeyExchangeFormatter_get_type_handle();
    }
    public required init(hndl: NonnullHandle) { super.init(hndl: hndl); }
    public required init(gval: GVal) { super.init(gval: gval); }
    // .ctor()
// docid: M:System.Security.Cryptography.RSAPKCS1KeyExchangeFormatter.#ctor
    /**
    Initializes a new instance of the  class.

    */
    public init() throws {
        var __thrown : NullableHandle = nil;
        let h = System_Security_Cryptography_RSAPKCS1KeyExchangeFormatter_ctor_0__0(&__thrown);
        if let __ex = __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
            super.init(hndl: h);
        }
    }
    // .ctor(System.Security.Cryptography.AsymmetricAlgorithm)
// docid: M:System.Security.Cryptography.RSAPKCS1KeyExchangeFormatter.#ctor(System.Security.Cryptography.AsymmetricAlgorithm)
    /**
    Initializes a new instance of the  class with the specified key.

    - Parameter key: The instance of the  algorithm that holds the public key.
    */
    public init(key : dotnet.System.Security.Cryptography.AsymmetricAlgorithm) throws {
        var __thrown : NullableHandle = nil;
        let h = System_Security_Cryptography_RSAPKCS1KeyExchangeFormatter_ctor_0__1__AsymmetricAlgorithm(&__thrown, key.get_handle());
        if let __ex = __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
            super.init(hndl: h);
        }
    }
    // System.Byte[] CreateKeyExchange(System.Byte[])
// docid: M:System.Security.Cryptography.RSAPKCS1KeyExchangeFormatter.CreateKeyExchange(System.Byte[])
    /**
    Creates the encrypted key exchange data from the specified input data.

    - Parameter rgbData: The secret information to be passed in the key exchange.
    - Returns: The encrypted key exchange data to be sent to the intended recipient.

    */
    open func CreateKeyExchange(rgbData : dotnet.System_Arr<Swift.UInt8>) throws -> dotnet.System_Arr<Swift.UInt8> {
        var __thrown : NullableHandle = nil;
        let __return = System_Security_Cryptography_RSAPKCS1KeyExchangeFormatter_u8Array__CreateKeyExchange_0__1__u8Array(&__thrown, self.get_handle(), rgbData.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return dotnet.System_Arr<Swift.UInt8>(hndl : __return);
        }
    }
    // System.Byte[] CreateKeyExchange(System.Byte[], System.Type)
// docid: M:System.Security.Cryptography.RSAPKCS1KeyExchangeFormatter.CreateKeyExchange(System.Byte[],System.Type)
    /**
    Creates the encrypted key exchange data from the specified input data.

    - Parameter rgbData: The secret information to be passed in the key exchange.
    - Parameter symAlgType: This parameter is not used in the current version.
    - Returns: The encrypted key exchange data to be sent to the intended recipient.

    */
    open func CreateKeyExchange(rgbData : dotnet.System_Arr<Swift.UInt8>, symAlgType : Optional<dotnet.System.Type_>) throws -> dotnet.System_Arr<Swift.UInt8> {
        var __thrown : NullableHandle = nil;
        let __return = System_Security_Cryptography_RSAPKCS1KeyExchangeFormatter_u8Array__CreateKeyExchange_0__2__u8Array_Type(&__thrown, self.get_handle(), rgbData.get_handle(), symAlgType?.get_handle() ?? nil);
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return dotnet.System_Arr<Swift.UInt8>(hndl : __return);
        }
    }
    // void SetKey(System.Security.Cryptography.AsymmetricAlgorithm)
// docid: M:System.Security.Cryptography.RSAPKCS1KeyExchangeFormatter.SetKey(System.Security.Cryptography.AsymmetricAlgorithm)
    /**
    Sets the public key to use for encrypting the key exchange data.

    - Parameter key: The instance of the  algorithm that holds the public key.
    */
    open override func SetKey(key : dotnet.System.Security.Cryptography.AsymmetricAlgorithm) throws {
        var __thrown : NullableHandle = nil;
        System_Security_Cryptography_RSAPKCS1KeyExchangeFormatter_void__SetKey_0__1__AsymmetricAlgorithm(&__thrown, self.get_handle(), key.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
            return;
        }
    }
    // [IsSpecialName] System.String get_Parameters()
// docid: M:System.Security.Cryptography.RSAPKCS1KeyExchangeFormatter.get_Parameters
    open override func get_Parameters() throws -> dotnet.System.String {
        var __thrown : NullableHandle = nil;
        let __return = System_Security_Cryptography_RSAPKCS1KeyExchangeFormatter_String__get_Parameters_0__0(&__thrown, self.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return dotnet.System.String(hndl : __return);
        }
    }
    // [IsSpecialName] System.Security.Cryptography.RandomNumberGenerator get_Rng()
// docid: M:System.Security.Cryptography.RSAPKCS1KeyExchangeFormatter.get_Rng
    open func get_Rng() throws -> Optional<dotnet.System.Security.Cryptography.RandomNumberGenerator> {
        var __thrown : NullableHandle = nil;
        let __return = System_Security_Cryptography_RSAPKCS1KeyExchangeFormatter_RandomNumberGenerator__get_Rng_0__0(&__thrown, self.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        if let __ret_unwrapped = __return {
            return dotnet.System.Security.Cryptography.RandomNumberGenerator(hndl : __ret_unwrapped);
        } else {
            return nil;
        }
        }
    }
    // [IsSpecialName] void set_Rng(System.Security.Cryptography.RandomNumberGenerator)
// docid: M:System.Security.Cryptography.RSAPKCS1KeyExchangeFormatter.set_Rng(System.Security.Cryptography.RandomNumberGenerator)
    open func set_Rng(value : Optional<dotnet.System.Security.Cryptography.RandomNumberGenerator>) throws {
        var __thrown : NullableHandle = nil;
        System_Security_Cryptography_RSAPKCS1KeyExchangeFormatter_void__set_Rng_0__1__RandomNumberGenerator(&__thrown, self.get_handle(), value?.get_handle() ?? nil);
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
            return;
        }
    }
    /**
    Gets the parameters for the PKCS #1 key exchange.

    */
    open override var Parameters : dotnet.System.String {
        get {
            return try! get_Parameters();
        }
    }
    /**
    Gets or sets the random number generator algorithm to use in the creation of the key exchange.

    */
    open var Rng : Optional<dotnet.System.Security.Cryptography.RandomNumberGenerator> {
        get {
            return try! get_Rng();
        }
        set(v) {
            return try! set_Rng(value: v!);
        }
    }
} // RSAPKCS1KeyExchangeFormatter


// type: System.Security.Cryptography.RSAPKCS1SignatureDeformatter
    /**
    Verifies an  PKCS #1 version 1.5 signature.

    */
open class RSAPKCS1SignatureDeformatter
    :
    dotnet.System.Security.Cryptography.AsymmetricSignatureDeformatter
{
    open class override func get_type_handle() -> TypeHandle {
        return System_Security_Cryptography_RSAPKCS1SignatureDeformatter_get_type_handle();
    }
    public required init(hndl: NonnullHandle) { super.init(hndl: hndl); }
    public required init(gval: GVal) { super.init(gval: gval); }
    // .ctor()
// docid: M:System.Security.Cryptography.RSAPKCS1SignatureDeformatter.#ctor
    /**
    Initializes a new instance of the  class.

    */
    public init() throws {
        var __thrown : NullableHandle = nil;
        let h = System_Security_Cryptography_RSAPKCS1SignatureDeformatter_ctor_0__0(&__thrown);
        if let __ex = __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
            super.init(hndl: h);
        }
    }
    // .ctor(System.Security.Cryptography.AsymmetricAlgorithm)
// docid: M:System.Security.Cryptography.RSAPKCS1SignatureDeformatter.#ctor(System.Security.Cryptography.AsymmetricAlgorithm)
    /**
    Initializes a new instance of the  class with the specified key.

    - Parameter key: The instance of  that holds the public key.
    */
    public init(key : dotnet.System.Security.Cryptography.AsymmetricAlgorithm) throws {
        var __thrown : NullableHandle = nil;
        let h = System_Security_Cryptography_RSAPKCS1SignatureDeformatter_ctor_0__1__AsymmetricAlgorithm(&__thrown, key.get_handle());
        if let __ex = __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
            super.init(hndl: h);
        }
    }
    // void SetHashAlgorithm(System.String)
// docid: M:System.Security.Cryptography.RSAPKCS1SignatureDeformatter.SetHashAlgorithm(System.String)
    /**
    Sets the hash algorithm to use for verifying the signature.

    - Parameter strName: The name of the hash algorithm to use for verifying the signature.
    */
    open override func SetHashAlgorithm(strName : dotnet.System.String) throws {
        var __thrown : NullableHandle = nil;
        System_Security_Cryptography_RSAPKCS1SignatureDeformatter_void__SetHashAlgorithm_0__1__String(&__thrown, self.get_handle(), strName.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
            return;
        }
    }
    // void SetKey(System.Security.Cryptography.AsymmetricAlgorithm)
// docid: M:System.Security.Cryptography.RSAPKCS1SignatureDeformatter.SetKey(System.Security.Cryptography.AsymmetricAlgorithm)
    /**
    Sets the public key to use for verifying the signature.

    - Parameter key: The instance of  that holds the public key.
    */
    open override func SetKey(key : dotnet.System.Security.Cryptography.AsymmetricAlgorithm) throws {
        var __thrown : NullableHandle = nil;
        System_Security_Cryptography_RSAPKCS1SignatureDeformatter_void__SetKey_0__1__AsymmetricAlgorithm(&__thrown, self.get_handle(), key.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
            return;
        }
    }
    // bool VerifySignature(System.Byte[], System.Byte[])
// docid: M:System.Security.Cryptography.RSAPKCS1SignatureDeformatter.VerifySignature(System.Byte[],System.Byte[])
    /**
    Verifies the  PKCS#1 signature for the specified data.

    - Parameter rgbHash: The data signed with .
    - Parameter rgbSignature: The signature to be verified for .
    - Returns: 
         if  matches the signature computed using the specified hash algorithm and key on ; otherwise, .

    */
    open override func VerifySignature(rgbHash : dotnet.System_Arr<Swift.UInt8>, rgbSignature : dotnet.System_Arr<Swift.UInt8>) throws -> Bool {
        var __thrown : NullableHandle = nil;
        let __return = System_Security_Cryptography_RSAPKCS1SignatureDeformatter_bool__VerifySignature_0__2__u8Array_u8Array(&__thrown, self.get_handle(), rgbHash.get_handle(), rgbSignature.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return (__return) != 0;
        }
    }
} // RSAPKCS1SignatureDeformatter


// type: System.Security.Cryptography.RSAPKCS1SignatureFormatter
    /**
    Creates an  PKCS #1 version 1.5 signature.

    */
open class RSAPKCS1SignatureFormatter
    :
    dotnet.System.Security.Cryptography.AsymmetricSignatureFormatter
{
    open class override func get_type_handle() -> TypeHandle {
        return System_Security_Cryptography_RSAPKCS1SignatureFormatter_get_type_handle();
    }
    public required init(hndl: NonnullHandle) { super.init(hndl: hndl); }
    public required init(gval: GVal) { super.init(gval: gval); }
    // .ctor()
// docid: M:System.Security.Cryptography.RSAPKCS1SignatureFormatter.#ctor
    /**
    Initializes a new instance of the  class.

    */
    public init() throws {
        var __thrown : NullableHandle = nil;
        let h = System_Security_Cryptography_RSAPKCS1SignatureFormatter_ctor_0__0(&__thrown);
        if let __ex = __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
            super.init(hndl: h);
        }
    }
    // .ctor(System.Security.Cryptography.AsymmetricAlgorithm)
// docid: M:System.Security.Cryptography.RSAPKCS1SignatureFormatter.#ctor(System.Security.Cryptography.AsymmetricAlgorithm)
    /**
    Initializes a new instance of the  class with the specified key.

    - Parameter key: The instance of the  algorithm that holds the private key.
    */
    public init(key : dotnet.System.Security.Cryptography.AsymmetricAlgorithm) throws {
        var __thrown : NullableHandle = nil;
        let h = System_Security_Cryptography_RSAPKCS1SignatureFormatter_ctor_0__1__AsymmetricAlgorithm(&__thrown, key.get_handle());
        if let __ex = __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
            super.init(hndl: h);
        }
    }
    // System.Byte[] CreateSignature(System.Byte[])
// docid: M:System.Security.Cryptography.RSAPKCS1SignatureFormatter.CreateSignature(System.Byte[])
    /**
    Creates the  PKCS #1 signature for the specified data.

    - Parameter rgbHash: The data to be signed.
    - Returns: The digital signature for .

    */
    open override func CreateSignature(rgbHash : dotnet.System_Arr<Swift.UInt8>) throws -> dotnet.System_Arr<Swift.UInt8> {
        var __thrown : NullableHandle = nil;
        let __return = System_Security_Cryptography_RSAPKCS1SignatureFormatter_u8Array__CreateSignature_0__1__u8Array(&__thrown, self.get_handle(), rgbHash.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return dotnet.System_Arr<Swift.UInt8>(hndl : __return);
        }
    }
    // void SetHashAlgorithm(System.String)
// docid: M:System.Security.Cryptography.RSAPKCS1SignatureFormatter.SetHashAlgorithm(System.String)
    /**
    Sets the hash algorithm to use for creating the signature.

    - Parameter strName: The name of the hash algorithm to use for creating the signature.
    */
    open override func SetHashAlgorithm(strName : dotnet.System.String) throws {
        var __thrown : NullableHandle = nil;
        System_Security_Cryptography_RSAPKCS1SignatureFormatter_void__SetHashAlgorithm_0__1__String(&__thrown, self.get_handle(), strName.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
            return;
        }
    }
    // void SetKey(System.Security.Cryptography.AsymmetricAlgorithm)
// docid: M:System.Security.Cryptography.RSAPKCS1SignatureFormatter.SetKey(System.Security.Cryptography.AsymmetricAlgorithm)
    /**
    Sets the private key to use for creating the signature.

    - Parameter key: The instance of the  algorithm that holds the private key.
    */
    open override func SetKey(key : dotnet.System.Security.Cryptography.AsymmetricAlgorithm) throws {
        var __thrown : NullableHandle = nil;
        System_Security_Cryptography_RSAPKCS1SignatureFormatter_void__SetKey_0__1__AsymmetricAlgorithm(&__thrown, self.get_handle(), key.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
            return;
        }
    }
} // RSAPKCS1SignatureFormatter


// type: System.Security.Cryptography.RSAParameters
// boxed value type
    /**
    Represents the standard parameters for the  algorithm.

    */
public final class RSAParameters
    :
    dotnet.System.Object
{
    public class override func get_type_handle() -> TypeHandle {
        return System_Security_Cryptography_RSAParameters_get_type_handle();
    }
    public required init(hndl: NonnullHandle) { super.init(hndl: hndl); }
    public required init(gval: GVal) { super.init(gval: gval); }
    public override init() {
        let h = System_Security_Cryptography_RSAParameters_implicit_ctor();
            super.init(hndl: h);
    }
} // RSAParameters


// type: System.Security.Cryptography.RSASignaturePadding
    /**
    Specifies the padding mode and parameters to use with RSA signature creation or verification operations.

    */
public final class RSASignaturePadding
    :
    dotnet.System.Object
{
    public class override func get_type_handle() -> TypeHandle {
        return System_Security_Cryptography_RSASignaturePadding_get_type_handle();
    }
    public required init(hndl: NonnullHandle) { super.init(hndl: hndl); }
    public required init(gval: GVal) { super.init(gval: gval); }
    // bool Equals(System.Object)
// docid: M:System.Security.Cryptography.RSASignaturePadding.Equals(System.Object)
    /**
    Returns a value that indicates whether this instance is equal to a specified object.

    - Parameter obj: The object to compare with the current instance.
    - Returns: 
         if the specified object is equal to the current object; otherwise, .

    */
    public override func Equals(obj : Optional<dotnet.System.Object>) throws -> Bool {
        var __thrown : NullableHandle = nil;
        let __return = System_Security_Cryptography_RSASignaturePadding_bool__Equals_0__1__Object(&__thrown, self.get_handle(), obj?.get_handle() ?? nil);
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return (__return) != 0;
        }
    }
    // bool Equals(System.Security.Cryptography.RSASignaturePadding)
// docid: M:System.Security.Cryptography.RSASignaturePadding.Equals(System.Security.Cryptography.RSASignaturePadding)
    /**
    Returns a value that indicates whether this instance is equal to a specified  object.

    - Parameter other: The object to compare with the current instance.
    - Returns: 
         if the specified object is equal to the current object; otherwise, .

    */
    public func Equals(other : Optional<dotnet.System.Security.Cryptography.RSASignaturePadding>) throws -> Bool {
        var __thrown : NullableHandle = nil;
        let __return = System_Security_Cryptography_RSASignaturePadding_bool__Equals_0__1__RSASignaturePadding(&__thrown, self.get_handle(), other?.get_handle() ?? nil);
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return (__return) != 0;
        }
    }
    // System.Int32 GetHashCode()
// docid: M:System.Security.Cryptography.RSASignaturePadding.GetHashCode
    /**
    Returns the hash code for this  instance.

    - Returns: The hash code for this  instance.

    */
    public override func GetHashCode() throws -> Swift.Int32 {
        var __thrown : NullableHandle = nil;
        let __return = System_Security_Cryptography_RSASignaturePadding_i32__GetHashCode_0__0(&__thrown, self.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return __return;
        }
    }
    // [IsSpecialName] bool op_Equality(System.Security.Cryptography.RSASignaturePadding, System.Security.Cryptography.RSASignaturePadding)
// docid: M:System.Security.Cryptography.RSASignaturePadding.op_Equality(System.Security.Cryptography.RSASignaturePadding,System.Security.Cryptography.RSASignaturePadding)
    /**
    Indicates whether two specified  objects are equal.

    - Parameter left: The first object to compare.
    - Parameter right: The second object to compare.
    - Returns: 
         if  and  are equal; otherwise, .

    */
    public class func op_Equality(left : Optional<dotnet.System.Security.Cryptography.RSASignaturePadding>, right : Optional<dotnet.System.Security.Cryptography.RSASignaturePadding>) throws -> Bool {
        var __thrown : NullableHandle = nil;
        let __return = System_Security_Cryptography_RSASignaturePadding_bool__op_Equality_0__2__RSASignaturePadding_RSASignaturePadding(&__thrown, left?.get_handle() ?? nil, right?.get_handle() ?? nil);
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return (__return) != 0;
        }
    }
    // [IsSpecialName] bool op_Inequality(System.Security.Cryptography.RSASignaturePadding, System.Security.Cryptography.RSASignaturePadding)
// docid: M:System.Security.Cryptography.RSASignaturePadding.op_Inequality(System.Security.Cryptography.RSASignaturePadding,System.Security.Cryptography.RSASignaturePadding)
    /**
    Indicates whether two specified  objects are unequal.

    - Parameter left: The first object to compare.
    - Parameter right: The second object to compare.
    - Returns: 
         if  and  are unequal; otherwise, .

    */
    public class func op_Inequality(left : Optional<dotnet.System.Security.Cryptography.RSASignaturePadding>, right : Optional<dotnet.System.Security.Cryptography.RSASignaturePadding>) throws -> Bool {
        var __thrown : NullableHandle = nil;
        let __return = System_Security_Cryptography_RSASignaturePadding_bool__op_Inequality_0__2__RSASignaturePadding_RSASignaturePadding(&__thrown, left?.get_handle() ?? nil, right?.get_handle() ?? nil);
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return (__return) != 0;
        }
    }
    // System.String ToString()
// docid: M:System.Security.Cryptography.RSASignaturePadding.ToString
    /**
    Returns the string representation of the current  instance.

    - Returns: The string representation of the current object.

    */
    public override func ToString() throws -> dotnet.System.String {
        var __thrown : NullableHandle = nil;
        let __return = System_Security_Cryptography_RSASignaturePadding_String__ToString_0__0(&__thrown, self.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return dotnet.System.String(hndl : __return);
        }
    }
    // [IsSpecialName] System.Security.Cryptography.RSASignaturePaddingMode get_Mode()
// docid: M:System.Security.Cryptography.RSASignaturePadding.get_Mode
    public func get_Mode() throws -> dotnet.System.Security.Cryptography.RSASignaturePaddingMode {
        var __thrown : NullableHandle = nil;
        let __return = System_Security_Cryptography_RSASignaturePadding_RSASignaturePaddingMode__get_Mode_0__0(&__thrown, self.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return dotnet.System.Security.Cryptography.RSASignaturePaddingMode(val: __return);
        }
    }
    // [IsSpecialName] System.Security.Cryptography.RSASignaturePadding get_Pkcs1()
// docid: M:System.Security.Cryptography.RSASignaturePadding.get_Pkcs1
    public class func get_Pkcs1() throws -> dotnet.System.Security.Cryptography.RSASignaturePadding {
        var __thrown : NullableHandle = nil;
        let __return = System_Security_Cryptography_RSASignaturePadding_RSASignaturePadding__get_Pkcs1_0__0(&__thrown);
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return dotnet.System.Security.Cryptography.RSASignaturePadding(hndl : __return);
        }
    }
    // [IsSpecialName] System.Security.Cryptography.RSASignaturePadding get_Pss()
// docid: M:System.Security.Cryptography.RSASignaturePadding.get_Pss
    public class func get_Pss() throws -> dotnet.System.Security.Cryptography.RSASignaturePadding {
        var __thrown : NullableHandle = nil;
        let __return = System_Security_Cryptography_RSASignaturePadding_RSASignaturePadding__get_Pss_0__0(&__thrown);
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return dotnet.System.Security.Cryptography.RSASignaturePadding(hndl : __return);
        }
    }
    /**
    Gets the padding mode of this  instance.

    */
    public var Mode : dotnet.System.Security.Cryptography.RSASignaturePaddingMode {
        get {
            return try! get_Mode();
        }
    }
    /**
    Gets an object that uses the PKCS #1 v1.5 padding mode.

    */
    public static var Pkcs1 : dotnet.System.Security.Cryptography.RSASignaturePadding {
        get {
            return try! get_Pkcs1();
        }
    }
    /**
    Gets an object that uses PSS padding mode.

    */
    public static var Pss : dotnet.System.Security.Cryptography.RSASignaturePadding {
        get {
            return try! get_Pss();
        }
    }
} // RSASignaturePadding


// type: System.Security.Cryptography.RSASignaturePaddingMode
    /**
    Specifies the padding mode to use with RSA signature creation or verification operations.

    */
public struct RSASignaturePaddingMode : SGBridgeGenericValue {
    let v : Swift.Int32;
    public init(val: Swift.Int32) { self.v = val; }
    public func get_value() -> Swift.Int32 { return self.v; }
    public static func get_type_handle() -> TypeHandle {
        return System_Security_Cryptography_RSASignaturePaddingMode_get_type_handle();
    }
    public func to_gval() -> GVal { return GVal(self.v); }
    public func dup_gval() -> GVal { return to_gval(); }
    public init(gval: GVal) { self.v = Swift.Int32(gval); }
    // static field: System.Security.Cryptography.RSASignaturePaddingMode Pkcs1
    /**
    PKCS #1 v1.5.

    */
    public static var Pkcs1 : dotnet.System.Security.Cryptography.RSASignaturePaddingMode {
        get {
        let __return = dotnet.System.Security.Cryptography.RSASignaturePaddingMode(val: System_Security_Cryptography_RSASignaturePaddingMode_get_Pkcs1());
            return __return;
        }
    }
    // static field: System.Security.Cryptography.RSASignaturePaddingMode Pss
    /**
    Probabilistic Signature Scheme.

    */
    public static var Pss : dotnet.System.Security.Cryptography.RSASignaturePaddingMode {
        get {
        let __return = dotnet.System.Security.Cryptography.RSASignaturePaddingMode(val: System_Security_Cryptography_RSASignaturePaddingMode_get_Pss());
            return __return;
        }
    }
} // RSASignaturePaddingMode


// type: System.Security.Cryptography.RandomNumberGenerator
    /**
    Represents the abstract class from which all implementations of cryptographic random number generators derive.

    */
open class RandomNumberGenerator
    :
    dotnet.System.Object,
    System_IDisposable
{
    open class override func get_type_handle() -> TypeHandle {
        return System_Security_Cryptography_RandomNumberGenerator_get_type_handle();
    }
    public required init(hndl: NonnullHandle) { super.init(hndl: hndl); }
    public required init(gval: GVal) { super.init(gval: gval); }
    // System.Security.Cryptography.RandomNumberGenerator Create()
// docid: M:System.Security.Cryptography.RandomNumberGenerator.Create
    /**
    Creates an instance of the default implementation of a cryptographic random number generator that can be used to generate random data.

    - Returns: A new instance of a cryptographic random number generator.

    */
    open class func Create() throws -> dotnet.System.Security.Cryptography.RandomNumberGenerator {
        var __thrown : NullableHandle = nil;
        let __return = System_Security_Cryptography_RandomNumberGenerator_RandomNumberGenerator__Create_0__0(&__thrown);
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return dotnet.System.Security.Cryptography.RandomNumberGenerator(hndl : __return);
        }
    }
    // System.Security.Cryptography.RandomNumberGenerator Create(System.String)
// docid: M:System.Security.Cryptography.RandomNumberGenerator.Create(System.String)
    /**
    Creates an instance of the specified implementation of a cryptographic random number generator.

    - Parameter rngName: The name of the random number generator implementation to use.
    - Returns: A new instance of a cryptographic random number generator.

    */
    open class func Create(rngName : dotnet.System.String) throws -> Optional<dotnet.System.Security.Cryptography.RandomNumberGenerator> {
        var __thrown : NullableHandle = nil;
        let __return = System_Security_Cryptography_RandomNumberGenerator_RandomNumberGenerator__Create_0__1__String(&__thrown, rngName.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        if let __ret_unwrapped = __return {
            return dotnet.System.Security.Cryptography.RandomNumberGenerator(hndl : __ret_unwrapped);
        } else {
            return nil;
        }
        }
    }
    // void Dispose()
// docid: M:System.Security.Cryptography.RandomNumberGenerator.Dispose
    /**
    When overridden in a derived class, releases all resources used by the current instance of the  class.

    */
    open /* method final */ func Dispose() throws {
        var __thrown : NullableHandle = nil;
        System_Security_Cryptography_RandomNumberGenerator_void__Dispose_0__0(&__thrown, self.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
            return;
        }
    }
// TODO COPE (write_all_methods) (span) void Fill(System.Span<System.Byte>)
    // void GetBytes(System.Byte[])
// docid: M:System.Security.Cryptography.RandomNumberGenerator.GetBytes(System.Byte[])
    /**
    When overridden in a derived class, fills an array of bytes with a cryptographically strong random sequence of values.

    - Parameter data: The array to fill with cryptographically strong random bytes.
    */
    open func GetBytes(data : dotnet.System_Arr<Swift.UInt8>) throws {
        var __thrown : NullableHandle = nil;
        System_Security_Cryptography_RandomNumberGenerator_void__GetBytes_0__1__u8Array(&__thrown, self.get_handle(), data.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
            return;
        }
    }
    // void GetBytes(System.Byte[], System.Int32, System.Int32)
// docid: M:System.Security.Cryptography.RandomNumberGenerator.GetBytes(System.Byte[],System.Int32,System.Int32)
    /**
    Fills the specified byte array with a cryptographically strong random sequence of values.

    - Parameter data: The array to fill with cryptographically strong random bytes.
    - Parameter offset: The index of the array to start the fill operation.
    - Parameter count: The number of bytes to fill.
    */
    open func GetBytes(data : dotnet.System_Arr<Swift.UInt8>, offset : Swift.Int32, count : Swift.Int32) throws {
        var __thrown : NullableHandle = nil;
        System_Security_Cryptography_RandomNumberGenerator_void__GetBytes_0__3__u8Array_i32_i32(&__thrown, self.get_handle(), data.get_handle(), offset, count);
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
            return;
        }
    }
    // System.Byte[] GetBytes(System.Int32)
// docid: M:System.Security.Cryptography.RandomNumberGenerator.GetBytes(System.Int32)
    open class func GetBytes(count : Swift.Int32) throws -> dotnet.System_Arr<Swift.UInt8> {
        var __thrown : NullableHandle = nil;
        let __return = System_Security_Cryptography_RandomNumberGenerator_u8Array__GetBytes_0__1__i32(&__thrown, count);
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return dotnet.System_Arr<Swift.UInt8>(hndl : __return);
        }
    }
// TODO COPE (write_all_methods) (span) void GetBytes(System.Span<System.Byte>)
    // System.Int32 GetInt32(System.Int32)
// docid: M:System.Security.Cryptography.RandomNumberGenerator.GetInt32(System.Int32)
    /**
    Generates a random integer between 0 (inclusive) and a specified exclusive upper bound using a cryptographically strong random number generator.

    - Parameter toExclusive: The exclusive upper bound of the random range.
    - Returns: A random integer between 0 (inclusive) and  (exclusive).

    */
    open class func GetInt32(toExclusive : Swift.Int32) throws -> Swift.Int32 {
        var __thrown : NullableHandle = nil;
        let __return = System_Security_Cryptography_RandomNumberGenerator_i32__GetInt32_0__1__i32(&__thrown, toExclusive);
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return __return;
        }
    }
    // System.Int32 GetInt32(System.Int32, System.Int32)
// docid: M:System.Security.Cryptography.RandomNumberGenerator.GetInt32(System.Int32,System.Int32)
    /**
    Generates a random integer between a specified inclusive lower bound and a specified exclusive upper bound using a cryptographically strong random number generator.

    - Parameter fromInclusive: The inclusive lower bound of the random range.
    - Parameter toExclusive: The exclusive upper bound of the random range.
    - Returns: A random integer between  (inclusive) and  (exclusive).

    */
    open class func GetInt32(fromInclusive : Swift.Int32, toExclusive : Swift.Int32) throws -> Swift.Int32 {
        var __thrown : NullableHandle = nil;
        let __return = System_Security_Cryptography_RandomNumberGenerator_i32__GetInt32_0__2__i32_i32(&__thrown, fromInclusive, toExclusive);
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return __return;
        }
    }
    // void GetNonZeroBytes(System.Byte[])
// docid: M:System.Security.Cryptography.RandomNumberGenerator.GetNonZeroBytes(System.Byte[])
    /**
    When overridden in a derived class, fills an array of bytes with a cryptographically strong random sequence of nonzero values.

    - Parameter data: The array to fill with cryptographically strong random nonzero bytes.
    */
    open func GetNonZeroBytes(data : dotnet.System_Arr<Swift.UInt8>) throws {
        var __thrown : NullableHandle = nil;
        System_Security_Cryptography_RandomNumberGenerator_void__GetNonZeroBytes_0__1__u8Array(&__thrown, self.get_handle(), data.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
            return;
        }
    }
// TODO COPE (write_all_methods) (span) void GetNonZeroBytes(System.Span<System.Byte>)
} // RandomNumberGenerator


// type: System.Security.Cryptography.Rfc2898DeriveBytes
    /**
    Implements password-based key derivation functionality, PBKDF2, by using a pseudo-random number generator based on .

    */
open class Rfc2898DeriveBytes
    :
    dotnet.System.Security.Cryptography.DeriveBytes
{
    open class override func get_type_handle() -> TypeHandle {
        return System_Security_Cryptography_Rfc2898DeriveBytes_get_type_handle();
    }
    public required init(hndl: NonnullHandle) { super.init(hndl: hndl); }
    public required init(gval: GVal) { super.init(gval: gval); }
    // .ctor(System.Byte[], System.Byte[], System.Int32)
// docid: M:System.Security.Cryptography.Rfc2898DeriveBytes.#ctor(System.Byte[],System.Byte[],System.Int32)
    /**
    Initializes a new instance of the  class using a password, a salt, and number of iterations to derive the key.

    - Parameter password: The password used to derive the key.
    - Parameter salt: The key salt used to derive the key.
    - Parameter iterations: The number of iterations for the operation.
    */
    public init(password : dotnet.System_Arr<Swift.UInt8>, salt : dotnet.System_Arr<Swift.UInt8>, iterations : Swift.Int32) throws {
        var __thrown : NullableHandle = nil;
        let h = System_Security_Cryptography_Rfc2898DeriveBytes_ctor_0__3__u8Array_u8Array_i32(&__thrown, password.get_handle(), salt.get_handle(), iterations);
        if let __ex = __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
            super.init(hndl: h);
        }
    }
    // .ctor(System.Byte[], System.Byte[], System.Int32, System.Security.Cryptography.HashAlgorithmName)
// docid: M:System.Security.Cryptography.Rfc2898DeriveBytes.#ctor(System.Byte[],System.Byte[],System.Int32,System.Security.Cryptography.HashAlgorithmName)
    /**
    Initializes a new instance of the  class using the specified password, salt, number of iterations and the hash algorithm name to derive the key.

    - Parameter password: The password to use to derive the key.
    - Parameter salt: The key salt to use to derive the key.
    - Parameter iterations: The number of iterations for the operation.
    - Parameter hashAlgorithm: The hash algorithm to use to derive the key.
    */
    public init(password : dotnet.System_Arr<Swift.UInt8>, salt : dotnet.System_Arr<Swift.UInt8>, iterations : Swift.Int32, hashAlgorithm : dotnet.System.Security.Cryptography.HashAlgorithmName) throws {
        var __thrown : NullableHandle = nil;
        let h = System_Security_Cryptography_Rfc2898DeriveBytes_ctor_0__4__u8Array_u8Array_i32_HashAlgorithmName(&__thrown, password.get_handle(), salt.get_handle(), iterations, hashAlgorithm.get_handle());
        if let __ex = __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
            super.init(hndl: h);
        }
    }
    // .ctor(System.String, System.Byte[])
// docid: M:System.Security.Cryptography.Rfc2898DeriveBytes.#ctor(System.String,System.Byte[])
    /**
    Initializes a new instance of the  class using a password and salt to derive the key.

    - Parameter password: The password used to derive the key.
    - Parameter salt: The key salt used to derive the key.
    */
    public init(password : dotnet.System.String, salt : dotnet.System_Arr<Swift.UInt8>) throws {
        var __thrown : NullableHandle = nil;
        let h = System_Security_Cryptography_Rfc2898DeriveBytes_ctor_0__2__String_u8Array(&__thrown, password.get_handle(), salt.get_handle());
        if let __ex = __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
            super.init(hndl: h);
        }
    }
    // .ctor(System.String, System.Byte[], System.Int32)
// docid: M:System.Security.Cryptography.Rfc2898DeriveBytes.#ctor(System.String,System.Byte[],System.Int32)
    /**
    Initializes a new instance of the  class using a password, a salt, and number of iterations to derive the key.

    - Parameter password: The password used to derive the key.
    - Parameter salt: The key salt used to derive the key.
    - Parameter iterations: The number of iterations for the operation.
    */
    public init(password : dotnet.System.String, salt : dotnet.System_Arr<Swift.UInt8>, iterations : Swift.Int32) throws {
        var __thrown : NullableHandle = nil;
        let h = System_Security_Cryptography_Rfc2898DeriveBytes_ctor_0__3__String_u8Array_i32(&__thrown, password.get_handle(), salt.get_handle(), iterations);
        if let __ex = __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
            super.init(hndl: h);
        }
    }
    // .ctor(System.String, System.Byte[], System.Int32, System.Security.Cryptography.HashAlgorithmName)
// docid: M:System.Security.Cryptography.Rfc2898DeriveBytes.#ctor(System.String,System.Byte[],System.Int32,System.Security.Cryptography.HashAlgorithmName)
    /**
    Initializes a new instance of the  class using the specified password, salt, number of iterations and the hash algorithm name to derive the key.

    - Parameter password: The password to use to derive the key.
    - Parameter salt: The key salt to use to derive the key.
    - Parameter iterations: The number of iterations for the operation.
    - Parameter hashAlgorithm: The hash algorithm to use to derive the key.
    */
    public init(password : dotnet.System.String, salt : dotnet.System_Arr<Swift.UInt8>, iterations : Swift.Int32, hashAlgorithm : dotnet.System.Security.Cryptography.HashAlgorithmName) throws {
        var __thrown : NullableHandle = nil;
        let h = System_Security_Cryptography_Rfc2898DeriveBytes_ctor_0__4__String_u8Array_i32_HashAlgorithmName(&__thrown, password.get_handle(), salt.get_handle(), iterations, hashAlgorithm.get_handle());
        if let __ex = __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
            super.init(hndl: h);
        }
    }
    // .ctor(System.String, System.Int32)
// docid: M:System.Security.Cryptography.Rfc2898DeriveBytes.#ctor(System.String,System.Int32)
    /**
    Initializes a new instance of the  class using the password and salt size to derive the key.

    - Parameter password: The password used to derive the key.
    - Parameter saltSize: The size of the random salt that you want the class to generate.
    */
    public init(password : dotnet.System.String, saltSize : Swift.Int32) throws {
        var __thrown : NullableHandle = nil;
        let h = System_Security_Cryptography_Rfc2898DeriveBytes_ctor_0__2__String_i32(&__thrown, password.get_handle(), saltSize);
        if let __ex = __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
            super.init(hndl: h);
        }
    }
    // .ctor(System.String, System.Int32, System.Int32)
// docid: M:System.Security.Cryptography.Rfc2898DeriveBytes.#ctor(System.String,System.Int32,System.Int32)
    /**
    Initializes a new instance of the  class using a password, a salt size, and number of iterations to derive the key.

    - Parameter password: The password used to derive the key.
    - Parameter saltSize: The size of the random salt that you want the class to generate.
    - Parameter iterations: The number of iterations for the operation.
    */
    public init(password : dotnet.System.String, saltSize : Swift.Int32, iterations : Swift.Int32) throws {
        var __thrown : NullableHandle = nil;
        let h = System_Security_Cryptography_Rfc2898DeriveBytes_ctor_0__3__String_i32_i32(&__thrown, password.get_handle(), saltSize, iterations);
        if let __ex = __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
            super.init(hndl: h);
        }
    }
    // .ctor(System.String, System.Int32, System.Int32, System.Security.Cryptography.HashAlgorithmName)
// docid: M:System.Security.Cryptography.Rfc2898DeriveBytes.#ctor(System.String,System.Int32,System.Int32,System.Security.Cryptography.HashAlgorithmName)
    /**
    Initializes a new instance of the  class using the specified password, salt size, number of iterations and the hash algorithm name to derive the key.

    - Parameter password: The password to use to derive the key.
    - Parameter saltSize: The size of the random salt that you want the class to generate.
    - Parameter iterations: The number of iterations for the operation.
    - Parameter hashAlgorithm: The hash algorithm to use to derive the key.
    */
    public init(password : dotnet.System.String, saltSize : Swift.Int32, iterations : Swift.Int32, hashAlgorithm : dotnet.System.Security.Cryptography.HashAlgorithmName) throws {
        var __thrown : NullableHandle = nil;
        let h = System_Security_Cryptography_Rfc2898DeriveBytes_ctor_0__4__String_i32_i32_HashAlgorithmName(&__thrown, password.get_handle(), saltSize, iterations, hashAlgorithm.get_handle());
        if let __ex = __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
            super.init(hndl: h);
        }
    }
    // System.Byte[] CryptDeriveKey(System.String, System.String, System.Int32, System.Byte[])
// docid: M:System.Security.Cryptography.Rfc2898DeriveBytes.CryptDeriveKey(System.String,System.String,System.Int32,System.Byte[])
    /**
    Derives a cryptographic key from the  object.

    - Parameter algname: The algorithm name for which to derive the key.
    - Parameter alghashname: The hash algorithm name to use to derive the key.
    - Parameter keySize: The size of the key, in bits, to derive.
    - Parameter rgbIV: The initialization vector (IV) to use to derive the key.
    - Returns: The derived key.

    */
    open func CryptDeriveKey(algname : dotnet.System.String, alghashname : dotnet.System.String, keySize : Swift.Int32, rgbIV : dotnet.System_Arr<Swift.UInt8>) throws -> dotnet.System_Arr<Swift.UInt8> {
        var __thrown : NullableHandle = nil;
        let __return = System_Security_Cryptography_Rfc2898DeriveBytes_u8Array__CryptDeriveKey_0__4__String_String_i32_u8Array(&__thrown, self.get_handle(), algname.get_handle(), alghashname.get_handle(), keySize, rgbIV.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return dotnet.System_Arr<Swift.UInt8>(hndl : __return);
        }
    }
    // System.Byte[] GetBytes(System.Int32)
// docid: M:System.Security.Cryptography.Rfc2898DeriveBytes.GetBytes(System.Int32)
    /**
    Returns the pseudo-random key for this object.

    - Parameter cb: The number of pseudo-random key bytes to generate.
    - Returns: A byte array filled with pseudo-random key bytes.

    */
    open override func GetBytes(cb : Swift.Int32) throws -> dotnet.System_Arr<Swift.UInt8> {
        var __thrown : NullableHandle = nil;
        let __return = System_Security_Cryptography_Rfc2898DeriveBytes_u8Array__GetBytes_0__1__i32(&__thrown, self.get_handle(), cb);
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return dotnet.System_Arr<Swift.UInt8>(hndl : __return);
        }
    }
    // System.Byte[] Pbkdf2(System.Byte[], System.Byte[], System.Int32, System.Security.Cryptography.HashAlgorithmName, System.Int32)
// docid: M:System.Security.Cryptography.Rfc2898DeriveBytes.Pbkdf2(System.Byte[],System.Byte[],System.Int32,System.Security.Cryptography.HashAlgorithmName,System.Int32)
    open class func Pbkdf2(password : dotnet.System_Arr<Swift.UInt8>, salt : dotnet.System_Arr<Swift.UInt8>, iterations : Swift.Int32, hashAlgorithm : dotnet.System.Security.Cryptography.HashAlgorithmName, outputLength : Swift.Int32) throws -> dotnet.System_Arr<Swift.UInt8> {
        var __thrown : NullableHandle = nil;
        let __return = System_Security_Cryptography_Rfc2898DeriveBytes_u8Array__Pbkdf2_0__5__u8Array_u8Array_i32_HashAlgorithmName_i32(&__thrown, password.get_handle(), salt.get_handle(), iterations, hashAlgorithm.get_handle(), outputLength);
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return dotnet.System_Arr<Swift.UInt8>(hndl : __return);
        }
    }
// TODO COPE (write_all_methods) (span) System.Byte[] Pbkdf2(System.ReadOnlySpan<System.Byte>, System.ReadOnlySpan<System.Byte>, System.Int32, System.Security.Cryptography.HashAlgorithmName, System.Int32)
// TODO COPE (write_all_methods) (span) void Pbkdf2(System.ReadOnlySpan<System.Byte>, System.ReadOnlySpan<System.Byte>, System.Span<System.Byte>, System.Int32, System.Security.Cryptography.HashAlgorithmName)
// TODO COPE (write_all_methods) (span) System.Byte[] Pbkdf2(System.ReadOnlySpan<System.Char>, System.ReadOnlySpan<System.Byte>, System.Int32, System.Security.Cryptography.HashAlgorithmName, System.Int32)
// TODO COPE (write_all_methods) (span) void Pbkdf2(System.ReadOnlySpan<System.Char>, System.ReadOnlySpan<System.Byte>, System.Span<System.Byte>, System.Int32, System.Security.Cryptography.HashAlgorithmName)
    // System.Byte[] Pbkdf2(System.String, System.Byte[], System.Int32, System.Security.Cryptography.HashAlgorithmName, System.Int32)
// docid: M:System.Security.Cryptography.Rfc2898DeriveBytes.Pbkdf2(System.String,System.Byte[],System.Int32,System.Security.Cryptography.HashAlgorithmName,System.Int32)
    open class func Pbkdf2(password : dotnet.System.String, salt : dotnet.System_Arr<Swift.UInt8>, iterations : Swift.Int32, hashAlgorithm : dotnet.System.Security.Cryptography.HashAlgorithmName, outputLength : Swift.Int32) throws -> dotnet.System_Arr<Swift.UInt8> {
        var __thrown : NullableHandle = nil;
        let __return = System_Security_Cryptography_Rfc2898DeriveBytes_u8Array__Pbkdf2_0__5__String_u8Array_i32_HashAlgorithmName_i32(&__thrown, password.get_handle(), salt.get_handle(), iterations, hashAlgorithm.get_handle(), outputLength);
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return dotnet.System_Arr<Swift.UInt8>(hndl : __return);
        }
    }
    // void Reset()
// docid: M:System.Security.Cryptography.Rfc2898DeriveBytes.Reset
    /**
    Resets the state of the operation.

    */
    open override func Reset() throws {
        var __thrown : NullableHandle = nil;
        System_Security_Cryptography_Rfc2898DeriveBytes_void__Reset_0__0(&__thrown, self.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
            return;
        }
    }
    // [IsSpecialName] System.Security.Cryptography.HashAlgorithmName get_HashAlgorithm()
// docid: M:System.Security.Cryptography.Rfc2898DeriveBytes.get_HashAlgorithm
    open func get_HashAlgorithm() throws -> dotnet.System.Security.Cryptography.HashAlgorithmName {
        var __thrown : NullableHandle = nil;
        let __return = System_Security_Cryptography_Rfc2898DeriveBytes_HashAlgorithmName__get_HashAlgorithm_0__0(&__thrown, self.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return dotnet.System.Security.Cryptography.HashAlgorithmName(hndl : __return);
        }
    }
    // [IsSpecialName] System.Int32 get_IterationCount()
// docid: M:System.Security.Cryptography.Rfc2898DeriveBytes.get_IterationCount
    open func get_IterationCount() throws -> Swift.Int32 {
        var __thrown : NullableHandle = nil;
        let __return = System_Security_Cryptography_Rfc2898DeriveBytes_i32__get_IterationCount_0__0(&__thrown, self.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return __return;
        }
    }
    // [IsSpecialName] void set_IterationCount(System.Int32)
// docid: M:System.Security.Cryptography.Rfc2898DeriveBytes.set_IterationCount(System.Int32)
    open func set_IterationCount(value : Swift.Int32) throws {
        var __thrown : NullableHandle = nil;
        System_Security_Cryptography_Rfc2898DeriveBytes_void__set_IterationCount_0__1__i32(&__thrown, self.get_handle(), value);
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
            return;
        }
    }
    // [IsSpecialName] System.Byte[] get_Salt()
// docid: M:System.Security.Cryptography.Rfc2898DeriveBytes.get_Salt
    open func get_Salt() throws -> dotnet.System_Arr<Swift.UInt8> {
        var __thrown : NullableHandle = nil;
        let __return = System_Security_Cryptography_Rfc2898DeriveBytes_u8Array__get_Salt_0__0(&__thrown, self.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return dotnet.System_Arr<Swift.UInt8>(hndl : __return);
        }
    }
    // [IsSpecialName] void set_Salt(System.Byte[])
// docid: M:System.Security.Cryptography.Rfc2898DeriveBytes.set_Salt(System.Byte[])
    open func set_Salt(value : dotnet.System_Arr<Swift.UInt8>) throws {
        var __thrown : NullableHandle = nil;
        System_Security_Cryptography_Rfc2898DeriveBytes_void__set_Salt_0__1__u8Array(&__thrown, self.get_handle(), value.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
            return;
        }
    }
    /**
    */
    open var HashAlgorithm : dotnet.System.Security.Cryptography.HashAlgorithmName {
        get {
            return try! get_HashAlgorithm();
        }
    }
    /**
    Gets or sets the number of iterations for the operation.

    */
    open var IterationCount : Swift.Int32 {
        get {
            return try! get_IterationCount();
        }
        set(v) {
            return try! set_IterationCount(value: v);
        }
    }
    /**
    Gets or sets the key salt value for the operation.

    */
    open var Salt : dotnet.System_Arr<Swift.UInt8> {
        get {
            return try! get_Salt();
        }
        set(v) {
            return try! set_Salt(value: v);
        }
    }
} // Rfc2898DeriveBytes


// type: System.Security.Cryptography.Rijndael
    /**
    Represents the base class from which all implementations of the  symmetric encryption algorithm must inherit.

    */
open class Rijndael
    :
    dotnet.System.Security.Cryptography.SymmetricAlgorithm
{
    open class override func get_type_handle() -> TypeHandle {
        return System_Security_Cryptography_Rijndael_get_type_handle();
    }
    public required init(hndl: NonnullHandle) { super.init(hndl: hndl); }
    public required init(gval: GVal) { super.init(gval: gval); }
    // System.Security.Cryptography.Rijndael Create()
// docid: M:System.Security.Cryptography.Rijndael.Create
    /**
    Creates a cryptographic object to perform the  algorithm.

    - Returns: A cryptographic object.

    */
    open class override func Create() throws -> dotnet.System.Security.Cryptography.Rijndael {
        var __thrown : NullableHandle = nil;
        let __return = System_Security_Cryptography_Rijndael_Rijndael__Create_0__0(&__thrown);
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return dotnet.System.Security.Cryptography.Rijndael(hndl : __return);
        }
    }
    // System.Security.Cryptography.Rijndael Create(System.String)
// docid: M:System.Security.Cryptography.Rijndael.Create(System.String)
    /**
    Creates a cryptographic object to perform the specified implementation of the  algorithm.

    - Parameter algName: The name of the specific implementation of  to create.
    - Returns: A cryptographic object.

    */
    open class override func Create(algName : dotnet.System.String) throws -> Optional<dotnet.System.Security.Cryptography.Rijndael> {
        var __thrown : NullableHandle = nil;
        let __return = System_Security_Cryptography_Rijndael_Rijndael__Create_0__1__String(&__thrown, algName.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        if let __ret_unwrapped = __return {
            return dotnet.System.Security.Cryptography.Rijndael(hndl : __ret_unwrapped);
        } else {
            return nil;
        }
        }
    }
} // Rijndael


// type: System.Security.Cryptography.RijndaelManaged
    /**
    Accesses the managed version of the  algorithm. This class cannot be inherited.

    */
public final class RijndaelManaged
    :
    dotnet.System.Security.Cryptography.Rijndael
{
    public class override func get_type_handle() -> TypeHandle {
        return System_Security_Cryptography_RijndaelManaged_get_type_handle();
    }
    public required init(hndl: NonnullHandle) { super.init(hndl: hndl); }
    public required init(gval: GVal) { super.init(gval: gval); }
    // .ctor()
// docid: M:System.Security.Cryptography.RijndaelManaged.#ctor
    /**
    Initializes a new instance of the  class.

    */
    public init() throws {
        var __thrown : NullableHandle = nil;
        let h = System_Security_Cryptography_RijndaelManaged_ctor_0__0(&__thrown);
        if let __ex = __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
            super.init(hndl: h);
        }
    }
    // System.Security.Cryptography.ICryptoTransform CreateDecryptor()
// docid: M:System.Security.Cryptography.RijndaelManaged.CreateDecryptor
    /**
    Creates a symmetric decryptor object with the current  property and initialization vector ().

    - Returns: A symmetric decryptor object.

    */
    public override func CreateDecryptor() throws -> dotnet.System.Security.Cryptography.ICryptoTransform {
        var __thrown : NullableHandle = nil;
        let __return = System_Security_Cryptography_RijndaelManaged_ICryptoTransform__CreateDecryptor_0__0(&__thrown, self.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return dotnet.System.Security.Cryptography.ICryptoTransform(hndl : __return);
        }
    }
    // System.Security.Cryptography.ICryptoTransform CreateDecryptor(System.Byte[], System.Byte[])
// docid: M:System.Security.Cryptography.RijndaelManaged.CreateDecryptor(System.Byte[],System.Byte[])
    /**
    Creates a symmetric  decryptor object with the specified  and initialization vector ().

    - Parameter rgbKey: The secret key to be used for the symmetric algorithm. The key size must be 128, 192, or 256 bits.
    - Parameter rgbIV: The IV to be used for the symmetric algorithm.
    - Returns: A symmetric  decryptor object.

    */
    public override func CreateDecryptor(rgbKey : dotnet.System_Arr<Swift.UInt8>, rgbIV : Optional<dotnet.System_Arr<Swift.UInt8>>) throws -> dotnet.System.Security.Cryptography.ICryptoTransform {
        var __thrown : NullableHandle = nil;
        let __return = System_Security_Cryptography_RijndaelManaged_ICryptoTransform__CreateDecryptor_0__2__u8Array_u8Array(&__thrown, self.get_handle(), rgbKey.get_handle(), (rgbIV?.get_handle()));
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return dotnet.System.Security.Cryptography.ICryptoTransform(hndl : __return);
        }
    }
    // System.Security.Cryptography.ICryptoTransform CreateEncryptor()
// docid: M:System.Security.Cryptography.RijndaelManaged.CreateEncryptor
    /**
    Creates a symmetric encryptor object with the current  property and initialization vector ().

    - Returns: A symmetric encryptor object.

    */
    public override func CreateEncryptor() throws -> dotnet.System.Security.Cryptography.ICryptoTransform {
        var __thrown : NullableHandle = nil;
        let __return = System_Security_Cryptography_RijndaelManaged_ICryptoTransform__CreateEncryptor_0__0(&__thrown, self.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return dotnet.System.Security.Cryptography.ICryptoTransform(hndl : __return);
        }
    }
    // System.Security.Cryptography.ICryptoTransform CreateEncryptor(System.Byte[], System.Byte[])
// docid: M:System.Security.Cryptography.RijndaelManaged.CreateEncryptor(System.Byte[],System.Byte[])
    /**
    Creates a symmetric  encryptor object with the specified  and initialization vector ().

    - Parameter rgbKey: The secret key to be used for the symmetric algorithm. The key size must be 128, 192, or 256 bits.
    - Parameter rgbIV: The IV to be used for the symmetric algorithm.
    - Returns: A symmetric  encryptor object.

    */
    public override func CreateEncryptor(rgbKey : dotnet.System_Arr<Swift.UInt8>, rgbIV : Optional<dotnet.System_Arr<Swift.UInt8>>) throws -> dotnet.System.Security.Cryptography.ICryptoTransform {
        var __thrown : NullableHandle = nil;
        let __return = System_Security_Cryptography_RijndaelManaged_ICryptoTransform__CreateEncryptor_0__2__u8Array_u8Array(&__thrown, self.get_handle(), rgbKey.get_handle(), (rgbIV?.get_handle()));
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return dotnet.System.Security.Cryptography.ICryptoTransform(hndl : __return);
        }
    }
    // void GenerateIV()
// docid: M:System.Security.Cryptography.RijndaelManaged.GenerateIV
    /**
    Generates a random initialization vector () to be used for the algorithm.

    */
    public override func GenerateIV() throws {
        var __thrown : NullableHandle = nil;
        System_Security_Cryptography_RijndaelManaged_void__GenerateIV_0__0(&__thrown, self.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
            return;
        }
    }
    // void GenerateKey()
// docid: M:System.Security.Cryptography.RijndaelManaged.GenerateKey
    /**
    Generates a random  to be used for the algorithm.

    */
    public override func GenerateKey() throws {
        var __thrown : NullableHandle = nil;
        System_Security_Cryptography_RijndaelManaged_void__GenerateKey_0__0(&__thrown, self.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
            return;
        }
    }
    // [IsSpecialName] System.Int32 get_BlockSize()
// docid: M:System.Security.Cryptography.RijndaelManaged.get_BlockSize
    public override func get_BlockSize() throws -> Swift.Int32 {
        var __thrown : NullableHandle = nil;
        let __return = System_Security_Cryptography_RijndaelManaged_i32__get_BlockSize_0__0(&__thrown, self.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return __return;
        }
    }
    // [IsSpecialName] void set_BlockSize(System.Int32)
// docid: M:System.Security.Cryptography.RijndaelManaged.set_BlockSize(System.Int32)
    public override func set_BlockSize(value : Swift.Int32) throws {
        var __thrown : NullableHandle = nil;
        System_Security_Cryptography_RijndaelManaged_void__set_BlockSize_0__1__i32(&__thrown, self.get_handle(), value);
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
            return;
        }
    }
    // [IsSpecialName] System.Int32 get_FeedbackSize()
// docid: M:System.Security.Cryptography.RijndaelManaged.get_FeedbackSize
    public override func get_FeedbackSize() throws -> Swift.Int32 {
        var __thrown : NullableHandle = nil;
        let __return = System_Security_Cryptography_RijndaelManaged_i32__get_FeedbackSize_0__0(&__thrown, self.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return __return;
        }
    }
    // [IsSpecialName] void set_FeedbackSize(System.Int32)
// docid: M:System.Security.Cryptography.RijndaelManaged.set_FeedbackSize(System.Int32)
    public override func set_FeedbackSize(value : Swift.Int32) throws {
        var __thrown : NullableHandle = nil;
        System_Security_Cryptography_RijndaelManaged_void__set_FeedbackSize_0__1__i32(&__thrown, self.get_handle(), value);
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
            return;
        }
    }
    // [IsSpecialName] System.Byte[] get_IV()
// docid: M:System.Security.Cryptography.RijndaelManaged.get_IV
    public override func get_IV() throws -> dotnet.System_Arr<Swift.UInt8> {
        var __thrown : NullableHandle = nil;
        let __return = System_Security_Cryptography_RijndaelManaged_u8Array__get_IV_0__0(&__thrown, self.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return dotnet.System_Arr<Swift.UInt8>(hndl : __return);
        }
    }
    // [IsSpecialName] void set_IV(System.Byte[])
// docid: M:System.Security.Cryptography.RijndaelManaged.set_IV(System.Byte[])
    public override func set_IV(value : dotnet.System_Arr<Swift.UInt8>) throws {
        var __thrown : NullableHandle = nil;
        System_Security_Cryptography_RijndaelManaged_void__set_IV_0__1__u8Array(&__thrown, self.get_handle(), value.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
            return;
        }
    }
    // [IsSpecialName] System.Byte[] get_Key()
// docid: M:System.Security.Cryptography.RijndaelManaged.get_Key
    public override func get_Key() throws -> dotnet.System_Arr<Swift.UInt8> {
        var __thrown : NullableHandle = nil;
        let __return = System_Security_Cryptography_RijndaelManaged_u8Array__get_Key_0__0(&__thrown, self.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return dotnet.System_Arr<Swift.UInt8>(hndl : __return);
        }
    }
    // [IsSpecialName] void set_Key(System.Byte[])
// docid: M:System.Security.Cryptography.RijndaelManaged.set_Key(System.Byte[])
    public override func set_Key(value : dotnet.System_Arr<Swift.UInt8>) throws {
        var __thrown : NullableHandle = nil;
        System_Security_Cryptography_RijndaelManaged_void__set_Key_0__1__u8Array(&__thrown, self.get_handle(), value.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
            return;
        }
    }
    // [IsSpecialName] System.Int32 get_KeySize()
// docid: M:System.Security.Cryptography.RijndaelManaged.get_KeySize
    public override func get_KeySize() throws -> Swift.Int32 {
        var __thrown : NullableHandle = nil;
        let __return = System_Security_Cryptography_RijndaelManaged_i32__get_KeySize_0__0(&__thrown, self.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return __return;
        }
    }
    // [IsSpecialName] void set_KeySize(System.Int32)
// docid: M:System.Security.Cryptography.RijndaelManaged.set_KeySize(System.Int32)
    public override func set_KeySize(value : Swift.Int32) throws {
        var __thrown : NullableHandle = nil;
        System_Security_Cryptography_RijndaelManaged_void__set_KeySize_0__1__i32(&__thrown, self.get_handle(), value);
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
            return;
        }
    }
    // [IsSpecialName] System.Security.Cryptography.KeySizes[] get_LegalKeySizes()
// docid: M:System.Security.Cryptography.RijndaelManaged.get_LegalKeySizes
    public override func get_LegalKeySizes() throws -> dotnet.System_Arr<dotnet.System.Security.Cryptography.KeySizes> {
        var __thrown : NullableHandle = nil;
        let __return = System_Security_Cryptography_RijndaelManaged_KeySizesArray__get_LegalKeySizes_0__0(&__thrown, self.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return dotnet.System_Arr<dotnet.System.Security.Cryptography.KeySizes>(hndl : __return);
        }
    }
    // [IsSpecialName] System.Security.Cryptography.CipherMode get_Mode()
// docid: M:System.Security.Cryptography.RijndaelManaged.get_Mode
    public override func get_Mode() throws -> dotnet.System.Security.Cryptography.CipherMode {
        var __thrown : NullableHandle = nil;
        let __return = System_Security_Cryptography_RijndaelManaged_CipherMode__get_Mode_0__0(&__thrown, self.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return dotnet.System.Security.Cryptography.CipherMode(val: __return);
        }
    }
    // [IsSpecialName] void set_Mode(System.Security.Cryptography.CipherMode)
// docid: M:System.Security.Cryptography.RijndaelManaged.set_Mode(System.Security.Cryptography.CipherMode)
    public override func set_Mode(value : dotnet.System.Security.Cryptography.CipherMode) throws {
        var __thrown : NullableHandle = nil;
        System_Security_Cryptography_RijndaelManaged_void__set_Mode_0__1__CipherMode(&__thrown, self.get_handle(), value.get_value());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
            return;
        }
    }
    // [IsSpecialName] System.Security.Cryptography.PaddingMode get_Padding()
// docid: M:System.Security.Cryptography.RijndaelManaged.get_Padding
    public override func get_Padding() throws -> dotnet.System.Security.Cryptography.PaddingMode {
        var __thrown : NullableHandle = nil;
        let __return = System_Security_Cryptography_RijndaelManaged_PaddingMode__get_Padding_0__0(&__thrown, self.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return dotnet.System.Security.Cryptography.PaddingMode(val: __return);
        }
    }
    // [IsSpecialName] void set_Padding(System.Security.Cryptography.PaddingMode)
// docid: M:System.Security.Cryptography.RijndaelManaged.set_Padding(System.Security.Cryptography.PaddingMode)
    public override func set_Padding(value : dotnet.System.Security.Cryptography.PaddingMode) throws {
        var __thrown : NullableHandle = nil;
        System_Security_Cryptography_RijndaelManaged_void__set_Padding_0__1__PaddingMode(&__thrown, self.get_handle(), value.get_value());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
            return;
        }
    }
    /**
    Gets or sets the block size, in bits, of the cryptographic operation.

    */
    public override var BlockSize : Swift.Int32 {
        get {
            return try! get_BlockSize();
        }
        set(v) {
            return try! set_BlockSize(value: v);
        }
    }
    public override var FeedbackSize : Swift.Int32 {
        get {
            return try! get_FeedbackSize();
        }
        set(v) {
            return try! set_FeedbackSize(value: v);
        }
    }
    /**
    Gets or sets the initialization vector (IV) to use for the symmetric algorithm.

    */
    public override var IV : dotnet.System_Arr<Swift.UInt8> {
        get {
            return try! get_IV();
        }
        set(v) {
            return try! set_IV(value: v);
        }
    }
    /**
    Gets or sets the secret key used for the symmetric algorithm.

    */
    public override var Key : dotnet.System_Arr<Swift.UInt8> {
        get {
            return try! get_Key();
        }
        set(v) {
            return try! set_Key(value: v);
        }
    }
    /**
    Gets or sets the size, in bits, of the secret key used for the symmetric algorithm.

    */
    public override var KeySize : Swift.Int32 {
        get {
            return try! get_KeySize();
        }
        set(v) {
            return try! set_KeySize(value: v);
        }
    }
    /**
    Gets the key sizes, in bits, that are supported by the symmetric algorithm.

    */
    public override var LegalKeySizes : dotnet.System_Arr<dotnet.System.Security.Cryptography.KeySizes> {
        get {
            return try! get_LegalKeySizes();
        }
    }
    /**
    Gets or sets the mode for operation of the symmetric algorithm.

    */
    public override var Mode : dotnet.System.Security.Cryptography.CipherMode {
        get {
            return try! get_Mode();
        }
        set(v) {
            return try! set_Mode(value: v);
        }
    }
    /**
    Gets or sets the padding mode used in the symmetric algorithm.

    */
    public override var Padding : dotnet.System.Security.Cryptography.PaddingMode {
        get {
            return try! get_Padding();
        }
        set(v) {
            return try! set_Padding(value: v);
        }
    }
} // RijndaelManaged


// type: System.Security.Cryptography.SHA1
    /**
    Computes the  hash for the input data.

    */
open class SHA1
    :
    dotnet.System.Security.Cryptography.HashAlgorithm
{
    open class override func get_type_handle() -> TypeHandle {
        return System_Security_Cryptography_SHA1_get_type_handle();
    }
    public required init(hndl: NonnullHandle) { super.init(hndl: hndl); }
    public required init(gval: GVal) { super.init(gval: gval); }
    // System.Security.Cryptography.SHA1 Create()
// docid: M:System.Security.Cryptography.SHA1.Create
    /**
    Creates an instance of the default implementation of .

    - Returns: A new instance of .

    */
    open class override func Create() throws -> dotnet.System.Security.Cryptography.SHA1 {
        var __thrown : NullableHandle = nil;
        let __return = System_Security_Cryptography_SHA1_SHA1__Create_0__0(&__thrown);
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return dotnet.System.Security.Cryptography.SHA1(hndl : __return);
        }
    }
    // System.Security.Cryptography.SHA1 Create(System.String)
// docid: M:System.Security.Cryptography.SHA1.Create(System.String)
    /**
    Creates an instance of the specified implementation of .

    - Parameter hashName: The name of the specific implementation of  to be used.
    - Returns: A new instance of  using the specified implementation.

    */
    open class override func Create(hashName : dotnet.System.String) throws -> Optional<dotnet.System.Security.Cryptography.SHA1> {
        var __thrown : NullableHandle = nil;
        let __return = System_Security_Cryptography_SHA1_SHA1__Create_0__1__String(&__thrown, hashName.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        if let __ret_unwrapped = __return {
            return dotnet.System.Security.Cryptography.SHA1(hndl : __ret_unwrapped);
        } else {
            return nil;
        }
        }
    }
    // System.Byte[] HashData(System.Byte[])
// docid: M:System.Security.Cryptography.SHA1.HashData(System.Byte[])
    /**
    Computes the hash of data using the SHA1 algorithm.

    - Parameter source: The data to hash.
    - Returns: The hash of the data.

    */
    open class func HashData(source : dotnet.System_Arr<Swift.UInt8>) throws -> dotnet.System_Arr<Swift.UInt8> {
        var __thrown : NullableHandle = nil;
        let __return = System_Security_Cryptography_SHA1_u8Array__HashData_0__1__u8Array(&__thrown, source.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return dotnet.System_Arr<Swift.UInt8>(hndl : __return);
        }
    }
// TODO COPE (write_all_methods) (span) System.Byte[] HashData(System.ReadOnlySpan<System.Byte>)
// TODO COPE (write_all_methods) (span) System.Int32 HashData(System.ReadOnlySpan<System.Byte>, System.Span<System.Byte>)
// TODO COPE (write_all_methods) (span) bool TryHashData(System.ReadOnlySpan<System.Byte>, System.Span<System.Byte>, ref System.Int32)
} // SHA1


// type: System.Security.Cryptography.SHA1Managed
    /**
    Computes the  hash for the input data using the managed library.

    */
public final class SHA1Managed
    :
    dotnet.System.Security.Cryptography.SHA1
{
    public class override func get_type_handle() -> TypeHandle {
        return System_Security_Cryptography_SHA1Managed_get_type_handle();
    }
    public required init(hndl: NonnullHandle) { super.init(hndl: hndl); }
    public required init(gval: GVal) { super.init(gval: gval); }
    // .ctor()
// docid: M:System.Security.Cryptography.SHA1Managed.#ctor
    /**
    Initializes a new instance of the  class.

    */
    public init() throws {
        var __thrown : NullableHandle = nil;
        let h = System_Security_Cryptography_SHA1Managed_ctor_0__0(&__thrown);
        if let __ex = __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
            super.init(hndl: h);
        }
    }
    // void Initialize()
// docid: M:System.Security.Cryptography.SHA1Managed.Initialize
    /**
    Initializes an instance of .

    */
    public override func Initialize() throws {
        var __thrown : NullableHandle = nil;
        System_Security_Cryptography_SHA1Managed_void__Initialize_0__0(&__thrown, self.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
            return;
        }
    }
} // SHA1Managed


// type: System.Security.Cryptography.SHA256
    /**
    Computes the  hash for the input data.

    */
open class SHA256
    :
    dotnet.System.Security.Cryptography.HashAlgorithm
{
    open class override func get_type_handle() -> TypeHandle {
        return System_Security_Cryptography_SHA256_get_type_handle();
    }
    public required init(hndl: NonnullHandle) { super.init(hndl: hndl); }
    public required init(gval: GVal) { super.init(gval: gval); }
    // System.Security.Cryptography.SHA256 Create()
// docid: M:System.Security.Cryptography.SHA256.Create
    /**
    Creates an instance of the default implementation of .

    - Returns: A new instance of . On the .NET Framework, this method creates an instance of the  class if FIPS mode is not active; if FIPS mode is active, it creates an instance of the  class. On .NET Core, it returns an instance of a private class derived from .

    */
    open class override func Create() throws -> dotnet.System.Security.Cryptography.SHA256 {
        var __thrown : NullableHandle = nil;
        let __return = System_Security_Cryptography_SHA256_SHA256__Create_0__0(&__thrown);
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return dotnet.System.Security.Cryptography.SHA256(hndl : __return);
        }
    }
    // System.Security.Cryptography.SHA256 Create(System.String)
// docid: M:System.Security.Cryptography.SHA256.Create(System.String)
    /**
    Creates an instance of a specified implementation of .

    - Parameter hashName: The name of the specific implementation of  to be used.
    - Returns: A new instance of  using the specified implementation.

    */
    open class override func Create(hashName : dotnet.System.String) throws -> Optional<dotnet.System.Security.Cryptography.SHA256> {
        var __thrown : NullableHandle = nil;
        let __return = System_Security_Cryptography_SHA256_SHA256__Create_0__1__String(&__thrown, hashName.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        if let __ret_unwrapped = __return {
            return dotnet.System.Security.Cryptography.SHA256(hndl : __ret_unwrapped);
        } else {
            return nil;
        }
        }
    }
    // System.Byte[] HashData(System.Byte[])
// docid: M:System.Security.Cryptography.SHA256.HashData(System.Byte[])
    /**
    Computes the hash of data using the SHA256 algorithm.

    - Parameter source: The data to hash.
    - Returns: The hash of the data.

    */
    open class func HashData(source : dotnet.System_Arr<Swift.UInt8>) throws -> dotnet.System_Arr<Swift.UInt8> {
        var __thrown : NullableHandle = nil;
        let __return = System_Security_Cryptography_SHA256_u8Array__HashData_0__1__u8Array(&__thrown, source.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return dotnet.System_Arr<Swift.UInt8>(hndl : __return);
        }
    }
// TODO COPE (write_all_methods) (span) System.Byte[] HashData(System.ReadOnlySpan<System.Byte>)
// TODO COPE (write_all_methods) (span) System.Int32 HashData(System.ReadOnlySpan<System.Byte>, System.Span<System.Byte>)
// TODO COPE (write_all_methods) (span) bool TryHashData(System.ReadOnlySpan<System.Byte>, System.Span<System.Byte>, ref System.Int32)
} // SHA256


// type: System.Security.Cryptography.SHA256Managed
    /**
    Computes the  hash for the input data using the managed library.

    */
public final class SHA256Managed
    :
    dotnet.System.Security.Cryptography.SHA256
{
    public class override func get_type_handle() -> TypeHandle {
        return System_Security_Cryptography_SHA256Managed_get_type_handle();
    }
    public required init(hndl: NonnullHandle) { super.init(hndl: hndl); }
    public required init(gval: GVal) { super.init(gval: gval); }
    // .ctor()
// docid: M:System.Security.Cryptography.SHA256Managed.#ctor
    /**
    Initializes a new instance of the  class using the managed library.

    */
    public init() throws {
        var __thrown : NullableHandle = nil;
        let h = System_Security_Cryptography_SHA256Managed_ctor_0__0(&__thrown);
        if let __ex = __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
            super.init(hndl: h);
        }
    }
    // void Initialize()
// docid: M:System.Security.Cryptography.SHA256Managed.Initialize
    /**
    Initializes an instance of .

    */
    public override func Initialize() throws {
        var __thrown : NullableHandle = nil;
        System_Security_Cryptography_SHA256Managed_void__Initialize_0__0(&__thrown, self.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
            return;
        }
    }
} // SHA256Managed


// type: System.Security.Cryptography.SHA384
    /**
    Computes the  hash for the input data.

    */
open class SHA384
    :
    dotnet.System.Security.Cryptography.HashAlgorithm
{
    open class override func get_type_handle() -> TypeHandle {
        return System_Security_Cryptography_SHA384_get_type_handle();
    }
    public required init(hndl: NonnullHandle) { super.init(hndl: hndl); }
    public required init(gval: GVal) { super.init(gval: gval); }
    // System.Security.Cryptography.SHA384 Create()
// docid: M:System.Security.Cryptography.SHA384.Create
    /**
    Creates an instance of the default implementation of .

    - Returns: A new instance of .

    */
    open class override func Create() throws -> dotnet.System.Security.Cryptography.SHA384 {
        var __thrown : NullableHandle = nil;
        let __return = System_Security_Cryptography_SHA384_SHA384__Create_0__0(&__thrown);
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return dotnet.System.Security.Cryptography.SHA384(hndl : __return);
        }
    }
    // System.Security.Cryptography.SHA384 Create(System.String)
// docid: M:System.Security.Cryptography.SHA384.Create(System.String)
    /**
    Creates an instance of a specified implementation of .

    - Parameter hashName: The name of the specific implementation of  to be used.
    - Returns: A new instance of  using the specified implementation.

    */
    open class override func Create(hashName : dotnet.System.String) throws -> Optional<dotnet.System.Security.Cryptography.SHA384> {
        var __thrown : NullableHandle = nil;
        let __return = System_Security_Cryptography_SHA384_SHA384__Create_0__1__String(&__thrown, hashName.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        if let __ret_unwrapped = __return {
            return dotnet.System.Security.Cryptography.SHA384(hndl : __ret_unwrapped);
        } else {
            return nil;
        }
        }
    }
    // System.Byte[] HashData(System.Byte[])
// docid: M:System.Security.Cryptography.SHA384.HashData(System.Byte[])
    /**
    Computes the hash of data using the SHA384 algorithm.

    - Parameter source: The data to hash.
    - Returns: The hash of the data.

    */
    open class func HashData(source : dotnet.System_Arr<Swift.UInt8>) throws -> dotnet.System_Arr<Swift.UInt8> {
        var __thrown : NullableHandle = nil;
        let __return = System_Security_Cryptography_SHA384_u8Array__HashData_0__1__u8Array(&__thrown, source.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return dotnet.System_Arr<Swift.UInt8>(hndl : __return);
        }
    }
// TODO COPE (write_all_methods) (span) System.Byte[] HashData(System.ReadOnlySpan<System.Byte>)
// TODO COPE (write_all_methods) (span) System.Int32 HashData(System.ReadOnlySpan<System.Byte>, System.Span<System.Byte>)
// TODO COPE (write_all_methods) (span) bool TryHashData(System.ReadOnlySpan<System.Byte>, System.Span<System.Byte>, ref System.Int32)
} // SHA384


// type: System.Security.Cryptography.SHA384Managed
    /**
    Computes the  hash for the input data using the managed library.

    */
public final class SHA384Managed
    :
    dotnet.System.Security.Cryptography.SHA384
{
    public class override func get_type_handle() -> TypeHandle {
        return System_Security_Cryptography_SHA384Managed_get_type_handle();
    }
    public required init(hndl: NonnullHandle) { super.init(hndl: hndl); }
    public required init(gval: GVal) { super.init(gval: gval); }
    // .ctor()
// docid: M:System.Security.Cryptography.SHA384Managed.#ctor
    /**
    Initializes a new instance of the  class.

    */
    public init() throws {
        var __thrown : NullableHandle = nil;
        let h = System_Security_Cryptography_SHA384Managed_ctor_0__0(&__thrown);
        if let __ex = __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
            super.init(hndl: h);
        }
    }
    // void Initialize()
// docid: M:System.Security.Cryptography.SHA384Managed.Initialize
    /**
    Initializes an instance of .

    */
    public override func Initialize() throws {
        var __thrown : NullableHandle = nil;
        System_Security_Cryptography_SHA384Managed_void__Initialize_0__0(&__thrown, self.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
            return;
        }
    }
} // SHA384Managed


// type: System.Security.Cryptography.SHA512
    /**
    Computes the  hash for the input data.

    */
open class SHA512
    :
    dotnet.System.Security.Cryptography.HashAlgorithm
{
    open class override func get_type_handle() -> TypeHandle {
        return System_Security_Cryptography_SHA512_get_type_handle();
    }
    public required init(hndl: NonnullHandle) { super.init(hndl: hndl); }
    public required init(gval: GVal) { super.init(gval: gval); }
    // System.Security.Cryptography.SHA512 Create()
// docid: M:System.Security.Cryptography.SHA512.Create
    /**
    Creates an instance of the default implementation of .

    - Returns: A new instance of .

    */
    open class override func Create() throws -> dotnet.System.Security.Cryptography.SHA512 {
        var __thrown : NullableHandle = nil;
        let __return = System_Security_Cryptography_SHA512_SHA512__Create_0__0(&__thrown);
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return dotnet.System.Security.Cryptography.SHA512(hndl : __return);
        }
    }
    // System.Security.Cryptography.SHA512 Create(System.String)
// docid: M:System.Security.Cryptography.SHA512.Create(System.String)
    /**
    Creates an instance of a specified implementation of .

    - Parameter hashName: The name of the specific implementation of  to be used.
    - Returns: A new instance of  using the specified implementation.

    */
    open class override func Create(hashName : dotnet.System.String) throws -> Optional<dotnet.System.Security.Cryptography.SHA512> {
        var __thrown : NullableHandle = nil;
        let __return = System_Security_Cryptography_SHA512_SHA512__Create_0__1__String(&__thrown, hashName.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        if let __ret_unwrapped = __return {
            return dotnet.System.Security.Cryptography.SHA512(hndl : __ret_unwrapped);
        } else {
            return nil;
        }
        }
    }
    // System.Byte[] HashData(System.Byte[])
// docid: M:System.Security.Cryptography.SHA512.HashData(System.Byte[])
    /**
    Computes the hash of data using the SHA512 algorithm.

    - Parameter source: The data to hash.
    - Returns: The hash of the data.

    */
    open class func HashData(source : dotnet.System_Arr<Swift.UInt8>) throws -> dotnet.System_Arr<Swift.UInt8> {
        var __thrown : NullableHandle = nil;
        let __return = System_Security_Cryptography_SHA512_u8Array__HashData_0__1__u8Array(&__thrown, source.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return dotnet.System_Arr<Swift.UInt8>(hndl : __return);
        }
    }
// TODO COPE (write_all_methods) (span) System.Byte[] HashData(System.ReadOnlySpan<System.Byte>)
// TODO COPE (write_all_methods) (span) System.Int32 HashData(System.ReadOnlySpan<System.Byte>, System.Span<System.Byte>)
// TODO COPE (write_all_methods) (span) bool TryHashData(System.ReadOnlySpan<System.Byte>, System.Span<System.Byte>, ref System.Int32)
} // SHA512


// type: System.Security.Cryptography.SHA512Managed
    /**
    Computes the  hash algorithm for the input data using the managed library.

    */
public final class SHA512Managed
    :
    dotnet.System.Security.Cryptography.SHA512
{
    public class override func get_type_handle() -> TypeHandle {
        return System_Security_Cryptography_SHA512Managed_get_type_handle();
    }
    public required init(hndl: NonnullHandle) { super.init(hndl: hndl); }
    public required init(gval: GVal) { super.init(gval: gval); }
    // .ctor()
// docid: M:System.Security.Cryptography.SHA512Managed.#ctor
    /**
    Initializes a new instance of the  class.

    */
    public init() throws {
        var __thrown : NullableHandle = nil;
        let h = System_Security_Cryptography_SHA512Managed_ctor_0__0(&__thrown);
        if let __ex = __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
            super.init(hndl: h);
        }
    }
    // void Initialize()
// docid: M:System.Security.Cryptography.SHA512Managed.Initialize
    /**
    Initializes an instance of the  class using the managed library.

    */
    public override func Initialize() throws {
        var __thrown : NullableHandle = nil;
        System_Security_Cryptography_SHA512Managed_void__Initialize_0__0(&__thrown, self.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
            return;
        }
    }
} // SHA512Managed


// type: System.Security.Cryptography.SignatureDescription
    /**
    Contains information about the properties of a digital signature.

    */
open class SignatureDescription
    :
    dotnet.System.Object
{
    open class override func get_type_handle() -> TypeHandle {
        return System_Security_Cryptography_SignatureDescription_get_type_handle();
    }
    public required init(hndl: NonnullHandle) { super.init(hndl: hndl); }
    public required init(gval: GVal) { super.init(gval: gval); }
    // .ctor()
// docid: M:System.Security.Cryptography.SignatureDescription.#ctor
    /**
    Initializes a new instance of the  class.

    */
    public override init() throws {
        var __thrown : NullableHandle = nil;
        let h = System_Security_Cryptography_SignatureDescription_ctor_0__0(&__thrown);
        if let __ex = __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
            super.init(hndl: h);
        }
    }
    // .ctor(System.Security.SecurityElement)
// docid: M:System.Security.Cryptography.SignatureDescription.#ctor(System.Security.SecurityElement)
    /**
    Initializes a new instance of the  class from the specified .

    - Parameter el: The  from which to get the algorithms for the signature description.
    */
    public init(el : dotnet.System.Security.SecurityElement) throws {
        var __thrown : NullableHandle = nil;
        let h = System_Security_Cryptography_SignatureDescription_ctor_0__1__SecurityElement(&__thrown, el.get_handle());
        if let __ex = __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
            super.init(hndl: h);
        }
    }
    // System.Security.Cryptography.AsymmetricSignatureDeformatter CreateDeformatter(System.Security.Cryptography.AsymmetricAlgorithm)
// docid: M:System.Security.Cryptography.SignatureDescription.CreateDeformatter(System.Security.Cryptography.AsymmetricAlgorithm)
    /**
    Creates an  instance with the specified key using the  property.

    - Parameter key: The key to use in the .
    - Returns: The newly created  instance.

    */
    open func CreateDeformatter(key : dotnet.System.Security.Cryptography.AsymmetricAlgorithm) throws -> dotnet.System.Security.Cryptography.AsymmetricSignatureDeformatter {
        var __thrown : NullableHandle = nil;
        let __return = System_Security_Cryptography_SignatureDescription_AsymmetricSignatureDeformatter__CreateDeformatter_0__1__AsymmetricAlgorithm(&__thrown, self.get_handle(), key.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return dotnet.System.Security.Cryptography.AsymmetricSignatureDeformatter(hndl : __return);
        }
    }
    // System.Security.Cryptography.HashAlgorithm CreateDigest()
// docid: M:System.Security.Cryptography.SignatureDescription.CreateDigest
    /**
    Creates a  instance using the  property.

    - Returns: The newly created  instance.

    */
    open func CreateDigest() throws -> Optional<dotnet.System.Security.Cryptography.HashAlgorithm> {
        var __thrown : NullableHandle = nil;
        let __return = System_Security_Cryptography_SignatureDescription_HashAlgorithm__CreateDigest_0__0(&__thrown, self.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        if let __ret_unwrapped = __return {
            return dotnet.System.Security.Cryptography.HashAlgorithm(hndl : __ret_unwrapped);
        } else {
            return nil;
        }
        }
    }
    // System.Security.Cryptography.AsymmetricSignatureFormatter CreateFormatter(System.Security.Cryptography.AsymmetricAlgorithm)
// docid: M:System.Security.Cryptography.SignatureDescription.CreateFormatter(System.Security.Cryptography.AsymmetricAlgorithm)
    /**
    Creates an  instance with the specified key using the  property.

    - Parameter key: The key to use in the .
    - Returns: The newly created  instance.

    */
    open func CreateFormatter(key : dotnet.System.Security.Cryptography.AsymmetricAlgorithm) throws -> dotnet.System.Security.Cryptography.AsymmetricSignatureFormatter {
        var __thrown : NullableHandle = nil;
        let __return = System_Security_Cryptography_SignatureDescription_AsymmetricSignatureFormatter__CreateFormatter_0__1__AsymmetricAlgorithm(&__thrown, self.get_handle(), key.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return dotnet.System.Security.Cryptography.AsymmetricSignatureFormatter(hndl : __return);
        }
    }
    // [IsSpecialName] System.String get_DeformatterAlgorithm()
// docid: M:System.Security.Cryptography.SignatureDescription.get_DeformatterAlgorithm
    open func get_DeformatterAlgorithm() throws -> Optional<dotnet.System.String> {
        var __thrown : NullableHandle = nil;
        let __return = System_Security_Cryptography_SignatureDescription_String__get_DeformatterAlgorithm_0__0(&__thrown, self.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        if let __ret_unwrapped = __return {
            return dotnet.System.String(hndl : __ret_unwrapped);
        } else {
            return nil;
        }
        }
    }
    // [IsSpecialName] void set_DeformatterAlgorithm(System.String)
// docid: M:System.Security.Cryptography.SignatureDescription.set_DeformatterAlgorithm(System.String)
    open func set_DeformatterAlgorithm(value : Optional<dotnet.System.String>) throws {
        var __thrown : NullableHandle = nil;
        System_Security_Cryptography_SignatureDescription_void__set_DeformatterAlgorithm_0__1__String(&__thrown, self.get_handle(), value?.get_handle() ?? nil);
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
            return;
        }
    }
    // [IsSpecialName] System.String get_DigestAlgorithm()
// docid: M:System.Security.Cryptography.SignatureDescription.get_DigestAlgorithm
    open func get_DigestAlgorithm() throws -> Optional<dotnet.System.String> {
        var __thrown : NullableHandle = nil;
        let __return = System_Security_Cryptography_SignatureDescription_String__get_DigestAlgorithm_0__0(&__thrown, self.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        if let __ret_unwrapped = __return {
            return dotnet.System.String(hndl : __ret_unwrapped);
        } else {
            return nil;
        }
        }
    }
    // [IsSpecialName] void set_DigestAlgorithm(System.String)
// docid: M:System.Security.Cryptography.SignatureDescription.set_DigestAlgorithm(System.String)
    open func set_DigestAlgorithm(value : Optional<dotnet.System.String>) throws {
        var __thrown : NullableHandle = nil;
        System_Security_Cryptography_SignatureDescription_void__set_DigestAlgorithm_0__1__String(&__thrown, self.get_handle(), value?.get_handle() ?? nil);
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
            return;
        }
    }
    // [IsSpecialName] System.String get_FormatterAlgorithm()
// docid: M:System.Security.Cryptography.SignatureDescription.get_FormatterAlgorithm
    open func get_FormatterAlgorithm() throws -> Optional<dotnet.System.String> {
        var __thrown : NullableHandle = nil;
        let __return = System_Security_Cryptography_SignatureDescription_String__get_FormatterAlgorithm_0__0(&__thrown, self.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        if let __ret_unwrapped = __return {
            return dotnet.System.String(hndl : __ret_unwrapped);
        } else {
            return nil;
        }
        }
    }
    // [IsSpecialName] void set_FormatterAlgorithm(System.String)
// docid: M:System.Security.Cryptography.SignatureDescription.set_FormatterAlgorithm(System.String)
    open func set_FormatterAlgorithm(value : Optional<dotnet.System.String>) throws {
        var __thrown : NullableHandle = nil;
        System_Security_Cryptography_SignatureDescription_void__set_FormatterAlgorithm_0__1__String(&__thrown, self.get_handle(), value?.get_handle() ?? nil);
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
            return;
        }
    }
    // [IsSpecialName] System.String get_KeyAlgorithm()
// docid: M:System.Security.Cryptography.SignatureDescription.get_KeyAlgorithm
    open func get_KeyAlgorithm() throws -> Optional<dotnet.System.String> {
        var __thrown : NullableHandle = nil;
        let __return = System_Security_Cryptography_SignatureDescription_String__get_KeyAlgorithm_0__0(&__thrown, self.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        if let __ret_unwrapped = __return {
            return dotnet.System.String(hndl : __ret_unwrapped);
        } else {
            return nil;
        }
        }
    }
    // [IsSpecialName] void set_KeyAlgorithm(System.String)
// docid: M:System.Security.Cryptography.SignatureDescription.set_KeyAlgorithm(System.String)
    open func set_KeyAlgorithm(value : Optional<dotnet.System.String>) throws {
        var __thrown : NullableHandle = nil;
        System_Security_Cryptography_SignatureDescription_void__set_KeyAlgorithm_0__1__String(&__thrown, self.get_handle(), value?.get_handle() ?? nil);
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
            return;
        }
    }
    /**
    Gets or sets the deformatter algorithm for the signature description.

    */
    open var DeformatterAlgorithm : Optional<dotnet.System.String> {
        get {
            return try! get_DeformatterAlgorithm();
        }
        set(v) {
            return try! set_DeformatterAlgorithm(value: v!);
        }
    }
    /**
    Gets or sets the digest algorithm for the signature description.

    */
    open var DigestAlgorithm : Optional<dotnet.System.String> {
        get {
            return try! get_DigestAlgorithm();
        }
        set(v) {
            return try! set_DigestAlgorithm(value: v!);
        }
    }
    /**
    Gets or sets the formatter algorithm for the signature description.

    */
    open var FormatterAlgorithm : Optional<dotnet.System.String> {
        get {
            return try! get_FormatterAlgorithm();
        }
        set(v) {
            return try! set_FormatterAlgorithm(value: v!);
        }
    }
    /**
    Gets or sets the key algorithm for the signature description.

    */
    open var KeyAlgorithm : Optional<dotnet.System.String> {
        get {
            return try! get_KeyAlgorithm();
        }
        set(v) {
            return try! set_KeyAlgorithm(value: v!);
        }
    }
} // SignatureDescription


// type: System.Security.Cryptography.TripleDES
    /**
    Represents the base class for Triple Data Encryption Standard algorithms from which all  implementations must derive.

    */
open class TripleDES
    :
    dotnet.System.Security.Cryptography.SymmetricAlgorithm
{
    open class override func get_type_handle() -> TypeHandle {
        return System_Security_Cryptography_TripleDES_get_type_handle();
    }
    public required init(hndl: NonnullHandle) { super.init(hndl: hndl); }
    public required init(gval: GVal) { super.init(gval: gval); }
    // System.Security.Cryptography.TripleDES Create()
// docid: M:System.Security.Cryptography.TripleDES.Create
    /**
    Creates an instance of a cryptographic object to perform the  algorithm.

    - Returns: An instance of a cryptographic object.

    */
    open class override func Create() throws -> dotnet.System.Security.Cryptography.TripleDES {
        var __thrown : NullableHandle = nil;
        let __return = System_Security_Cryptography_TripleDES_TripleDES__Create_0__0(&__thrown);
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return dotnet.System.Security.Cryptography.TripleDES(hndl : __return);
        }
    }
    // System.Security.Cryptography.TripleDES Create(System.String)
// docid: M:System.Security.Cryptography.TripleDES.Create(System.String)
    /**
    Creates an instance of a cryptographic object to perform the specified implementation of the  algorithm.

    - Parameter str: The name of the specific implementation of  to use.
    - Returns: An instance of a cryptographic object.

    */
    open class func Create(str : dotnet.System.String) throws -> Optional<dotnet.System.Security.Cryptography.TripleDES> {
        var __thrown : NullableHandle = nil;
        let __return = System_Security_Cryptography_TripleDES_TripleDES__Create_0__1__String(&__thrown, str.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        if let __ret_unwrapped = __return {
            return dotnet.System.Security.Cryptography.TripleDES(hndl : __ret_unwrapped);
        } else {
            return nil;
        }
        }
    }
    // bool IsWeakKey(System.Byte[])
// docid: M:System.Security.Cryptography.TripleDES.IsWeakKey(System.Byte[])
    /**
    Determines whether the specified key is weak.

    - Parameter rgbKey: The secret key to test for weakness.
    - Returns: 
         if the key is weak; otherwise, .

    */
    open class func IsWeakKey(rgbKey : dotnet.System_Arr<Swift.UInt8>) throws -> Bool {
        var __thrown : NullableHandle = nil;
        let __return = System_Security_Cryptography_TripleDES_bool__IsWeakKey_0__1__u8Array(&__thrown, rgbKey.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return (__return) != 0;
        }
    }
    // [IsSpecialName] System.Byte[] get_Key()
// docid: M:System.Security.Cryptography.TripleDES.get_Key
    open override func get_Key() throws -> dotnet.System_Arr<Swift.UInt8> {
        var __thrown : NullableHandle = nil;
        let __return = System_Security_Cryptography_TripleDES_u8Array__get_Key_0__0(&__thrown, self.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return dotnet.System_Arr<Swift.UInt8>(hndl : __return);
        }
    }
    // [IsSpecialName] void set_Key(System.Byte[])
// docid: M:System.Security.Cryptography.TripleDES.set_Key(System.Byte[])
    open override func set_Key(value : dotnet.System_Arr<Swift.UInt8>) throws {
        var __thrown : NullableHandle = nil;
        System_Security_Cryptography_TripleDES_void__set_Key_0__1__u8Array(&__thrown, self.get_handle(), value.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
            return;
        }
    }
    /**
    Gets or sets the secret key for the  algorithm.

    */
    open override var Key : dotnet.System_Arr<Swift.UInt8> {
        get {
            return try! get_Key();
        }
        set(v) {
            return try! set_Key(value: v);
        }
    }
} // TripleDES


}



