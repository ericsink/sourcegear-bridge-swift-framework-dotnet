// this file is automatically generated
// Copyright 2021 SourceGear

import jumptable_dotnet;

// System
// System.Threading
extension System.Threading {
// type: System.Threading.IThreadPoolWorkItem
    /**
    Represents a work item that can be executed by the .

    */
open class IThreadPoolWorkItem
    :
    SGBridgeGenericValue,
    System_Threading_IThreadPoolWorkItem
{
    open class func get_type_handle() -> TypeHandle {
        return System_Threading_IThreadPoolWorkItem_get_type_handle();
    }
    let h : NonnullHandle;
    public func to_gval() -> GVal { return GVal(Swift.Int(bitPattern: self.h)); }
    public func dup_gval() -> GVal { return GVal(Swift.Int(bitPattern: __copy_handle(self.h))); }
    public required init(gval: GVal) { self.h = NonnullHandle(bitPattern: Swift.Int(truncatingIfNeeded: gval))!; }
    public required init(hndl: NonnullHandle) { self.h = hndl; }
    public func get_handle() -> NonnullHandle { return self.h; }

    deinit { __drop_handle(self.h); }

    // void Execute()
// docid: M:System.Threading.IThreadPoolWorkItem.Execute
    /**
    Executes the work item on the thread pool.

    */
    open func Execute() throws {
        var __thrown : NullableHandle = nil;
        System_Threading_IThreadPoolWorkItem_void__Execute_0__0(&__thrown, self.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
            return;
        }
    }
} // IThreadPoolWorkItem


// type: System.Threading.RegisteredWaitHandle
    /**
    Represents a handle that has been registered when calling . This class cannot be inherited.

    */
public final class RegisteredWaitHandle
    :
    dotnet.System.MarshalByRefObject
{
    public class override func get_type_handle() -> TypeHandle {
        return System_Threading_RegisteredWaitHandle_get_type_handle();
    }
    public required init(hndl: NonnullHandle) { super.init(hndl: hndl); }
    public required init(gval: GVal) { super.init(gval: gval); }
    // bool Unregister(System.Threading.WaitHandle)
// docid: M:System.Threading.RegisteredWaitHandle.Unregister(System.Threading.WaitHandle)
    /**
    Cancels a registered wait operation issued by the  method.

    - Parameter waitObject: The  to be signaled.
    - Returns: 
         if the function succeeds; otherwise, .

    */
    public func Unregister(waitObject : Optional<dotnet.System.Threading.WaitHandle>) throws -> Bool {
        var __thrown : NullableHandle = nil;
        let __return = System_Threading_RegisteredWaitHandle_bool__Unregister_0__1__WaitHandle(&__thrown, self.get_handle(), waitObject?.get_handle() ?? nil);
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return (__return) != 0;
        }
    }
} // RegisteredWaitHandle


// type: System.Threading.ThreadPool
public struct ThreadPool {
    // bool BindHandle(System.IntPtr)
// docid: M:System.Threading.ThreadPool.BindHandle(System.IntPtr)
    /**
    Binds an operating system handle to the .

    - Parameter osHandle: An  that holds the handle. The handle must have been opened for overlapped I/O on the unmanaged side.
    - Returns: 
         if the handle is bound; otherwise, .

    */
    public static func BindHandle(osHandle : dotnet.System.IntPtr) throws -> Bool {
        var __thrown : NullableHandle = nil;
        let __return = System_Threading_ThreadPool_bool__BindHandle_0__1__IntPtr(&__thrown, osHandle.get_value());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return (__return) != 0;
        }
    }
    // bool BindHandle(System.Runtime.InteropServices.SafeHandle)
// docid: M:System.Threading.ThreadPool.BindHandle(System.Runtime.InteropServices.SafeHandle)
    /**
    Binds an operating system handle to the .

    - Parameter osHandle: A  that holds the operating system handle. The handle must have been opened for overlapped I/O on the unmanaged side.
    - Returns: 
         if the handle is bound; otherwise, .

    */
    public static func BindHandle(osHandle : dotnet.System.Runtime.InteropServices.SafeHandle) throws -> Bool {
        var __thrown : NullableHandle = nil;
        let __return = System_Threading_ThreadPool_bool__BindHandle_0__1__SafeHandle(&__thrown, osHandle.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return (__return) != 0;
        }
    }
    // void GetAvailableThreads(ref System.Int32, ref System.Int32)
// docid: M:System.Threading.ThreadPool.GetAvailableThreads(System.Int32@,System.Int32@)
    /**
    Retrieves the difference between the maximum number of thread pool threads returned by the  method, and the number currently active.

    - Parameter workerThreads: The number of available worker threads.
    - Parameter completionPortThreads: The number of available asynchronous I/O threads.
    */
    public static func GetAvailableThreads(workerThreads : inout Swift.Int32, completionPortThreads : inout Swift.Int32) throws {
        var __thrown : NullableHandle = nil;
            var _tmp_out_workerThreads = workerThreads;
            var _tmp_out_completionPortThreads = completionPortThreads;
        System_Threading_ThreadPool_void__GetAvailableThreads_0__2__outi32_outi32(&__thrown, &_tmp_out_workerThreads, &_tmp_out_completionPortThreads);
        let _tmp2_workerThreads = _tmp_out_workerThreads;
            workerThreads = _tmp2_workerThreads;
        let _tmp2_completionPortThreads = _tmp_out_completionPortThreads;
            completionPortThreads = _tmp2_completionPortThreads;
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
            return;
        }
    }
    // void GetMaxThreads(ref System.Int32, ref System.Int32)
// docid: M:System.Threading.ThreadPool.GetMaxThreads(System.Int32@,System.Int32@)
    /**
    Retrieves the number of requests to the thread pool that can be active concurrently. All requests above that number remain queued until thread pool threads become available.

    - Parameter workerThreads: The maximum number of worker threads in the thread pool.
    - Parameter completionPortThreads: The maximum number of asynchronous I/O threads in the thread pool.
    */
    public static func GetMaxThreads(workerThreads : inout Swift.Int32, completionPortThreads : inout Swift.Int32) throws {
        var __thrown : NullableHandle = nil;
            var _tmp_out_workerThreads = workerThreads;
            var _tmp_out_completionPortThreads = completionPortThreads;
        System_Threading_ThreadPool_void__GetMaxThreads_0__2__outi32_outi32(&__thrown, &_tmp_out_workerThreads, &_tmp_out_completionPortThreads);
        let _tmp2_workerThreads = _tmp_out_workerThreads;
            workerThreads = _tmp2_workerThreads;
        let _tmp2_completionPortThreads = _tmp_out_completionPortThreads;
            completionPortThreads = _tmp2_completionPortThreads;
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
            return;
        }
    }
    // void GetMinThreads(ref System.Int32, ref System.Int32)
// docid: M:System.Threading.ThreadPool.GetMinThreads(System.Int32@,System.Int32@)
    /**
    Retrieves the minimum number of threads the thread pool creates on demand, as new requests are made, before switching to an algorithm for managing thread creation and destruction.

    - Parameter workerThreads: When this method returns, contains the minimum number of worker threads that the thread pool creates on demand.
    - Parameter completionPortThreads: When this method returns, contains the minimum number of asynchronous I/O threads that the thread pool creates on demand.
    */
    public static func GetMinThreads(workerThreads : inout Swift.Int32, completionPortThreads : inout Swift.Int32) throws {
        var __thrown : NullableHandle = nil;
            var _tmp_out_workerThreads = workerThreads;
            var _tmp_out_completionPortThreads = completionPortThreads;
        System_Threading_ThreadPool_void__GetMinThreads_0__2__outi32_outi32(&__thrown, &_tmp_out_workerThreads, &_tmp_out_completionPortThreads);
        let _tmp2_workerThreads = _tmp_out_workerThreads;
            workerThreads = _tmp2_workerThreads;
        let _tmp2_completionPortThreads = _tmp_out_completionPortThreads;
            completionPortThreads = _tmp2_completionPortThreads;
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
            return;
        }
    }
    // bool QueueUserWorkItem(System.Threading.WaitCallback)
// docid: M:System.Threading.ThreadPool.QueueUserWorkItem(System.Threading.WaitCallback)
    /**
    Queues a method for execution. The method executes when a thread pool thread becomes available.

    - Parameter callBack: A  that represents the method to be executed.
    - Returns: 
         if the method is successfully queued;  is thrown if the work item could not be queued.

    */
    public static func QueueUserWorkItem(callBack : dotnet.System.Threading.WaitCallback) throws -> Bool {
        var __thrown : NullableHandle = nil;
        let __return = System_Threading_ThreadPool_bool__QueueUserWorkItem_0__1__WaitCallback(&__thrown, callBack.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return (__return) != 0;
        }
    }
    // delegate closure overload
    public static func QueueUserWorkItem(callBack : @escaping (Optional<dotnet.System.Object>) throws -> Void) throws -> Bool {
        let del_callBack = try dotnet.System.Threading.WaitCallback(callBack);
        return try QueueUserWorkItem(callBack: del_callBack);
    }
    // bool QueueUserWorkItem(System.Threading.WaitCallback, System.Object)
// docid: M:System.Threading.ThreadPool.QueueUserWorkItem(System.Threading.WaitCallback,System.Object)
    /**
    Queues a method for execution, and specifies an object containing data to be used by the method. The method executes when a thread pool thread becomes available.

    - Parameter callBack: A  representing the method to execute.
    - Parameter state: An object containing data to be used by the method.
    - Returns: 
         if the method is successfully queued;  is thrown if the work item could not be queued.

    */
    public static func QueueUserWorkItem(callBack : dotnet.System.Threading.WaitCallback, state : Optional<dotnet.System.Object>) throws -> Bool {
        var __thrown : NullableHandle = nil;
        let __return = System_Threading_ThreadPool_bool__QueueUserWorkItem_0__2__WaitCallback_Object(&__thrown, callBack.get_handle(), state?.get_handle() ?? nil);
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return (__return) != 0;
        }
    }
    // delegate closure overload
    public static func QueueUserWorkItem(callBack : @escaping (Optional<dotnet.System.Object>) throws -> Void, state : Optional<dotnet.System.Object>) throws -> Bool {
        let del_callBack = try dotnet.System.Threading.WaitCallback(callBack);
        return try QueueUserWorkItem(callBack: del_callBack, state: state);
    }
    // bool QueueUserWorkItem<TState>(System.Action<TState>, TState, bool)
// docid: M:System.Threading.ThreadPool.QueueUserWorkItem``1(System.Action{``0},``0,System.Boolean)
    /**
    Queues a method specified by an  delegate for execution, and provides data to be used by the method. The method executes when a thread pool thread becomes available.

    - Parameter callBack: An  representing the method to execute.
    - Parameter state: An object containing data to be used by the method.
    - Parameter preferLocal: 
         to prefer queueing the work item in a queue close to the current thread;  to prefer queueing the work item to the thread pool's shared queue.
    - Returns: 
         if the method is successfully queued;  is thrown if the work item could not be queued.

    */
    public static func QueueUserWorkItem<UTState : SGBridgeGenericValue>(callBack : dotnet.System.Action_1<UTState>, state : UTState, preferLocal : Bool) throws -> Bool {
        var __thrown : NullableHandle = nil;
        let __return = System_Threading_ThreadPool_bool__QueueUserWorkItem_1__3__System_Action_UTState__UTState_bool(UTState.get_type_handle(), &__thrown, callBack.get_handle(), state.to_gval(), Swift.Int32(preferLocal ? 1 : 0));
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return (__return) != 0;
        }
    }
    // delegate closure overload
    public static func QueueUserWorkItem<UTState : SGBridgeGenericValue>(callBack : @escaping (UTState) throws -> Void, state : UTState, preferLocal : Bool) throws -> Bool {
        let del_callBack = try dotnet.System.Action_1<UTState>(callBack);
        return try QueueUserWorkItem(callBack: del_callBack, state: state, preferLocal: preferLocal);
    }
    // System.Threading.RegisteredWaitHandle RegisterWaitForSingleObject(System.Threading.WaitHandle, System.Threading.WaitOrTimerCallback, System.Object, System.Int32, bool)
// docid: M:System.Threading.ThreadPool.RegisterWaitForSingleObject(System.Threading.WaitHandle,System.Threading.WaitOrTimerCallback,System.Object,System.Int32,System.Boolean)
    /**
    Registers a delegate to wait for a , specifying a 32-bit signed integer for the time-out in milliseconds.

    - Parameter waitObject: The  to register. Use a  other than .
    - Parameter callBack: The  delegate to call when the  parameter is signaled.
    - Parameter state: The object that is passed to the delegate.
    - Parameter millisecondsTimeOutInterval: The time-out in milliseconds. If the  parameter is 0 (zero), the function tests the object's state and returns immediately. If  is -1, the function's time-out interval never elapses.
    - Parameter executeOnlyOnce: 
         to indicate that the thread will no longer wait on the  parameter after the delegate has been called;  to indicate that the timer is reset every time the wait operation completes until the wait is unregistered.
    - Returns: The  that encapsulates the native handle.

    */
    public static func RegisterWaitForSingleObject(waitObject : dotnet.System.Threading.WaitHandle, callBack : dotnet.System.Threading.WaitOrTimerCallback, state : Optional<dotnet.System.Object>, millisecondsTimeOutInterval : Swift.Int32, executeOnlyOnce : Bool) throws -> dotnet.System.Threading.RegisteredWaitHandle {
        var __thrown : NullableHandle = nil;
        let __return = System_Threading_ThreadPool_RegisteredWaitHandle__RegisterWaitForSingleObject_0__5__WaitHandle_WaitOrTimerCallback_Object_i32_bool(&__thrown, waitObject.get_handle(), callBack.get_handle(), state?.get_handle() ?? nil, millisecondsTimeOutInterval, Swift.Int32(executeOnlyOnce ? 1 : 0));
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return dotnet.System.Threading.RegisteredWaitHandle(hndl : __return);
        }
    }
    // delegate closure overload
    public static func RegisterWaitForSingleObject(waitObject : dotnet.System.Threading.WaitHandle, callBack : @escaping (Optional<dotnet.System.Object>, Bool) throws -> Void, state : Optional<dotnet.System.Object>, millisecondsTimeOutInterval : Swift.Int32, executeOnlyOnce : Bool) throws -> dotnet.System.Threading.RegisteredWaitHandle {
        let del_callBack = try dotnet.System.Threading.WaitOrTimerCallback(callBack);
        return try RegisterWaitForSingleObject(waitObject: waitObject, callBack: del_callBack, state: state, millisecondsTimeOutInterval: millisecondsTimeOutInterval, executeOnlyOnce: executeOnlyOnce);
    }
    // System.Threading.RegisteredWaitHandle RegisterWaitForSingleObject(System.Threading.WaitHandle, System.Threading.WaitOrTimerCallback, System.Object, System.Int64, bool)
// docid: M:System.Threading.ThreadPool.RegisterWaitForSingleObject(System.Threading.WaitHandle,System.Threading.WaitOrTimerCallback,System.Object,System.Int64,System.Boolean)
    /**
    Registers a delegate to wait for a , specifying a 64-bit signed integer for the time-out in milliseconds.

    - Parameter waitObject: The  to register. Use a  other than .
    - Parameter callBack: The  delegate to call when the  parameter is signaled.
    - Parameter state: The object passed to the delegate.
    - Parameter millisecondsTimeOutInterval: The time-out in milliseconds. If the  parameter is 0 (zero), the function tests the object's state and returns immediately. If  is -1, the function's time-out interval never elapses.
    - Parameter executeOnlyOnce: 
         to indicate that the thread will no longer wait on the  parameter after the delegate has been called;  to indicate that the timer is reset every time the wait operation completes until the wait is unregistered.
    - Returns: The  that encapsulates the native handle.

    */
    public static func RegisterWaitForSingleObject(waitObject : dotnet.System.Threading.WaitHandle, callBack : dotnet.System.Threading.WaitOrTimerCallback, state : Optional<dotnet.System.Object>, millisecondsTimeOutInterval : Swift.Int64, executeOnlyOnce : Bool) throws -> dotnet.System.Threading.RegisteredWaitHandle {
        var __thrown : NullableHandle = nil;
        let __return = System_Threading_ThreadPool_RegisteredWaitHandle__RegisterWaitForSingleObject_0__5__WaitHandle_WaitOrTimerCallback_Object_i64_bool(&__thrown, waitObject.get_handle(), callBack.get_handle(), state?.get_handle() ?? nil, millisecondsTimeOutInterval, Swift.Int32(executeOnlyOnce ? 1 : 0));
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return dotnet.System.Threading.RegisteredWaitHandle(hndl : __return);
        }
    }
    // delegate closure overload
    public static func RegisterWaitForSingleObject(waitObject : dotnet.System.Threading.WaitHandle, callBack : @escaping (Optional<dotnet.System.Object>, Bool) throws -> Void, state : Optional<dotnet.System.Object>, millisecondsTimeOutInterval : Swift.Int64, executeOnlyOnce : Bool) throws -> dotnet.System.Threading.RegisteredWaitHandle {
        let del_callBack = try dotnet.System.Threading.WaitOrTimerCallback(callBack);
        return try RegisterWaitForSingleObject(waitObject: waitObject, callBack: del_callBack, state: state, millisecondsTimeOutInterval: millisecondsTimeOutInterval, executeOnlyOnce: executeOnlyOnce);
    }
// TODO COPE (write_all_methods) (span) System.Threading.RegisteredWaitHandle RegisterWaitForSingleObject(System.Threading.WaitHandle, System.Threading.WaitOrTimerCallback, System.Object, System.TimeSpan, bool)
    // System.Threading.RegisteredWaitHandle RegisterWaitForSingleObject(System.Threading.WaitHandle, System.Threading.WaitOrTimerCallback, System.Object, System.UInt32, bool)
// docid: M:System.Threading.ThreadPool.RegisterWaitForSingleObject(System.Threading.WaitHandle,System.Threading.WaitOrTimerCallback,System.Object,System.UInt32,System.Boolean)
    /**
    Registers a delegate to wait for a , specifying a 32-bit unsigned integer for the time-out in milliseconds.

    - Parameter waitObject: The  to register. Use a  other than .
    - Parameter callBack: The  delegate to call when the  parameter is signaled.
    - Parameter state: The object passed to the delegate.
    - Parameter millisecondsTimeOutInterval: The time-out in milliseconds. If the  parameter is 0 (zero), the function tests the object's state and returns immediately. If  is -1, the function's time-out interval never elapses.
    - Parameter executeOnlyOnce: 
         to indicate that the thread will no longer wait on the  parameter after the delegate has been called;  to indicate that the timer is reset every time the wait operation completes until the wait is unregistered.
    - Returns: The  that can be used to cancel the registered wait operation.

    */
    public static func RegisterWaitForSingleObject(waitObject : dotnet.System.Threading.WaitHandle, callBack : dotnet.System.Threading.WaitOrTimerCallback, state : Optional<dotnet.System.Object>, millisecondsTimeOutInterval : Swift.UInt32, executeOnlyOnce : Bool) throws -> dotnet.System.Threading.RegisteredWaitHandle {
        var __thrown : NullableHandle = nil;
        let __return = System_Threading_ThreadPool_RegisteredWaitHandle__RegisterWaitForSingleObject_0__5__WaitHandle_WaitOrTimerCallback_Object_u32_bool(&__thrown, waitObject.get_handle(), callBack.get_handle(), state?.get_handle() ?? nil, millisecondsTimeOutInterval, Swift.Int32(executeOnlyOnce ? 1 : 0));
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return dotnet.System.Threading.RegisteredWaitHandle(hndl : __return);
        }
    }
    // delegate closure overload
    public static func RegisterWaitForSingleObject(waitObject : dotnet.System.Threading.WaitHandle, callBack : @escaping (Optional<dotnet.System.Object>, Bool) throws -> Void, state : Optional<dotnet.System.Object>, millisecondsTimeOutInterval : Swift.UInt32, executeOnlyOnce : Bool) throws -> dotnet.System.Threading.RegisteredWaitHandle {
        let del_callBack = try dotnet.System.Threading.WaitOrTimerCallback(callBack);
        return try RegisterWaitForSingleObject(waitObject: waitObject, callBack: del_callBack, state: state, millisecondsTimeOutInterval: millisecondsTimeOutInterval, executeOnlyOnce: executeOnlyOnce);
    }
    // bool SetMaxThreads(System.Int32, System.Int32)
// docid: M:System.Threading.ThreadPool.SetMaxThreads(System.Int32,System.Int32)
    /**
    Sets the number of requests to the thread pool that can be active concurrently. All requests above that number remain queued until thread pool threads become available.

    - Parameter workerThreads: The maximum number of worker threads in the thread pool.
    - Parameter completionPortThreads: The maximum number of asynchronous I/O threads in the thread pool.
    - Returns: 
         if the change is successful; otherwise, .

    */
    public static func SetMaxThreads(workerThreads : Swift.Int32, completionPortThreads : Swift.Int32) throws -> Bool {
        var __thrown : NullableHandle = nil;
        let __return = System_Threading_ThreadPool_bool__SetMaxThreads_0__2__i32_i32(&__thrown, workerThreads, completionPortThreads);
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return (__return) != 0;
        }
    }
    // bool SetMinThreads(System.Int32, System.Int32)
// docid: M:System.Threading.ThreadPool.SetMinThreads(System.Int32,System.Int32)
    /**
    Sets the minimum number of threads the thread pool creates on demand, as new requests are made, before switching to an algorithm for managing thread creation and destruction.

    - Parameter workerThreads: The minimum number of worker threads that the thread pool creates on demand.
    - Parameter completionPortThreads: The minimum number of asynchronous I/O threads that the thread pool creates on demand.
    - Returns: 
         if the change is successful; otherwise, .

    */
    public static func SetMinThreads(workerThreads : Swift.Int32, completionPortThreads : Swift.Int32) throws -> Bool {
        var __thrown : NullableHandle = nil;
        let __return = System_Threading_ThreadPool_bool__SetMinThreads_0__2__i32_i32(&__thrown, workerThreads, completionPortThreads);
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return (__return) != 0;
        }
    }
    // bool UnsafeQueueUserWorkItem(System.Threading.IThreadPoolWorkItem, bool)
// docid: M:System.Threading.ThreadPool.UnsafeQueueUserWorkItem(System.Threading.IThreadPoolWorkItem,System.Boolean)
    /**
    Queues the specified work item object to the thread pool.

    - Parameter callBack: The work item to invoke when a thread in the thread pool picks up the work item.
    - Parameter preferLocal: 
         to prefer queueing the work item in a queue close to the current thread;  to prefer queueing the work item to the thread pool's shared queue.
    - Returns: 
         if the method succeeds;  is thrown if the work item could not be queued.

    */
    public static func UnsafeQueueUserWorkItem(callBack : dotnet.System.Threading.IThreadPoolWorkItem, preferLocal : Bool) throws -> Bool {
        var __thrown : NullableHandle = nil;
        let __return = System_Threading_ThreadPool_bool__UnsafeQueueUserWorkItem_0__2__IThreadPoolWorkItem_bool(&__thrown, callBack.get_handle(), Swift.Int32(preferLocal ? 1 : 0));
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return (__return) != 0;
        }
    }
    // bool UnsafeQueueUserWorkItem(System.Threading.WaitCallback, System.Object)
// docid: M:System.Threading.ThreadPool.UnsafeQueueUserWorkItem(System.Threading.WaitCallback,System.Object)
    /**
    Queues the specified delegate to the thread pool, but does not propagate the calling stack to the worker thread.

    - Parameter callBack: A  that represents the delegate to invoke when a thread in the thread pool picks up the work item.
    - Parameter state: The object that is passed to the delegate when serviced from the thread pool.
    - Returns: 
         if the method succeeds;  is thrown if the work item could not be queued.

    */
    public static func UnsafeQueueUserWorkItem(callBack : dotnet.System.Threading.WaitCallback, state : Optional<dotnet.System.Object>) throws -> Bool {
        var __thrown : NullableHandle = nil;
        let __return = System_Threading_ThreadPool_bool__UnsafeQueueUserWorkItem_0__2__WaitCallback_Object(&__thrown, callBack.get_handle(), state?.get_handle() ?? nil);
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return (__return) != 0;
        }
    }
    // delegate closure overload
    public static func UnsafeQueueUserWorkItem(callBack : @escaping (Optional<dotnet.System.Object>) throws -> Void, state : Optional<dotnet.System.Object>) throws -> Bool {
        let del_callBack = try dotnet.System.Threading.WaitCallback(callBack);
        return try UnsafeQueueUserWorkItem(callBack: del_callBack, state: state);
    }
    // bool UnsafeQueueUserWorkItem<TState>(System.Action<TState>, TState, bool)
// docid: M:System.Threading.ThreadPool.UnsafeQueueUserWorkItem``1(System.Action{``0},``0,System.Boolean)
    /**
    Queues a method specified by an  delegate for execution, and specifies an object containing data to be used by the method. The method executes when a thread pool thread becomes available.

    - Parameter callBack: A delegate representing the method to execute.
    - Parameter state: An object containing data to be used by the method.
    - Parameter preferLocal: 
         to prefer queueing the work item in a queue close to the current thread;  to prefer queueing the work item to the thread pool's shared queue.
    - Returns: 
         if the method is successfully queued;  is thrown if the work item could not be queued.

    */
    public static func UnsafeQueueUserWorkItem<UTState : SGBridgeGenericValue>(callBack : dotnet.System.Action_1<UTState>, state : UTState, preferLocal : Bool) throws -> Bool {
        var __thrown : NullableHandle = nil;
        let __return = System_Threading_ThreadPool_bool__UnsafeQueueUserWorkItem_1__3__System_Action_UTState__UTState_bool(UTState.get_type_handle(), &__thrown, callBack.get_handle(), state.to_gval(), Swift.Int32(preferLocal ? 1 : 0));
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return (__return) != 0;
        }
    }
    // delegate closure overload
    public static func UnsafeQueueUserWorkItem<UTState : SGBridgeGenericValue>(callBack : @escaping (UTState) throws -> Void, state : UTState, preferLocal : Bool) throws -> Bool {
        let del_callBack = try dotnet.System.Action_1<UTState>(callBack);
        return try UnsafeQueueUserWorkItem(callBack: del_callBack, state: state, preferLocal: preferLocal);
    }
    // System.Threading.RegisteredWaitHandle UnsafeRegisterWaitForSingleObject(System.Threading.WaitHandle, System.Threading.WaitOrTimerCallback, System.Object, System.Int32, bool)
// docid: M:System.Threading.ThreadPool.UnsafeRegisterWaitForSingleObject(System.Threading.WaitHandle,System.Threading.WaitOrTimerCallback,System.Object,System.Int32,System.Boolean)
    /**
    Registers a delegate to wait for a , using a 32-bit signed integer for the time-out in milliseconds. This method does not propagate the calling stack to the worker thread.

    - Parameter waitObject: The  to register. Use a  other than .
    - Parameter callBack: The delegate to call when the  parameter is signaled.
    - Parameter state: The object that is passed to the delegate.
    - Parameter millisecondsTimeOutInterval: The time-out in milliseconds. If the  parameter is 0 (zero), the function tests the object's state and returns immediately. If  is -1, the function's time-out interval never elapses.
    - Parameter executeOnlyOnce: 
         to indicate that the thread will no longer wait on the  parameter after the delegate has been called;  to indicate that the timer is reset every time the wait operation completes until the wait is unregistered.
    - Returns: The  object that can be used to cancel the registered wait operation.

    */
    public static func UnsafeRegisterWaitForSingleObject(waitObject : dotnet.System.Threading.WaitHandle, callBack : dotnet.System.Threading.WaitOrTimerCallback, state : Optional<dotnet.System.Object>, millisecondsTimeOutInterval : Swift.Int32, executeOnlyOnce : Bool) throws -> dotnet.System.Threading.RegisteredWaitHandle {
        var __thrown : NullableHandle = nil;
        let __return = System_Threading_ThreadPool_RegisteredWaitHandle__UnsafeRegisterWaitForSingleObject_0__5__WaitHandle_WaitOrTimerCallback_Object_i32_bool(&__thrown, waitObject.get_handle(), callBack.get_handle(), state?.get_handle() ?? nil, millisecondsTimeOutInterval, Swift.Int32(executeOnlyOnce ? 1 : 0));
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return dotnet.System.Threading.RegisteredWaitHandle(hndl : __return);
        }
    }
    // delegate closure overload
    public static func UnsafeRegisterWaitForSingleObject(waitObject : dotnet.System.Threading.WaitHandle, callBack : @escaping (Optional<dotnet.System.Object>, Bool) throws -> Void, state : Optional<dotnet.System.Object>, millisecondsTimeOutInterval : Swift.Int32, executeOnlyOnce : Bool) throws -> dotnet.System.Threading.RegisteredWaitHandle {
        let del_callBack = try dotnet.System.Threading.WaitOrTimerCallback(callBack);
        return try UnsafeRegisterWaitForSingleObject(waitObject: waitObject, callBack: del_callBack, state: state, millisecondsTimeOutInterval: millisecondsTimeOutInterval, executeOnlyOnce: executeOnlyOnce);
    }
    // System.Threading.RegisteredWaitHandle UnsafeRegisterWaitForSingleObject(System.Threading.WaitHandle, System.Threading.WaitOrTimerCallback, System.Object, System.Int64, bool)
// docid: M:System.Threading.ThreadPool.UnsafeRegisterWaitForSingleObject(System.Threading.WaitHandle,System.Threading.WaitOrTimerCallback,System.Object,System.Int64,System.Boolean)
    /**
    Registers a delegate to wait for a , specifying a 64-bit signed integer for the time-out in milliseconds. This method does not propagate the calling stack to the worker thread.

    - Parameter waitObject: The  to register. Use a  other than .
    - Parameter callBack: The delegate to call when the  parameter is signaled.
    - Parameter state: The object that is passed to the delegate.
    - Parameter millisecondsTimeOutInterval: The time-out in milliseconds. If the  parameter is 0 (zero), the function tests the object's state and returns immediately. If  is -1, the function's time-out interval never elapses.
    - Parameter executeOnlyOnce: 
         to indicate that the thread will no longer wait on the  parameter after the delegate has been called;  to indicate that the timer is reset every time the wait operation completes until the wait is unregistered.
    - Returns: The  object that can be used to cancel the registered wait operation.

    */
    public static func UnsafeRegisterWaitForSingleObject(waitObject : dotnet.System.Threading.WaitHandle, callBack : dotnet.System.Threading.WaitOrTimerCallback, state : Optional<dotnet.System.Object>, millisecondsTimeOutInterval : Swift.Int64, executeOnlyOnce : Bool) throws -> dotnet.System.Threading.RegisteredWaitHandle {
        var __thrown : NullableHandle = nil;
        let __return = System_Threading_ThreadPool_RegisteredWaitHandle__UnsafeRegisterWaitForSingleObject_0__5__WaitHandle_WaitOrTimerCallback_Object_i64_bool(&__thrown, waitObject.get_handle(), callBack.get_handle(), state?.get_handle() ?? nil, millisecondsTimeOutInterval, Swift.Int32(executeOnlyOnce ? 1 : 0));
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return dotnet.System.Threading.RegisteredWaitHandle(hndl : __return);
        }
    }
    // delegate closure overload
    public static func UnsafeRegisterWaitForSingleObject(waitObject : dotnet.System.Threading.WaitHandle, callBack : @escaping (Optional<dotnet.System.Object>, Bool) throws -> Void, state : Optional<dotnet.System.Object>, millisecondsTimeOutInterval : Swift.Int64, executeOnlyOnce : Bool) throws -> dotnet.System.Threading.RegisteredWaitHandle {
        let del_callBack = try dotnet.System.Threading.WaitOrTimerCallback(callBack);
        return try UnsafeRegisterWaitForSingleObject(waitObject: waitObject, callBack: del_callBack, state: state, millisecondsTimeOutInterval: millisecondsTimeOutInterval, executeOnlyOnce: executeOnlyOnce);
    }
// TODO COPE (write_all_methods) (span) System.Threading.RegisteredWaitHandle UnsafeRegisterWaitForSingleObject(System.Threading.WaitHandle, System.Threading.WaitOrTimerCallback, System.Object, System.TimeSpan, bool)
    // System.Threading.RegisteredWaitHandle UnsafeRegisterWaitForSingleObject(System.Threading.WaitHandle, System.Threading.WaitOrTimerCallback, System.Object, System.UInt32, bool)
// docid: M:System.Threading.ThreadPool.UnsafeRegisterWaitForSingleObject(System.Threading.WaitHandle,System.Threading.WaitOrTimerCallback,System.Object,System.UInt32,System.Boolean)
    /**
    Registers a delegate to wait for a , specifying a 32-bit unsigned integer for the time-out in milliseconds. This method does not propagate the calling stack to the worker thread.

    - Parameter waitObject: The  to register. Use a  other than .
    - Parameter callBack: The delegate to call when the  parameter is signaled.
    - Parameter state: The object that is passed to the delegate.
    - Parameter millisecondsTimeOutInterval: The time-out in milliseconds. If the  parameter is 0 (zero), the function tests the object's state and returns immediately. If  is -1, the function's time-out interval never elapses.
    - Parameter executeOnlyOnce: 
         to indicate that the thread will no longer wait on the  parameter after the delegate has been called;  to indicate that the timer is reset every time the wait operation completes until the wait is unregistered.
    - Returns: The  object that can be used to cancel the registered wait operation.

    */
    public static func UnsafeRegisterWaitForSingleObject(waitObject : dotnet.System.Threading.WaitHandle, callBack : dotnet.System.Threading.WaitOrTimerCallback, state : Optional<dotnet.System.Object>, millisecondsTimeOutInterval : Swift.UInt32, executeOnlyOnce : Bool) throws -> dotnet.System.Threading.RegisteredWaitHandle {
        var __thrown : NullableHandle = nil;
        let __return = System_Threading_ThreadPool_RegisteredWaitHandle__UnsafeRegisterWaitForSingleObject_0__5__WaitHandle_WaitOrTimerCallback_Object_u32_bool(&__thrown, waitObject.get_handle(), callBack.get_handle(), state?.get_handle() ?? nil, millisecondsTimeOutInterval, Swift.Int32(executeOnlyOnce ? 1 : 0));
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return dotnet.System.Threading.RegisteredWaitHandle(hndl : __return);
        }
    }
    // delegate closure overload
    public static func UnsafeRegisterWaitForSingleObject(waitObject : dotnet.System.Threading.WaitHandle, callBack : @escaping (Optional<dotnet.System.Object>, Bool) throws -> Void, state : Optional<dotnet.System.Object>, millisecondsTimeOutInterval : Swift.UInt32, executeOnlyOnce : Bool) throws -> dotnet.System.Threading.RegisteredWaitHandle {
        let del_callBack = try dotnet.System.Threading.WaitOrTimerCallback(callBack);
        return try UnsafeRegisterWaitForSingleObject(waitObject: waitObject, callBack: del_callBack, state: state, millisecondsTimeOutInterval: millisecondsTimeOutInterval, executeOnlyOnce: executeOnlyOnce);
    }
    // [IsSpecialName] System.Int64 get_CompletedWorkItemCount()
// docid: M:System.Threading.ThreadPool.get_CompletedWorkItemCount
    public static func get_CompletedWorkItemCount() throws -> Swift.Int64 {
        var __thrown : NullableHandle = nil;
        let __return = System_Threading_ThreadPool_i64__get_CompletedWorkItemCount_0__0(&__thrown);
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return __return;
        }
    }
    // [IsSpecialName] System.Int64 get_PendingWorkItemCount()
// docid: M:System.Threading.ThreadPool.get_PendingWorkItemCount
    public static func get_PendingWorkItemCount() throws -> Swift.Int64 {
        var __thrown : NullableHandle = nil;
        let __return = System_Threading_ThreadPool_i64__get_PendingWorkItemCount_0__0(&__thrown);
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return __return;
        }
    }
    // [IsSpecialName] System.Int32 get_ThreadCount()
// docid: M:System.Threading.ThreadPool.get_ThreadCount
    public static func get_ThreadCount() throws -> Swift.Int32 {
        var __thrown : NullableHandle = nil;
        let __return = System_Threading_ThreadPool_i32__get_ThreadCount_0__0(&__thrown);
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return __return;
        }
    }
    /**
    Gets the number of work items that have been processed so far.

    */
    public static var CompletedWorkItemCount : Swift.Int64 {
        get {
            return try! get_CompletedWorkItemCount();
        }
    }
    /**
    Gets the number of work items that are currently queued to be processed.

    */
    public static var PendingWorkItemCount : Swift.Int64 {
        get {
            return try! get_PendingWorkItemCount();
        }
    }
    /**
    Gets the number of thread pool threads that currently exist.

    */
    public static var ThreadCount : Swift.Int32 {
        get {
            return try! get_ThreadCount();
        }
    }
} // ThreadPool


// type: System.Threading.WaitCallback
    /**
    Represents a callback method to be executed by a thread pool thread.

    */
public final class WaitCallback
    :
    dotnet.System.Delegate
{
    public class override func get_type_handle() -> TypeHandle {
        return System_Threading_WaitCallback_get_type_handle();
    }
    public required init(hndl: NonnullHandle) { super.init(hndl: hndl); }
    public required init(gval: GVal) { super.init(gval: gval); }
    // void Invoke(System.Object)
// docid: M:System.Threading.WaitCallback.Invoke(System.Object)
    public func Invoke(state : Optional<dotnet.System.Object>) throws {
        var __thrown : NullableHandle = nil;
        System_Threading_WaitCallback_void__Invoke_0__1__Object(&__thrown, self.get_handle(), state?.get_handle() ?? nil);
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
            return;
        }
    }
    // System.IAsyncResult BeginInvoke(System.Object, System.AsyncCallback, System.Object)
// docid: M:System.Threading.WaitCallback.BeginInvoke(System.Object,System.AsyncCallback,System.Object)
    public func BeginInvoke(state : Optional<dotnet.System.Object>, callback : Optional<dotnet.System.AsyncCallback>, object : Optional<dotnet.System.Object>) throws -> Optional<dotnet.System.IAsyncResult> {
        var __thrown : NullableHandle = nil;
        let __return = System_Threading_WaitCallback_IAsyncResult__BeginInvoke_0__3__Object_AsyncCallback_Object(&__thrown, self.get_handle(), state?.get_handle() ?? nil, callback?.get_handle() ?? nil, object?.get_handle() ?? nil);
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        if let __ret_unwrapped = __return {
            return dotnet.System.IAsyncResult(hndl : __ret_unwrapped);
        } else {
            return nil;
        }
        }
    }
    // void EndInvoke(System.IAsyncResult)
// docid: M:System.Threading.WaitCallback.EndInvoke(System.IAsyncResult)
    public func EndInvoke(result : Optional<dotnet.System.IAsyncResult>) throws {
        var __thrown : NullableHandle = nil;
        System_Threading_WaitCallback_void__EndInvoke_0__1__IAsyncResult(&__thrown, self.get_handle(), result?.get_handle() ?? nil);
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
            return;
        }
    }
    public init(_ callback : @escaping (Optional<dotnet.System.Object>) throws -> Void) throws
    {
        let __bridge : (UnsafeMutablePointer<NullableHandle>, NullableHandle) -> Void =
        {
            (thrown : UnsafeMutablePointer<NullableHandle>, state : NullableHandle) -> Void in
            do
            {
                thrown.pointee = nil;
                try callback((state != nil) ? (dotnet.System.Object(hndl: state!)) : nil);
            }
            catch let e as dotnet.System.Exception
            {
                thrown.pointee = __copy_handle(e.get_handle());
            }
            catch
            {
                let e = try! dotnet.System.Exception(message: "TODO fail inside closure");
                thrown.pointee = __copy_handle(e.get_handle());
            }
        };
        let cbarg = UnsafeRawPointer(Unmanaged.passRetained(__bridge as AnyObject).toOpaque());
        func __cb(cb : UnsafeRawPointer?, thrown : UnsafeMutablePointer<NullableHandle>, state : NullableHandle) -> Void
        {
            let f = Unmanaged<AnyObject>.fromOpaque(cb!).takeUnretainedValue() as! (UnsafeMutablePointer<NullableHandle>, NullableHandle) -> Void;
            f(thrown, state);
        }
        var __thrown : NullableHandle = nil;
        let h = System_Threading_WaitCallback_create(
            &__thrown,
            cbarg,
            nil, // TODO deinit
            __cb
            );
            // TODO check thrown
        if let __ex = __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
            super.init(hndl: h);
        }
    }
    // void Invoke(System.Object)
// docid: M:System.Threading.WaitCallback.Invoke(System.Object)
    public func callAsFunction(state : Optional<dotnet.System.Object>) throws {
        var __thrown : NullableHandle = nil;
        System_Threading_WaitCallback_void__Invoke_0__1__Object(&__thrown, self.get_handle(), state?.get_handle() ?? nil);
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
            return;
        }
    }
} // WaitCallback


// type: System.Threading.WaitOrTimerCallback
    /**
    Represents a method to be called when a  is signaled or times out.

    */
public final class WaitOrTimerCallback
    :
    dotnet.System.Delegate
{
    public class override func get_type_handle() -> TypeHandle {
        return System_Threading_WaitOrTimerCallback_get_type_handle();
    }
    public required init(hndl: NonnullHandle) { super.init(hndl: hndl); }
    public required init(gval: GVal) { super.init(gval: gval); }
    // void Invoke(System.Object, bool)
// docid: M:System.Threading.WaitOrTimerCallback.Invoke(System.Object,System.Boolean)
    public func Invoke(state : Optional<dotnet.System.Object>, timedOut : Bool) throws {
        var __thrown : NullableHandle = nil;
        System_Threading_WaitOrTimerCallback_void__Invoke_0__2__Object_bool(&__thrown, self.get_handle(), state?.get_handle() ?? nil, Swift.Int32(timedOut ? 1 : 0));
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
            return;
        }
    }
    // System.IAsyncResult BeginInvoke(System.Object, bool, System.AsyncCallback, System.Object)
// docid: M:System.Threading.WaitOrTimerCallback.BeginInvoke(System.Object,System.Boolean,System.AsyncCallback,System.Object)
    public func BeginInvoke(state : Optional<dotnet.System.Object>, timedOut : Bool, callback : Optional<dotnet.System.AsyncCallback>, object : Optional<dotnet.System.Object>) throws -> Optional<dotnet.System.IAsyncResult> {
        var __thrown : NullableHandle = nil;
        let __return = System_Threading_WaitOrTimerCallback_IAsyncResult__BeginInvoke_0__4__Object_bool_AsyncCallback_Object(&__thrown, self.get_handle(), state?.get_handle() ?? nil, Swift.Int32(timedOut ? 1 : 0), callback?.get_handle() ?? nil, object?.get_handle() ?? nil);
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        if let __ret_unwrapped = __return {
            return dotnet.System.IAsyncResult(hndl : __ret_unwrapped);
        } else {
            return nil;
        }
        }
    }
    // void EndInvoke(System.IAsyncResult)
// docid: M:System.Threading.WaitOrTimerCallback.EndInvoke(System.IAsyncResult)
    public func EndInvoke(result : Optional<dotnet.System.IAsyncResult>) throws {
        var __thrown : NullableHandle = nil;
        System_Threading_WaitOrTimerCallback_void__EndInvoke_0__1__IAsyncResult(&__thrown, self.get_handle(), result?.get_handle() ?? nil);
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
            return;
        }
    }
    public init(_ callback : @escaping (Optional<dotnet.System.Object>, Bool) throws -> Void) throws
    {
        let __bridge : (UnsafeMutablePointer<NullableHandle>, NullableHandle, Swift.Int32) -> Void =
        {
            (thrown : UnsafeMutablePointer<NullableHandle>, state : NullableHandle, timedOut : Swift.Int32) -> Void in
            do
            {
                thrown.pointee = nil;
                try callback((state != nil) ? (dotnet.System.Object(hndl: state!)) : nil, timedOut != 0);
            }
            catch let e as dotnet.System.Exception
            {
                thrown.pointee = __copy_handle(e.get_handle());
            }
            catch
            {
                let e = try! dotnet.System.Exception(message: "TODO fail inside closure");
                thrown.pointee = __copy_handle(e.get_handle());
            }
        };
        let cbarg = UnsafeRawPointer(Unmanaged.passRetained(__bridge as AnyObject).toOpaque());
        func __cb(cb : UnsafeRawPointer?, thrown : UnsafeMutablePointer<NullableHandle>, state : NullableHandle, timedOut : Swift.Int32) -> Void
        {
            let f = Unmanaged<AnyObject>.fromOpaque(cb!).takeUnretainedValue() as! (UnsafeMutablePointer<NullableHandle>, NullableHandle, Swift.Int32) -> Void;
            f(thrown, state, timedOut);
        }
        var __thrown : NullableHandle = nil;
        let h = System_Threading_WaitOrTimerCallback_create(
            &__thrown,
            cbarg,
            nil, // TODO deinit
            __cb
            );
            // TODO check thrown
        if let __ex = __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
            super.init(hndl: h);
        }
    }
    // void Invoke(System.Object, bool)
// docid: M:System.Threading.WaitOrTimerCallback.Invoke(System.Object,System.Boolean)
    public func callAsFunction(state : Optional<dotnet.System.Object>, timedOut : Bool) throws {
        var __thrown : NullableHandle = nil;
        System_Threading_WaitOrTimerCallback_void__Invoke_0__2__Object_bool(&__thrown, self.get_handle(), state?.get_handle() ?? nil, Swift.Int32(timedOut ? 1 : 0));
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
            return;
        }
    }
} // WaitOrTimerCallback


}


public protocol System_Threading_IThreadPoolWorkItem
    :
    SGBridgeGetHandle
{
}

