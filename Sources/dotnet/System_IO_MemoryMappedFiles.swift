// this file is automatically generated
// Copyright 2021 SourceGear

import jumptable_dotnet;

// Microsoft
// Microsoft.Win32
// Microsoft.Win32.SafeHandles
extension Microsoft.Win32.SafeHandles {
// type: Microsoft.Win32.SafeHandles.SafeMemoryMappedFileHandle
    /**
    Provides a safe handle that represents a memory-mapped file for sequential access.

    */
public final class SafeMemoryMappedFileHandle
    :
    dotnet.Microsoft.Win32.SafeHandles.SafeHandleZeroOrMinusOneIsInvalid
{
    public class override func get_type_handle() -> TypeHandle {
        return Microsoft_Win32_SafeHandles_SafeMemoryMappedFileHandle_get_type_handle();
    }
    public required init(hndl: NonnullHandle) { super.init(hndl: hndl); }
    public required init(gval: GVal) { super.init(gval: gval); }
    // .ctor()
// docid: M:Microsoft.Win32.SafeHandles.SafeMemoryMappedFileHandle.#ctor
    public init() throws {
        var __thrown : NullableHandle = nil;
        let h = Microsoft_Win32_SafeHandles_SafeMemoryMappedFileHandle_ctor_0__0(&__thrown);
        if let __ex = __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
            super.init(hndl: h);
        }
    }
    // [IsSpecialName] bool get_IsInvalid()
// docid: M:Microsoft.Win32.SafeHandles.SafeMemoryMappedFileHandle.get_IsInvalid
    public override func get_IsInvalid() throws -> Bool {
        var __thrown : NullableHandle = nil;
        let __return = Microsoft_Win32_SafeHandles_SafeMemoryMappedFileHandle_bool__get_IsInvalid_0__0(&__thrown, self.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return (__return) != 0;
        }
    }
    /**
    Gets a value that indicates whether the handle is invalid.

    */
    public override var IsInvalid : Bool {
        get {
            return try! get_IsInvalid();
        }
    }
} // SafeMemoryMappedFileHandle


// type: Microsoft.Win32.SafeHandles.SafeMemoryMappedViewHandle
    /**
    Provides a safe handle that represents a view of a block of unmanaged memory for random access.

    */
public final class SafeMemoryMappedViewHandle
    :
    dotnet.System.Runtime.InteropServices.SafeBuffer
{
    public class override func get_type_handle() -> TypeHandle {
        return Microsoft_Win32_SafeHandles_SafeMemoryMappedViewHandle_get_type_handle();
    }
    public required init(hndl: NonnullHandle) { super.init(hndl: hndl); }
    public required init(gval: GVal) { super.init(gval: gval); }
    // .ctor()
// docid: M:Microsoft.Win32.SafeHandles.SafeMemoryMappedViewHandle.#ctor
    public init() throws {
        var __thrown : NullableHandle = nil;
        let h = Microsoft_Win32_SafeHandles_SafeMemoryMappedViewHandle_ctor_0__0(&__thrown);
        if let __ex = __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
            super.init(hndl: h);
        }
    }
} // SafeMemoryMappedViewHandle


}



// System
// System.IO
// System.IO.MemoryMappedFiles
extension System.IO.MemoryMappedFiles {
// type: System.IO.MemoryMappedFiles.MemoryMappedFile
    /**
    Represents a memory-mapped file.

    */
open class MemoryMappedFile
    :
    dotnet.System.Object,
    System_IDisposable
{
    open class override func get_type_handle() -> TypeHandle {
        return System_IO_MemoryMappedFiles_MemoryMappedFile_get_type_handle();
    }
    public required init(hndl: NonnullHandle) { super.init(hndl: hndl); }
    public required init(gval: GVal) { super.init(gval: gval); }
    // System.IO.MemoryMappedFiles.MemoryMappedFile CreateFromFile(System.IO.FileStream, System.String, System.Int64, System.IO.MemoryMappedFiles.MemoryMappedFileAccess, System.IO.HandleInheritability, bool)
// docid: M:System.IO.MemoryMappedFiles.MemoryMappedFile.CreateFromFile(System.IO.FileStream,System.String,System.Int64,System.IO.MemoryMappedFiles.MemoryMappedFileAccess,System.IO.HandleInheritability,System.Boolean)
    /**
    Creates a memory-mapped file from an existing file with the specified access mode, name, inheritability, and capacity.

    - Parameter fileStream: The file stream of the existing file.
    - Parameter mapName: A name to assign to the memory-mapped file, or  for a  that you do not intend to share across processes.
    - Parameter capacity: The maximum size, in bytes, to allocate to the memory-mapped file. Specify 0 to set the capacity to the size of filestream.
    - Parameter access: One of the enumeration values that specifies the type of access allowed to the memory-mapped file.  
  
 This parameter can't be set to .
    - Parameter inheritability: One of the enumeration values that specifies whether a handle to the memory-mapped file can be inherited by a child process. The default is .
    - Parameter leaveOpen: A value that indicates whether to close the source file stream when the  is disposed.
    - Returns: A memory-mapped file that has the specified characteristics.

    */
    open class func CreateFromFile(fileStream : dotnet.System.IO.FileStream, mapName : Optional<dotnet.System.String>, capacity : Swift.Int64, access : dotnet.System.IO.MemoryMappedFiles.MemoryMappedFileAccess, inheritability : dotnet.System.IO.HandleInheritability, leaveOpen : Bool) throws -> dotnet.System.IO.MemoryMappedFiles.MemoryMappedFile {
        var __thrown : NullableHandle = nil;
        let __return = System_IO_MemoryMappedFiles_MemoryMappedFile_MemoryMappedFile__CreateFromFile_0__6__FileStream_String_i64_MemoryMappedFileAccess_HandleInheritability_bool(&__thrown, fileStream.get_handle(), mapName?.get_handle() ?? nil, capacity, access.get_value(), inheritability.get_value(), Swift.Int32(leaveOpen ? 1 : 0));
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return dotnet.System.IO.MemoryMappedFiles.MemoryMappedFile(hndl : __return);
        }
    }
    // System.IO.MemoryMappedFiles.MemoryMappedFile CreateFromFile(System.String)
// docid: M:System.IO.MemoryMappedFiles.MemoryMappedFile.CreateFromFile(System.String)
    /**
    Creates a memory-mapped file from a file on disk.

    - Parameter path: The path to file to map.
    - Returns: A memory-mapped file.

    */
    open class func CreateFromFile(path : dotnet.System.String) throws -> dotnet.System.IO.MemoryMappedFiles.MemoryMappedFile {
        var __thrown : NullableHandle = nil;
        let __return = System_IO_MemoryMappedFiles_MemoryMappedFile_MemoryMappedFile__CreateFromFile_0__1__String(&__thrown, path.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return dotnet.System.IO.MemoryMappedFiles.MemoryMappedFile(hndl : __return);
        }
    }
    // System.IO.MemoryMappedFiles.MemoryMappedFile CreateFromFile(System.String, System.IO.FileMode)
// docid: M:System.IO.MemoryMappedFiles.MemoryMappedFile.CreateFromFile(System.String,System.IO.FileMode)
    /**
    Creates a memory-mapped file that has the specified access mode from a file on disk.

    - Parameter path: The path to the file to map.
    - Parameter mode: Access mode; must be .
    - Returns: A memory-mapped file that has the specified access mode.

    */
    open class func CreateFromFile(path : dotnet.System.String, mode : dotnet.System.IO.FileMode) throws -> dotnet.System.IO.MemoryMappedFiles.MemoryMappedFile {
        var __thrown : NullableHandle = nil;
        let __return = System_IO_MemoryMappedFiles_MemoryMappedFile_MemoryMappedFile__CreateFromFile_0__2__String_FileMode(&__thrown, path.get_handle(), mode.get_value());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return dotnet.System.IO.MemoryMappedFiles.MemoryMappedFile(hndl : __return);
        }
    }
    // System.IO.MemoryMappedFiles.MemoryMappedFile CreateFromFile(System.String, System.IO.FileMode, System.String)
// docid: M:System.IO.MemoryMappedFiles.MemoryMappedFile.CreateFromFile(System.String,System.IO.FileMode,System.String)
    /**
    Creates a memory-mapped file that has the specified access mode and name from a file on disk.

    - Parameter path: The path to the file to map.
    - Parameter mode: Access mode; must be .
    - Parameter mapName: A name to assign to the memory-mapped file, or  for a  that you do not intend to share across processes.
    - Returns: A memory-mapped file that has the specified name and access mode.

    */
    open class func CreateFromFile(path : dotnet.System.String, mode : dotnet.System.IO.FileMode, mapName : Optional<dotnet.System.String>) throws -> dotnet.System.IO.MemoryMappedFiles.MemoryMappedFile {
        var __thrown : NullableHandle = nil;
        let __return = System_IO_MemoryMappedFiles_MemoryMappedFile_MemoryMappedFile__CreateFromFile_0__3__String_FileMode_String(&__thrown, path.get_handle(), mode.get_value(), mapName?.get_handle() ?? nil);
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return dotnet.System.IO.MemoryMappedFiles.MemoryMappedFile(hndl : __return);
        }
    }
    // System.IO.MemoryMappedFiles.MemoryMappedFile CreateFromFile(System.String, System.IO.FileMode, System.String, System.Int64)
// docid: M:System.IO.MemoryMappedFiles.MemoryMappedFile.CreateFromFile(System.String,System.IO.FileMode,System.String,System.Int64)
    /**
    Creates a memory-mapped file that has the specified access mode, name, and capacity from a file on disk.

    - Parameter path: The path to the file to map.
    - Parameter mode: Access mode; can be any of the  enumeration values except .
    - Parameter mapName: A name to assign to the memory-mapped file, or  for a  that you do not intend to share across processes.
    - Parameter capacity: The maximum size, in bytes, to allocate to the memory-mapped file. Specify 0 to set the capacity to the size of the file on disk.
    - Returns: A memory-mapped file that has the specified characteristics.

    */
    open class func CreateFromFile(path : dotnet.System.String, mode : dotnet.System.IO.FileMode, mapName : Optional<dotnet.System.String>, capacity : Swift.Int64) throws -> dotnet.System.IO.MemoryMappedFiles.MemoryMappedFile {
        var __thrown : NullableHandle = nil;
        let __return = System_IO_MemoryMappedFiles_MemoryMappedFile_MemoryMappedFile__CreateFromFile_0__4__String_FileMode_String_i64(&__thrown, path.get_handle(), mode.get_value(), mapName?.get_handle() ?? nil, capacity);
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return dotnet.System.IO.MemoryMappedFiles.MemoryMappedFile(hndl : __return);
        }
    }
    // System.IO.MemoryMappedFiles.MemoryMappedFile CreateFromFile(System.String, System.IO.FileMode, System.String, System.Int64, System.IO.MemoryMappedFiles.MemoryMappedFileAccess)
// docid: M:System.IO.MemoryMappedFiles.MemoryMappedFile.CreateFromFile(System.String,System.IO.FileMode,System.String,System.Int64,System.IO.MemoryMappedFiles.MemoryMappedFileAccess)
    /**
    Creates a memory-mapped file that has the specified access mode, name, capacity, and access type from a file on disk.

    - Parameter path: The path to the file to map.
    - Parameter mode: Access mode; can be any of the  enumeration values except .
    - Parameter mapName: A name to assign to the memory-mapped file, or  for a  that you do not intend to share across processes.
    - Parameter capacity: The maximum size, in bytes, to allocate to the memory-mapped file. Specify 0 to set the capacity to the size of the file on disk.
    - Parameter access: One of the enumeration values that specifies the type of access allowed to the memory-mapped file.
    - Returns: A memory-mapped file that has the specified characteristics.

    */
    open class func CreateFromFile(path : dotnet.System.String, mode : dotnet.System.IO.FileMode, mapName : Optional<dotnet.System.String>, capacity : Swift.Int64, access : dotnet.System.IO.MemoryMappedFiles.MemoryMappedFileAccess) throws -> dotnet.System.IO.MemoryMappedFiles.MemoryMappedFile {
        var __thrown : NullableHandle = nil;
        let __return = System_IO_MemoryMappedFiles_MemoryMappedFile_MemoryMappedFile__CreateFromFile_0__5__String_FileMode_String_i64_MemoryMappedFileAccess(&__thrown, path.get_handle(), mode.get_value(), mapName?.get_handle() ?? nil, capacity, access.get_value());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return dotnet.System.IO.MemoryMappedFiles.MemoryMappedFile(hndl : __return);
        }
    }
    // System.IO.MemoryMappedFiles.MemoryMappedFile CreateNew(System.String, System.Int64)
// docid: M:System.IO.MemoryMappedFiles.MemoryMappedFile.CreateNew(System.String,System.Int64)
    /**
    Creates a memory-mapped file that has the specified capacity in system memory.

    - Parameter mapName: A name to assign to the memory-mapped file, or  for a  that you do not intend to share across processes.
    - Parameter capacity: The maximum size, in bytes, to allocate to the memory-mapped file.
    - Returns: A memory-mapped file that has the specified name and capacity.

    */
    open class func CreateNew(mapName : Optional<dotnet.System.String>, capacity : Swift.Int64) throws -> dotnet.System.IO.MemoryMappedFiles.MemoryMappedFile {
        var __thrown : NullableHandle = nil;
        let __return = System_IO_MemoryMappedFiles_MemoryMappedFile_MemoryMappedFile__CreateNew_0__2__String_i64(&__thrown, mapName?.get_handle() ?? nil, capacity);
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return dotnet.System.IO.MemoryMappedFiles.MemoryMappedFile(hndl : __return);
        }
    }
    // System.IO.MemoryMappedFiles.MemoryMappedFile CreateNew(System.String, System.Int64, System.IO.MemoryMappedFiles.MemoryMappedFileAccess)
// docid: M:System.IO.MemoryMappedFiles.MemoryMappedFile.CreateNew(System.String,System.Int64,System.IO.MemoryMappedFiles.MemoryMappedFileAccess)
    /**
    Creates a memory-mapped file that has the specified capacity and access type in system memory.

    - Parameter mapName: A name to assign to the memory-mapped file, or  for a  that you do not intend to share across processes.
    - Parameter capacity: The maximum size, in bytes, to allocate to the memory-mapped file.
    - Parameter access: One of the enumeration values that specifies the type of access allowed to the memory-mapped file. The default is .
    - Returns: A memory-mapped file that has the specified characteristics.

    */
    open class func CreateNew(mapName : Optional<dotnet.System.String>, capacity : Swift.Int64, access : dotnet.System.IO.MemoryMappedFiles.MemoryMappedFileAccess) throws -> dotnet.System.IO.MemoryMappedFiles.MemoryMappedFile {
        var __thrown : NullableHandle = nil;
        let __return = System_IO_MemoryMappedFiles_MemoryMappedFile_MemoryMappedFile__CreateNew_0__3__String_i64_MemoryMappedFileAccess(&__thrown, mapName?.get_handle() ?? nil, capacity, access.get_value());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return dotnet.System.IO.MemoryMappedFiles.MemoryMappedFile(hndl : __return);
        }
    }
    // System.IO.MemoryMappedFiles.MemoryMappedFile CreateNew(System.String, System.Int64, System.IO.MemoryMappedFiles.MemoryMappedFileAccess, System.IO.MemoryMappedFiles.MemoryMappedFileOptions, System.IO.HandleInheritability)
// docid: M:System.IO.MemoryMappedFiles.MemoryMappedFile.CreateNew(System.String,System.Int64,System.IO.MemoryMappedFiles.MemoryMappedFileAccess,System.IO.MemoryMappedFiles.MemoryMappedFileOptions,System.IO.HandleInheritability)
    /**
    Creates a memory-mapped file that has the specified name, capacity, access type, memory allocation options and inheritability.

    - Parameter mapName: A name to assign to the memory-mapped file, or  for a  that you do not intend to share across processes.
    - Parameter capacity: The maximum size, in bytes, to allocate to the memory-mapped file.
    - Parameter access: One of the enumeration values that specifies the type of access allowed to the memory-mapped file. The default is .
    - Parameter options: A bitwise combination of enumeration values that specifies memory allocation options for the memory-mapped file.
    - Parameter inheritability: A value that specifies whether a handle to the memory-mapped file can be inherited by a child process. The default is .
    - Returns: A memory-mapped file that has the specified characteristics.

    */
    open class func CreateNew(mapName : Optional<dotnet.System.String>, capacity : Swift.Int64, access : dotnet.System.IO.MemoryMappedFiles.MemoryMappedFileAccess, options : dotnet.System.IO.MemoryMappedFiles.MemoryMappedFileOptions, inheritability : dotnet.System.IO.HandleInheritability) throws -> dotnet.System.IO.MemoryMappedFiles.MemoryMappedFile {
        var __thrown : NullableHandle = nil;
        let __return = System_IO_MemoryMappedFiles_MemoryMappedFile_MemoryMappedFile__CreateNew_0__5__String_i64_MemoryMappedFileAccess_MemoryMappedFileOptions_HandleInheritability(&__thrown, mapName?.get_handle() ?? nil, capacity, access.get_value(), options.get_value(), inheritability.get_value());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return dotnet.System.IO.MemoryMappedFiles.MemoryMappedFile(hndl : __return);
        }
    }
    // System.IO.MemoryMappedFiles.MemoryMappedFile CreateOrOpen(System.String, System.Int64)
// docid: M:System.IO.MemoryMappedFiles.MemoryMappedFile.CreateOrOpen(System.String,System.Int64)
    /**
    Creates or opens a memory-mapped file that has the specified name and capacity in system memory.

    - Parameter mapName: The name of the memory-mapped file.
    - Parameter capacity: The maximum size, in bytes, to allocate to the memory-mapped file.
    - Returns: A memory-mapped file that has the specified name and size.

    */
    open class func CreateOrOpen(mapName : dotnet.System.String, capacity : Swift.Int64) throws -> dotnet.System.IO.MemoryMappedFiles.MemoryMappedFile {
        var __thrown : NullableHandle = nil;
        let __return = System_IO_MemoryMappedFiles_MemoryMappedFile_MemoryMappedFile__CreateOrOpen_0__2__String_i64(&__thrown, mapName.get_handle(), capacity);
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return dotnet.System.IO.MemoryMappedFiles.MemoryMappedFile(hndl : __return);
        }
    }
    // System.IO.MemoryMappedFiles.MemoryMappedFile CreateOrOpen(System.String, System.Int64, System.IO.MemoryMappedFiles.MemoryMappedFileAccess)
// docid: M:System.IO.MemoryMappedFiles.MemoryMappedFile.CreateOrOpen(System.String,System.Int64,System.IO.MemoryMappedFiles.MemoryMappedFileAccess)
    /**
    Creates or opens a memory-mapped file that has the specified name, capacity and access type in system memory.

    - Parameter mapName: The name of the memory-mapped file.
    - Parameter capacity: The maximum size, in bytes, to allocate to the memory-mapped file.
    - Parameter access: One of the enumeration values that specifies the type of access allowed to the memory-mapped file. The default is .
    - Returns: A memory-mapped file that has the specified characteristics.

    */
    open class func CreateOrOpen(mapName : dotnet.System.String, capacity : Swift.Int64, access : dotnet.System.IO.MemoryMappedFiles.MemoryMappedFileAccess) throws -> dotnet.System.IO.MemoryMappedFiles.MemoryMappedFile {
        var __thrown : NullableHandle = nil;
        let __return = System_IO_MemoryMappedFiles_MemoryMappedFile_MemoryMappedFile__CreateOrOpen_0__3__String_i64_MemoryMappedFileAccess(&__thrown, mapName.get_handle(), capacity, access.get_value());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return dotnet.System.IO.MemoryMappedFiles.MemoryMappedFile(hndl : __return);
        }
    }
    // System.IO.MemoryMappedFiles.MemoryMappedFile CreateOrOpen(System.String, System.Int64, System.IO.MemoryMappedFiles.MemoryMappedFileAccess, System.IO.MemoryMappedFiles.MemoryMappedFileOptions, System.IO.HandleInheritability)
// docid: M:System.IO.MemoryMappedFiles.MemoryMappedFile.CreateOrOpen(System.String,System.Int64,System.IO.MemoryMappedFiles.MemoryMappedFileAccess,System.IO.MemoryMappedFiles.MemoryMappedFileOptions,System.IO.HandleInheritability)
    /**
    Creates a new empty memory mapped file or opens an existing memory mapped file if one exists with the same name. If opening an existing file, the capacity, options, and memory arguments will be ignored.

    - Parameter mapName: The name of the memory-mapped file.
    - Parameter capacity: The maximum size, in bytes, to allocate to the memory-mapped file.
    - Parameter access: One of the enumeration values that specifies the type of access allowed to the memory-mapped file. The default is .
    - Parameter options: A bitwise combination of values that indicate the memory allocation options to apply to the file.
    - Parameter inheritability: A value that specifies whether a handle to the memory-mapped file can be inherited by a child process. The default is .
    - Returns: A memory-mapped file that has the specified characteristics.

    */
    open class func CreateOrOpen(mapName : dotnet.System.String, capacity : Swift.Int64, access : dotnet.System.IO.MemoryMappedFiles.MemoryMappedFileAccess, options : dotnet.System.IO.MemoryMappedFiles.MemoryMappedFileOptions, inheritability : dotnet.System.IO.HandleInheritability) throws -> dotnet.System.IO.MemoryMappedFiles.MemoryMappedFile {
        var __thrown : NullableHandle = nil;
        let __return = System_IO_MemoryMappedFiles_MemoryMappedFile_MemoryMappedFile__CreateOrOpen_0__5__String_i64_MemoryMappedFileAccess_MemoryMappedFileOptions_HandleInheritability(&__thrown, mapName.get_handle(), capacity, access.get_value(), options.get_value(), inheritability.get_value());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return dotnet.System.IO.MemoryMappedFiles.MemoryMappedFile(hndl : __return);
        }
    }
    // System.IO.MemoryMappedFiles.MemoryMappedViewAccessor CreateViewAccessor()
// docid: M:System.IO.MemoryMappedFiles.MemoryMappedFile.CreateViewAccessor
    /**
    Creates a  that maps to a view of the memory-mapped file.

    - Returns: A randomly accessible block of memory.

    */
    open func CreateViewAccessor() throws -> dotnet.System.IO.MemoryMappedFiles.MemoryMappedViewAccessor {
        var __thrown : NullableHandle = nil;
        let __return = System_IO_MemoryMappedFiles_MemoryMappedFile_MemoryMappedViewAccessor__CreateViewAccessor_0__0(&__thrown, self.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return dotnet.System.IO.MemoryMappedFiles.MemoryMappedViewAccessor(hndl : __return);
        }
    }
    // System.IO.MemoryMappedFiles.MemoryMappedViewAccessor CreateViewAccessor(System.Int64, System.Int64)
// docid: M:System.IO.MemoryMappedFiles.MemoryMappedFile.CreateViewAccessor(System.Int64,System.Int64)
    /**
    Creates a  that maps to a view of the memory-mapped file, and that has the specified offset and size.

    - Parameter offset: The byte at which to start the view.
    - Parameter size: The size of the view. Specify 0 (zero) to create a view that starts at  and ends approximately at the end of the memory-mapped file.
    - Returns: A randomly accessible block of memory.

    */
    open func CreateViewAccessor(offset : Swift.Int64, size : Swift.Int64) throws -> dotnet.System.IO.MemoryMappedFiles.MemoryMappedViewAccessor {
        var __thrown : NullableHandle = nil;
        let __return = System_IO_MemoryMappedFiles_MemoryMappedFile_MemoryMappedViewAccessor__CreateViewAccessor_0__2__i64_i64(&__thrown, self.get_handle(), offset, size);
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return dotnet.System.IO.MemoryMappedFiles.MemoryMappedViewAccessor(hndl : __return);
        }
    }
    // System.IO.MemoryMappedFiles.MemoryMappedViewAccessor CreateViewAccessor(System.Int64, System.Int64, System.IO.MemoryMappedFiles.MemoryMappedFileAccess)
// docid: M:System.IO.MemoryMappedFiles.MemoryMappedFile.CreateViewAccessor(System.Int64,System.Int64,System.IO.MemoryMappedFiles.MemoryMappedFileAccess)
    /**
    Creates a  that maps to a view of the memory-mapped file, and that has the specified offset, size, and access restrictions.

    - Parameter offset: The byte at which to start the view.
    - Parameter size: The size of the view. Specify 0 (zero) to create a view that starts at  and ends approximately at the end of the memory-mapped file.
    - Parameter access: One of the enumeration values that specifies the type of access allowed to the memory-mapped file. The default is .
    - Returns: A randomly accessible block of memory.

    */
    open func CreateViewAccessor(offset : Swift.Int64, size : Swift.Int64, access : dotnet.System.IO.MemoryMappedFiles.MemoryMappedFileAccess) throws -> dotnet.System.IO.MemoryMappedFiles.MemoryMappedViewAccessor {
        var __thrown : NullableHandle = nil;
        let __return = System_IO_MemoryMappedFiles_MemoryMappedFile_MemoryMappedViewAccessor__CreateViewAccessor_0__3__i64_i64_MemoryMappedFileAccess(&__thrown, self.get_handle(), offset, size, access.get_value());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return dotnet.System.IO.MemoryMappedFiles.MemoryMappedViewAccessor(hndl : __return);
        }
    }
    // System.IO.MemoryMappedFiles.MemoryMappedViewStream CreateViewStream()
// docid: M:System.IO.MemoryMappedFiles.MemoryMappedFile.CreateViewStream
    /**
    Creates a stream that maps to a view of the memory-mapped file.

    - Returns: A stream of memory.

    */
    open func CreateViewStream() throws -> dotnet.System.IO.MemoryMappedFiles.MemoryMappedViewStream {
        var __thrown : NullableHandle = nil;
        let __return = System_IO_MemoryMappedFiles_MemoryMappedFile_MemoryMappedViewStream__CreateViewStream_0__0(&__thrown, self.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return dotnet.System.IO.MemoryMappedFiles.MemoryMappedViewStream(hndl : __return);
        }
    }
    // System.IO.MemoryMappedFiles.MemoryMappedViewStream CreateViewStream(System.Int64, System.Int64)
// docid: M:System.IO.MemoryMappedFiles.MemoryMappedFile.CreateViewStream(System.Int64,System.Int64)
    /**
    Creates a stream that maps to a view of the memory-mapped file, and that has the specified offset and size.

    - Parameter offset: The byte at which to start the view.
    - Parameter size: The size of the view. Specify 0 (zero) to create a view that starts at  and ends approximately at the end of the memory-mapped file.
    - Returns: A stream of memory that has the specified offset and size.

    */
    open func CreateViewStream(offset : Swift.Int64, size : Swift.Int64) throws -> dotnet.System.IO.MemoryMappedFiles.MemoryMappedViewStream {
        var __thrown : NullableHandle = nil;
        let __return = System_IO_MemoryMappedFiles_MemoryMappedFile_MemoryMappedViewStream__CreateViewStream_0__2__i64_i64(&__thrown, self.get_handle(), offset, size);
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return dotnet.System.IO.MemoryMappedFiles.MemoryMappedViewStream(hndl : __return);
        }
    }
    // System.IO.MemoryMappedFiles.MemoryMappedViewStream CreateViewStream(System.Int64, System.Int64, System.IO.MemoryMappedFiles.MemoryMappedFileAccess)
// docid: M:System.IO.MemoryMappedFiles.MemoryMappedFile.CreateViewStream(System.Int64,System.Int64,System.IO.MemoryMappedFiles.MemoryMappedFileAccess)
    /**
    Creates a stream that maps to a view of the memory-mapped file, and that has the specified offset, size, and access type.

    - Parameter offset: The byte at which to start the view.
    - Parameter size: The size of the view. Specify 0 (zero) to create a view that starts at  and ends approximately at the end of the memory-mapped file.
    - Parameter access: One of the enumeration values that specifies the type of access allowed to the memory-mapped file. The default is .
    - Returns: A stream of memory that has the specified characteristics.

    */
    open func CreateViewStream(offset : Swift.Int64, size : Swift.Int64, access : dotnet.System.IO.MemoryMappedFiles.MemoryMappedFileAccess) throws -> dotnet.System.IO.MemoryMappedFiles.MemoryMappedViewStream {
        var __thrown : NullableHandle = nil;
        let __return = System_IO_MemoryMappedFiles_MemoryMappedFile_MemoryMappedViewStream__CreateViewStream_0__3__i64_i64_MemoryMappedFileAccess(&__thrown, self.get_handle(), offset, size, access.get_value());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return dotnet.System.IO.MemoryMappedFiles.MemoryMappedViewStream(hndl : __return);
        }
    }
    // void Dispose()
// docid: M:System.IO.MemoryMappedFiles.MemoryMappedFile.Dispose
    /**
    Releases all resources used by the .

    */
    open /* method final */ func Dispose() throws {
        var __thrown : NullableHandle = nil;
        System_IO_MemoryMappedFiles_MemoryMappedFile_void__Dispose_0__0(&__thrown, self.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
            return;
        }
    }
    // System.IO.MemoryMappedFiles.MemoryMappedFile OpenExisting(System.String)
// docid: M:System.IO.MemoryMappedFiles.MemoryMappedFile.OpenExisting(System.String)
    /**
    Opens an existing memory-mapped file that has the specified name in system memory.

    - Parameter mapName: The name of the memory-mapped file.
    - Returns: A memory-mapped file that has the specified name.

    */
    open class func OpenExisting(mapName : dotnet.System.String) throws -> dotnet.System.IO.MemoryMappedFiles.MemoryMappedFile {
        var __thrown : NullableHandle = nil;
        let __return = System_IO_MemoryMappedFiles_MemoryMappedFile_MemoryMappedFile__OpenExisting_0__1__String(&__thrown, mapName.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return dotnet.System.IO.MemoryMappedFiles.MemoryMappedFile(hndl : __return);
        }
    }
    // System.IO.MemoryMappedFiles.MemoryMappedFile OpenExisting(System.String, System.IO.MemoryMappedFiles.MemoryMappedFileRights)
// docid: M:System.IO.MemoryMappedFiles.MemoryMappedFile.OpenExisting(System.String,System.IO.MemoryMappedFiles.MemoryMappedFileRights)
    /**
    Opens an existing memory-mapped file that has the specified name and access rights in system memory.

    - Parameter mapName: The name of the memory-mapped file to open.
    - Parameter desiredAccessRights: One of the enumeration values that specifies the access rights to apply to the memory-mapped file.
    - Returns: A memory-mapped file that has the specified characteristics.

    */
    open class func OpenExisting(mapName : dotnet.System.String, desiredAccessRights : dotnet.System.IO.MemoryMappedFiles.MemoryMappedFileRights) throws -> dotnet.System.IO.MemoryMappedFiles.MemoryMappedFile {
        var __thrown : NullableHandle = nil;
        let __return = System_IO_MemoryMappedFiles_MemoryMappedFile_MemoryMappedFile__OpenExisting_0__2__String_MemoryMappedFileRights(&__thrown, mapName.get_handle(), desiredAccessRights.get_value());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return dotnet.System.IO.MemoryMappedFiles.MemoryMappedFile(hndl : __return);
        }
    }
    // System.IO.MemoryMappedFiles.MemoryMappedFile OpenExisting(System.String, System.IO.MemoryMappedFiles.MemoryMappedFileRights, System.IO.HandleInheritability)
// docid: M:System.IO.MemoryMappedFiles.MemoryMappedFile.OpenExisting(System.String,System.IO.MemoryMappedFiles.MemoryMappedFileRights,System.IO.HandleInheritability)
    /**
    Opens an existing memory-mapped file that has the specified name, access rights, and inheritability in system memory.

    - Parameter mapName: The name of the memory-mapped file to open.
    - Parameter desiredAccessRights: One of the enumeration values that specifies the access rights to apply to the memory-mapped file.
    - Parameter inheritability: One of the enumeration values that specifies whether a handle to the memory-mapped file can be inherited by a child process. The default is .
    - Returns: A memory-mapped file that has the specified characteristics.

    */
    open class func OpenExisting(mapName : dotnet.System.String, desiredAccessRights : dotnet.System.IO.MemoryMappedFiles.MemoryMappedFileRights, inheritability : dotnet.System.IO.HandleInheritability) throws -> dotnet.System.IO.MemoryMappedFiles.MemoryMappedFile {
        var __thrown : NullableHandle = nil;
        let __return = System_IO_MemoryMappedFiles_MemoryMappedFile_MemoryMappedFile__OpenExisting_0__3__String_MemoryMappedFileRights_HandleInheritability(&__thrown, mapName.get_handle(), desiredAccessRights.get_value(), inheritability.get_value());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return dotnet.System.IO.MemoryMappedFiles.MemoryMappedFile(hndl : __return);
        }
    }
    // [IsSpecialName] Microsoft.Win32.SafeHandles.SafeMemoryMappedFileHandle get_SafeMemoryMappedFileHandle()
// docid: M:System.IO.MemoryMappedFiles.MemoryMappedFile.get_SafeMemoryMappedFileHandle
    open func get_SafeMemoryMappedFileHandle() throws -> dotnet.Microsoft.Win32.SafeHandles.SafeMemoryMappedFileHandle {
        var __thrown : NullableHandle = nil;
        let __return = System_IO_MemoryMappedFiles_MemoryMappedFile_SafeMemoryMappedFileHandle__get_SafeMemoryMappedFileHandle_0__0(&__thrown, self.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return dotnet.Microsoft.Win32.SafeHandles.SafeMemoryMappedFileHandle(hndl : __return);
        }
    }
    /**
    Gets the file handle of a memory-mapped file.

    */
    open var SafeMemoryMappedFileHandle : dotnet.Microsoft.Win32.SafeHandles.SafeMemoryMappedFileHandle {
        get {
            return try! get_SafeMemoryMappedFileHandle();
        }
    }
} // MemoryMappedFile


// type: System.IO.MemoryMappedFiles.MemoryMappedFileAccess
    /**
    Specifies access capabilities and restrictions for a memory-mapped file or view.

    */
public struct MemoryMappedFileAccess : SGBridgeGenericValue {
    let v : Swift.Int32;
    public init(val: Swift.Int32) { self.v = val; }
    public func get_value() -> Swift.Int32 { return self.v; }
    public static func get_type_handle() -> TypeHandle {
        return System_IO_MemoryMappedFiles_MemoryMappedFileAccess_get_type_handle();
    }
    public func to_gval() -> GVal { return GVal(self.v); }
    public func dup_gval() -> GVal { return to_gval(); }
    public init(gval: GVal) { self.v = Swift.Int32(gval); }
    // static field: System.IO.MemoryMappedFiles.MemoryMappedFileAccess ReadWrite
    /**
    Read and write access to the file.

    */
    public static var ReadWrite : dotnet.System.IO.MemoryMappedFiles.MemoryMappedFileAccess {
        get {
        let __return = dotnet.System.IO.MemoryMappedFiles.MemoryMappedFileAccess(val: System_IO_MemoryMappedFiles_MemoryMappedFileAccess_get_ReadWrite());
            return __return;
        }
    }
    // static field: System.IO.MemoryMappedFiles.MemoryMappedFileAccess Read
    /**
    Read-only access to the file.

    */
    public static var Read : dotnet.System.IO.MemoryMappedFiles.MemoryMappedFileAccess {
        get {
        let __return = dotnet.System.IO.MemoryMappedFiles.MemoryMappedFileAccess(val: System_IO_MemoryMappedFiles_MemoryMappedFileAccess_get_Read());
            return __return;
        }
    }
    // static field: System.IO.MemoryMappedFiles.MemoryMappedFileAccess Write
    /**
    Write-only access to file.

    */
    public static var Write : dotnet.System.IO.MemoryMappedFiles.MemoryMappedFileAccess {
        get {
        let __return = dotnet.System.IO.MemoryMappedFiles.MemoryMappedFileAccess(val: System_IO_MemoryMappedFiles_MemoryMappedFileAccess_get_Write());
            return __return;
        }
    }
    // static field: System.IO.MemoryMappedFiles.MemoryMappedFileAccess CopyOnWrite
    /**
    Read and write access to the file, with the restriction that any write operations will not be seen by other processes.

    */
    public static var CopyOnWrite : dotnet.System.IO.MemoryMappedFiles.MemoryMappedFileAccess {
        get {
        let __return = dotnet.System.IO.MemoryMappedFiles.MemoryMappedFileAccess(val: System_IO_MemoryMappedFiles_MemoryMappedFileAccess_get_CopyOnWrite());
            return __return;
        }
    }
    // static field: System.IO.MemoryMappedFiles.MemoryMappedFileAccess ReadExecute
    /**
    Read access to the file that can store and run executable code.

    */
    public static var ReadExecute : dotnet.System.IO.MemoryMappedFiles.MemoryMappedFileAccess {
        get {
        let __return = dotnet.System.IO.MemoryMappedFiles.MemoryMappedFileAccess(val: System_IO_MemoryMappedFiles_MemoryMappedFileAccess_get_ReadExecute());
            return __return;
        }
    }
    // static field: System.IO.MemoryMappedFiles.MemoryMappedFileAccess ReadWriteExecute
    /**
    Read and write access to the file that can store and run executable code.

    */
    public static var ReadWriteExecute : dotnet.System.IO.MemoryMappedFiles.MemoryMappedFileAccess {
        get {
        let __return = dotnet.System.IO.MemoryMappedFiles.MemoryMappedFileAccess(val: System_IO_MemoryMappedFiles_MemoryMappedFileAccess_get_ReadWriteExecute());
            return __return;
        }
    }
} // MemoryMappedFileAccess


// type: System.IO.MemoryMappedFiles.MemoryMappedFileOptions
    /**
    Provides memory allocation options for memory-mapped files.

    */
public struct MemoryMappedFileOptions : SGBridgeGenericValue {
    let v : Swift.Int32;
    public init(val: Swift.Int32) { self.v = val; }
    public func get_value() -> Swift.Int32 { return self.v; }
    public static func get_type_handle() -> TypeHandle {
        return System_IO_MemoryMappedFiles_MemoryMappedFileOptions_get_type_handle();
    }
    public func to_gval() -> GVal { return GVal(self.v); }
    public func dup_gval() -> GVal { return to_gval(); }
    public init(gval: GVal) { self.v = Swift.Int32(gval); }
    // static field: System.IO.MemoryMappedFiles.MemoryMappedFileOptions None
    /**
    No memory allocation options are applied.

    */
    public static var None : dotnet.System.IO.MemoryMappedFiles.MemoryMappedFileOptions {
        get {
        let __return = dotnet.System.IO.MemoryMappedFiles.MemoryMappedFileOptions(val: System_IO_MemoryMappedFiles_MemoryMappedFileOptions_get_None());
            return __return;
        }
    }
    // static field: System.IO.MemoryMappedFiles.MemoryMappedFileOptions DelayAllocatePages
    /**
    Memory allocation is delayed until a view is created with either the  or  method.

    */
    public static var DelayAllocatePages : dotnet.System.IO.MemoryMappedFiles.MemoryMappedFileOptions {
        get {
        let __return = dotnet.System.IO.MemoryMappedFiles.MemoryMappedFileOptions(val: System_IO_MemoryMappedFiles_MemoryMappedFileOptions_get_DelayAllocatePages());
            return __return;
        }
    }
} // MemoryMappedFileOptions


// type: System.IO.MemoryMappedFiles.MemoryMappedFileRights
    /**
    Specifies access rights to a memory-mapped file that is not associated with a file on disk.

    */
public struct MemoryMappedFileRights : SGBridgeGenericValue {
    let v : Swift.Int32;
    public init(val: Swift.Int32) { self.v = val; }
    public func get_value() -> Swift.Int32 { return self.v; }
    public static func get_type_handle() -> TypeHandle {
        return System_IO_MemoryMappedFiles_MemoryMappedFileRights_get_type_handle();
    }
    public func to_gval() -> GVal { return GVal(self.v); }
    public func dup_gval() -> GVal { return to_gval(); }
    public init(gval: GVal) { self.v = Swift.Int32(gval); }
    // static field: System.IO.MemoryMappedFiles.MemoryMappedFileRights CopyOnWrite
    /**
    The right to read and write to a file with the restriction that write operations will not be seen by other processes.

    */
    public static var CopyOnWrite : dotnet.System.IO.MemoryMappedFiles.MemoryMappedFileRights {
        get {
        let __return = dotnet.System.IO.MemoryMappedFiles.MemoryMappedFileRights(val: System_IO_MemoryMappedFiles_MemoryMappedFileRights_get_CopyOnWrite());
            return __return;
        }
    }
    // static field: System.IO.MemoryMappedFiles.MemoryMappedFileRights Write
    /**
    The right to add data to a file or remove data from a file.

    */
    public static var Write : dotnet.System.IO.MemoryMappedFiles.MemoryMappedFileRights {
        get {
        let __return = dotnet.System.IO.MemoryMappedFiles.MemoryMappedFileRights(val: System_IO_MemoryMappedFiles_MemoryMappedFileRights_get_Write());
            return __return;
        }
    }
    // static field: System.IO.MemoryMappedFiles.MemoryMappedFileRights Read
    /**
    The right to open and copy a file as read-only.

    */
    public static var Read : dotnet.System.IO.MemoryMappedFiles.MemoryMappedFileRights {
        get {
        let __return = dotnet.System.IO.MemoryMappedFiles.MemoryMappedFileRights(val: System_IO_MemoryMappedFiles_MemoryMappedFileRights_get_Read());
            return __return;
        }
    }
    // static field: System.IO.MemoryMappedFiles.MemoryMappedFileRights ReadWrite
    /**
    The right to open and copy a file, and the right to add data to a file or remove data from a file.

    */
    public static var ReadWrite : dotnet.System.IO.MemoryMappedFiles.MemoryMappedFileRights {
        get {
        let __return = dotnet.System.IO.MemoryMappedFiles.MemoryMappedFileRights(val: System_IO_MemoryMappedFiles_MemoryMappedFileRights_get_ReadWrite());
            return __return;
        }
    }
    // static field: System.IO.MemoryMappedFiles.MemoryMappedFileRights Execute
    /**
    The right to run an application file.

    */
    public static var Execute : dotnet.System.IO.MemoryMappedFiles.MemoryMappedFileRights {
        get {
        let __return = dotnet.System.IO.MemoryMappedFiles.MemoryMappedFileRights(val: System_IO_MemoryMappedFiles_MemoryMappedFileRights_get_Execute());
            return __return;
        }
    }
    // static field: System.IO.MemoryMappedFiles.MemoryMappedFileRights ReadExecute
    /**
    The right to open and copy a folder or file as read-only, and to run application files. This right includes the  right and the  right.

    */
    public static var ReadExecute : dotnet.System.IO.MemoryMappedFiles.MemoryMappedFileRights {
        get {
        let __return = dotnet.System.IO.MemoryMappedFiles.MemoryMappedFileRights(val: System_IO_MemoryMappedFiles_MemoryMappedFileRights_get_ReadExecute());
            return __return;
        }
    }
    // static field: System.IO.MemoryMappedFiles.MemoryMappedFileRights ReadWriteExecute
    /**
    The right to open and copy a file, the right to add data to a file or remove data from a file, and the right to run an application file.

    */
    public static var ReadWriteExecute : dotnet.System.IO.MemoryMappedFiles.MemoryMappedFileRights {
        get {
        let __return = dotnet.System.IO.MemoryMappedFiles.MemoryMappedFileRights(val: System_IO_MemoryMappedFiles_MemoryMappedFileRights_get_ReadWriteExecute());
            return __return;
        }
    }
    // static field: System.IO.MemoryMappedFiles.MemoryMappedFileRights Delete
    /**
    The right to delete a file.

    */
    public static var Delete : dotnet.System.IO.MemoryMappedFiles.MemoryMappedFileRights {
        get {
        let __return = dotnet.System.IO.MemoryMappedFiles.MemoryMappedFileRights(val: System_IO_MemoryMappedFiles_MemoryMappedFileRights_get_Delete());
            return __return;
        }
    }
    // static field: System.IO.MemoryMappedFiles.MemoryMappedFileRights ReadPermissions
    /**
    The right to open and copy access and audit rules from a file. This does not include the right to read data, file system attributes, or extended file system attributes.

    */
    public static var ReadPermissions : dotnet.System.IO.MemoryMappedFiles.MemoryMappedFileRights {
        get {
        let __return = dotnet.System.IO.MemoryMappedFiles.MemoryMappedFileRights(val: System_IO_MemoryMappedFiles_MemoryMappedFileRights_get_ReadPermissions());
            return __return;
        }
    }
    // static field: System.IO.MemoryMappedFiles.MemoryMappedFileRights ChangePermissions
    /**
    The right to change the security and audit rules associated with a file.

    */
    public static var ChangePermissions : dotnet.System.IO.MemoryMappedFiles.MemoryMappedFileRights {
        get {
        let __return = dotnet.System.IO.MemoryMappedFiles.MemoryMappedFileRights(val: System_IO_MemoryMappedFiles_MemoryMappedFileRights_get_ChangePermissions());
            return __return;
        }
    }
    // static field: System.IO.MemoryMappedFiles.MemoryMappedFileRights TakeOwnership
    /**
    The right to change the owner of a file.

    */
    public static var TakeOwnership : dotnet.System.IO.MemoryMappedFiles.MemoryMappedFileRights {
        get {
        let __return = dotnet.System.IO.MemoryMappedFiles.MemoryMappedFileRights(val: System_IO_MemoryMappedFiles_MemoryMappedFileRights_get_TakeOwnership());
            return __return;
        }
    }
    // static field: System.IO.MemoryMappedFiles.MemoryMappedFileRights FullControl
    /**
    The right to exert full control over a file, and to modify access control and audit rules. This value represents the right to do anything with a file and is the combination of all rights in this enumeration.

    */
    public static var FullControl : dotnet.System.IO.MemoryMappedFiles.MemoryMappedFileRights {
        get {
        let __return = dotnet.System.IO.MemoryMappedFiles.MemoryMappedFileRights(val: System_IO_MemoryMappedFiles_MemoryMappedFileRights_get_FullControl());
            return __return;
        }
    }
    // static field: System.IO.MemoryMappedFiles.MemoryMappedFileRights AccessSystemSecurity
    /**
    The right to get or set permissions on a file.

    */
    public static var AccessSystemSecurity : dotnet.System.IO.MemoryMappedFiles.MemoryMappedFileRights {
        get {
        let __return = dotnet.System.IO.MemoryMappedFiles.MemoryMappedFileRights(val: System_IO_MemoryMappedFiles_MemoryMappedFileRights_get_AccessSystemSecurity());
            return __return;
        }
    }
} // MemoryMappedFileRights


// type: System.IO.MemoryMappedFiles.MemoryMappedViewAccessor
    /**
    Represents a randomly accessed view of a memory-mapped file.

    */
public final class MemoryMappedViewAccessor
    :
    dotnet.System.IO.UnmanagedMemoryAccessor
{
    public class override func get_type_handle() -> TypeHandle {
        return System_IO_MemoryMappedFiles_MemoryMappedViewAccessor_get_type_handle();
    }
    public required init(hndl: NonnullHandle) { super.init(hndl: hndl); }
    public required init(gval: GVal) { super.init(gval: gval); }
    // void Flush()
// docid: M:System.IO.MemoryMappedFiles.MemoryMappedViewAccessor.Flush
    /**
    Clears all buffers for this view and causes any buffered data to be written to the underlying file.

    */
    public func Flush() throws {
        var __thrown : NullableHandle = nil;
        System_IO_MemoryMappedFiles_MemoryMappedViewAccessor_void__Flush_0__0(&__thrown, self.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
            return;
        }
    }
    // [IsSpecialName] System.Int64 get_PointerOffset()
// docid: M:System.IO.MemoryMappedFiles.MemoryMappedViewAccessor.get_PointerOffset
    public func get_PointerOffset() throws -> Swift.Int64 {
        var __thrown : NullableHandle = nil;
        let __return = System_IO_MemoryMappedFiles_MemoryMappedViewAccessor_i64__get_PointerOffset_0__0(&__thrown, self.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return __return;
        }
    }
    // [IsSpecialName] Microsoft.Win32.SafeHandles.SafeMemoryMappedViewHandle get_SafeMemoryMappedViewHandle()
// docid: M:System.IO.MemoryMappedFiles.MemoryMappedViewAccessor.get_SafeMemoryMappedViewHandle
    public func get_SafeMemoryMappedViewHandle() throws -> dotnet.Microsoft.Win32.SafeHandles.SafeMemoryMappedViewHandle {
        var __thrown : NullableHandle = nil;
        let __return = System_IO_MemoryMappedFiles_MemoryMappedViewAccessor_SafeMemoryMappedViewHandle__get_SafeMemoryMappedViewHandle_0__0(&__thrown, self.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return dotnet.Microsoft.Win32.SafeHandles.SafeMemoryMappedViewHandle(hndl : __return);
        }
    }
    /**
    Gets the number of bytes by which the starting position of this view is offset from the beginning of the memory-mapped file.

    */
    public var PointerOffset : Swift.Int64 {
        get {
            return try! get_PointerOffset();
        }
    }
    /**
    Gets a handle to the view of a memory-mapped file.

    */
    public var SafeMemoryMappedViewHandle : dotnet.Microsoft.Win32.SafeHandles.SafeMemoryMappedViewHandle {
        get {
            return try! get_SafeMemoryMappedViewHandle();
        }
    }
} // MemoryMappedViewAccessor


// type: System.IO.MemoryMappedFiles.MemoryMappedViewStream
    /**
    Represents a view of a memory-mapped file as a sequentially accessed stream.

    */
public final class MemoryMappedViewStream
    :
    dotnet.System.IO.UnmanagedMemoryStream
{
    public class override func get_type_handle() -> TypeHandle {
        return System_IO_MemoryMappedFiles_MemoryMappedViewStream_get_type_handle();
    }
    public required init(hndl: NonnullHandle) { super.init(hndl: hndl); }
    public required init(gval: GVal) { super.init(gval: gval); }
    // void Flush()
// docid: M:System.IO.MemoryMappedFiles.MemoryMappedViewStream.Flush
    /**
    Clears all buffers for this stream and causes any buffered data to be written to the underlying file.

    */
    public override func Flush() throws {
        var __thrown : NullableHandle = nil;
        System_IO_MemoryMappedFiles_MemoryMappedViewStream_void__Flush_0__0(&__thrown, self.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
            return;
        }
    }
    // void SetLength(System.Int64)
// docid: M:System.IO.MemoryMappedFiles.MemoryMappedViewStream.SetLength(System.Int64)
    /**
    Sets the length of the current stream.

    - Parameter value: The desired length of the current stream in bytes.
    */
    public override func SetLength(value : Swift.Int64) throws {
        var __thrown : NullableHandle = nil;
        System_IO_MemoryMappedFiles_MemoryMappedViewStream_void__SetLength_0__1__i64(&__thrown, self.get_handle(), value);
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
            return;
        }
    }
    // [IsSpecialName] System.Int64 get_PointerOffset()
// docid: M:System.IO.MemoryMappedFiles.MemoryMappedViewStream.get_PointerOffset
    public func get_PointerOffset() throws -> Swift.Int64 {
        var __thrown : NullableHandle = nil;
        let __return = System_IO_MemoryMappedFiles_MemoryMappedViewStream_i64__get_PointerOffset_0__0(&__thrown, self.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return __return;
        }
    }
    // [IsSpecialName] Microsoft.Win32.SafeHandles.SafeMemoryMappedViewHandle get_SafeMemoryMappedViewHandle()
// docid: M:System.IO.MemoryMappedFiles.MemoryMappedViewStream.get_SafeMemoryMappedViewHandle
    public func get_SafeMemoryMappedViewHandle() throws -> dotnet.Microsoft.Win32.SafeHandles.SafeMemoryMappedViewHandle {
        var __thrown : NullableHandle = nil;
        let __return = System_IO_MemoryMappedFiles_MemoryMappedViewStream_SafeMemoryMappedViewHandle__get_SafeMemoryMappedViewHandle_0__0(&__thrown, self.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return dotnet.Microsoft.Win32.SafeHandles.SafeMemoryMappedViewHandle(hndl : __return);
        }
    }
    /**
    Gets the number of bytes by which the starting position of this view is offset from the beginning of the memory-mapped file.

    */
    public var PointerOffset : Swift.Int64 {
        get {
            return try! get_PointerOffset();
        }
    }
    /**
    Gets a handle to the view of a memory-mapped file.

    */
    public var SafeMemoryMappedViewHandle : dotnet.Microsoft.Win32.SafeHandles.SafeMemoryMappedViewHandle {
        get {
            return try! get_SafeMemoryMappedViewHandle();
        }
    }
} // MemoryMappedViewStream


}



