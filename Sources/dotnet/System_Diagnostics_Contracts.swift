// this file is automatically generated
// Copyright 2021 SourceGear

import jumptable_dotnet;

// System
// System.Diagnostics
// System.Diagnostics.Contracts
extension System.Diagnostics.Contracts {
// type: System.Diagnostics.Contracts.Contract
public struct Contract {
    // void Assert(bool)
// docid: M:System.Diagnostics.Contracts.Contract.Assert(System.Boolean)
    /**
    Checks for a condition; if the condition is , follows the escalation policy set for the analyzer.

    - Parameter condition: The conditional expression to test.
    */
    public static func Assert(condition : Bool) throws {
        var __thrown : NullableHandle = nil;
        System_Diagnostics_Contracts_Contract_void__Assert_0__1__bool(&__thrown, Swift.Int32(condition ? 1 : 0));
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
            return;
        }
    }
    // void Assert(bool, System.String)
// docid: M:System.Diagnostics.Contracts.Contract.Assert(System.Boolean,System.String)
    /**
    Checks for a condition; if the condition is , follows the escalation policy set by the analyzer and displays the specified message.

    - Parameter condition: The conditional expression to test.
    - Parameter userMessage: A message to display if the condition is not met.
    */
    public static func Assert(condition : Bool, userMessage : Optional<dotnet.System.String>) throws {
        var __thrown : NullableHandle = nil;
        System_Diagnostics_Contracts_Contract_void__Assert_0__2__bool_String(&__thrown, Swift.Int32(condition ? 1 : 0), userMessage?.get_handle() ?? nil);
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
            return;
        }
    }
    // void Assume(bool)
// docid: M:System.Diagnostics.Contracts.Contract.Assume(System.Boolean)
    /**
    Instructs code analysis tools to assume that the specified condition is , even if it cannot be statically proven to always be .

    - Parameter condition: The conditional expression to assume .
    */
    public static func Assume(condition : Bool) throws {
        var __thrown : NullableHandle = nil;
        System_Diagnostics_Contracts_Contract_void__Assume_0__1__bool(&__thrown, Swift.Int32(condition ? 1 : 0));
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
            return;
        }
    }
    // void Assume(bool, System.String)
// docid: M:System.Diagnostics.Contracts.Contract.Assume(System.Boolean,System.String)
    /**
    Instructs code analysis tools to assume that a condition is , even if it cannot be statically proven to always be , and displays a message if the assumption fails.

    - Parameter condition: The conditional expression to assume .
    - Parameter userMessage: The message to post if the assumption fails.
    */
    public static func Assume(condition : Bool, userMessage : Optional<dotnet.System.String>) throws {
        var __thrown : NullableHandle = nil;
        System_Diagnostics_Contracts_Contract_void__Assume_0__2__bool_String(&__thrown, Swift.Int32(condition ? 1 : 0), userMessage?.get_handle() ?? nil);
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
            return;
        }
    }
    // void EndContractBlock()
// docid: M:System.Diagnostics.Contracts.Contract.EndContractBlock
    /**
    Marks the end of the contract section when a method's contracts contain only preconditions in the -- form.

    */
    public static func EndContractBlock() throws {
        var __thrown : NullableHandle = nil;
        System_Diagnostics_Contracts_Contract_void__EndContractBlock_0__0(&__thrown);
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
            return;
        }
    }
    // void Ensures(bool)
// docid: M:System.Diagnostics.Contracts.Contract.Ensures(System.Boolean)
    /**
    Specifies a postcondition contract for the enclosing method or property.

    - Parameter condition: The conditional expression to test. The expression may include , , and  values.
    */
    public static func Ensures(condition : Bool) throws {
        var __thrown : NullableHandle = nil;
        System_Diagnostics_Contracts_Contract_void__Ensures_0__1__bool(&__thrown, Swift.Int32(condition ? 1 : 0));
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
            return;
        }
    }
    // void Ensures(bool, System.String)
// docid: M:System.Diagnostics.Contracts.Contract.Ensures(System.Boolean,System.String)
    /**
    Specifies a postcondition contract for a provided exit condition and a message to display if the condition is .

    - Parameter condition: The conditional expression to test. The expression may include  and  values.
    - Parameter userMessage: The message to display if the expression is not .
    */
    public static func Ensures(condition : Bool, userMessage : Optional<dotnet.System.String>) throws {
        var __thrown : NullableHandle = nil;
        System_Diagnostics_Contracts_Contract_void__Ensures_0__2__bool_String(&__thrown, Swift.Int32(condition ? 1 : 0), userMessage?.get_handle() ?? nil);
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
            return;
        }
    }
// TODO COPE (write_all_methods) (unused generic param) void EnsuresOnThrow<TException>(bool)
// TODO COPE (write_all_methods) (unused generic param) void EnsuresOnThrow<TException>(bool, System.String)
    // bool Exists(System.Int32, System.Int32, System.Predicate<System.Int32>)
// docid: M:System.Diagnostics.Contracts.Contract.Exists(System.Int32,System.Int32,System.Predicate{System.Int32})
    /**
    Determines whether a specified test is true for any integer within a range of integers.

    - Parameter fromInclusive: The first integer to pass to .
    - Parameter toExclusive: One more than the last integer to pass to .
    - Parameter predicate: The function to evaluate for any value of the integer in the specified range.
    - Returns: 
         if  returns  for any integer starting from  to  - 1.

    */
    public static func Exists(fromInclusive : Swift.Int32, toExclusive : Swift.Int32, predicate : dotnet.System.Predicate_1<Swift.Int32>) throws -> Bool {
        var __thrown : NullableHandle = nil;
        let __return = System_Diagnostics_Contracts_Contract_bool__Exists_0__3__i32_i32_System_Predicate_i32_(&__thrown, fromInclusive, toExclusive, predicate.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return (__return) != 0;
        }
    }
    // delegate closure overload
    public static func Exists(fromInclusive : Swift.Int32, toExclusive : Swift.Int32, predicate : @escaping (Swift.Int32) throws -> Bool) throws -> Bool {
        let del_predicate = try dotnet.System.Predicate_1<Swift.Int32>(predicate);
        return try Exists(fromInclusive: fromInclusive, toExclusive: toExclusive, predicate: del_predicate);
    }
    // bool Exists<T>(System.Collections.Generic.IEnumerable<T>, System.Predicate<T>)
// docid: M:System.Diagnostics.Contracts.Contract.Exists``1(System.Collections.Generic.IEnumerable{``0},System.Predicate{``0})
    /**
    Determines whether an element within a collection of elements exists within a function.

    - Parameter collection: The collection from which elements of type T will be drawn to pass to .
    - Parameter predicate: The function to evaluate for an element in .
    - Returns: 
         if and only if  returns  for any element of type  in .

    */
    public static func Exists<UT : SGBridgeGenericValue>(collection : dotnet.System.Collections.Generic.IEnumerable_1<UT>, predicate : dotnet.System.Predicate_1<UT>) throws -> Bool {
        var __thrown : NullableHandle = nil;
        let __return = System_Diagnostics_Contracts_Contract_bool__Exists_1__2__System_Collections_Generic_IEnumerable_UT__System_Predicate_UT_(UT.get_type_handle(), &__thrown, collection.get_handle(), predicate.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return (__return) != 0;
        }
    }
    // delegate closure overload
    public static func Exists<UT : SGBridgeGenericValue>(collection : dotnet.System.Collections.Generic.IEnumerable_1<UT>, predicate : @escaping (UT) throws -> Bool) throws -> Bool {
        let del_predicate = try dotnet.System.Predicate_1<UT>(predicate);
        return try Exists(collection: collection, predicate: del_predicate);
    }
    // bool ForAll(System.Int32, System.Int32, System.Predicate<System.Int32>)
// docid: M:System.Diagnostics.Contracts.Contract.ForAll(System.Int32,System.Int32,System.Predicate{System.Int32})
    /**
    Determines whether a particular condition is valid for all integers in a specified range.

    - Parameter fromInclusive: The first integer to pass to .
    - Parameter toExclusive: One more than the last integer to pass to .
    - Parameter predicate: The function to evaluate for the existence of the integers in the specified range.
    - Returns: 
         if  returns  for all integers starting from  to  - 1.

    */
    public static func ForAll(fromInclusive : Swift.Int32, toExclusive : Swift.Int32, predicate : dotnet.System.Predicate_1<Swift.Int32>) throws -> Bool {
        var __thrown : NullableHandle = nil;
        let __return = System_Diagnostics_Contracts_Contract_bool__ForAll_0__3__i32_i32_System_Predicate_i32_(&__thrown, fromInclusive, toExclusive, predicate.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return (__return) != 0;
        }
    }
    // delegate closure overload
    public static func ForAll(fromInclusive : Swift.Int32, toExclusive : Swift.Int32, predicate : @escaping (Swift.Int32) throws -> Bool) throws -> Bool {
        let del_predicate = try dotnet.System.Predicate_1<Swift.Int32>(predicate);
        return try ForAll(fromInclusive: fromInclusive, toExclusive: toExclusive, predicate: del_predicate);
    }
    // bool ForAll<T>(System.Collections.Generic.IEnumerable<T>, System.Predicate<T>)
// docid: M:System.Diagnostics.Contracts.Contract.ForAll``1(System.Collections.Generic.IEnumerable{``0},System.Predicate{``0})
    /**
    Determines whether all the elements in a collection exist within a function.

    - Parameter collection: The collection from which elements of type T will be drawn to pass to .
    - Parameter predicate: The function to evaluate for the existence of all the elements in .
    - Returns: 
         if and only if  returns  for all elements of type  in .

    */
    public static func ForAll<UT : SGBridgeGenericValue>(collection : dotnet.System.Collections.Generic.IEnumerable_1<UT>, predicate : dotnet.System.Predicate_1<UT>) throws -> Bool {
        var __thrown : NullableHandle = nil;
        let __return = System_Diagnostics_Contracts_Contract_bool__ForAll_1__2__System_Collections_Generic_IEnumerable_UT__System_Predicate_UT_(UT.get_type_handle(), &__thrown, collection.get_handle(), predicate.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return (__return) != 0;
        }
    }
    // delegate closure overload
    public static func ForAll<UT : SGBridgeGenericValue>(collection : dotnet.System.Collections.Generic.IEnumerable_1<UT>, predicate : @escaping (UT) throws -> Bool) throws -> Bool {
        let del_predicate = try dotnet.System.Predicate_1<UT>(predicate);
        return try ForAll(collection: collection, predicate: del_predicate);
    }
    // void Invariant(bool)
// docid: M:System.Diagnostics.Contracts.Contract.Invariant(System.Boolean)
    /**
    Specifies an invariant contract for the enclosing method or property.

    - Parameter condition: The conditional expression to test.
    */
    public static func Invariant(condition : Bool) throws {
        var __thrown : NullableHandle = nil;
        System_Diagnostics_Contracts_Contract_void__Invariant_0__1__bool(&__thrown, Swift.Int32(condition ? 1 : 0));
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
            return;
        }
    }
    // void Invariant(bool, System.String)
// docid: M:System.Diagnostics.Contracts.Contract.Invariant(System.Boolean,System.String)
    /**
    Specifies an invariant contract for the enclosing method or property, and displays a message if the condition for the contract fails.

    - Parameter condition: The conditional expression to test.
    - Parameter userMessage: The message to display if the condition is .
    */
    public static func Invariant(condition : Bool, userMessage : Optional<dotnet.System.String>) throws {
        var __thrown : NullableHandle = nil;
        System_Diagnostics_Contracts_Contract_void__Invariant_0__2__bool_String(&__thrown, Swift.Int32(condition ? 1 : 0), userMessage?.get_handle() ?? nil);
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
            return;
        }
    }
    // T OldValue<T>(T)
// docid: M:System.Diagnostics.Contracts.Contract.OldValue``1(``0)
    /**
    Represents values as they were at the start of a method or property.

    - Parameter value: The value to represent (field or parameter).
    - Returns: The value of the parameter or field at the start of a method or property.

    */
    public static func OldValue<UT : SGBridgeGenericValue>(value : UT) throws -> UT {
        var __thrown : NullableHandle = nil;
        let __return = System_Diagnostics_Contracts_Contract_UT__OldValue_1__1__UT(UT.get_type_handle(), &__thrown, value.to_gval());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
            return UT(gval: __return);
        }
    }
    // void Requires(bool)
// docid: M:System.Diagnostics.Contracts.Contract.Requires(System.Boolean)
    /**
    Specifies a precondition contract for the enclosing method or property.

    - Parameter condition: The conditional expression to test.
    */
    public static func Requires(condition : Bool) throws {
        var __thrown : NullableHandle = nil;
        System_Diagnostics_Contracts_Contract_void__Requires_0__1__bool(&__thrown, Swift.Int32(condition ? 1 : 0));
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
            return;
        }
    }
    // void Requires(bool, System.String)
// docid: M:System.Diagnostics.Contracts.Contract.Requires(System.Boolean,System.String)
    /**
    Specifies a precondition contract for the enclosing method or property, and displays a message if the condition for the contract fails.

    - Parameter condition: The conditional expression to test.
    - Parameter userMessage: The message to display if the condition is .
    */
    public static func Requires(condition : Bool, userMessage : Optional<dotnet.System.String>) throws {
        var __thrown : NullableHandle = nil;
        System_Diagnostics_Contracts_Contract_void__Requires_0__2__bool_String(&__thrown, Swift.Int32(condition ? 1 : 0), userMessage?.get_handle() ?? nil);
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
            return;
        }
    }
// TODO COPE (write_all_methods) (unused generic param) void Requires<TException>(bool)
// TODO COPE (write_all_methods) (unused generic param) void Requires<TException>(bool, System.String)
// TODO COPE (write_all_methods) (unused generic param) T Result<T>()
// TODO COPE (write_all_methods) (unused generic param) T ValueAtReturn<T>(ref T)
    // [IsSpecialName] void add_ContractFailed(System.EventHandler<System.Diagnostics.Contracts.ContractFailedEventArgs>)
// docid: M:System.Diagnostics.Contracts.Contract.add_ContractFailed(System.EventHandler{System.Diagnostics.Contracts.ContractFailedEventArgs})
    public static func add_ContractFailed(value : Optional<dotnet.System.EventHandler_1<dotnet.System.Diagnostics.Contracts.ContractFailedEventArgs>>) throws {
        var __thrown : NullableHandle = nil;
        System_Diagnostics_Contracts_Contract_void__add_ContractFailed_0__1__System_EventHandler_System_Diagnostics_Contracts_ContractFailedEventArgs_(&__thrown, (value?.get_handle()));
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
            return;
        }
    }
    // delegate closure overload
    public static func add_ContractFailed(value : @escaping (Optional<dotnet.System.Object>, Optional<dotnet.System.Diagnostics.Contracts.ContractFailedEventArgs>) throws -> Void) throws {
        let del_value = try dotnet.System.EventHandler_1<dotnet.System.Diagnostics.Contracts.ContractFailedEventArgs>(value);
        return try add_ContractFailed(value: del_value);
    }
    // [IsSpecialName] void remove_ContractFailed(System.EventHandler<System.Diagnostics.Contracts.ContractFailedEventArgs>)
// docid: M:System.Diagnostics.Contracts.Contract.remove_ContractFailed(System.EventHandler{System.Diagnostics.Contracts.ContractFailedEventArgs})
    public static func remove_ContractFailed(value : Optional<dotnet.System.EventHandler_1<dotnet.System.Diagnostics.Contracts.ContractFailedEventArgs>>) throws {
        var __thrown : NullableHandle = nil;
        System_Diagnostics_Contracts_Contract_void__remove_ContractFailed_0__1__System_EventHandler_System_Diagnostics_Contracts_ContractFailedEventArgs_(&__thrown, (value?.get_handle()));
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
            return;
        }
    }
    // delegate closure overload
    public static func remove_ContractFailed(value : @escaping (Optional<dotnet.System.Object>, Optional<dotnet.System.Diagnostics.Contracts.ContractFailedEventArgs>) throws -> Void) throws {
        let del_value = try dotnet.System.EventHandler_1<dotnet.System.Diagnostics.Contracts.ContractFailedEventArgs>(value);
        return try remove_ContractFailed(value: del_value);
    }
} // Contract


// type: System.Diagnostics.Contracts.ContractAbbreviatorAttribute
    /**
    Defines abbreviations that you can use in place of the full contract syntax.

    */
public final class ContractAbbreviatorAttribute
    :
    dotnet.System.Attribute
{
    public class override func get_type_handle() -> TypeHandle {
        return System_Diagnostics_Contracts_ContractAbbreviatorAttribute_get_type_handle();
    }
    public required init(hndl: NonnullHandle) { super.init(hndl: hndl); }
    public required init(gval: GVal) { super.init(gval: gval); }
    // .ctor()
// docid: M:System.Diagnostics.Contracts.ContractAbbreviatorAttribute.#ctor
    /**
    Initializes a new instance of the  class.

    */
    public init() throws {
        var __thrown : NullableHandle = nil;
        let h = System_Diagnostics_Contracts_ContractAbbreviatorAttribute_ctor_0__0(&__thrown);
        if let __ex = __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
            super.init(hndl: h);
        }
    }
} // ContractAbbreviatorAttribute


// type: System.Diagnostics.Contracts.ContractArgumentValidatorAttribute
    /**
    Enables the factoring of legacy  code into separate methods for reuse, and provides full control over thrown exceptions and arguments.

    */
public final class ContractArgumentValidatorAttribute
    :
    dotnet.System.Attribute
{
    public class override func get_type_handle() -> TypeHandle {
        return System_Diagnostics_Contracts_ContractArgumentValidatorAttribute_get_type_handle();
    }
    public required init(hndl: NonnullHandle) { super.init(hndl: hndl); }
    public required init(gval: GVal) { super.init(gval: gval); }
    // .ctor()
// docid: M:System.Diagnostics.Contracts.ContractArgumentValidatorAttribute.#ctor
    /**
    Initializes a new instance of the  class.

    */
    public init() throws {
        var __thrown : NullableHandle = nil;
        let h = System_Diagnostics_Contracts_ContractArgumentValidatorAttribute_ctor_0__0(&__thrown);
        if let __ex = __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
            super.init(hndl: h);
        }
    }
} // ContractArgumentValidatorAttribute


// type: System.Diagnostics.Contracts.ContractClassAttribute
    /**
    Specifies that a separate type contains the code contracts for this type.

    */
public final class ContractClassAttribute
    :
    dotnet.System.Attribute
{
    public class override func get_type_handle() -> TypeHandle {
        return System_Diagnostics_Contracts_ContractClassAttribute_get_type_handle();
    }
    public required init(hndl: NonnullHandle) { super.init(hndl: hndl); }
    public required init(gval: GVal) { super.init(gval: gval); }
    // .ctor(System.Type)
// docid: M:System.Diagnostics.Contracts.ContractClassAttribute.#ctor(System.Type)
    /**
    Initializes a new instance of the  class.

    - Parameter typeContainingContracts: The type that contains the code contracts for this type.
    */
    public init(typeContainingContracts : dotnet.System.Type_) throws {
        var __thrown : NullableHandle = nil;
        let h = System_Diagnostics_Contracts_ContractClassAttribute_ctor_0__1__Type(&__thrown, typeContainingContracts.get_handle());
        if let __ex = __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
            super.init(hndl: h);
        }
    }
    // [IsSpecialName] System.Type get_TypeContainingContracts()
// docid: M:System.Diagnostics.Contracts.ContractClassAttribute.get_TypeContainingContracts
    public func get_TypeContainingContracts() throws -> dotnet.System.Type_ {
        var __thrown : NullableHandle = nil;
        let __return = System_Diagnostics_Contracts_ContractClassAttribute_Type__get_TypeContainingContracts_0__0(&__thrown, self.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return dotnet.System.Type_(hndl : __return);
        }
    }
    /**
    Gets the type that contains the code contracts for this type.

    */
    public var TypeContainingContracts : dotnet.System.Type_ {
        get {
            return try! get_TypeContainingContracts();
        }
    }
} // ContractClassAttribute


// type: System.Diagnostics.Contracts.ContractClassForAttribute
    /**
    Specifies that a class is a contract for a type.

    */
public final class ContractClassForAttribute
    :
    dotnet.System.Attribute
{
    public class override func get_type_handle() -> TypeHandle {
        return System_Diagnostics_Contracts_ContractClassForAttribute_get_type_handle();
    }
    public required init(hndl: NonnullHandle) { super.init(hndl: hndl); }
    public required init(gval: GVal) { super.init(gval: gval); }
    // .ctor(System.Type)
// docid: M:System.Diagnostics.Contracts.ContractClassForAttribute.#ctor(System.Type)
    /**
    Initializes a new instance of the  class, specifying the type the current class is a contract for.

    - Parameter typeContractsAreFor: The type the current class is a contract for.
    */
    public init(typeContractsAreFor : dotnet.System.Type_) throws {
        var __thrown : NullableHandle = nil;
        let h = System_Diagnostics_Contracts_ContractClassForAttribute_ctor_0__1__Type(&__thrown, typeContractsAreFor.get_handle());
        if let __ex = __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
            super.init(hndl: h);
        }
    }
    // [IsSpecialName] System.Type get_TypeContractsAreFor()
// docid: M:System.Diagnostics.Contracts.ContractClassForAttribute.get_TypeContractsAreFor
    public func get_TypeContractsAreFor() throws -> dotnet.System.Type_ {
        var __thrown : NullableHandle = nil;
        let __return = System_Diagnostics_Contracts_ContractClassForAttribute_Type__get_TypeContractsAreFor_0__0(&__thrown, self.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return dotnet.System.Type_(hndl : __return);
        }
    }
    /**
    Gets the type that this code contract applies to.

    */
    public var TypeContractsAreFor : dotnet.System.Type_ {
        get {
            return try! get_TypeContractsAreFor();
        }
    }
} // ContractClassForAttribute


// type: System.Diagnostics.Contracts.ContractFailedEventArgs
    /**
    Provides methods and data for the  event.

    */
public final class ContractFailedEventArgs
    :
    dotnet.System.EventArgs
{
    public class override func get_type_handle() -> TypeHandle {
        return System_Diagnostics_Contracts_ContractFailedEventArgs_get_type_handle();
    }
    public required init(hndl: NonnullHandle) { super.init(hndl: hndl); }
    public required init(gval: GVal) { super.init(gval: gval); }
    // .ctor(System.Diagnostics.Contracts.ContractFailureKind, System.String, System.String, System.Exception)
// docid: M:System.Diagnostics.Contracts.ContractFailedEventArgs.#ctor(System.Diagnostics.Contracts.ContractFailureKind,System.String,System.String,System.Exception)
    /**
    Provides data for the  event.

    - Parameter failureKind: One of the enumeration values that specifies the contract that failed.
    - Parameter message: The message for the event.
    - Parameter condition: The condition for the event.
    - Parameter originalException: The exception that caused the event.
    */
    public init(failureKind : dotnet.System.Diagnostics.Contracts.ContractFailureKind, message : Optional<dotnet.System.String>, condition : Optional<dotnet.System.String>, originalException : Optional<dotnet.System.Exception>) throws {
        var __thrown : NullableHandle = nil;
        let h = System_Diagnostics_Contracts_ContractFailedEventArgs_ctor_0__4__ContractFailureKind_String_String_Exception(&__thrown, failureKind.get_value(), message?.get_handle() ?? nil, condition?.get_handle() ?? nil, originalException?.get_handle() ?? nil);
        if let __ex = __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
            super.init(hndl: h);
        }
    }
    // void SetHandled()
// docid: M:System.Diagnostics.Contracts.ContractFailedEventArgs.SetHandled
    /**
    Sets the  property to .

    */
    public func SetHandled() throws {
        var __thrown : NullableHandle = nil;
        System_Diagnostics_Contracts_ContractFailedEventArgs_void__SetHandled_0__0(&__thrown, self.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
            return;
        }
    }
    // void SetUnwind()
// docid: M:System.Diagnostics.Contracts.ContractFailedEventArgs.SetUnwind
    /**
    Sets the  property to .

    */
    public func SetUnwind() throws {
        var __thrown : NullableHandle = nil;
        System_Diagnostics_Contracts_ContractFailedEventArgs_void__SetUnwind_0__0(&__thrown, self.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
            return;
        }
    }
    // [IsSpecialName] System.String get_Condition()
// docid: M:System.Diagnostics.Contracts.ContractFailedEventArgs.get_Condition
    public func get_Condition() throws -> Optional<dotnet.System.String> {
        var __thrown : NullableHandle = nil;
        let __return = System_Diagnostics_Contracts_ContractFailedEventArgs_String__get_Condition_0__0(&__thrown, self.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        if let __ret_unwrapped = __return {
            return dotnet.System.String(hndl : __ret_unwrapped);
        } else {
            return nil;
        }
        }
    }
    // [IsSpecialName] System.Diagnostics.Contracts.ContractFailureKind get_FailureKind()
// docid: M:System.Diagnostics.Contracts.ContractFailedEventArgs.get_FailureKind
    public func get_FailureKind() throws -> dotnet.System.Diagnostics.Contracts.ContractFailureKind {
        var __thrown : NullableHandle = nil;
        let __return = System_Diagnostics_Contracts_ContractFailedEventArgs_ContractFailureKind__get_FailureKind_0__0(&__thrown, self.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return dotnet.System.Diagnostics.Contracts.ContractFailureKind(val: __return);
        }
    }
    // [IsSpecialName] bool get_Handled()
// docid: M:System.Diagnostics.Contracts.ContractFailedEventArgs.get_Handled
    public func get_Handled() throws -> Bool {
        var __thrown : NullableHandle = nil;
        let __return = System_Diagnostics_Contracts_ContractFailedEventArgs_bool__get_Handled_0__0(&__thrown, self.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return (__return) != 0;
        }
    }
    // [IsSpecialName] System.String get_Message()
// docid: M:System.Diagnostics.Contracts.ContractFailedEventArgs.get_Message
    public func get_Message() throws -> Optional<dotnet.System.String> {
        var __thrown : NullableHandle = nil;
        let __return = System_Diagnostics_Contracts_ContractFailedEventArgs_String__get_Message_0__0(&__thrown, self.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        if let __ret_unwrapped = __return {
            return dotnet.System.String(hndl : __ret_unwrapped);
        } else {
            return nil;
        }
        }
    }
    // [IsSpecialName] System.Exception get_OriginalException()
// docid: M:System.Diagnostics.Contracts.ContractFailedEventArgs.get_OriginalException
    public func get_OriginalException() throws -> Optional<dotnet.System.Exception> {
        var __thrown : NullableHandle = nil;
        let __return = System_Diagnostics_Contracts_ContractFailedEventArgs_Exception__get_OriginalException_0__0(&__thrown, self.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        if let __ret_unwrapped = __return {
            return dotnet.System.Exception(hndl : __ret_unwrapped);
        } else {
            return nil;
        }
        }
    }
    // [IsSpecialName] bool get_Unwind()
// docid: M:System.Diagnostics.Contracts.ContractFailedEventArgs.get_Unwind
    public func get_Unwind() throws -> Bool {
        var __thrown : NullableHandle = nil;
        let __return = System_Diagnostics_Contracts_ContractFailedEventArgs_bool__get_Unwind_0__0(&__thrown, self.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return (__return) != 0;
        }
    }
    /**
    Gets the condition for the failure of the contract.

    */
    public var Condition : Optional<dotnet.System.String> {
        get {
            return try! get_Condition();
        }
    }
    /**
    Gets the type of contract that failed.

    */
    public var FailureKind : dotnet.System.Diagnostics.Contracts.ContractFailureKind {
        get {
            return try! get_FailureKind();
        }
    }
    /**
    Indicates whether the  event has been handled.

    */
    public var Handled : Bool {
        get {
            return try! get_Handled();
        }
    }
    /**
    Gets the message that describes the  event.

    */
    public var Message : Optional<dotnet.System.String> {
        get {
            return try! get_Message();
        }
    }
    /**
    Gets the original exception that caused the  event.

    */
    public var OriginalException : Optional<dotnet.System.Exception> {
        get {
            return try! get_OriginalException();
        }
    }
    /**
    Indicates whether the code contract escalation policy should be applied.

    */
    public var Unwind : Bool {
        get {
            return try! get_Unwind();
        }
    }
} // ContractFailedEventArgs


// type: System.Diagnostics.Contracts.ContractFailureKind
    /**
    Specifies the type of contract that failed.

    */
public struct ContractFailureKind : SGBridgeGenericValue {
    let v : Swift.Int32;
    public init(val: Swift.Int32) { self.v = val; }
    public func get_value() -> Swift.Int32 { return self.v; }
    public static func get_type_handle() -> TypeHandle {
        return System_Diagnostics_Contracts_ContractFailureKind_get_type_handle();
    }
    public func to_gval() -> GVal { return GVal(self.v); }
    public func dup_gval() -> GVal { return to_gval(); }
    public init(gval: GVal) { self.v = Swift.Int32(gval); }
    // static field: System.Diagnostics.Contracts.ContractFailureKind Precondition
    /**
    A  contract failed.

    */
    public static var Precondition : dotnet.System.Diagnostics.Contracts.ContractFailureKind {
        get {
        let __return = dotnet.System.Diagnostics.Contracts.ContractFailureKind(val: System_Diagnostics_Contracts_ContractFailureKind_get_Precondition());
            return __return;
        }
    }
    // static field: System.Diagnostics.Contracts.ContractFailureKind Postcondition
    /**
    An  contract failed.

    */
    public static var Postcondition : dotnet.System.Diagnostics.Contracts.ContractFailureKind {
        get {
        let __return = dotnet.System.Diagnostics.Contracts.ContractFailureKind(val: System_Diagnostics_Contracts_ContractFailureKind_get_Postcondition());
            return __return;
        }
    }
    // static field: System.Diagnostics.Contracts.ContractFailureKind PostconditionOnException
    /**
    An  contract failed.

    */
    public static var PostconditionOnException : dotnet.System.Diagnostics.Contracts.ContractFailureKind {
        get {
        let __return = dotnet.System.Diagnostics.Contracts.ContractFailureKind(val: System_Diagnostics_Contracts_ContractFailureKind_get_PostconditionOnException());
            return __return;
        }
    }
    // static field: System.Diagnostics.Contracts.ContractFailureKind Invariant
    /**
    An  contract failed.

    */
    public static var Invariant : dotnet.System.Diagnostics.Contracts.ContractFailureKind {
        get {
        let __return = dotnet.System.Diagnostics.Contracts.ContractFailureKind(val: System_Diagnostics_Contracts_ContractFailureKind_get_Invariant());
            return __return;
        }
    }
    // static field: System.Diagnostics.Contracts.ContractFailureKind Assert
    /**
    An  contract failed.

    */
    public static var Assert : dotnet.System.Diagnostics.Contracts.ContractFailureKind {
        get {
        let __return = dotnet.System.Diagnostics.Contracts.ContractFailureKind(val: System_Diagnostics_Contracts_ContractFailureKind_get_Assert());
            return __return;
        }
    }
    // static field: System.Diagnostics.Contracts.ContractFailureKind Assume
    /**
    An  contract failed.

    */
    public static var Assume : dotnet.System.Diagnostics.Contracts.ContractFailureKind {
        get {
        let __return = dotnet.System.Diagnostics.Contracts.ContractFailureKind(val: System_Diagnostics_Contracts_ContractFailureKind_get_Assume());
            return __return;
        }
    }
} // ContractFailureKind


// type: System.Diagnostics.Contracts.ContractInvariantMethodAttribute
    /**
    Marks a method as being the invariant method for a class.

    */
public final class ContractInvariantMethodAttribute
    :
    dotnet.System.Attribute
{
    public class override func get_type_handle() -> TypeHandle {
        return System_Diagnostics_Contracts_ContractInvariantMethodAttribute_get_type_handle();
    }
    public required init(hndl: NonnullHandle) { super.init(hndl: hndl); }
    public required init(gval: GVal) { super.init(gval: gval); }
    // .ctor()
// docid: M:System.Diagnostics.Contracts.ContractInvariantMethodAttribute.#ctor
    /**
    Initializes a new instance of the  class.

    */
    public init() throws {
        var __thrown : NullableHandle = nil;
        let h = System_Diagnostics_Contracts_ContractInvariantMethodAttribute_ctor_0__0(&__thrown);
        if let __ex = __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
            super.init(hndl: h);
        }
    }
} // ContractInvariantMethodAttribute


// type: System.Diagnostics.Contracts.ContractOptionAttribute
    /**
    Enables you to set contract and tool options at assembly, type, or method granularity.

    */
public final class ContractOptionAttribute
    :
    dotnet.System.Attribute
{
    public class override func get_type_handle() -> TypeHandle {
        return System_Diagnostics_Contracts_ContractOptionAttribute_get_type_handle();
    }
    public required init(hndl: NonnullHandle) { super.init(hndl: hndl); }
    public required init(gval: GVal) { super.init(gval: gval); }
    // .ctor(System.String, System.String, bool)
// docid: M:System.Diagnostics.Contracts.ContractOptionAttribute.#ctor(System.String,System.String,System.Boolean)
    /**
    Initializes a new instance of the  class by using the provided category, setting, and enable/disable value.

    - Parameter category: The category for the option to be set.
    - Parameter setting: The option setting.
    - Parameter enabled: 
         to enable the option;  to disable the option.
    */
    public init(category : dotnet.System.String, setting : dotnet.System.String, enabled : Bool) throws {
        var __thrown : NullableHandle = nil;
        let h = System_Diagnostics_Contracts_ContractOptionAttribute_ctor_0__3__String_String_bool(&__thrown, category.get_handle(), setting.get_handle(), Swift.Int32(enabled ? 1 : 0));
        if let __ex = __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
            super.init(hndl: h);
        }
    }
    // .ctor(System.String, System.String, System.String)
// docid: M:System.Diagnostics.Contracts.ContractOptionAttribute.#ctor(System.String,System.String,System.String)
    /**
    Initializes a new instance of the  class by using the provided category, setting, and value.

    - Parameter category: The category of the option to be set.
    - Parameter setting: The option setting.
    - Parameter value: The value for the setting.
    */
    public init(category : dotnet.System.String, setting : dotnet.System.String, value : dotnet.System.String) throws {
        var __thrown : NullableHandle = nil;
        let h = System_Diagnostics_Contracts_ContractOptionAttribute_ctor_0__3__String_String_String(&__thrown, category.get_handle(), setting.get_handle(), value.get_handle());
        if let __ex = __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
            super.init(hndl: h);
        }
    }
    // [IsSpecialName] System.String get_Category()
// docid: M:System.Diagnostics.Contracts.ContractOptionAttribute.get_Category
    public func get_Category() throws -> dotnet.System.String {
        var __thrown : NullableHandle = nil;
        let __return = System_Diagnostics_Contracts_ContractOptionAttribute_String__get_Category_0__0(&__thrown, self.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return dotnet.System.String(hndl : __return);
        }
    }
    // [IsSpecialName] bool get_Enabled()
// docid: M:System.Diagnostics.Contracts.ContractOptionAttribute.get_Enabled
    public func get_Enabled() throws -> Bool {
        var __thrown : NullableHandle = nil;
        let __return = System_Diagnostics_Contracts_ContractOptionAttribute_bool__get_Enabled_0__0(&__thrown, self.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return (__return) != 0;
        }
    }
    // [IsSpecialName] System.String get_Setting()
// docid: M:System.Diagnostics.Contracts.ContractOptionAttribute.get_Setting
    public func get_Setting() throws -> dotnet.System.String {
        var __thrown : NullableHandle = nil;
        let __return = System_Diagnostics_Contracts_ContractOptionAttribute_String__get_Setting_0__0(&__thrown, self.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return dotnet.System.String(hndl : __return);
        }
    }
    // [IsSpecialName] System.String get_Value()
// docid: M:System.Diagnostics.Contracts.ContractOptionAttribute.get_Value
    public func get_Value() throws -> Optional<dotnet.System.String> {
        var __thrown : NullableHandle = nil;
        let __return = System_Diagnostics_Contracts_ContractOptionAttribute_String__get_Value_0__0(&__thrown, self.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        if let __ret_unwrapped = __return {
            return dotnet.System.String(hndl : __ret_unwrapped);
        } else {
            return nil;
        }
        }
    }
    /**
    Gets the category of the option.

    */
    public var Category : dotnet.System.String {
        get {
            return try! get_Category();
        }
    }
    /**
    Determines if an option is enabled.

    */
    public var Enabled : Bool {
        get {
            return try! get_Enabled();
        }
    }
    /**
    Gets the setting for the option.

    */
    public var Setting : dotnet.System.String {
        get {
            return try! get_Setting();
        }
    }
    /**
    Gets the value for the option.

    */
    public var Value : Optional<dotnet.System.String> {
        get {
            return try! get_Value();
        }
    }
} // ContractOptionAttribute


// type: System.Diagnostics.Contracts.ContractPublicPropertyNameAttribute
    /**
    Specifies that a field can be used in method contracts when the field has less visibility than the method.

    */
public final class ContractPublicPropertyNameAttribute
    :
    dotnet.System.Attribute
{
    public class override func get_type_handle() -> TypeHandle {
        return System_Diagnostics_Contracts_ContractPublicPropertyNameAttribute_get_type_handle();
    }
    public required init(hndl: NonnullHandle) { super.init(hndl: hndl); }
    public required init(gval: GVal) { super.init(gval: gval); }
    // .ctor(System.String)
// docid: M:System.Diagnostics.Contracts.ContractPublicPropertyNameAttribute.#ctor(System.String)
    /**
    Initializes a new instance of the  class.

    - Parameter name: The property name to apply to the field.
    */
    public init(name : dotnet.System.String) throws {
        var __thrown : NullableHandle = nil;
        let h = System_Diagnostics_Contracts_ContractPublicPropertyNameAttribute_ctor_0__1__String(&__thrown, name.get_handle());
        if let __ex = __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
            super.init(hndl: h);
        }
    }
    // [IsSpecialName] System.String get_Name()
// docid: M:System.Diagnostics.Contracts.ContractPublicPropertyNameAttribute.get_Name
    public func get_Name() throws -> dotnet.System.String {
        var __thrown : NullableHandle = nil;
        let __return = System_Diagnostics_Contracts_ContractPublicPropertyNameAttribute_String__get_Name_0__0(&__thrown, self.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return dotnet.System.String(hndl : __return);
        }
    }
    /**
    Gets the property name to be applied to the field.

    */
    public var Name : dotnet.System.String {
        get {
            return try! get_Name();
        }
    }
} // ContractPublicPropertyNameAttribute


// type: System.Diagnostics.Contracts.ContractReferenceAssemblyAttribute
    /**
    Specifies that an assembly is a reference assembly that contains contracts.

    */
public final class ContractReferenceAssemblyAttribute
    :
    dotnet.System.Attribute
{
    public class override func get_type_handle() -> TypeHandle {
        return System_Diagnostics_Contracts_ContractReferenceAssemblyAttribute_get_type_handle();
    }
    public required init(hndl: NonnullHandle) { super.init(hndl: hndl); }
    public required init(gval: GVal) { super.init(gval: gval); }
    // .ctor()
// docid: M:System.Diagnostics.Contracts.ContractReferenceAssemblyAttribute.#ctor
    /**
    Initializes a new instance of the  class.

    */
    public init() throws {
        var __thrown : NullableHandle = nil;
        let h = System_Diagnostics_Contracts_ContractReferenceAssemblyAttribute_ctor_0__0(&__thrown);
        if let __ex = __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
            super.init(hndl: h);
        }
    }
} // ContractReferenceAssemblyAttribute


// type: System.Diagnostics.Contracts.ContractRuntimeIgnoredAttribute
    /**
    Identifies a member that has no run-time behavior.

    */
public final class ContractRuntimeIgnoredAttribute
    :
    dotnet.System.Attribute
{
    public class override func get_type_handle() -> TypeHandle {
        return System_Diagnostics_Contracts_ContractRuntimeIgnoredAttribute_get_type_handle();
    }
    public required init(hndl: NonnullHandle) { super.init(hndl: hndl); }
    public required init(gval: GVal) { super.init(gval: gval); }
    // .ctor()
// docid: M:System.Diagnostics.Contracts.ContractRuntimeIgnoredAttribute.#ctor
    /**
    Initializes a new instance of the  class.

    */
    public init() throws {
        var __thrown : NullableHandle = nil;
        let h = System_Diagnostics_Contracts_ContractRuntimeIgnoredAttribute_ctor_0__0(&__thrown);
        if let __ex = __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
            super.init(hndl: h);
        }
    }
} // ContractRuntimeIgnoredAttribute


// type: System.Diagnostics.Contracts.ContractVerificationAttribute
    /**
    Instructs analysis tools to assume the correctness of an assembly, type, or member without performing static verification.

    */
public final class ContractVerificationAttribute
    :
    dotnet.System.Attribute
{
    public class override func get_type_handle() -> TypeHandle {
        return System_Diagnostics_Contracts_ContractVerificationAttribute_get_type_handle();
    }
    public required init(hndl: NonnullHandle) { super.init(hndl: hndl); }
    public required init(gval: GVal) { super.init(gval: gval); }
    // .ctor(bool)
// docid: M:System.Diagnostics.Contracts.ContractVerificationAttribute.#ctor(System.Boolean)
    /**
    Initializes a new instance of the  class.

    - Parameter value: 
         to require verification; otherwise, .
    */
    public init(value : Bool) throws {
        var __thrown : NullableHandle = nil;
        let h = System_Diagnostics_Contracts_ContractVerificationAttribute_ctor_0__1__bool(&__thrown, Swift.Int32(value ? 1 : 0));
        if let __ex = __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
            super.init(hndl: h);
        }
    }
    // [IsSpecialName] bool get_Value()
// docid: M:System.Diagnostics.Contracts.ContractVerificationAttribute.get_Value
    public func get_Value() throws -> Bool {
        var __thrown : NullableHandle = nil;
        let __return = System_Diagnostics_Contracts_ContractVerificationAttribute_bool__get_Value_0__0(&__thrown, self.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return (__return) != 0;
        }
    }
    /**
    Gets the value that indicates whether to verify the contract of the target.

    */
    public var Value : Bool {
        get {
            return try! get_Value();
        }
    }
} // ContractVerificationAttribute


// type: System.Diagnostics.Contracts.PureAttribute
    /**
    Indicates that a type or method is pure, that is, it does not make any visible state changes.

    */
public final class PureAttribute
    :
    dotnet.System.Attribute
{
    public class override func get_type_handle() -> TypeHandle {
        return System_Diagnostics_Contracts_PureAttribute_get_type_handle();
    }
    public required init(hndl: NonnullHandle) { super.init(hndl: hndl); }
    public required init(gval: GVal) { super.init(gval: gval); }
    // .ctor()
// docid: M:System.Diagnostics.Contracts.PureAttribute.#ctor
    /**
    Initializes a new instance of the  class.

    */
    public init() throws {
        var __thrown : NullableHandle = nil;
        let h = System_Diagnostics_Contracts_PureAttribute_ctor_0__0(&__thrown);
        if let __ex = __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
            super.init(hndl: h);
        }
    }
} // PureAttribute


}


// System.Runtime
// System.Runtime.CompilerServices
extension System.Runtime.CompilerServices {
// type: System.Runtime.CompilerServices.ContractHelper
public struct ContractHelper {
    // System.String RaiseContractFailedEvent(System.Diagnostics.Contracts.ContractFailureKind, System.String, System.String, System.Exception)
// docid: M:System.Runtime.CompilerServices.ContractHelper.RaiseContractFailedEvent(System.Diagnostics.Contracts.ContractFailureKind,System.String,System.String,System.Exception)
    /**
    Used by the binary rewriter to activate the default failure behavior.

    - Parameter failureKind: One of the enumeration values that specifies the type of failure.
    - Parameter userMessage: Additional user information.
    - Parameter conditionText: The description of the condition that caused the failure.
    - Parameter innerException: The inner exception that caused the current exception.
    - Returns: A null reference ( in Visual Basic) if the event was handled and should not trigger a failure; otherwise, returns the localized failure message.

    */
    public static func RaiseContractFailedEvent(failureKind : dotnet.System.Diagnostics.Contracts.ContractFailureKind, userMessage : Optional<dotnet.System.String>, conditionText : Optional<dotnet.System.String>, innerException : Optional<dotnet.System.Exception>) throws -> Optional<dotnet.System.String> {
        var __thrown : NullableHandle = nil;
        let __return = System_Runtime_CompilerServices_ContractHelper_String__RaiseContractFailedEvent_0__4__ContractFailureKind_String_String_Exception(&__thrown, failureKind.get_value(), userMessage?.get_handle() ?? nil, conditionText?.get_handle() ?? nil, innerException?.get_handle() ?? nil);
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        if let __ret_unwrapped = __return {
            return dotnet.System.String(hndl : __ret_unwrapped);
        } else {
            return nil;
        }
        }
    }
    // void TriggerFailure(System.Diagnostics.Contracts.ContractFailureKind, System.String, System.String, System.String, System.Exception)
// docid: M:System.Runtime.CompilerServices.ContractHelper.TriggerFailure(System.Diagnostics.Contracts.ContractFailureKind,System.String,System.String,System.String,System.Exception)
    /**
    Triggers the default failure behavior.

    - Parameter kind: One of the enumeration values that specifies the type of failure.
    - Parameter displayMessage: The message to display.
    - Parameter userMessage: Additional user information.
    - Parameter conditionText: The description of the condition that caused the failure.
    - Parameter innerException: The inner exception that caused the current exception.
    */
    public static func TriggerFailure(kind : dotnet.System.Diagnostics.Contracts.ContractFailureKind, displayMessage : Optional<dotnet.System.String>, userMessage : Optional<dotnet.System.String>, conditionText : Optional<dotnet.System.String>, innerException : Optional<dotnet.System.Exception>) throws {
        var __thrown : NullableHandle = nil;
        System_Runtime_CompilerServices_ContractHelper_void__TriggerFailure_0__5__ContractFailureKind_String_String_String_Exception(&__thrown, kind.get_value(), displayMessage?.get_handle() ?? nil, userMessage?.get_handle() ?? nil, conditionText?.get_handle() ?? nil, innerException?.get_handle() ?? nil);
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
            return;
        }
    }
} // ContractHelper


}



