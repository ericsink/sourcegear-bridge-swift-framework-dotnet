// this file is automatically generated
// Copyright 2021 SourceGear

import jumptable_dotnet;

// System
// System.Reflection
// System.Reflection.Emit
extension System.Reflection.Emit {
// type: System.Reflection.Emit.DynamicILInfo
    /**
    Provides support for alternative ways to generate the Microsoft intermediate language (MSIL) and metadata for a dynamic method, including methods for creating tokens and for inserting the code, exception handling, and local variable signature blobs.

    */
public final class DynamicILInfo
    :
    dotnet.System.Object
{
    public class override func get_type_handle() -> TypeHandle {
        return System_Reflection_Emit_DynamicILInfo_get_type_handle();
    }
    public required init(hndl: NonnullHandle) { super.init(hndl: hndl); }
    public required init(gval: GVal) { super.init(gval: gval); }
    // System.Int32 GetTokenFor(System.Byte[])
// docid: M:System.Reflection.Emit.DynamicILInfo.GetTokenFor(System.Byte[])
    /**
    Gets a token, valid in the scope of the current , representing the signature for the associated dynamic method.

    - Parameter signature: An array that contains the signature.
    - Returns: A token that can be embedded in the metadata and the MSIL stream for the associated dynamic method.

    */
    public func GetTokenFor(signature : dotnet.System_Arr<Swift.UInt8>) throws -> Swift.Int32 {
        var __thrown : NullableHandle = nil;
        let __return = System_Reflection_Emit_DynamicILInfo_i32__GetTokenFor_0__1__u8Array(&__thrown, self.get_handle(), signature.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return __return;
        }
    }
    // System.Int32 GetTokenFor(System.Reflection.Emit.DynamicMethod)
// docid: M:System.Reflection.Emit.DynamicILInfo.GetTokenFor(System.Reflection.Emit.DynamicMethod)
    /**
    Gets a token, valid in the scope of the current , representing a dynamic method to be called from the associated method.

    - Parameter method: The dynamic method to call.
    - Returns: A token that can be embedded in the MSIL stream for the associated dynamic method, as the target of an MSIL instruction.

    */
    public func GetTokenFor(method : dotnet.System.Reflection.Emit.DynamicMethod) throws -> Swift.Int32 {
        var __thrown : NullableHandle = nil;
        let __return = System_Reflection_Emit_DynamicILInfo_i32__GetTokenFor_0__1__DynamicMethod(&__thrown, self.get_handle(), method.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return __return;
        }
    }
    // System.Int32 GetTokenFor(System.RuntimeFieldHandle)
// docid: M:System.Reflection.Emit.DynamicILInfo.GetTokenFor(System.RuntimeFieldHandle)
    /**
    Gets a token, valid in the scope of the current , representing a field to be accessed from the associated dynamic method.

    - Parameter field: The field to be accessed.
    - Returns: A token that can be used as the operand of an MSIL instruction that accesses fields, in the scope of the current  object.

    */
    public func GetTokenFor(field : dotnet.System.RuntimeFieldHandle) throws -> Swift.Int32 {
        var __thrown : NullableHandle = nil;
        let __return = System_Reflection_Emit_DynamicILInfo_i32__GetTokenFor_0__1__RuntimeFieldHandle(&__thrown, self.get_handle(), field.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return __return;
        }
    }
    // System.Int32 GetTokenFor(System.RuntimeFieldHandle, System.RuntimeTypeHandle)
// docid: M:System.Reflection.Emit.DynamicILInfo.GetTokenFor(System.RuntimeFieldHandle,System.RuntimeTypeHandle)
    /**
    Gets a token, valid in the scope of the current , representing a field to be accessed from the associated dynamic method; the field is on the specified generic type.

    - Parameter field: The field to be accessed.
    - Parameter contextType: The generic type the field belongs to.
    - Returns: A token that can be used as the operand of an MSIL instruction that accesses fields in the scope of the current  object.

    */
    public func GetTokenFor(field : dotnet.System.RuntimeFieldHandle, contextType : dotnet.System.RuntimeTypeHandle) throws -> Swift.Int32 {
        var __thrown : NullableHandle = nil;
        let __return = System_Reflection_Emit_DynamicILInfo_i32__GetTokenFor_0__2__RuntimeFieldHandle_RuntimeTypeHandle(&__thrown, self.get_handle(), field.get_handle(), contextType.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return __return;
        }
    }
    // System.Int32 GetTokenFor(System.RuntimeMethodHandle)
// docid: M:System.Reflection.Emit.DynamicILInfo.GetTokenFor(System.RuntimeMethodHandle)
    /**
    Gets a token, valid in the scope of the current , representing a method to be accessed from the associated dynamic method.

    - Parameter method: The method to be accessed.
    - Returns: A token that can be used as the operand of an MSIL instruction that accesses methods, such as  or , in the scope of the current  object.

    */
    public func GetTokenFor(method : dotnet.System.RuntimeMethodHandle) throws -> Swift.Int32 {
        var __thrown : NullableHandle = nil;
        let __return = System_Reflection_Emit_DynamicILInfo_i32__GetTokenFor_0__1__RuntimeMethodHandle(&__thrown, self.get_handle(), method.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return __return;
        }
    }
    // System.Int32 GetTokenFor(System.RuntimeMethodHandle, System.RuntimeTypeHandle)
// docid: M:System.Reflection.Emit.DynamicILInfo.GetTokenFor(System.RuntimeMethodHandle,System.RuntimeTypeHandle)
    /**
    Gets a token, valid in the scope of the current , representing a method on a generic type.

    - Parameter method: The method.
    - Parameter contextType: The generic type the method belongs to.
    - Returns: A token that can be used as the operand of an MSIL instruction that accesses methods, such as  or , in the scope of the current  object.

    */
    public func GetTokenFor(method : dotnet.System.RuntimeMethodHandle, contextType : dotnet.System.RuntimeTypeHandle) throws -> Swift.Int32 {
        var __thrown : NullableHandle = nil;
        let __return = System_Reflection_Emit_DynamicILInfo_i32__GetTokenFor_0__2__RuntimeMethodHandle_RuntimeTypeHandle(&__thrown, self.get_handle(), method.get_handle(), contextType.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return __return;
        }
    }
    // System.Int32 GetTokenFor(System.RuntimeTypeHandle)
// docid: M:System.Reflection.Emit.DynamicILInfo.GetTokenFor(System.RuntimeTypeHandle)
    /**
    Gets a token, valid in the scope of the current , representing a type to be used in the associated dynamic method.

    - Parameter type: The type to be used.
    - Returns: A token that can be used as the operand of an MSIL instruction that requires a type, in the scope of the current  object.

    */
    public func GetTokenFor(type : dotnet.System.RuntimeTypeHandle) throws -> Swift.Int32 {
        var __thrown : NullableHandle = nil;
        let __return = System_Reflection_Emit_DynamicILInfo_i32__GetTokenFor_0__1__RuntimeTypeHandle(&__thrown, self.get_handle(), type.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return __return;
        }
    }
    // System.Int32 GetTokenFor(System.String)
// docid: M:System.Reflection.Emit.DynamicILInfo.GetTokenFor(System.String)
    /**
    Gets a token, valid in the scope of the current , representing a string literal to be used in the associated dynamic method.

    - Parameter literal: The string to be used.
    - Returns: A token that can be used as the operand of an MSIL instruction that requires a string, in the scope of the current  object.

    */
    public func GetTokenFor(literal : dotnet.System.String) throws -> Swift.Int32 {
        var __thrown : NullableHandle = nil;
        let __return = System_Reflection_Emit_DynamicILInfo_i32__GetTokenFor_0__1__String(&__thrown, self.get_handle(), literal.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return __return;
        }
    }
    // void SetCode(System.Byte*, System.Int32, System.Int32)
// docid: M:System.Reflection.Emit.DynamicILInfo.SetCode(System.Byte*,System.Int32,System.Int32)
    /**
    Sets the code body of the associated dynamic method.

    - Parameter code: A pointer to a byte array containing the MSIL stream.
    - Parameter codeSize: The number of bytes in the MSIL stream.
    - Parameter maxStackSize: The maximum number of items on the operand stack when the method is executing.
    */
    public func SetCode(code : UnsafeMutablePointer<Swift.UInt8>?, codeSize : Swift.Int32, maxStackSize : Swift.Int32) throws {
        var __thrown : NullableHandle = nil;
        System_Reflection_Emit_DynamicILInfo_void__SetCode_0__3__pu8_i32_i32(&__thrown, self.get_handle(), code, codeSize, maxStackSize);
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
            return;
        }
    }
    // void SetCode(System.Byte[], System.Int32)
// docid: M:System.Reflection.Emit.DynamicILInfo.SetCode(System.Byte[],System.Int32)
    /**
    Sets the code body of the associated dynamic method.

    - Parameter code: An array that contains the MSIL stream.
    - Parameter maxStackSize: The maximum number of items on the operand stack when the method is executing.
    */
    public func SetCode(code : Optional<dotnet.System_Arr<Swift.UInt8>>, maxStackSize : Swift.Int32) throws {
        var __thrown : NullableHandle = nil;
        System_Reflection_Emit_DynamicILInfo_void__SetCode_0__2__u8Array_i32(&__thrown, self.get_handle(), (code?.get_handle()), maxStackSize);
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
            return;
        }
    }
    // void SetExceptions(System.Byte*, System.Int32)
// docid: M:System.Reflection.Emit.DynamicILInfo.SetExceptions(System.Byte*,System.Int32)
    /**
    Sets the exception metadata for the associated dynamic method.

    - Parameter exceptions: A pointer to a byte array containing the exception metadata.
    - Parameter exceptionsSize: The number of bytes of exception metadata.
    */
    public func SetExceptions(exceptions : UnsafeMutablePointer<Swift.UInt8>?, exceptionsSize : Swift.Int32) throws {
        var __thrown : NullableHandle = nil;
        System_Reflection_Emit_DynamicILInfo_void__SetExceptions_0__2__pu8_i32(&__thrown, self.get_handle(), exceptions, exceptionsSize);
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
            return;
        }
    }
    // void SetExceptions(System.Byte[])
// docid: M:System.Reflection.Emit.DynamicILInfo.SetExceptions(System.Byte[])
    /**
    Sets the exception metadata for the associated dynamic method.

    - Parameter exceptions: An array that contains the exception metadata.
    */
    public func SetExceptions(exceptions : Optional<dotnet.System_Arr<Swift.UInt8>>) throws {
        var __thrown : NullableHandle = nil;
        System_Reflection_Emit_DynamicILInfo_void__SetExceptions_0__1__u8Array(&__thrown, self.get_handle(), (exceptions?.get_handle()));
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
            return;
        }
    }
    // void SetLocalSignature(System.Byte*, System.Int32)
// docid: M:System.Reflection.Emit.DynamicILInfo.SetLocalSignature(System.Byte*,System.Int32)
    /**
    Sets the local variable signature that describes the layout of local variables for the associated dynamic method.

    - Parameter localSignature: An array that contains the layout of local variables for the associated .
    - Parameter signatureSize: The number of bytes in the signature.
    */
    public func SetLocalSignature(localSignature : UnsafeMutablePointer<Swift.UInt8>?, signatureSize : Swift.Int32) throws {
        var __thrown : NullableHandle = nil;
        System_Reflection_Emit_DynamicILInfo_void__SetLocalSignature_0__2__pu8_i32(&__thrown, self.get_handle(), localSignature, signatureSize);
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
            return;
        }
    }
    // void SetLocalSignature(System.Byte[])
// docid: M:System.Reflection.Emit.DynamicILInfo.SetLocalSignature(System.Byte[])
    /**
    Sets the local variable signature that describes the layout of local variables for the associated dynamic method.

    - Parameter localSignature: An array that contains the layout of local variables for the associated .
    */
    public func SetLocalSignature(localSignature : Optional<dotnet.System_Arr<Swift.UInt8>>) throws {
        var __thrown : NullableHandle = nil;
        System_Reflection_Emit_DynamicILInfo_void__SetLocalSignature_0__1__u8Array(&__thrown, self.get_handle(), (localSignature?.get_handle()));
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
            return;
        }
    }
    // [IsSpecialName] System.Reflection.Emit.DynamicMethod get_DynamicMethod()
// docid: M:System.Reflection.Emit.DynamicILInfo.get_DynamicMethod
    public func get_DynamicMethod() throws -> dotnet.System.Reflection.Emit.DynamicMethod {
        var __thrown : NullableHandle = nil;
        let __return = System_Reflection_Emit_DynamicILInfo_DynamicMethod__get_DynamicMethod_0__0(&__thrown, self.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return dotnet.System.Reflection.Emit.DynamicMethod(hndl : __return);
        }
    }
    /**
    Gets the dynamic method whose body is generated by the current instance.

    */
    public var DynamicMethod : dotnet.System.Reflection.Emit.DynamicMethod {
        get {
            return try! get_DynamicMethod();
        }
    }
} // DynamicILInfo


// type: System.Reflection.Emit.DynamicMethod
    /**
    Defines and represents a dynamic method that can be compiled, executed, and discarded. Discarded methods are available for garbage collection.

    */
public final class DynamicMethod
    :
    dotnet.System.Reflection.MethodInfo
{
    public class override func get_type_handle() -> TypeHandle {
        return System_Reflection_Emit_DynamicMethod_get_type_handle();
    }
    public required init(hndl: NonnullHandle) { super.init(hndl: hndl); }
    public required init(gval: GVal) { super.init(gval: gval); }
    // .ctor(System.String, System.Reflection.MethodAttributes, System.Reflection.CallingConventions, System.Type, System.Type[], System.Reflection.Module, bool)
// docid: M:System.Reflection.Emit.DynamicMethod.#ctor(System.String,System.Reflection.MethodAttributes,System.Reflection.CallingConventions,System.Type,System.Type[],System.Reflection.Module,System.Boolean)
    /**
    Creates a dynamic method that is global to a module, specifying the method name, attributes, calling convention, return type, parameter types, module, and whether just-in-time (JIT) visibility checks should be skipped for types and members accessed by the Microsoft intermediate language (MSIL) of the dynamic method.

    - Parameter name: The name of the dynamic method. This can be a zero-length string, but it cannot be .
    - Parameter attributes: A bitwise combination of  values that specifies the attributes of the dynamic method. The only combination allowed is  and .
    - Parameter callingConvention: The calling convention for the dynamic method. Must be .
    - Parameter returnType: A  object that specifies the return type of the dynamic method, or  if the method has no return type.
    - Parameter parameterTypes: An array of  objects specifying the types of the parameters of the dynamic method, or  if the method has no parameters.
    - Parameter m: A  representing the module with which the dynamic method is to be logically associated.
    - Parameter skipVisibility: 
         to skip JIT visibility checks on types and members accessed by the MSIL of the dynamic method; otherwise, .
    */
    public init(name : dotnet.System.String, attributes : dotnet.System.Reflection.MethodAttributes, callingConvention : dotnet.System.Reflection.CallingConventions, returnType : Optional<dotnet.System.Type_>, parameterTypes : Optional<dotnet.System_Arr<dotnet.System.Type_>>, m : dotnet.System.Reflection.Module, skipVisibility : Bool) throws {
        var __thrown : NullableHandle = nil;
        let h = System_Reflection_Emit_DynamicMethod_ctor_0__7__String_MethodAttributes_CallingConventions_Type_TypeArray_Module_bool(&__thrown, name.get_handle(), attributes.get_value(), callingConvention.get_value(), returnType?.get_handle() ?? nil, (parameterTypes?.get_handle()), m.get_handle(), Swift.Int32(skipVisibility ? 1 : 0));
        if let __ex = __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
            super.init(hndl: h);
        }
    }
    // .ctor(System.String, System.Reflection.MethodAttributes, System.Reflection.CallingConventions, System.Type, System.Type[], System.Type, bool)
// docid: M:System.Reflection.Emit.DynamicMethod.#ctor(System.String,System.Reflection.MethodAttributes,System.Reflection.CallingConventions,System.Type,System.Type[],System.Type,System.Boolean)
    /**
    Creates a dynamic method, specifying the method name, attributes, calling convention, return type, parameter types, the type with which the dynamic method is logically associated, and whether just-in-time (JIT) visibility checks should be skipped for types and members accessed by the Microsoft intermediate language (MSIL) of the dynamic method.

    - Parameter name: The name of the dynamic method. This can be a zero-length string, but it cannot be .
    - Parameter attributes: A bitwise combination of  values that specifies the attributes of the dynamic method. The only combination allowed is  and .
    - Parameter callingConvention: The calling convention for the dynamic method. Must be .
    - Parameter returnType: A  object that specifies the return type of the dynamic method, or  if the method has no return type.
    - Parameter parameterTypes: An array of  objects specifying the types of the parameters of the dynamic method, or  if the method has no parameters.
    - Parameter owner: A  with which the dynamic method is logically associated. The dynamic method has access to all members of the type.
    - Parameter skipVisibility: 
         to skip JIT visibility checks on types and members accessed by the MSIL of the dynamic method; otherwise, .
    */
    public init(name : dotnet.System.String, attributes : dotnet.System.Reflection.MethodAttributes, callingConvention : dotnet.System.Reflection.CallingConventions, returnType : Optional<dotnet.System.Type_>, parameterTypes : Optional<dotnet.System_Arr<dotnet.System.Type_>>, owner : dotnet.System.Type_, skipVisibility : Bool) throws {
        var __thrown : NullableHandle = nil;
        let h = System_Reflection_Emit_DynamicMethod_ctor_0__7__String_MethodAttributes_CallingConventions_Type_TypeArray_Type_bool(&__thrown, name.get_handle(), attributes.get_value(), callingConvention.get_value(), returnType?.get_handle() ?? nil, (parameterTypes?.get_handle()), owner.get_handle(), Swift.Int32(skipVisibility ? 1 : 0));
        if let __ex = __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
            super.init(hndl: h);
        }
    }
    // .ctor(System.String, System.Type, System.Type[])
// docid: M:System.Reflection.Emit.DynamicMethod.#ctor(System.String,System.Type,System.Type[])
    /**
    Initializes an anonymously hosted dynamic method, specifying the method name, return type, and parameter types.

    - Parameter name: The name of the dynamic method. This can be a zero-length string, but it cannot be .
    - Parameter returnType: A  object that specifies the return type of the dynamic method, or  if the method has no return type.
    - Parameter parameterTypes: An array of  objects specifying the types of the parameters of the dynamic method, or  if the method has no parameters.
    */
    public init(name : dotnet.System.String, returnType : Optional<dotnet.System.Type_>, parameterTypes : Optional<dotnet.System_Arr<dotnet.System.Type_>>) throws {
        var __thrown : NullableHandle = nil;
        let h = System_Reflection_Emit_DynamicMethod_ctor_0__3__String_Type_TypeArray(&__thrown, name.get_handle(), returnType?.get_handle() ?? nil, (parameterTypes?.get_handle()));
        if let __ex = __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
            super.init(hndl: h);
        }
    }
    // .ctor(System.String, System.Type, System.Type[], bool)
// docid: M:System.Reflection.Emit.DynamicMethod.#ctor(System.String,System.Type,System.Type[],System.Boolean)
    /**
    Initializes an anonymously hosted dynamic method, specifying the method name, return type, parameter types, and whether just-in-time (JIT) visibility checks should be skipped for types and members accessed by the Microsoft intermediate language (MSIL) of the dynamic method.

    - Parameter name: The name of the dynamic method. This can be a zero-length string, but it cannot be .
    - Parameter returnType: A  object that specifies the return type of the dynamic method, or  if the method has no return type.
    - Parameter parameterTypes: An array of  objects specifying the types of the parameters of the dynamic method, or  if the method has no parameters.
    - Parameter restrictedSkipVisibility: 
         to skip JIT visibility checks on types and members accessed by the MSIL of the dynamic method, with this restriction: the trust level of the assemblies that contain those types and members must be equal to or less than the trust level of the call stack that emits the dynamic method; otherwise, .
    */
    public init(name : dotnet.System.String, returnType : Optional<dotnet.System.Type_>, parameterTypes : Optional<dotnet.System_Arr<dotnet.System.Type_>>, restrictedSkipVisibility : Bool) throws {
        var __thrown : NullableHandle = nil;
        let h = System_Reflection_Emit_DynamicMethod_ctor_0__4__String_Type_TypeArray_bool(&__thrown, name.get_handle(), returnType?.get_handle() ?? nil, (parameterTypes?.get_handle()), Swift.Int32(restrictedSkipVisibility ? 1 : 0));
        if let __ex = __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
            super.init(hndl: h);
        }
    }
    // .ctor(System.String, System.Type, System.Type[], System.Reflection.Module)
// docid: M:System.Reflection.Emit.DynamicMethod.#ctor(System.String,System.Type,System.Type[],System.Reflection.Module)
    /**
    Creates a dynamic method that is global to a module, specifying the method name, return type, parameter types, and module.

    - Parameter name: The name of the dynamic method. This can be a zero-length string, but it cannot be .
    - Parameter returnType: A  object that specifies the return type of the dynamic method, or  if the method has no return type.
    - Parameter parameterTypes: An array of  objects specifying the types of the parameters of the dynamic method, or  if the method has no parameters.
    - Parameter m: A  representing the module with which the dynamic method is to be logically associated.
    */
    public init(name : dotnet.System.String, returnType : Optional<dotnet.System.Type_>, parameterTypes : Optional<dotnet.System_Arr<dotnet.System.Type_>>, m : dotnet.System.Reflection.Module) throws {
        var __thrown : NullableHandle = nil;
        let h = System_Reflection_Emit_DynamicMethod_ctor_0__4__String_Type_TypeArray_Module(&__thrown, name.get_handle(), returnType?.get_handle() ?? nil, (parameterTypes?.get_handle()), m.get_handle());
        if let __ex = __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
            super.init(hndl: h);
        }
    }
    // .ctor(System.String, System.Type, System.Type[], System.Reflection.Module, bool)
// docid: M:System.Reflection.Emit.DynamicMethod.#ctor(System.String,System.Type,System.Type[],System.Reflection.Module,System.Boolean)
    /**
    Creates a dynamic method that is global to a module, specifying the method name, return type, parameter types, module, and whether just-in-time (JIT) visibility checks should be skipped for types and members accessed by the Microsoft intermediate language (MSIL) of the dynamic method.

    - Parameter name: The name of the dynamic method. This can be a zero-length string, but it cannot be .
    - Parameter returnType: A  object that specifies the return type of the dynamic method, or  if the method has no return type.
    - Parameter parameterTypes: An array of  objects specifying the types of the parameters of the dynamic method, or  if the method has no parameters.
    - Parameter m: A  representing the module with which the dynamic method is to be logically associated.
    - Parameter skipVisibility: 
         to skip JIT visibility checks on types and members accessed by the MSIL of the dynamic method.
    */
    public init(name : dotnet.System.String, returnType : Optional<dotnet.System.Type_>, parameterTypes : Optional<dotnet.System_Arr<dotnet.System.Type_>>, m : dotnet.System.Reflection.Module, skipVisibility : Bool) throws {
        var __thrown : NullableHandle = nil;
        let h = System_Reflection_Emit_DynamicMethod_ctor_0__5__String_Type_TypeArray_Module_bool(&__thrown, name.get_handle(), returnType?.get_handle() ?? nil, (parameterTypes?.get_handle()), m.get_handle(), Swift.Int32(skipVisibility ? 1 : 0));
        if let __ex = __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
            super.init(hndl: h);
        }
    }
    // .ctor(System.String, System.Type, System.Type[], System.Type)
// docid: M:System.Reflection.Emit.DynamicMethod.#ctor(System.String,System.Type,System.Type[],System.Type)
    /**
    Creates a dynamic method, specifying the method name, return type, parameter types, and the type with which the dynamic method is logically associated.

    - Parameter name: The name of the dynamic method. This can be a zero-length string, but it cannot be .
    - Parameter returnType: A  object that specifies the return type of the dynamic method, or  if the method has no return type.
    - Parameter parameterTypes: An array of  objects specifying the types of the parameters of the dynamic method, or  if the method has no parameters.
    - Parameter owner: A  with which the dynamic method is logically associated. The dynamic method has access to all members of the type.
    */
    public init(name : dotnet.System.String, returnType : Optional<dotnet.System.Type_>, parameterTypes : Optional<dotnet.System_Arr<dotnet.System.Type_>>, owner : dotnet.System.Type_) throws {
        var __thrown : NullableHandle = nil;
        let h = System_Reflection_Emit_DynamicMethod_ctor_0__4__String_Type_TypeArray_Type(&__thrown, name.get_handle(), returnType?.get_handle() ?? nil, (parameterTypes?.get_handle()), owner.get_handle());
        if let __ex = __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
            super.init(hndl: h);
        }
    }
    // .ctor(System.String, System.Type, System.Type[], System.Type, bool)
// docid: M:System.Reflection.Emit.DynamicMethod.#ctor(System.String,System.Type,System.Type[],System.Type,System.Boolean)
    /**
    Creates a dynamic method, specifying the method name, return type, parameter types, the type with which the dynamic method is logically associated, and whether just-in-time (JIT) visibility checks should be skipped for types and members accessed by the Microsoft intermediate language (MSIL) of the dynamic method.

    - Parameter name: The name of the dynamic method. This can be a zero-length string, but it cannot be .
    - Parameter returnType: A  object that specifies the return type of the dynamic method, or  if the method has no return type.
    - Parameter parameterTypes: An array of  objects specifying the types of the parameters of the dynamic method, or  if the method has no parameters.
    - Parameter owner: A  with which the dynamic method is logically associated. The dynamic method has access to all members of the type.
    - Parameter skipVisibility: 
         to skip JIT visibility checks on types and members accessed by the MSIL of the dynamic method; otherwise, .
    */
    public init(name : dotnet.System.String, returnType : Optional<dotnet.System.Type_>, parameterTypes : Optional<dotnet.System_Arr<dotnet.System.Type_>>, owner : dotnet.System.Type_, skipVisibility : Bool) throws {
        var __thrown : NullableHandle = nil;
        let h = System_Reflection_Emit_DynamicMethod_ctor_0__5__String_Type_TypeArray_Type_bool(&__thrown, name.get_handle(), returnType?.get_handle() ?? nil, (parameterTypes?.get_handle()), owner.get_handle(), Swift.Int32(skipVisibility ? 1 : 0));
        if let __ex = __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
            super.init(hndl: h);
        }
    }
    // System.Delegate CreateDelegate(System.Type)
// docid: M:System.Reflection.Emit.DynamicMethod.CreateDelegate(System.Type)
    /**
    Completes the dynamic method and creates a delegate that can be used to execute it.

    - Parameter delegateType: A delegate type whose signature matches that of the dynamic method.
    - Returns: A delegate of the specified type, which can be used to execute the dynamic method.

    */
    public override func CreateDelegate(delegateType : dotnet.System.Type_) throws -> dotnet.System.Delegate {
        var __thrown : NullableHandle = nil;
        let __return = System_Reflection_Emit_DynamicMethod_Delegate__CreateDelegate_0__1__Type(&__thrown, self.get_handle(), delegateType.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return dotnet.System.Delegate(hndl : __return);
        }
    }
    // System.Delegate CreateDelegate(System.Type, System.Object)
// docid: M:System.Reflection.Emit.DynamicMethod.CreateDelegate(System.Type,System.Object)
    /**
    Completes the dynamic method and creates a delegate that can be used to execute it, specifying the delegate type and an object the delegate is bound to.

    - Parameter delegateType: A delegate type whose signature matches that of the dynamic method, minus the first parameter.
    - Parameter target: An object the delegate is bound to. Must be of the same type as the first parameter of the dynamic method.
    - Returns: A delegate of the specified type, which can be used to execute the dynamic method with the specified target object.

    */
    public override func CreateDelegate(delegateType : dotnet.System.Type_, target : Optional<dotnet.System.Object>) throws -> dotnet.System.Delegate {
        var __thrown : NullableHandle = nil;
        let __return = System_Reflection_Emit_DynamicMethod_Delegate__CreateDelegate_0__2__Type_Object(&__thrown, self.get_handle(), delegateType.get_handle(), target?.get_handle() ?? nil);
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return dotnet.System.Delegate(hndl : __return);
        }
    }
    // System.Reflection.Emit.ParameterBuilder DefineParameter(System.Int32, System.Reflection.ParameterAttributes, System.String)
// docid: M:System.Reflection.Emit.DynamicMethod.DefineParameter(System.Int32,System.Reflection.ParameterAttributes,System.String)
    /**
    Defines a parameter of the dynamic method.

    - Parameter position: The position of the parameter in the parameter list. Parameters are indexed beginning with the number 1 for the first parameter.
    - Parameter attributes: A bitwise combination of  values that specifies the attributes of the parameter.
    - Parameter parameterName: The name of the parameter. The name can be a zero-length string.
    - Returns: Always returns .

    */
    public func DefineParameter(position : Swift.Int32, attributes : dotnet.System.Reflection.ParameterAttributes, parameterName : Optional<dotnet.System.String>) throws -> Optional<dotnet.System.Reflection.Emit.ParameterBuilder> {
        var __thrown : NullableHandle = nil;
        let __return = System_Reflection_Emit_DynamicMethod_ParameterBuilder__DefineParameter_0__3__i32_ParameterAttributes_String(&__thrown, self.get_handle(), position, attributes.get_value(), parameterName?.get_handle() ?? nil);
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        if let __ret_unwrapped = __return {
            return dotnet.System.Reflection.Emit.ParameterBuilder(hndl : __ret_unwrapped);
        } else {
            return nil;
        }
        }
    }
    // System.Reflection.MethodInfo GetBaseDefinition()
// docid: M:System.Reflection.Emit.DynamicMethod.GetBaseDefinition
    /**
    Returns the base implementation for the method.

    - Returns: The base implementation of the method.

    */
    public override func GetBaseDefinition() throws -> dotnet.System.Reflection.MethodInfo {
        var __thrown : NullableHandle = nil;
        let __return = System_Reflection_Emit_DynamicMethod_MethodInfo__GetBaseDefinition_0__0(&__thrown, self.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return dotnet.System.Reflection.MethodInfo(hndl : __return);
        }
    }
    // System.Object[] GetCustomAttributes(bool)
// docid: M:System.Reflection.Emit.DynamicMethod.GetCustomAttributes(System.Boolean)
    /**
    Returns all the custom attributes defined for the method.

    - Parameter inherit: 
         to search the method's inheritance chain to find the custom attributes;  to check only the current method.
    - Returns: An array of objects representing all the custom attributes of the method.

    */
    public override func GetCustomAttributes(inherit : Bool) throws -> dotnet.System_Arr<dotnet.System.Object> {
        var __thrown : NullableHandle = nil;
        let __return = System_Reflection_Emit_DynamicMethod_ObjectArray__GetCustomAttributes_0__1__bool(&__thrown, self.get_handle(), Swift.Int32(inherit ? 1 : 0));
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return dotnet.System_Arr<dotnet.System.Object>(hndl : __return);
        }
    }
    // System.Object[] GetCustomAttributes(System.Type, bool)
// docid: M:System.Reflection.Emit.DynamicMethod.GetCustomAttributes(System.Type,System.Boolean)
    /**
    Returns the custom attributes of the specified type that have been applied to the method.

    - Parameter attributeType: A  representing the type of custom attribute to return.
    - Parameter inherit: 
         to search the method's inheritance chain to find the custom attributes;  to check only the current method.
    - Returns: An array of objects representing the attributes of the method that are of type  or derive from type .

    */
    public override func GetCustomAttributes(attributeType : dotnet.System.Type_, inherit : Bool) throws -> dotnet.System_Arr<dotnet.System.Object> {
        var __thrown : NullableHandle = nil;
        let __return = System_Reflection_Emit_DynamicMethod_ObjectArray__GetCustomAttributes_0__2__Type_bool(&__thrown, self.get_handle(), attributeType.get_handle(), Swift.Int32(inherit ? 1 : 0));
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return dotnet.System_Arr<dotnet.System.Object>(hndl : __return);
        }
    }
    // System.Reflection.Emit.DynamicILInfo GetDynamicILInfo()
// docid: M:System.Reflection.Emit.DynamicMethod.GetDynamicILInfo
    /**
    Returns a  object that can be used to generate a method body from metadata tokens, scopes, and Microsoft intermediate language (MSIL) streams.

    - Returns: A  object that can be used to generate a method body from metadata tokens, scopes, and MSIL streams.

    */
    public func GetDynamicILInfo() throws -> dotnet.System.Reflection.Emit.DynamicILInfo {
        var __thrown : NullableHandle = nil;
        let __return = System_Reflection_Emit_DynamicMethod_DynamicILInfo__GetDynamicILInfo_0__0(&__thrown, self.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return dotnet.System.Reflection.Emit.DynamicILInfo(hndl : __return);
        }
    }
    // System.Reflection.Emit.ILGenerator GetILGenerator()
// docid: M:System.Reflection.Emit.DynamicMethod.GetILGenerator
    /**
    Returns a Microsoft intermediate language (MSIL) generator for the method with a default MSIL stream size of 64 bytes.

    - Returns: An  object for the method.

    */
    public func GetILGenerator() throws -> dotnet.System.Reflection.Emit.ILGenerator {
        var __thrown : NullableHandle = nil;
        let __return = System_Reflection_Emit_DynamicMethod_ILGenerator__GetILGenerator_0__0(&__thrown, self.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return dotnet.System.Reflection.Emit.ILGenerator(hndl : __return);
        }
    }
    // System.Reflection.Emit.ILGenerator GetILGenerator(System.Int32)
// docid: M:System.Reflection.Emit.DynamicMethod.GetILGenerator(System.Int32)
    /**
    Returns a Microsoft intermediate language (MSIL) generator for the method with the specified MSIL stream size.

    - Parameter streamSize: The size of the MSIL stream, in bytes.
    - Returns: An  object for the method, with the specified MSIL stream size.

    */
    public func GetILGenerator(streamSize : Swift.Int32) throws -> dotnet.System.Reflection.Emit.ILGenerator {
        var __thrown : NullableHandle = nil;
        let __return = System_Reflection_Emit_DynamicMethod_ILGenerator__GetILGenerator_0__1__i32(&__thrown, self.get_handle(), streamSize);
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return dotnet.System.Reflection.Emit.ILGenerator(hndl : __return);
        }
    }
    // System.Reflection.MethodImplAttributes GetMethodImplementationFlags()
// docid: M:System.Reflection.Emit.DynamicMethod.GetMethodImplementationFlags
    /**
    Returns the implementation flags for the method.

    - Returns: A bitwise combination of  values representing the implementation flags for the method.

    */
    public override func GetMethodImplementationFlags() throws -> dotnet.System.Reflection.MethodImplAttributes {
        var __thrown : NullableHandle = nil;
        let __return = System_Reflection_Emit_DynamicMethod_MethodImplAttributes__GetMethodImplementationFlags_0__0(&__thrown, self.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return dotnet.System.Reflection.MethodImplAttributes(val: __return);
        }
    }
    // System.Reflection.ParameterInfo[] GetParameters()
// docid: M:System.Reflection.Emit.DynamicMethod.GetParameters
    /**
    Returns the parameters of the dynamic method.

    - Returns: An array of  objects that represent the parameters of the dynamic method.

    */
    public override func GetParameters() throws -> dotnet.System_Arr<dotnet.System.Reflection.ParameterInfo> {
        var __thrown : NullableHandle = nil;
        let __return = System_Reflection_Emit_DynamicMethod_ParameterInfoArray__GetParameters_0__0(&__thrown, self.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return dotnet.System_Arr<dotnet.System.Reflection.ParameterInfo>(hndl : __return);
        }
    }
    // System.Object Invoke(System.Object, System.Reflection.BindingFlags, System.Reflection.Binder, System.Object[], System.Globalization.CultureInfo)
// docid: M:System.Reflection.Emit.DynamicMethod.Invoke(System.Object,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo)
    /**
    Invokes the dynamic method using the specified parameters, under the constraints of the specified binder, with the specified culture information.

    - Parameter obj: This parameter is ignored for dynamic methods, because they are static. Specify .
    - Parameter invokeAttr: A bitwise combination of  values.
    - Parameter binder: A  object that enables the binding, coercion of argument types, invocation of members, and retrieval of  objects through reflection. If  is , the default binder is used. For more details, see .
    - Parameter parameters: An argument list. This is an array of arguments with the same number, order, and type as the parameters of the method to be invoked. If there are no parameters this parameter should be .
    - Parameter culture: An instance of  used to govern the coercion of types. If this is , the  for the current thread is used. For example, this information is needed to correctly convert a  that represents 1000 to a  value, because 1000 is represented differently by different cultures.
    - Returns: A  containing the return value of the invoked method.

    */
    public override func Invoke(obj : Optional<dotnet.System.Object>, invokeAttr : dotnet.System.Reflection.BindingFlags, binder : Optional<dotnet.System.Reflection.Binder>, parameters : Optional<dotnet.System_Arr<dotnet.System.Object>>, culture : Optional<dotnet.System.Globalization.CultureInfo>) throws -> Optional<dotnet.System.Object> {
        var __thrown : NullableHandle = nil;
        let __return = System_Reflection_Emit_DynamicMethod_Object__Invoke_0__5__Object_BindingFlags_Binder_ObjectArray_CultureInfo(&__thrown, self.get_handle(), obj?.get_handle() ?? nil, invokeAttr.get_value(), binder?.get_handle() ?? nil, (parameters?.get_handle()), culture?.get_handle() ?? nil);
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        if let __ret_unwrapped = __return {
            return dotnet.System.Object(hndl : __ret_unwrapped);
        } else {
            return nil;
        }
        }
    }
    // bool IsDefined(System.Type, bool)
// docid: M:System.Reflection.Emit.DynamicMethod.IsDefined(System.Type,System.Boolean)
    /**
    Indicates whether the specified custom attribute type is defined.

    - Parameter attributeType: A  representing the type of custom attribute to search for.
    - Parameter inherit: 
         to search the method's inheritance chain to find the custom attributes;  to check only the current method.
    - Returns: 
         if the specified custom attribute type is defined; otherwise, .

    */
    public override func IsDefined(attributeType : dotnet.System.Type_, inherit : Bool) throws -> Bool {
        var __thrown : NullableHandle = nil;
        let __return = System_Reflection_Emit_DynamicMethod_bool__IsDefined_0__2__Type_bool(&__thrown, self.get_handle(), attributeType.get_handle(), Swift.Int32(inherit ? 1 : 0));
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return (__return) != 0;
        }
    }
    // System.String ToString()
// docid: M:System.Reflection.Emit.DynamicMethod.ToString
    /**
    Returns the signature of the method, represented as a string.

    - Returns: A string representing the method signature.

    */
    public override func ToString() throws -> dotnet.System.String {
        var __thrown : NullableHandle = nil;
        let __return = System_Reflection_Emit_DynamicMethod_String__ToString_0__0(&__thrown, self.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return dotnet.System.String(hndl : __return);
        }
    }
    // [IsSpecialName] System.Reflection.MethodAttributes get_Attributes()
// docid: M:System.Reflection.Emit.DynamicMethod.get_Attributes
    public override func get_Attributes() throws -> dotnet.System.Reflection.MethodAttributes {
        var __thrown : NullableHandle = nil;
        let __return = System_Reflection_Emit_DynamicMethod_MethodAttributes__get_Attributes_0__0(&__thrown, self.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return dotnet.System.Reflection.MethodAttributes(val: __return);
        }
    }
    // [IsSpecialName] System.Reflection.CallingConventions get_CallingConvention()
// docid: M:System.Reflection.Emit.DynamicMethod.get_CallingConvention
    public override func get_CallingConvention() throws -> dotnet.System.Reflection.CallingConventions {
        var __thrown : NullableHandle = nil;
        let __return = System_Reflection_Emit_DynamicMethod_CallingConventions__get_CallingConvention_0__0(&__thrown, self.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return dotnet.System.Reflection.CallingConventions(val: __return);
        }
    }
    // [IsSpecialName] System.Type get_DeclaringType()
// docid: M:System.Reflection.Emit.DynamicMethod.get_DeclaringType
    public override func get_DeclaringType() throws -> Optional<dotnet.System.Type_> {
        var __thrown : NullableHandle = nil;
        let __return = System_Reflection_Emit_DynamicMethod_Type__get_DeclaringType_0__0(&__thrown, self.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        if let __ret_unwrapped = __return {
            return dotnet.System.Type_(hndl : __ret_unwrapped);
        } else {
            return nil;
        }
        }
    }
    // [IsSpecialName] bool get_InitLocals()
// docid: M:System.Reflection.Emit.DynamicMethod.get_InitLocals
    public func get_InitLocals() throws -> Bool {
        var __thrown : NullableHandle = nil;
        let __return = System_Reflection_Emit_DynamicMethod_bool__get_InitLocals_0__0(&__thrown, self.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return (__return) != 0;
        }
    }
    // [IsSpecialName] void set_InitLocals(bool)
// docid: M:System.Reflection.Emit.DynamicMethod.set_InitLocals(System.Boolean)
    public func set_InitLocals(value : Bool) throws {
        var __thrown : NullableHandle = nil;
        System_Reflection_Emit_DynamicMethod_void__set_InitLocals_0__1__bool(&__thrown, self.get_handle(), Swift.Int32(value ? 1 : 0));
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
            return;
        }
    }
    // [IsSpecialName] bool get_IsSecurityCritical()
// docid: M:System.Reflection.Emit.DynamicMethod.get_IsSecurityCritical
    public override func get_IsSecurityCritical() throws -> Bool {
        var __thrown : NullableHandle = nil;
        let __return = System_Reflection_Emit_DynamicMethod_bool__get_IsSecurityCritical_0__0(&__thrown, self.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return (__return) != 0;
        }
    }
    // [IsSpecialName] bool get_IsSecuritySafeCritical()
// docid: M:System.Reflection.Emit.DynamicMethod.get_IsSecuritySafeCritical
    public override func get_IsSecuritySafeCritical() throws -> Bool {
        var __thrown : NullableHandle = nil;
        let __return = System_Reflection_Emit_DynamicMethod_bool__get_IsSecuritySafeCritical_0__0(&__thrown, self.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return (__return) != 0;
        }
    }
    // [IsSpecialName] bool get_IsSecurityTransparent()
// docid: M:System.Reflection.Emit.DynamicMethod.get_IsSecurityTransparent
    public override func get_IsSecurityTransparent() throws -> Bool {
        var __thrown : NullableHandle = nil;
        let __return = System_Reflection_Emit_DynamicMethod_bool__get_IsSecurityTransparent_0__0(&__thrown, self.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return (__return) != 0;
        }
    }
    // [IsSpecialName] System.RuntimeMethodHandle get_MethodHandle()
// docid: M:System.Reflection.Emit.DynamicMethod.get_MethodHandle
    public override func get_MethodHandle() throws -> dotnet.System.RuntimeMethodHandle {
        var __thrown : NullableHandle = nil;
        let __return = System_Reflection_Emit_DynamicMethod_RuntimeMethodHandle__get_MethodHandle_0__0(&__thrown, self.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return dotnet.System.RuntimeMethodHandle(hndl : __return);
        }
    }
    // [IsSpecialName] System.Reflection.Module get_Module()
// docid: M:System.Reflection.Emit.DynamicMethod.get_Module
    public override func get_Module() throws -> dotnet.System.Reflection.Module {
        var __thrown : NullableHandle = nil;
        let __return = System_Reflection_Emit_DynamicMethod_Module__get_Module_0__0(&__thrown, self.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return dotnet.System.Reflection.Module(hndl : __return);
        }
    }
    // [IsSpecialName] System.String get_Name()
// docid: M:System.Reflection.Emit.DynamicMethod.get_Name
    public override func get_Name() throws -> dotnet.System.String {
        var __thrown : NullableHandle = nil;
        let __return = System_Reflection_Emit_DynamicMethod_String__get_Name_0__0(&__thrown, self.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return dotnet.System.String(hndl : __return);
        }
    }
    // [IsSpecialName] System.Type get_ReflectedType()
// docid: M:System.Reflection.Emit.DynamicMethod.get_ReflectedType
    public override func get_ReflectedType() throws -> Optional<dotnet.System.Type_> {
        var __thrown : NullableHandle = nil;
        let __return = System_Reflection_Emit_DynamicMethod_Type__get_ReflectedType_0__0(&__thrown, self.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        if let __ret_unwrapped = __return {
            return dotnet.System.Type_(hndl : __ret_unwrapped);
        } else {
            return nil;
        }
        }
    }
    // [IsSpecialName] System.Reflection.ParameterInfo get_ReturnParameter()
// docid: M:System.Reflection.Emit.DynamicMethod.get_ReturnParameter
    public override func get_ReturnParameter() throws -> dotnet.System.Reflection.ParameterInfo {
        var __thrown : NullableHandle = nil;
        let __return = System_Reflection_Emit_DynamicMethod_ParameterInfo__get_ReturnParameter_0__0(&__thrown, self.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return dotnet.System.Reflection.ParameterInfo(hndl : __return);
        }
    }
    // [IsSpecialName] System.Type get_ReturnType()
// docid: M:System.Reflection.Emit.DynamicMethod.get_ReturnType
    public override func get_ReturnType() throws -> dotnet.System.Type_ {
        var __thrown : NullableHandle = nil;
        let __return = System_Reflection_Emit_DynamicMethod_Type__get_ReturnType_0__0(&__thrown, self.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return dotnet.System.Type_(hndl : __return);
        }
    }
    // [IsSpecialName] System.Reflection.ICustomAttributeProvider get_ReturnTypeCustomAttributes()
// docid: M:System.Reflection.Emit.DynamicMethod.get_ReturnTypeCustomAttributes
    public override func get_ReturnTypeCustomAttributes() throws -> dotnet.System.Reflection.ICustomAttributeProvider {
        var __thrown : NullableHandle = nil;
        let __return = System_Reflection_Emit_DynamicMethod_ICustomAttributeProvider__get_ReturnTypeCustomAttributes_0__0(&__thrown, self.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return dotnet.System.Reflection.ICustomAttributeProvider(hndl : __return);
        }
    }
    /**
    Gets the attributes specified when the dynamic method was created.

    */
    public override var Attributes : dotnet.System.Reflection.MethodAttributes {
        get {
            return try! get_Attributes();
        }
    }
    /**
    Gets the calling convention specified when the dynamic method was created.

    */
    public override var CallingConvention : dotnet.System.Reflection.CallingConventions {
        get {
            return try! get_CallingConvention();
        }
    }
    /**
    Gets the type that declares the method, which is always  for dynamic methods.

    */
    public override var DeclaringType : Optional<dotnet.System.Type_> {
        get {
            return try! get_DeclaringType();
        }
    }
    /**
    Gets or sets a value indicating whether the local variables in the method are zero-initialized.

    */
    public var InitLocals : Bool {
        get {
            return try! get_InitLocals();
        }
        set(v) {
            return try! set_InitLocals(value: v);
        }
    }
    /**
    Gets a value that indicates whether the current dynamic method is security-critical or security-safe-critical, and therefore can perform critical operations.

    */
    public override var IsSecurityCritical : Bool {
        get {
            return try! get_IsSecurityCritical();
        }
    }
    /**
    Gets a value that indicates whether the current dynamic method is security-safe-critical at the current trust level; that is, whether it can perform critical operations and can be accessed by transparent code.

    */
    public override var IsSecuritySafeCritical : Bool {
        get {
            return try! get_IsSecuritySafeCritical();
        }
    }
    /**
    Gets a value that indicates whether the current dynamic method is transparent at the current trust level, and therefore cannot perform critical operations.

    */
    public override var IsSecurityTransparent : Bool {
        get {
            return try! get_IsSecurityTransparent();
        }
    }
    /**
    Not supported for dynamic methods.

    */
    public override var MethodHandle : dotnet.System.RuntimeMethodHandle {
        get {
            return try! get_MethodHandle();
        }
    }
    /**
    Gets the module with which the dynamic method is logically associated.

    */
    public override var Module : dotnet.System.Reflection.Module {
        get {
            return try! get_Module();
        }
    }
    /**
    Gets the name of the dynamic method.

    */
    public override var Name : dotnet.System.String {
        get {
            return try! get_Name();
        }
    }
    /**
    Gets the class that was used in reflection to obtain the method.

    */
    public override var ReflectedType : Optional<dotnet.System.Type_> {
        get {
            return try! get_ReflectedType();
        }
    }
    /**
    Gets the return parameter of the dynamic method.

    */
    public override var ReturnParameter : dotnet.System.Reflection.ParameterInfo {
        get {
            return try! get_ReturnParameter();
        }
    }
    /**
    Gets the type of return value for the dynamic method.

    */
    public override var ReturnType : dotnet.System.Type_ {
        get {
            return try! get_ReturnType();
        }
    }
    /**
    Gets the custom attributes of the return type for the dynamic method.

    */
    public override var ReturnTypeCustomAttributes : dotnet.System.Reflection.ICustomAttributeProvider {
        get {
            return try! get_ReturnTypeCustomAttributes();
        }
    }
} // DynamicMethod


}



