// this file is automatically generated
// Copyright 2021 SourceGear

import jumptable_dotnet;

// Microsoft
// Microsoft.Win32
// Microsoft.Win32.SafeHandles
extension Microsoft.Win32.SafeHandles {
// type: Microsoft.Win32.SafeHandles.SafePipeHandle
    /**
    Represents a wrapper class for a pipe handle.

    */
public final class SafePipeHandle
    :
    dotnet.Microsoft.Win32.SafeHandles.SafeHandleZeroOrMinusOneIsInvalid
{
    public class override func get_type_handle() -> TypeHandle {
        return Microsoft_Win32_SafeHandles_SafePipeHandle_get_type_handle();
    }
    public required init(hndl: NonnullHandle) { super.init(hndl: hndl); }
    public required init(gval: GVal) { super.init(gval: gval); }
    // .ctor()
// docid: M:Microsoft.Win32.SafeHandles.SafePipeHandle.#ctor
    public init() throws {
        var __thrown : NullableHandle = nil;
        let h = Microsoft_Win32_SafeHandles_SafePipeHandle_ctor_0__0(&__thrown);
        if let __ex = __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
            super.init(hndl: h);
        }
    }
    // .ctor(System.IntPtr, bool)
// docid: M:Microsoft.Win32.SafeHandles.SafePipeHandle.#ctor(System.IntPtr,System.Boolean)
    /**
    Initializes a new instance of the  class.

    - Parameter preexistingHandle: An  object that represents the pre-existing handle to use.
    - Parameter ownsHandle: 
         to reliably release the handle during the finalization phase;  to prevent reliable release (not recommended).
    */
    public init(preexistingHandle : dotnet.System.IntPtr, ownsHandle : Bool) throws {
        var __thrown : NullableHandle = nil;
        let h = Microsoft_Win32_SafeHandles_SafePipeHandle_ctor_0__2__IntPtr_bool(&__thrown, preexistingHandle.get_value(), Swift.Int32(ownsHandle ? 1 : 0));
        if let __ex = __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
            super.init(hndl: h);
        }
    }
    // [IsSpecialName] bool get_IsInvalid()
// docid: M:Microsoft.Win32.SafeHandles.SafePipeHandle.get_IsInvalid
    public override func get_IsInvalid() throws -> Bool {
        var __thrown : NullableHandle = nil;
        let __return = Microsoft_Win32_SafeHandles_SafePipeHandle_bool__get_IsInvalid_0__0(&__thrown, self.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return (__return) != 0;
        }
    }
    /**
    Gets a value that indicates whether the handle is invalid.

    */
    public override var IsInvalid : Bool {
        get {
            return try! get_IsInvalid();
        }
    }
} // SafePipeHandle


}



// System
// System.IO
// System.IO.Pipes
extension System.IO.Pipes {
// type: System.IO.Pipes.AnonymousPipeClientStream
    /**
    Exposes the client side of an anonymous pipe stream, which supports both synchronous and asynchronous read and write operations.

    */
public final class AnonymousPipeClientStream
    :
    dotnet.System.IO.Pipes.PipeStream
{
    public class override func get_type_handle() -> TypeHandle {
        return System_IO_Pipes_AnonymousPipeClientStream_get_type_handle();
    }
    public required init(hndl: NonnullHandle) { super.init(hndl: hndl); }
    public required init(gval: GVal) { super.init(gval: gval); }
    // .ctor(System.IO.Pipes.PipeDirection, Microsoft.Win32.SafeHandles.SafePipeHandle)
// docid: M:System.IO.Pipes.AnonymousPipeClientStream.#ctor(System.IO.Pipes.PipeDirection,Microsoft.Win32.SafeHandles.SafePipeHandle)
    /**
    Initializes a new instance of the  class from the specified handle.

    - Parameter direction: One of the enumeration values that determines the direction of the pipe.  
  
 Anonymous pipes can only be in one direction, so  cannot be set to .
    - Parameter safePipeHandle: A safe handle for the pipe that this  object will encapsulate.
    */
    public init(direction : dotnet.System.IO.Pipes.PipeDirection, safePipeHandle : dotnet.Microsoft.Win32.SafeHandles.SafePipeHandle) throws {
        var __thrown : NullableHandle = nil;
        let h = System_IO_Pipes_AnonymousPipeClientStream_ctor_0__2__PipeDirection_SafePipeHandle(&__thrown, direction.get_value(), safePipeHandle.get_handle());
        if let __ex = __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
            super.init(hndl: h);
        }
    }
    // .ctor(System.IO.Pipes.PipeDirection, System.String)
// docid: M:System.IO.Pipes.AnonymousPipeClientStream.#ctor(System.IO.Pipes.PipeDirection,System.String)
    /**
    Initializes a new instance of the  class with the specified pipe direction and a string representation of the pipe handle.

    - Parameter direction: One of the enumeration values that determines the direction of the pipe.  
  
 Anonymous pipes can only be in one direction, so  cannot be set to .
    - Parameter pipeHandleAsString: A string that represents the pipe handle.
    */
    public init(direction : dotnet.System.IO.Pipes.PipeDirection, pipeHandleAsString : dotnet.System.String) throws {
        var __thrown : NullableHandle = nil;
        let h = System_IO_Pipes_AnonymousPipeClientStream_ctor_0__2__PipeDirection_String(&__thrown, direction.get_value(), pipeHandleAsString.get_handle());
        if let __ex = __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
            super.init(hndl: h);
        }
    }
    // .ctor(System.String)
// docid: M:System.IO.Pipes.AnonymousPipeClientStream.#ctor(System.String)
    /**
    Initializes a new instance of the  class with the specified string representation of the pipe handle.

    - Parameter pipeHandleAsString: A string that represents the pipe handle.
    */
    public init(pipeHandleAsString : dotnet.System.String) throws {
        var __thrown : NullableHandle = nil;
        let h = System_IO_Pipes_AnonymousPipeClientStream_ctor_0__1__String(&__thrown, pipeHandleAsString.get_handle());
        if let __ex = __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
            super.init(hndl: h);
        }
    }
    // [IsSpecialName] void set_ReadMode(System.IO.Pipes.PipeTransmissionMode)
// docid: M:System.IO.Pipes.AnonymousPipeClientStream.set_ReadMode(System.IO.Pipes.PipeTransmissionMode)
    public override func set_ReadMode(value : dotnet.System.IO.Pipes.PipeTransmissionMode) throws {
        var __thrown : NullableHandle = nil;
        System_IO_Pipes_AnonymousPipeClientStream_void__set_ReadMode_0__1__PipeTransmissionMode(&__thrown, self.get_handle(), value.get_value());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
            return;
        }
    }
    // [IsSpecialName] System.IO.Pipes.PipeTransmissionMode get_TransmissionMode()
// docid: M:System.IO.Pipes.AnonymousPipeClientStream.get_TransmissionMode
    public override func get_TransmissionMode() throws -> dotnet.System.IO.Pipes.PipeTransmissionMode {
        var __thrown : NullableHandle = nil;
        let __return = System_IO_Pipes_AnonymousPipeClientStream_PipeTransmissionMode__get_TransmissionMode_0__0(&__thrown, self.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return dotnet.System.IO.Pipes.PipeTransmissionMode(val: __return);
        }
    }
    /**
    Gets the pipe transmission mode supported by the current pipe.

    */
    public override var TransmissionMode : dotnet.System.IO.Pipes.PipeTransmissionMode {
        get {
            return try! get_TransmissionMode();
        }
    }
} // AnonymousPipeClientStream


// type: System.IO.Pipes.AnonymousPipeServerStream
    /**
    Exposes a stream around an anonymous pipe, which supports both synchronous and asynchronous read and write operations.

    */
public final class AnonymousPipeServerStream
    :
    dotnet.System.IO.Pipes.PipeStream
{
    public class override func get_type_handle() -> TypeHandle {
        return System_IO_Pipes_AnonymousPipeServerStream_get_type_handle();
    }
    public required init(hndl: NonnullHandle) { super.init(hndl: hndl); }
    public required init(gval: GVal) { super.init(gval: gval); }
    // .ctor()
// docid: M:System.IO.Pipes.AnonymousPipeServerStream.#ctor
    /**
    Initializes a new instance of the  class.

    */
    public init() throws {
        var __thrown : NullableHandle = nil;
        let h = System_IO_Pipes_AnonymousPipeServerStream_ctor_0__0(&__thrown);
        if let __ex = __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
            super.init(hndl: h);
        }
    }
    // .ctor(System.IO.Pipes.PipeDirection)
// docid: M:System.IO.Pipes.AnonymousPipeServerStream.#ctor(System.IO.Pipes.PipeDirection)
    /**
    Initializes a new instance of the  class with the specified pipe direction.

    - Parameter direction: One of the enumeration values that determines the direction of the pipe.  
  
 Anonymous pipes can only be in one direction, so  cannot be set to .
    */
    public init(direction : dotnet.System.IO.Pipes.PipeDirection) throws {
        var __thrown : NullableHandle = nil;
        let h = System_IO_Pipes_AnonymousPipeServerStream_ctor_0__1__PipeDirection(&__thrown, direction.get_value());
        if let __ex = __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
            super.init(hndl: h);
        }
    }
    // .ctor(System.IO.Pipes.PipeDirection, Microsoft.Win32.SafeHandles.SafePipeHandle, Microsoft.Win32.SafeHandles.SafePipeHandle)
// docid: M:System.IO.Pipes.AnonymousPipeServerStream.#ctor(System.IO.Pipes.PipeDirection,Microsoft.Win32.SafeHandles.SafePipeHandle,Microsoft.Win32.SafeHandles.SafePipeHandle)
    /**
    Initializes a new instance of the  class from the specified pipe handles.

    - Parameter direction: One of the enumeration values that determines the direction of the pipe.  
  
 Anonymous pipes can only be in one direction, so  cannot be set to .
    - Parameter serverSafePipeHandle: A safe handle for the pipe that this  object will encapsulate.
    - Parameter clientSafePipeHandle: A safe handle for the  object.
    */
    public init(direction : dotnet.System.IO.Pipes.PipeDirection, serverSafePipeHandle : dotnet.Microsoft.Win32.SafeHandles.SafePipeHandle, clientSafePipeHandle : dotnet.Microsoft.Win32.SafeHandles.SafePipeHandle) throws {
        var __thrown : NullableHandle = nil;
        let h = System_IO_Pipes_AnonymousPipeServerStream_ctor_0__3__PipeDirection_SafePipeHandle_SafePipeHandle(&__thrown, direction.get_value(), serverSafePipeHandle.get_handle(), clientSafePipeHandle.get_handle());
        if let __ex = __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
            super.init(hndl: h);
        }
    }
    // .ctor(System.IO.Pipes.PipeDirection, System.IO.HandleInheritability)
// docid: M:System.IO.Pipes.AnonymousPipeServerStream.#ctor(System.IO.Pipes.PipeDirection,System.IO.HandleInheritability)
    /**
    Initializes a new instance of the  class with the specified pipe direction and inheritability mode.

    - Parameter direction: One of the enumeration values that determines the direction of the pipe.  
  
 Anonymous pipes can only be in one direction, so  cannot be set to .
    - Parameter inheritability: One of the enumeration values that determines whether the underlying handle can be inherited by child processes. Must be set to either  or .
    */
    public init(direction : dotnet.System.IO.Pipes.PipeDirection, inheritability : dotnet.System.IO.HandleInheritability) throws {
        var __thrown : NullableHandle = nil;
        let h = System_IO_Pipes_AnonymousPipeServerStream_ctor_0__2__PipeDirection_HandleInheritability(&__thrown, direction.get_value(), inheritability.get_value());
        if let __ex = __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
            super.init(hndl: h);
        }
    }
    // .ctor(System.IO.Pipes.PipeDirection, System.IO.HandleInheritability, System.Int32)
// docid: M:System.IO.Pipes.AnonymousPipeServerStream.#ctor(System.IO.Pipes.PipeDirection,System.IO.HandleInheritability,System.Int32)
    /**
    Initializes a new instance of the  class with the specified pipe direction, inheritability mode, and buffer size.

    - Parameter direction: One of the enumeration values that determines the direction of the pipe.  
  
 Anonymous pipes can only be in one direction, so  cannot be set to .
    - Parameter inheritability: One of the enumeration values that determines whether the underlying handle can be inherited by child processes. Must be set to either  or .
    - Parameter bufferSize: The size of the buffer. This value must be greater than or equal to 0.
    */
    public init(direction : dotnet.System.IO.Pipes.PipeDirection, inheritability : dotnet.System.IO.HandleInheritability, bufferSize : Swift.Int32) throws {
        var __thrown : NullableHandle = nil;
        let h = System_IO_Pipes_AnonymousPipeServerStream_ctor_0__3__PipeDirection_HandleInheritability_i32(&__thrown, direction.get_value(), inheritability.get_value(), bufferSize);
        if let __ex = __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
            super.init(hndl: h);
        }
    }
    // void DisposeLocalCopyOfClientHandle()
// docid: M:System.IO.Pipes.AnonymousPipeServerStream.DisposeLocalCopyOfClientHandle
    /**
    Closes the local copy of the  object's handle.

    */
    public func DisposeLocalCopyOfClientHandle() throws {
        var __thrown : NullableHandle = nil;
        System_IO_Pipes_AnonymousPipeServerStream_void__DisposeLocalCopyOfClientHandle_0__0(&__thrown, self.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
            return;
        }
    }
    // System.String GetClientHandleAsString()
// docid: M:System.IO.Pipes.AnonymousPipeServerStream.GetClientHandleAsString
    /**
    Gets the connected  object's handle as a string.

    - Returns: A string that represents the connected  object's handle.

    */
    public func GetClientHandleAsString() throws -> dotnet.System.String {
        var __thrown : NullableHandle = nil;
        let __return = System_IO_Pipes_AnonymousPipeServerStream_String__GetClientHandleAsString_0__0(&__thrown, self.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return dotnet.System.String(hndl : __return);
        }
    }
    // [IsSpecialName] Microsoft.Win32.SafeHandles.SafePipeHandle get_ClientSafePipeHandle()
// docid: M:System.IO.Pipes.AnonymousPipeServerStream.get_ClientSafePipeHandle
    public func get_ClientSafePipeHandle() throws -> dotnet.Microsoft.Win32.SafeHandles.SafePipeHandle {
        var __thrown : NullableHandle = nil;
        let __return = System_IO_Pipes_AnonymousPipeServerStream_SafePipeHandle__get_ClientSafePipeHandle_0__0(&__thrown, self.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return dotnet.Microsoft.Win32.SafeHandles.SafePipeHandle(hndl : __return);
        }
    }
    // [IsSpecialName] void set_ReadMode(System.IO.Pipes.PipeTransmissionMode)
// docid: M:System.IO.Pipes.AnonymousPipeServerStream.set_ReadMode(System.IO.Pipes.PipeTransmissionMode)
    public override func set_ReadMode(value : dotnet.System.IO.Pipes.PipeTransmissionMode) throws {
        var __thrown : NullableHandle = nil;
        System_IO_Pipes_AnonymousPipeServerStream_void__set_ReadMode_0__1__PipeTransmissionMode(&__thrown, self.get_handle(), value.get_value());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
            return;
        }
    }
    // [IsSpecialName] System.IO.Pipes.PipeTransmissionMode get_TransmissionMode()
// docid: M:System.IO.Pipes.AnonymousPipeServerStream.get_TransmissionMode
    public override func get_TransmissionMode() throws -> dotnet.System.IO.Pipes.PipeTransmissionMode {
        var __thrown : NullableHandle = nil;
        let __return = System_IO_Pipes_AnonymousPipeServerStream_PipeTransmissionMode__get_TransmissionMode_0__0(&__thrown, self.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return dotnet.System.IO.Pipes.PipeTransmissionMode(val: __return);
        }
    }
    /**
    Gets the safe handle for the  object that is currently connected to the  object.

    */
    public var ClientSafePipeHandle : dotnet.Microsoft.Win32.SafeHandles.SafePipeHandle {
        get {
            return try! get_ClientSafePipeHandle();
        }
    }
    /**
    Gets the pipe transmission mode that is supported by the current pipe.

    */
    public override var TransmissionMode : dotnet.System.IO.Pipes.PipeTransmissionMode {
        get {
            return try! get_TransmissionMode();
        }
    }
} // AnonymousPipeServerStream


// type: System.IO.Pipes.NamedPipeClientStream
    /**
    Exposes a  around a named pipe, which supports both synchronous and asynchronous read and write operations.

    */
public final class NamedPipeClientStream
    :
    dotnet.System.IO.Pipes.PipeStream
{
    public class override func get_type_handle() -> TypeHandle {
        return System_IO_Pipes_NamedPipeClientStream_get_type_handle();
    }
    public required init(hndl: NonnullHandle) { super.init(hndl: hndl); }
    public required init(gval: GVal) { super.init(gval: gval); }
    // .ctor(System.IO.Pipes.PipeDirection, bool, bool, Microsoft.Win32.SafeHandles.SafePipeHandle)
// docid: M:System.IO.Pipes.NamedPipeClientStream.#ctor(System.IO.Pipes.PipeDirection,System.Boolean,System.Boolean,Microsoft.Win32.SafeHandles.SafePipeHandle)
    /**
    Initializes a new instance of the  class for the specified pipe handle with the specified pipe direction.

    - Parameter direction: One of the enumeration values that determines the direction of the pipe.
    - Parameter isAsync: 
         to indicate that the handle was opened asynchronously; otherwise, .
    - Parameter isConnected: 
         to indicate that the pipe is connected; otherwise, .
    - Parameter safePipeHandle: A safe handle for the pipe that this  object will encapsulate.
    */
    public init(direction : dotnet.System.IO.Pipes.PipeDirection, isAsync : Bool, isConnected : Bool, safePipeHandle : dotnet.Microsoft.Win32.SafeHandles.SafePipeHandle) throws {
        var __thrown : NullableHandle = nil;
        let h = System_IO_Pipes_NamedPipeClientStream_ctor_0__4__PipeDirection_bool_bool_SafePipeHandle(&__thrown, direction.get_value(), Swift.Int32(isAsync ? 1 : 0), Swift.Int32(isConnected ? 1 : 0), safePipeHandle.get_handle());
        if let __ex = __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
            super.init(hndl: h);
        }
    }
    // .ctor(System.String)
// docid: M:System.IO.Pipes.NamedPipeClientStream.#ctor(System.String)
    /**
    Initializes a new instance of the  class with the specified pipe name.

    - Parameter pipeName: The name of the pipe.
    */
    public init(pipeName : dotnet.System.String) throws {
        var __thrown : NullableHandle = nil;
        let h = System_IO_Pipes_NamedPipeClientStream_ctor_0__1__String(&__thrown, pipeName.get_handle());
        if let __ex = __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
            super.init(hndl: h);
        }
    }
    // .ctor(System.String, System.String)
// docid: M:System.IO.Pipes.NamedPipeClientStream.#ctor(System.String,System.String)
    /**
    Initializes a new instance of the  class with the specified pipe and server names.

    - Parameter serverName: The name of the remote computer to connect to, or "." to specify the local computer.
    - Parameter pipeName: The name of the pipe.
    */
    public init(serverName : dotnet.System.String, pipeName : dotnet.System.String) throws {
        var __thrown : NullableHandle = nil;
        let h = System_IO_Pipes_NamedPipeClientStream_ctor_0__2__String_String(&__thrown, serverName.get_handle(), pipeName.get_handle());
        if let __ex = __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
            super.init(hndl: h);
        }
    }
    // .ctor(System.String, System.String, System.IO.Pipes.PipeDirection)
// docid: M:System.IO.Pipes.NamedPipeClientStream.#ctor(System.String,System.String,System.IO.Pipes.PipeDirection)
    /**
    Initializes a new instance of the  class with the specified pipe and server names, and the specified pipe direction.

    - Parameter serverName: The name of the remote computer to connect to, or "." to specify the local computer.
    - Parameter pipeName: The name of the pipe.
    - Parameter direction: One of the enumeration values that determines the direction of the pipe.
    */
    public init(serverName : dotnet.System.String, pipeName : dotnet.System.String, direction : dotnet.System.IO.Pipes.PipeDirection) throws {
        var __thrown : NullableHandle = nil;
        let h = System_IO_Pipes_NamedPipeClientStream_ctor_0__3__String_String_PipeDirection(&__thrown, serverName.get_handle(), pipeName.get_handle(), direction.get_value());
        if let __ex = __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
            super.init(hndl: h);
        }
    }
    // .ctor(System.String, System.String, System.IO.Pipes.PipeDirection, System.IO.Pipes.PipeOptions)
// docid: M:System.IO.Pipes.NamedPipeClientStream.#ctor(System.String,System.String,System.IO.Pipes.PipeDirection,System.IO.Pipes.PipeOptions)
    /**
    Initializes a new instance of the  class with the specified pipe and server names, and the specified pipe direction and pipe options.

    - Parameter serverName: The name of the remote computer to connect to, or "." to specify the local computer.
    - Parameter pipeName: The name of the pipe.
    - Parameter direction: One of the enumeration values that determines the direction of the pipe.
    - Parameter options: One of the enumeration values that determines how to open or create the pipe.
    */
    public init(serverName : dotnet.System.String, pipeName : dotnet.System.String, direction : dotnet.System.IO.Pipes.PipeDirection, options : dotnet.System.IO.Pipes.PipeOptions) throws {
        var __thrown : NullableHandle = nil;
        let h = System_IO_Pipes_NamedPipeClientStream_ctor_0__4__String_String_PipeDirection_PipeOptions(&__thrown, serverName.get_handle(), pipeName.get_handle(), direction.get_value(), options.get_value());
        if let __ex = __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
            super.init(hndl: h);
        }
    }
    // .ctor(System.String, System.String, System.IO.Pipes.PipeDirection, System.IO.Pipes.PipeOptions, System.Security.Principal.TokenImpersonationLevel)
// docid: M:System.IO.Pipes.NamedPipeClientStream.#ctor(System.String,System.String,System.IO.Pipes.PipeDirection,System.IO.Pipes.PipeOptions,System.Security.Principal.TokenImpersonationLevel)
    /**
    Initializes a new instance of the  class with the specified pipe and server names, and the specified pipe direction, pipe options, and security impersonation level.

    - Parameter serverName: The name of the remote computer to connect to, or "." to specify the local computer.
    - Parameter pipeName: The name of the pipe.
    - Parameter direction: One of the enumeration values that determines the direction of the pipe.
    - Parameter options: One of the enumeration values that determines how to open or create the pipe.
    - Parameter impersonationLevel: One of the enumeration values that determines the security impersonation level.
    */
    public init(serverName : dotnet.System.String, pipeName : dotnet.System.String, direction : dotnet.System.IO.Pipes.PipeDirection, options : dotnet.System.IO.Pipes.PipeOptions, impersonationLevel : dotnet.System.Security.Principal.TokenImpersonationLevel) throws {
        var __thrown : NullableHandle = nil;
        let h = System_IO_Pipes_NamedPipeClientStream_ctor_0__5__String_String_PipeDirection_PipeOptions_TokenImpersonationLevel(&__thrown, serverName.get_handle(), pipeName.get_handle(), direction.get_value(), options.get_value(), impersonationLevel.get_value());
        if let __ex = __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
            super.init(hndl: h);
        }
    }
    // .ctor(System.String, System.String, System.IO.Pipes.PipeDirection, System.IO.Pipes.PipeOptions, System.Security.Principal.TokenImpersonationLevel, System.IO.HandleInheritability)
// docid: M:System.IO.Pipes.NamedPipeClientStream.#ctor(System.String,System.String,System.IO.Pipes.PipeDirection,System.IO.Pipes.PipeOptions,System.Security.Principal.TokenImpersonationLevel,System.IO.HandleInheritability)
    /**
    Initializes a new instance of the  class with the specified pipe and server names, and the specified pipe direction, pipe options, security impersonation level, and inheritability mode.

    - Parameter serverName: The name of the remote computer to connect to, or "." to specify the local computer.
    - Parameter pipeName: The name of the pipe.
    - Parameter direction: One of the enumeration values that determines the direction of the pipe.
    - Parameter options: One of the enumeration values that determines how to open or create the pipe.
    - Parameter impersonationLevel: One of the enumeration values that determines the security impersonation level.
    - Parameter inheritability: One of the enumeration values that determines whether the underlying handle will be inheritable by child processes.
    */
    public init(serverName : dotnet.System.String, pipeName : dotnet.System.String, direction : dotnet.System.IO.Pipes.PipeDirection, options : dotnet.System.IO.Pipes.PipeOptions, impersonationLevel : dotnet.System.Security.Principal.TokenImpersonationLevel, inheritability : dotnet.System.IO.HandleInheritability) throws {
        var __thrown : NullableHandle = nil;
        let h = System_IO_Pipes_NamedPipeClientStream_ctor_0__6__String_String_PipeDirection_PipeOptions_TokenImpersonationLevel_HandleInheritability(&__thrown, serverName.get_handle(), pipeName.get_handle(), direction.get_value(), options.get_value(), impersonationLevel.get_value(), inheritability.get_value());
        if let __ex = __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
            super.init(hndl: h);
        }
    }
    // void Connect()
// docid: M:System.IO.Pipes.NamedPipeClientStream.Connect
    /**
    Connects to a waiting server with an infinite time-out value.

    */
    public func Connect() throws {
        var __thrown : NullableHandle = nil;
        System_IO_Pipes_NamedPipeClientStream_void__Connect_0__0(&__thrown, self.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
            return;
        }
    }
    // void Connect(System.Int32)
// docid: M:System.IO.Pipes.NamedPipeClientStream.Connect(System.Int32)
    /**
    Connects to a waiting server within the specified time-out period.

    - Parameter timeout: The number of milliseconds to wait for the server to respond before the connection times out.
    */
    public func Connect(timeout : Swift.Int32) throws {
        var __thrown : NullableHandle = nil;
        System_IO_Pipes_NamedPipeClientStream_void__Connect_0__1__i32(&__thrown, self.get_handle(), timeout);
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
            return;
        }
    }
    // System.Threading.Tasks.Task ConnectAsync()
// docid: M:System.IO.Pipes.NamedPipeClientStream.ConnectAsync
    /**
    Asynchronously connects to a waiting server with an infinite timeout period.

    - Returns: A task that represents the asynchronous connect operation.

    */
    public func ConnectAsync() throws -> dotnet.System.Threading.Tasks.Task {
        var __thrown : NullableHandle = nil;
        let __return = System_IO_Pipes_NamedPipeClientStream_Task__ConnectAsync_0__0(&__thrown, self.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return dotnet.System.Threading.Tasks.Task(hndl : __return);
        }
    }
    // System.Threading.Tasks.Task ConnectAsync(System.Int32)
// docid: M:System.IO.Pipes.NamedPipeClientStream.ConnectAsync(System.Int32)
    /**
    Asynchronously connects to a waiting server within the specified timeout period.

    - Parameter timeout: The number of milliseconds to wait for the server to respond before the connection times out.
    - Returns: A task that represents the asynchronous connect operation.

    */
    public func ConnectAsync(timeout : Swift.Int32) throws -> dotnet.System.Threading.Tasks.Task {
        var __thrown : NullableHandle = nil;
        let __return = System_IO_Pipes_NamedPipeClientStream_Task__ConnectAsync_0__1__i32(&__thrown, self.get_handle(), timeout);
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return dotnet.System.Threading.Tasks.Task(hndl : __return);
        }
    }
    // System.Threading.Tasks.Task ConnectAsync(System.Int32, System.Threading.CancellationToken)
// docid: M:System.IO.Pipes.NamedPipeClientStream.ConnectAsync(System.Int32,System.Threading.CancellationToken)
    /**
    Asynchronously connects to a waiting server within the specified timeout period and monitors cancellation requests.

    - Parameter timeout: The number of milliseconds to wait for the server to respond before the connection times out.
    - Parameter cancellationToken: The token to monitor for cancellation requests. The default value is .
    - Returns: A task that represents the asynchronous connect operation.

    */
    public func ConnectAsync(timeout : Swift.Int32, cancellationToken : dotnet.System.Threading.CancellationToken) throws -> dotnet.System.Threading.Tasks.Task {
        var __thrown : NullableHandle = nil;
        let __return = System_IO_Pipes_NamedPipeClientStream_Task__ConnectAsync_0__2__i32_CancellationToken(&__thrown, self.get_handle(), timeout, cancellationToken.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return dotnet.System.Threading.Tasks.Task(hndl : __return);
        }
    }
    // System.Threading.Tasks.Task ConnectAsync(System.Threading.CancellationToken)
// docid: M:System.IO.Pipes.NamedPipeClientStream.ConnectAsync(System.Threading.CancellationToken)
    /**
    Asynchronously connects to a waiting server and monitors cancellation requests.

    - Parameter cancellationToken: The token to monitor for cancellation requests. The default value is .
    - Returns: A task that represents the asynchronous connect operation.

    */
    public func ConnectAsync(cancellationToken : dotnet.System.Threading.CancellationToken) throws -> dotnet.System.Threading.Tasks.Task {
        var __thrown : NullableHandle = nil;
        let __return = System_IO_Pipes_NamedPipeClientStream_Task__ConnectAsync_0__1__CancellationToken(&__thrown, self.get_handle(), cancellationToken.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return dotnet.System.Threading.Tasks.Task(hndl : __return);
        }
    }
    // [IsSpecialName] System.Int32 get_NumberOfServerInstances()
// docid: M:System.IO.Pipes.NamedPipeClientStream.get_NumberOfServerInstances
    public func get_NumberOfServerInstances() throws -> Swift.Int32 {
        var __thrown : NullableHandle = nil;
        let __return = System_IO_Pipes_NamedPipeClientStream_i32__get_NumberOfServerInstances_0__0(&__thrown, self.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return __return;
        }
    }
    /**
    Gets the number of server instances that share the same pipe name.

    */
    public var NumberOfServerInstances : Swift.Int32 {
        get {
            return try! get_NumberOfServerInstances();
        }
    }
} // NamedPipeClientStream


// type: System.IO.Pipes.NamedPipeServerStream
    /**
    Exposes a  around a named pipe, supporting both synchronous and asynchronous read and write operations.

    */
public final class NamedPipeServerStream
    :
    dotnet.System.IO.Pipes.PipeStream
{
    public class override func get_type_handle() -> TypeHandle {
        return System_IO_Pipes_NamedPipeServerStream_get_type_handle();
    }
    public required init(hndl: NonnullHandle) { super.init(hndl: hndl); }
    public required init(gval: GVal) { super.init(gval: gval); }
    // static field: System.Int32 MaxAllowedServerInstances
    /**
    Represents the maximum number of server instances that the system resources allow.

    */
    public class var MaxAllowedServerInstances : Swift.Int32 {
        get {
        let __return = System_IO_Pipes_NamedPipeServerStream_get_MaxAllowedServerInstances();
            return __return;
        }
    }
    // .ctor(System.IO.Pipes.PipeDirection, bool, bool, Microsoft.Win32.SafeHandles.SafePipeHandle)
// docid: M:System.IO.Pipes.NamedPipeServerStream.#ctor(System.IO.Pipes.PipeDirection,System.Boolean,System.Boolean,Microsoft.Win32.SafeHandles.SafePipeHandle)
    /**
    Initializes a new instance of the  class from the specified pipe handle.

    - Parameter direction: One of the enumeration values that determines the direction of the pipe.
    - Parameter isAsync: 
         to indicate that the handle was opened asynchronously; otherwise, .
    - Parameter isConnected: 
         to indicate that the pipe is connected; otherwise, .
    - Parameter safePipeHandle: A safe handle for the pipe that this  object will encapsulate.
    */
    public init(direction : dotnet.System.IO.Pipes.PipeDirection, isAsync : Bool, isConnected : Bool, safePipeHandle : dotnet.Microsoft.Win32.SafeHandles.SafePipeHandle) throws {
        var __thrown : NullableHandle = nil;
        let h = System_IO_Pipes_NamedPipeServerStream_ctor_0__4__PipeDirection_bool_bool_SafePipeHandle(&__thrown, direction.get_value(), Swift.Int32(isAsync ? 1 : 0), Swift.Int32(isConnected ? 1 : 0), safePipeHandle.get_handle());
        if let __ex = __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
            super.init(hndl: h);
        }
    }
    // .ctor(System.String)
// docid: M:System.IO.Pipes.NamedPipeServerStream.#ctor(System.String)
    /**
    Initializes a new instance of the  class with the specified pipe name.

    - Parameter pipeName: The name of the pipe.
    */
    public init(pipeName : dotnet.System.String) throws {
        var __thrown : NullableHandle = nil;
        let h = System_IO_Pipes_NamedPipeServerStream_ctor_0__1__String(&__thrown, pipeName.get_handle());
        if let __ex = __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
            super.init(hndl: h);
        }
    }
    // .ctor(System.String, System.IO.Pipes.PipeDirection)
// docid: M:System.IO.Pipes.NamedPipeServerStream.#ctor(System.String,System.IO.Pipes.PipeDirection)
    /**
    Initializes a new instance of the  class with the specified pipe name and pipe direction.

    - Parameter pipeName: The name of the pipe.
    - Parameter direction: One of the enumeration values that determines the direction of the pipe.
    */
    public init(pipeName : dotnet.System.String, direction : dotnet.System.IO.Pipes.PipeDirection) throws {
        var __thrown : NullableHandle = nil;
        let h = System_IO_Pipes_NamedPipeServerStream_ctor_0__2__String_PipeDirection(&__thrown, pipeName.get_handle(), direction.get_value());
        if let __ex = __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
            super.init(hndl: h);
        }
    }
    // .ctor(System.String, System.IO.Pipes.PipeDirection, System.Int32)
// docid: M:System.IO.Pipes.NamedPipeServerStream.#ctor(System.String,System.IO.Pipes.PipeDirection,System.Int32)
    /**
    Initializes a new instance of the  class with the specified pipe name, pipe direction, and maximum number of server instances.

    - Parameter pipeName: The name of the pipe.
    - Parameter direction: One of the enumeration values that determines the direction of the pipe.
    - Parameter maxNumberOfServerInstances: The maximum number of server instances that share the same name. You can pass  for this value.
    */
    public init(pipeName : dotnet.System.String, direction : dotnet.System.IO.Pipes.PipeDirection, maxNumberOfServerInstances : Swift.Int32) throws {
        var __thrown : NullableHandle = nil;
        let h = System_IO_Pipes_NamedPipeServerStream_ctor_0__3__String_PipeDirection_i32(&__thrown, pipeName.get_handle(), direction.get_value(), maxNumberOfServerInstances);
        if let __ex = __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
            super.init(hndl: h);
        }
    }
    // .ctor(System.String, System.IO.Pipes.PipeDirection, System.Int32, System.IO.Pipes.PipeTransmissionMode)
// docid: M:System.IO.Pipes.NamedPipeServerStream.#ctor(System.String,System.IO.Pipes.PipeDirection,System.Int32,System.IO.Pipes.PipeTransmissionMode)
    /**
    Initializes a new instance of the  class with the specified pipe name, pipe direction, maximum number of server instances, and transmission mode.

    - Parameter pipeName: The name of the pipe.
    - Parameter direction: One of the enumeration values that determines the direction of the pipe.
    - Parameter maxNumberOfServerInstances: The maximum number of server instances that share the same name. You can pass  for this value.
    - Parameter transmissionMode: One of the enumeration values that determines the transmission mode of the pipe.
    */
    public init(pipeName : dotnet.System.String, direction : dotnet.System.IO.Pipes.PipeDirection, maxNumberOfServerInstances : Swift.Int32, transmissionMode : dotnet.System.IO.Pipes.PipeTransmissionMode) throws {
        var __thrown : NullableHandle = nil;
        let h = System_IO_Pipes_NamedPipeServerStream_ctor_0__4__String_PipeDirection_i32_PipeTransmissionMode(&__thrown, pipeName.get_handle(), direction.get_value(), maxNumberOfServerInstances, transmissionMode.get_value());
        if let __ex = __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
            super.init(hndl: h);
        }
    }
    // .ctor(System.String, System.IO.Pipes.PipeDirection, System.Int32, System.IO.Pipes.PipeTransmissionMode, System.IO.Pipes.PipeOptions)
// docid: M:System.IO.Pipes.NamedPipeServerStream.#ctor(System.String,System.IO.Pipes.PipeDirection,System.Int32,System.IO.Pipes.PipeTransmissionMode,System.IO.Pipes.PipeOptions)
    /**
    Initializes a new instance of the  class with the specified pipe name, pipe direction, maximum number of server instances, transmission mode, and pipe options.

    - Parameter pipeName: The name of the pipe.
    - Parameter direction: One of the enumeration values that determines the direction of the pipe.
    - Parameter maxNumberOfServerInstances: The maximum number of server instances that share the same name. You can pass  for this value.
    - Parameter transmissionMode: One of the enumeration values that determines the transmission mode of the pipe.
    - Parameter options: One of the enumeration values that determines how to open or create the pipe.
    */
    public init(pipeName : dotnet.System.String, direction : dotnet.System.IO.Pipes.PipeDirection, maxNumberOfServerInstances : Swift.Int32, transmissionMode : dotnet.System.IO.Pipes.PipeTransmissionMode, options : dotnet.System.IO.Pipes.PipeOptions) throws {
        var __thrown : NullableHandle = nil;
        let h = System_IO_Pipes_NamedPipeServerStream_ctor_0__5__String_PipeDirection_i32_PipeTransmissionMode_PipeOptions(&__thrown, pipeName.get_handle(), direction.get_value(), maxNumberOfServerInstances, transmissionMode.get_value(), options.get_value());
        if let __ex = __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
            super.init(hndl: h);
        }
    }
    // .ctor(System.String, System.IO.Pipes.PipeDirection, System.Int32, System.IO.Pipes.PipeTransmissionMode, System.IO.Pipes.PipeOptions, System.Int32, System.Int32)
// docid: M:System.IO.Pipes.NamedPipeServerStream.#ctor(System.String,System.IO.Pipes.PipeDirection,System.Int32,System.IO.Pipes.PipeTransmissionMode,System.IO.Pipes.PipeOptions,System.Int32,System.Int32)
    /**
    Initializes a new instance of the  class with the specified pipe name, pipe direction, maximum number of server instances, transmission mode, pipe options, and recommended in and out buffer sizes.

    - Parameter pipeName: The name of the pipe.
    - Parameter direction: One of the enumeration values that determines the direction of the pipe.
    - Parameter maxNumberOfServerInstances: The maximum number of server instances that share the same name. You can pass  for this value.
    - Parameter transmissionMode: One of the enumeration values that determines the transmission mode of the pipe.
    - Parameter options: One of the enumeration values that determines how to open or create the pipe.
    - Parameter inBufferSize: A positive value greater than 0 that indicates the input buffer size.
    - Parameter outBufferSize: A positive value greater than 0 that indicates the output buffer size.
    */
    public init(pipeName : dotnet.System.String, direction : dotnet.System.IO.Pipes.PipeDirection, maxNumberOfServerInstances : Swift.Int32, transmissionMode : dotnet.System.IO.Pipes.PipeTransmissionMode, options : dotnet.System.IO.Pipes.PipeOptions, inBufferSize : Swift.Int32, outBufferSize : Swift.Int32) throws {
        var __thrown : NullableHandle = nil;
        let h = System_IO_Pipes_NamedPipeServerStream_ctor_0__7__String_PipeDirection_i32_PipeTransmissionMode_PipeOptions_i32_i32(&__thrown, pipeName.get_handle(), direction.get_value(), maxNumberOfServerInstances, transmissionMode.get_value(), options.get_value(), inBufferSize, outBufferSize);
        if let __ex = __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
            super.init(hndl: h);
        }
    }
    // System.IAsyncResult BeginWaitForConnection(System.AsyncCallback, System.Object)
// docid: M:System.IO.Pipes.NamedPipeServerStream.BeginWaitForConnection(System.AsyncCallback,System.Object)
    /**
    Begins an asynchronous operation to wait for a client to connect.

    - Parameter callback: The method to call when a client connects to the  object.
    - Parameter state: A user-provided object that distinguishes this particular asynchronous request from other requests.
    - Returns: An object that references the asynchronous request.

    */
    public func BeginWaitForConnection(callback : Optional<dotnet.System.AsyncCallback>, state : Optional<dotnet.System.Object>) throws -> dotnet.System.IAsyncResult {
        var __thrown : NullableHandle = nil;
        let __return = System_IO_Pipes_NamedPipeServerStream_IAsyncResult__BeginWaitForConnection_0__2__AsyncCallback_Object(&__thrown, self.get_handle(), callback?.get_handle() ?? nil, state?.get_handle() ?? nil);
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return dotnet.System.IAsyncResult(hndl : __return);
        }
    }
    // delegate closure overload
    public func BeginWaitForConnection(callback : @escaping (dotnet.System.IAsyncResult) throws -> Void, state : Optional<dotnet.System.Object>) throws -> dotnet.System.IAsyncResult {
        let del_callback = try dotnet.System.AsyncCallback(callback);
        return try BeginWaitForConnection(callback: del_callback, state: state);
    }
    // void Disconnect()
// docid: M:System.IO.Pipes.NamedPipeServerStream.Disconnect
    /**
    Disconnects the current connection.

    */
    public func Disconnect() throws {
        var __thrown : NullableHandle = nil;
        System_IO_Pipes_NamedPipeServerStream_void__Disconnect_0__0(&__thrown, self.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
            return;
        }
    }
    // void EndWaitForConnection(System.IAsyncResult)
// docid: M:System.IO.Pipes.NamedPipeServerStream.EndWaitForConnection(System.IAsyncResult)
    /**
    Ends an asynchronous operation to wait for a client to connect.

    - Parameter asyncResult: The pending asynchronous request.
    */
    public func EndWaitForConnection(asyncResult : dotnet.System.IAsyncResult) throws {
        var __thrown : NullableHandle = nil;
        System_IO_Pipes_NamedPipeServerStream_void__EndWaitForConnection_0__1__IAsyncResult(&__thrown, self.get_handle(), asyncResult.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
            return;
        }
    }
    // System.String GetImpersonationUserName()
// docid: M:System.IO.Pipes.NamedPipeServerStream.GetImpersonationUserName
    /**
    Gets the user name of the client on the other end of the pipe.

    - Returns: The user name of the client on the other end of the pipe.

    */
    public func GetImpersonationUserName() throws -> dotnet.System.String {
        var __thrown : NullableHandle = nil;
        let __return = System_IO_Pipes_NamedPipeServerStream_String__GetImpersonationUserName_0__0(&__thrown, self.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return dotnet.System.String(hndl : __return);
        }
    }
    // void RunAsClient(System.IO.Pipes.PipeStreamImpersonationWorker)
// docid: M:System.IO.Pipes.NamedPipeServerStream.RunAsClient(System.IO.Pipes.PipeStreamImpersonationWorker)
    /**
    Calls a delegate while impersonating the client.

    - Parameter impersonationWorker: The delegate that specifies a method to call.
    */
    public func RunAsClient(impersonationWorker : dotnet.System.IO.Pipes.PipeStreamImpersonationWorker) throws {
        var __thrown : NullableHandle = nil;
        System_IO_Pipes_NamedPipeServerStream_void__RunAsClient_0__1__PipeStreamImpersonationWorker(&__thrown, self.get_handle(), impersonationWorker.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
            return;
        }
    }
    // delegate closure overload
    public func RunAsClient(impersonationWorker : @escaping () throws -> Void) throws {
        let del_impersonationWorker = try dotnet.System.IO.Pipes.PipeStreamImpersonationWorker(impersonationWorker);
        return try RunAsClient(impersonationWorker: del_impersonationWorker);
    }
    // void WaitForConnection()
// docid: M:System.IO.Pipes.NamedPipeServerStream.WaitForConnection
    /**
    Waits for a client to connect to this  object.

    */
    public func WaitForConnection() throws {
        var __thrown : NullableHandle = nil;
        System_IO_Pipes_NamedPipeServerStream_void__WaitForConnection_0__0(&__thrown, self.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
            return;
        }
    }
    // System.Threading.Tasks.Task WaitForConnectionAsync()
// docid: M:System.IO.Pipes.NamedPipeServerStream.WaitForConnectionAsync
    /**
    Asynchronously waits for a client to connect to this  object.

    - Returns: A task that represents the asynchronous wait operation.

    */
    public func WaitForConnectionAsync() throws -> dotnet.System.Threading.Tasks.Task {
        var __thrown : NullableHandle = nil;
        let __return = System_IO_Pipes_NamedPipeServerStream_Task__WaitForConnectionAsync_0__0(&__thrown, self.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return dotnet.System.Threading.Tasks.Task(hndl : __return);
        }
    }
    // System.Threading.Tasks.Task WaitForConnectionAsync(System.Threading.CancellationToken)
// docid: M:System.IO.Pipes.NamedPipeServerStream.WaitForConnectionAsync(System.Threading.CancellationToken)
    /**
    Asynchronously waits for a client to connect to this  object and monitors cancellation requests.

    - Parameter cancellationToken: The token to monitor for cancellation requests.
    - Returns: A task that represents the asynchronous wait operation.

    */
    public func WaitForConnectionAsync(cancellationToken : dotnet.System.Threading.CancellationToken) throws -> dotnet.System.Threading.Tasks.Task {
        var __thrown : NullableHandle = nil;
        let __return = System_IO_Pipes_NamedPipeServerStream_Task__WaitForConnectionAsync_0__1__CancellationToken(&__thrown, self.get_handle(), cancellationToken.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return dotnet.System.Threading.Tasks.Task(hndl : __return);
        }
    }
} // NamedPipeServerStream


// type: System.IO.Pipes.PipeDirection
    /**
    Specifies the direction of the pipe.

    */
public struct PipeDirection : SGBridgeGenericValue {
    let v : Swift.Int32;
    public init(val: Swift.Int32) { self.v = val; }
    public func get_value() -> Swift.Int32 { return self.v; }
    public static func get_type_handle() -> TypeHandle {
        return System_IO_Pipes_PipeDirection_get_type_handle();
    }
    public func to_gval() -> GVal { return GVal(self.v); }
    public func dup_gval() -> GVal { return to_gval(); }
    public init(gval: GVal) { self.v = Swift.Int32(gval); }
    // static field: System.IO.Pipes.PipeDirection In
    /**
    Specifies that the pipe direction is in.

    */
    public static var In : dotnet.System.IO.Pipes.PipeDirection {
        get {
        let __return = dotnet.System.IO.Pipes.PipeDirection(val: System_IO_Pipes_PipeDirection_get_In());
            return __return;
        }
    }
    // static field: System.IO.Pipes.PipeDirection Out
    /**
    Specifies that the pipe direction is out.

    */
    public static var Out : dotnet.System.IO.Pipes.PipeDirection {
        get {
        let __return = dotnet.System.IO.Pipes.PipeDirection(val: System_IO_Pipes_PipeDirection_get_Out());
            return __return;
        }
    }
    // static field: System.IO.Pipes.PipeDirection InOut
    /**
    Specifies that the pipe direction is two-way.

    */
    public static var InOut : dotnet.System.IO.Pipes.PipeDirection {
        get {
        let __return = dotnet.System.IO.Pipes.PipeDirection(val: System_IO_Pipes_PipeDirection_get_InOut());
            return __return;
        }
    }
} // PipeDirection


// type: System.IO.Pipes.PipeOptions
    /**
    Provides options for creating a  object. This enumeration has a  attribute that allows a bitwise combination of its member values.

    */
public struct PipeOptions : SGBridgeGenericValue {
    let v : Swift.Int32;
    public init(val: Swift.Int32) { self.v = val; }
    public func get_value() -> Swift.Int32 { return self.v; }
    public static func get_type_handle() -> TypeHandle {
        return System_IO_Pipes_PipeOptions_get_type_handle();
    }
    public func to_gval() -> GVal { return GVal(self.v); }
    public func dup_gval() -> GVal { return to_gval(); }
    public init(gval: GVal) { self.v = Swift.Int32(gval); }
    // static field: System.IO.Pipes.PipeOptions WriteThrough
    /**
    Indicates that the system should write through any intermediate cache and go directly to the pipe.

    */
    public static var WriteThrough : dotnet.System.IO.Pipes.PipeOptions {
        get {
        let __return = dotnet.System.IO.Pipes.PipeOptions(val: System_IO_Pipes_PipeOptions_get_WriteThrough());
            return __return;
        }
    }
    // static field: System.IO.Pipes.PipeOptions None
    /**
    Indicates that there are no additional parameters.

    */
    public static var None : dotnet.System.IO.Pipes.PipeOptions {
        get {
        let __return = dotnet.System.IO.Pipes.PipeOptions(val: System_IO_Pipes_PipeOptions_get_None());
            return __return;
        }
    }
    // static field: System.IO.Pipes.PipeOptions CurrentUserOnly
    /**
    When used to create a  instance, indicates that the pipe can only be connected to a client created by the same user. When used to create a  instance, indicates that the pipe can only connect to a server created by the same user. On Windows, it verifies both the user account and elevation level.

    */
    public static var CurrentUserOnly : dotnet.System.IO.Pipes.PipeOptions {
        get {
        let __return = dotnet.System.IO.Pipes.PipeOptions(val: System_IO_Pipes_PipeOptions_get_CurrentUserOnly());
            return __return;
        }
    }
    // static field: System.IO.Pipes.PipeOptions Asynchronous
    /**
    Indicates that the pipe can be used for asynchronous reading and writing.

    */
    public static var Asynchronous : dotnet.System.IO.Pipes.PipeOptions {
        get {
        let __return = dotnet.System.IO.Pipes.PipeOptions(val: System_IO_Pipes_PipeOptions_get_Asynchronous());
            return __return;
        }
    }
} // PipeOptions


// type: System.IO.Pipes.PipeStream
    /**
    Exposes a  object around a pipe, which supports both anonymous and named pipes.

    */
open class PipeStream
    :
    dotnet.System.IO.Stream
{
    open class override func get_type_handle() -> TypeHandle {
        return System_IO_Pipes_PipeStream_get_type_handle();
    }
    public required init(hndl: NonnullHandle) { super.init(hndl: hndl); }
    public required init(gval: GVal) { super.init(gval: gval); }
    // System.IAsyncResult BeginRead(System.Byte[], System.Int32, System.Int32, System.AsyncCallback, System.Object)
// docid: M:System.IO.Pipes.PipeStream.BeginRead(System.Byte[],System.Int32,System.Int32,System.AsyncCallback,System.Object)
    /**
    Begins an asynchronous read operation.

    - Parameter buffer: The buffer to read data into.
    - Parameter offset: The byte offset in  at which to begin reading.
    - Parameter count: The maximum number of bytes to read.
    - Parameter callback: The method to call when the asynchronous read operation is completed.
    - Parameter state: A user-provided object that distinguishes this particular asynchronous read request from other requests.
    - Returns: An  object that references the asynchronous read.

    */
    open override func BeginRead(buffer : dotnet.System_Arr<Swift.UInt8>, offset : Swift.Int32, count : Swift.Int32, callback : Optional<dotnet.System.AsyncCallback>, state : Optional<dotnet.System.Object>) throws -> dotnet.System.IAsyncResult {
        var __thrown : NullableHandle = nil;
        let __return = System_IO_Pipes_PipeStream_IAsyncResult__BeginRead_0__5__u8Array_i32_i32_AsyncCallback_Object(&__thrown, self.get_handle(), buffer.get_handle(), offset, count, callback?.get_handle() ?? nil, state?.get_handle() ?? nil);
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return dotnet.System.IAsyncResult(hndl : __return);
        }
    }
    // delegate closure overload
    open override func BeginRead(buffer : dotnet.System_Arr<Swift.UInt8>, offset : Swift.Int32, count : Swift.Int32, callback : @escaping (dotnet.System.IAsyncResult) throws -> Void, state : Optional<dotnet.System.Object>) throws -> dotnet.System.IAsyncResult {
        let del_callback = try dotnet.System.AsyncCallback(callback);
        return try BeginRead(buffer: buffer, offset: offset, count: count, callback: del_callback, state: state);
    }
    // System.IAsyncResult BeginWrite(System.Byte[], System.Int32, System.Int32, System.AsyncCallback, System.Object)
// docid: M:System.IO.Pipes.PipeStream.BeginWrite(System.Byte[],System.Int32,System.Int32,System.AsyncCallback,System.Object)
    /**
    Begins an asynchronous write operation.

    - Parameter buffer: The buffer that contains the data to write to the current stream.
    - Parameter offset: The zero-based byte offset in  at which to begin copying bytes to the current stream.
    - Parameter count: The maximum number of bytes to write.
    - Parameter callback: The method to call when the asynchronous write operation is completed.
    - Parameter state: A user-provided object that distinguishes this particular asynchronous write request from other requests.
    - Returns: An  object that references the asynchronous write operation.

    */
    open override func BeginWrite(buffer : dotnet.System_Arr<Swift.UInt8>, offset : Swift.Int32, count : Swift.Int32, callback : Optional<dotnet.System.AsyncCallback>, state : Optional<dotnet.System.Object>) throws -> dotnet.System.IAsyncResult {
        var __thrown : NullableHandle = nil;
        let __return = System_IO_Pipes_PipeStream_IAsyncResult__BeginWrite_0__5__u8Array_i32_i32_AsyncCallback_Object(&__thrown, self.get_handle(), buffer.get_handle(), offset, count, callback?.get_handle() ?? nil, state?.get_handle() ?? nil);
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return dotnet.System.IAsyncResult(hndl : __return);
        }
    }
    // delegate closure overload
    open override func BeginWrite(buffer : dotnet.System_Arr<Swift.UInt8>, offset : Swift.Int32, count : Swift.Int32, callback : @escaping (dotnet.System.IAsyncResult) throws -> Void, state : Optional<dotnet.System.Object>) throws -> dotnet.System.IAsyncResult {
        let del_callback = try dotnet.System.AsyncCallback(callback);
        return try BeginWrite(buffer: buffer, offset: offset, count: count, callback: del_callback, state: state);
    }
    // System.Int32 EndRead(System.IAsyncResult)
// docid: M:System.IO.Pipes.PipeStream.EndRead(System.IAsyncResult)
    /**
    Ends a pending asynchronous read request.

    - Parameter asyncResult: The reference to the pending asynchronous request.
    - Returns: The number of bytes that were read. A return value of 0 indicates the end of the stream (the pipe has been closed).

    */
    open override func EndRead(asyncResult : dotnet.System.IAsyncResult) throws -> Swift.Int32 {
        var __thrown : NullableHandle = nil;
        let __return = System_IO_Pipes_PipeStream_i32__EndRead_0__1__IAsyncResult(&__thrown, self.get_handle(), asyncResult.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return __return;
        }
    }
    // void EndWrite(System.IAsyncResult)
// docid: M:System.IO.Pipes.PipeStream.EndWrite(System.IAsyncResult)
    /**
    Ends a pending asynchronous write request.

    - Parameter asyncResult: The reference to the pending asynchronous request.
    */
    open override func EndWrite(asyncResult : dotnet.System.IAsyncResult) throws {
        var __thrown : NullableHandle = nil;
        System_IO_Pipes_PipeStream_void__EndWrite_0__1__IAsyncResult(&__thrown, self.get_handle(), asyncResult.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
            return;
        }
    }
    // void Flush()
// docid: M:System.IO.Pipes.PipeStream.Flush
    /**
    Clears the buffer for the current stream and causes any buffered data to be written to the underlying device.

    */
    open override func Flush() throws {
        var __thrown : NullableHandle = nil;
        System_IO_Pipes_PipeStream_void__Flush_0__0(&__thrown, self.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
            return;
        }
    }
    // System.Threading.Tasks.Task FlushAsync(System.Threading.CancellationToken)
// docid: M:System.IO.Pipes.PipeStream.FlushAsync(System.Threading.CancellationToken)
    /**
    Asynchronously clears the buffer for the current stream and causes any buffered data to be written to the underlying device.

    - Parameter cancellationToken: The token to monitor for cancellation requests.
    - Returns: A task that represent the asynchronous flush operation.

    */
    open override func FlushAsync(cancellationToken : dotnet.System.Threading.CancellationToken) throws -> dotnet.System.Threading.Tasks.Task {
        var __thrown : NullableHandle = nil;
        let __return = System_IO_Pipes_PipeStream_Task__FlushAsync_0__1__CancellationToken(&__thrown, self.get_handle(), cancellationToken.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return dotnet.System.Threading.Tasks.Task(hndl : __return);
        }
    }
    // System.Int32 Read(System.Byte[], System.Int32, System.Int32)
// docid: M:System.IO.Pipes.PipeStream.Read(System.Byte[],System.Int32,System.Int32)
    /**
    Reads a block of bytes from a stream and writes the data to a specified buffer starting at a specified position for a specified length.

    - Parameter buffer: When this method returns, contains the specified byte array with the values between  and ( +  - 1) replaced by the bytes read from the current source.
    - Parameter offset: The byte offset in the  array at which the bytes that are read will be placed.
    - Parameter count: The maximum number of bytes to read.
    - Returns: The total number of bytes that are read into . This might be less than the number of bytes requested if that number of bytes is not currently available, or 0 if the end of the stream is reached.

    */
    open override func Read(buffer : dotnet.System_Arr<Swift.UInt8>, offset : Swift.Int32, count : Swift.Int32) throws -> Swift.Int32 {
        var __thrown : NullableHandle = nil;
        let __return = System_IO_Pipes_PipeStream_i32__Read_0__3__u8Array_i32_i32(&__thrown, self.get_handle(), buffer.get_handle(), offset, count);
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return __return;
        }
    }
// TODO COPE (write_all_methods) (span) System.Int32 Read(System.Span<System.Byte>)
    // System.Threading.Tasks.Task<System.Int32> ReadAsync(System.Byte[], System.Int32, System.Int32, System.Threading.CancellationToken)
// docid: M:System.IO.Pipes.PipeStream.ReadAsync(System.Byte[],System.Int32,System.Int32,System.Threading.CancellationToken)
    /**
    Asynchronously reads a sequence of bytes from the current stream to a byte array starting at a specified position for a specified number of bytes, advances the position within the stream by the number of bytes read, and monitors cancellation requests.

    - Parameter buffer: The buffer to write the data into.
    - Parameter offset: The byte offset in  at which to begin writing data from the stream.
    - Parameter count: The maximum number of bytes to read.
    - Parameter cancellationToken: The token to monitor for cancellation requests. The default value is .
    - Returns: A task that represents the asynchronous read operation. The value of its  property contains the total number of bytes read into the buffer. The result value can be less than the number of bytes requested if the number of bytes currently available is less than the requested number, or it can be 0 (zero) if the end of the stream has been reached.

    */
    open override func ReadAsync(buffer : dotnet.System_Arr<Swift.UInt8>, offset : Swift.Int32, count : Swift.Int32, cancellationToken : dotnet.System.Threading.CancellationToken) throws -> dotnet.System.Threading.Tasks.Task_1<Swift.Int32> {
        var __thrown : NullableHandle = nil;
        let __return = System_IO_Pipes_PipeStream_System_Threading_Tasks_Task_i32___ReadAsync_0__4__u8Array_i32_i32_CancellationToken(&__thrown, self.get_handle(), buffer.get_handle(), offset, count, cancellationToken.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return dotnet.System.Threading.Tasks.Task_1(hndl : __return);
        }
    }
    // System.Threading.Tasks.ValueTask<System.Int32> ReadAsync(System.Memory<System.Byte>, System.Threading.CancellationToken)
// docid: M:System.IO.Pipes.PipeStream.ReadAsync(System.Memory{System.Byte},System.Threading.CancellationToken)
    /**
    Asynchronously reads a sequence of bytes from the current stream, writes them to a byte memory range, advances the position within the stream by the number of bytes read, and monitors cancellation requests.

    - Parameter buffer: The region of memory to write the data into.
    - Parameter cancellationToken: The token to monitor for cancellation requests. The default value is .
    - Returns: A task that represents the asynchronous read operation. The value of its  property contains the total number of bytes read into the buffer. The result value can be less than the number of bytes allocated in the buffer if that many bytes are not currently available, or it can be 0 (zero) if the end of the stream has been reached.

    */
    open override func ReadAsync(buffer : dotnet.System.Memory_1<Swift.UInt8>, cancellationToken : dotnet.System.Threading.CancellationToken = System.Threading.CancellationToken.None) throws -> dotnet.System.Threading.Tasks.ValueTask_1<Swift.Int32> {
        var __thrown : NullableHandle = nil;
        let __return = System_IO_Pipes_PipeStream_System_Threading_Tasks_ValueTask_i32___ReadAsync_0__2__System_Memory_u8__CancellationToken(&__thrown, self.get_handle(), buffer.get_handle(), cancellationToken.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return dotnet.System.Threading.Tasks.ValueTask_1(hndl : __return);
        }
    }
    // System.Int32 ReadByte()
// docid: M:System.IO.Pipes.PipeStream.ReadByte
    /**
    Reads a byte from a pipe.

    - Returns: The byte, cast to , or -1 indicates the end of the stream (the pipe has been closed).

    */
    open override func ReadByte() throws -> Swift.Int32 {
        var __thrown : NullableHandle = nil;
        let __return = System_IO_Pipes_PipeStream_i32__ReadByte_0__0(&__thrown, self.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return __return;
        }
    }
    // System.Int64 Seek(System.Int64, System.IO.SeekOrigin)
// docid: M:System.IO.Pipes.PipeStream.Seek(System.Int64,System.IO.SeekOrigin)
    /**
    Sets the current position of the current stream to the specified value.

    - Parameter offset: The point, relative to , to begin seeking from.
    - Parameter origin: Specifies the beginning, the end, or the current position as a reference point for , using a value of type .
    - Returns: The new position in the stream.

    */
    open override func Seek(offset : Swift.Int64, origin : dotnet.System.IO.SeekOrigin) throws -> Swift.Int64 {
        var __thrown : NullableHandle = nil;
        let __return = System_IO_Pipes_PipeStream_i64__Seek_0__2__i64_SeekOrigin(&__thrown, self.get_handle(), offset, origin.get_value());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return __return;
        }
    }
    // void SetLength(System.Int64)
// docid: M:System.IO.Pipes.PipeStream.SetLength(System.Int64)
    /**
    Sets the length of the current stream to the specified value.

    - Parameter value: The new length of the stream.
    */
    open override func SetLength(value : Swift.Int64) throws {
        var __thrown : NullableHandle = nil;
        System_IO_Pipes_PipeStream_void__SetLength_0__1__i64(&__thrown, self.get_handle(), value);
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
            return;
        }
    }
    // void WaitForPipeDrain()
// docid: M:System.IO.Pipes.PipeStream.WaitForPipeDrain
    /**
    Waits for the other end of the pipe to read all sent bytes.

    */
    open func WaitForPipeDrain() throws {
        var __thrown : NullableHandle = nil;
        System_IO_Pipes_PipeStream_void__WaitForPipeDrain_0__0(&__thrown, self.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
            return;
        }
    }
    // void Write(System.Byte[], System.Int32, System.Int32)
// docid: M:System.IO.Pipes.PipeStream.Write(System.Byte[],System.Int32,System.Int32)
    /**
    Writes a block of bytes to the current stream using data from a buffer.

    - Parameter buffer: The buffer that contains data to write to the pipe.
    - Parameter offset: The zero-based byte offset in  at which to begin copying bytes to the current stream.
    - Parameter count: The maximum number of bytes to write to the current stream.
    */
    open override func Write(buffer : dotnet.System_Arr<Swift.UInt8>, offset : Swift.Int32, count : Swift.Int32) throws {
        var __thrown : NullableHandle = nil;
        System_IO_Pipes_PipeStream_void__Write_0__3__u8Array_i32_i32(&__thrown, self.get_handle(), buffer.get_handle(), offset, count);
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
            return;
        }
    }
// TODO COPE (write_all_methods) (span) void Write(System.ReadOnlySpan<System.Byte>)
    // System.Threading.Tasks.Task WriteAsync(System.Byte[], System.Int32, System.Int32, System.Threading.CancellationToken)
// docid: M:System.IO.Pipes.PipeStream.WriteAsync(System.Byte[],System.Int32,System.Int32,System.Threading.CancellationToken)
    /**
    Asynchronously writes a specified number of bytes from a byte array starting at a specified position, advances the current position within this stream by the number of bytes written, and monitors cancellation requests.

    - Parameter buffer: The buffer to write data from.
    - Parameter offset: The zero-based byte offset in  from which to begin copying bytes to the stream.
    - Parameter count: The maximum number of bytes to write.
    - Parameter cancellationToken: The token to monitor for cancellation requests. The default value is .
    - Returns: A task that represents the asynchronous write operation.

    */
    open override func WriteAsync(buffer : dotnet.System_Arr<Swift.UInt8>, offset : Swift.Int32, count : Swift.Int32, cancellationToken : dotnet.System.Threading.CancellationToken) throws -> dotnet.System.Threading.Tasks.Task {
        var __thrown : NullableHandle = nil;
        let __return = System_IO_Pipes_PipeStream_Task__WriteAsync_0__4__u8Array_i32_i32_CancellationToken(&__thrown, self.get_handle(), buffer.get_handle(), offset, count, cancellationToken.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return dotnet.System.Threading.Tasks.Task(hndl : __return);
        }
    }
    // System.Threading.Tasks.ValueTask WriteAsync(System.ReadOnlyMemory<System.Byte>, System.Threading.CancellationToken)
// docid: M:System.IO.Pipes.PipeStream.WriteAsync(System.ReadOnlyMemory{System.Byte},System.Threading.CancellationToken)
    /**
    Asynchronously writes a sequence of bytes to the current stream, advances the current position within this stream by the number of bytes written, and monitors cancellation requests.

    - Parameter buffer: The region of memory to write data from.
    - Parameter cancellationToken: The token to monitor for cancellation requests. The default value is .
    - Returns: A task that represents the asynchronous write operation.

    */
    open override func WriteAsync(buffer : dotnet.System.ReadOnlyMemory_1<Swift.UInt8>, cancellationToken : dotnet.System.Threading.CancellationToken = System.Threading.CancellationToken.None) throws -> dotnet.System.Threading.Tasks.ValueTask {
        var __thrown : NullableHandle = nil;
        let __return = System_IO_Pipes_PipeStream_ValueTask__WriteAsync_0__2__System_ReadOnlyMemory_u8__CancellationToken(&__thrown, self.get_handle(), buffer.get_handle(), cancellationToken.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return dotnet.System.Threading.Tasks.ValueTask(hndl : __return);
        }
    }
    // void WriteByte(System.Byte)
// docid: M:System.IO.Pipes.PipeStream.WriteByte(System.Byte)
    /**
    Writes a byte to the current stream.

    - Parameter value: The byte to write to the stream.
    */
    open override func WriteByte(value : Swift.UInt8) throws {
        var __thrown : NullableHandle = nil;
        System_IO_Pipes_PipeStream_void__WriteByte_0__1__u8(&__thrown, self.get_handle(), value);
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
            return;
        }
    }
    // [IsSpecialName] bool get_CanRead()
// docid: M:System.IO.Pipes.PipeStream.get_CanRead
    open override func get_CanRead() throws -> Bool {
        var __thrown : NullableHandle = nil;
        let __return = System_IO_Pipes_PipeStream_bool__get_CanRead_0__0(&__thrown, self.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return (__return) != 0;
        }
    }
    // [IsSpecialName] bool get_CanSeek()
// docid: M:System.IO.Pipes.PipeStream.get_CanSeek
    open override func get_CanSeek() throws -> Bool {
        var __thrown : NullableHandle = nil;
        let __return = System_IO_Pipes_PipeStream_bool__get_CanSeek_0__0(&__thrown, self.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return (__return) != 0;
        }
    }
    // [IsSpecialName] bool get_CanWrite()
// docid: M:System.IO.Pipes.PipeStream.get_CanWrite
    open override func get_CanWrite() throws -> Bool {
        var __thrown : NullableHandle = nil;
        let __return = System_IO_Pipes_PipeStream_bool__get_CanWrite_0__0(&__thrown, self.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return (__return) != 0;
        }
    }
    // [IsSpecialName] System.Int32 get_InBufferSize()
// docid: M:System.IO.Pipes.PipeStream.get_InBufferSize
    open func get_InBufferSize() throws -> Swift.Int32 {
        var __thrown : NullableHandle = nil;
        let __return = System_IO_Pipes_PipeStream_i32__get_InBufferSize_0__0(&__thrown, self.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return __return;
        }
    }
    // [IsSpecialName] bool get_IsAsync()
// docid: M:System.IO.Pipes.PipeStream.get_IsAsync
    open func get_IsAsync() throws -> Bool {
        var __thrown : NullableHandle = nil;
        let __return = System_IO_Pipes_PipeStream_bool__get_IsAsync_0__0(&__thrown, self.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return (__return) != 0;
        }
    }
    // [IsSpecialName] bool get_IsConnected()
// docid: M:System.IO.Pipes.PipeStream.get_IsConnected
    open func get_IsConnected() throws -> Bool {
        var __thrown : NullableHandle = nil;
        let __return = System_IO_Pipes_PipeStream_bool__get_IsConnected_0__0(&__thrown, self.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return (__return) != 0;
        }
    }
    // [IsSpecialName] void set_IsConnected(bool)
// docid: M:System.IO.Pipes.PipeStream.set_IsConnected(System.Boolean)
    open func set_IsConnected(value : Bool) throws {
        var __thrown : NullableHandle = nil;
        System_IO_Pipes_PipeStream_void__set_IsConnected_0__1__bool(&__thrown, self.get_handle(), Swift.Int32(value ? 1 : 0));
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
            return;
        }
    }
    // [IsSpecialName] bool get_IsMessageComplete()
// docid: M:System.IO.Pipes.PipeStream.get_IsMessageComplete
    open func get_IsMessageComplete() throws -> Bool {
        var __thrown : NullableHandle = nil;
        let __return = System_IO_Pipes_PipeStream_bool__get_IsMessageComplete_0__0(&__thrown, self.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return (__return) != 0;
        }
    }
    // [IsSpecialName] System.Int64 get_Length()
// docid: M:System.IO.Pipes.PipeStream.get_Length
    open override func get_Length() throws -> Swift.Int64 {
        var __thrown : NullableHandle = nil;
        let __return = System_IO_Pipes_PipeStream_i64__get_Length_0__0(&__thrown, self.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return __return;
        }
    }
    // [IsSpecialName] System.Int32 get_OutBufferSize()
// docid: M:System.IO.Pipes.PipeStream.get_OutBufferSize
    open func get_OutBufferSize() throws -> Swift.Int32 {
        var __thrown : NullableHandle = nil;
        let __return = System_IO_Pipes_PipeStream_i32__get_OutBufferSize_0__0(&__thrown, self.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return __return;
        }
    }
    // [IsSpecialName] System.Int64 get_Position()
// docid: M:System.IO.Pipes.PipeStream.get_Position
    open override func get_Position() throws -> Swift.Int64 {
        var __thrown : NullableHandle = nil;
        let __return = System_IO_Pipes_PipeStream_i64__get_Position_0__0(&__thrown, self.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return __return;
        }
    }
    // [IsSpecialName] void set_Position(System.Int64)
// docid: M:System.IO.Pipes.PipeStream.set_Position(System.Int64)
    open override func set_Position(value : Swift.Int64) throws {
        var __thrown : NullableHandle = nil;
        System_IO_Pipes_PipeStream_void__set_Position_0__1__i64(&__thrown, self.get_handle(), value);
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
            return;
        }
    }
    // [IsSpecialName] System.IO.Pipes.PipeTransmissionMode get_ReadMode()
// docid: M:System.IO.Pipes.PipeStream.get_ReadMode
    open func get_ReadMode() throws -> dotnet.System.IO.Pipes.PipeTransmissionMode {
        var __thrown : NullableHandle = nil;
        let __return = System_IO_Pipes_PipeStream_PipeTransmissionMode__get_ReadMode_0__0(&__thrown, self.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return dotnet.System.IO.Pipes.PipeTransmissionMode(val: __return);
        }
    }
    // [IsSpecialName] void set_ReadMode(System.IO.Pipes.PipeTransmissionMode)
// docid: M:System.IO.Pipes.PipeStream.set_ReadMode(System.IO.Pipes.PipeTransmissionMode)
    open func set_ReadMode(value : dotnet.System.IO.Pipes.PipeTransmissionMode) throws {
        var __thrown : NullableHandle = nil;
        System_IO_Pipes_PipeStream_void__set_ReadMode_0__1__PipeTransmissionMode(&__thrown, self.get_handle(), value.get_value());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
            return;
        }
    }
    // [IsSpecialName] Microsoft.Win32.SafeHandles.SafePipeHandle get_SafePipeHandle()
// docid: M:System.IO.Pipes.PipeStream.get_SafePipeHandle
    open func get_SafePipeHandle() throws -> dotnet.Microsoft.Win32.SafeHandles.SafePipeHandle {
        var __thrown : NullableHandle = nil;
        let __return = System_IO_Pipes_PipeStream_SafePipeHandle__get_SafePipeHandle_0__0(&__thrown, self.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return dotnet.Microsoft.Win32.SafeHandles.SafePipeHandle(hndl : __return);
        }
    }
    // [IsSpecialName] System.IO.Pipes.PipeTransmissionMode get_TransmissionMode()
// docid: M:System.IO.Pipes.PipeStream.get_TransmissionMode
    open func get_TransmissionMode() throws -> dotnet.System.IO.Pipes.PipeTransmissionMode {
        var __thrown : NullableHandle = nil;
        let __return = System_IO_Pipes_PipeStream_PipeTransmissionMode__get_TransmissionMode_0__0(&__thrown, self.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return dotnet.System.IO.Pipes.PipeTransmissionMode(val: __return);
        }
    }
    /**
    Gets a value indicating whether the current stream supports read operations.

    */
    open override var CanRead : Bool {
        get {
            return try! get_CanRead();
        }
    }
    /**
    Gets a value indicating whether the current stream supports seek operations.

    */
    open override var CanSeek : Bool {
        get {
            return try! get_CanSeek();
        }
    }
    /**
    Gets a value indicating whether the current stream supports write operations.

    */
    open override var CanWrite : Bool {
        get {
            return try! get_CanWrite();
        }
    }
    /**
    Gets the size, in bytes, of the inbound buffer for a pipe.

    */
    open var InBufferSize : Swift.Int32 {
        get {
            return try! get_InBufferSize();
        }
    }
    /**
    Gets a value indicating whether a  object was opened asynchronously or synchronously.

    */
    open var IsAsync : Bool {
        get {
            return try! get_IsAsync();
        }
    }
    /**
    Gets or sets a value indicating whether a  object is connected.

    */
    open var IsConnected : Bool {
        get {
            return try! get_IsConnected();
        }
        set(v) {
            return try! set_IsConnected(value: v);
        }
    }
    /**
    Gets a value indicating whether there is more data in the message returned from the most recent read operation.

    */
    open var IsMessageComplete : Bool {
        get {
            return try! get_IsMessageComplete();
        }
    }
    /**
    Gets the length of a stream, in bytes.

    */
    open override var Length : Swift.Int64 {
        get {
            return try! get_Length();
        }
    }
    /**
    Gets the size, in bytes, of the outbound buffer for a pipe.

    */
    open var OutBufferSize : Swift.Int32 {
        get {
            return try! get_OutBufferSize();
        }
    }
    /**
    Gets or sets the current position of the current stream.

    */
    open override var Position : Swift.Int64 {
        get {
            return try! get_Position();
        }
        set(v) {
            return try! set_Position(value: v);
        }
    }
    /**
    Gets or sets the reading mode for a  object.

    */
    open var ReadMode : dotnet.System.IO.Pipes.PipeTransmissionMode {
        get {
            return try! get_ReadMode();
        }
        set(v) {
            return try! set_ReadMode(value: v);
        }
    }
    /**
    Gets the safe handle for the local end of the pipe that the current  object encapsulates.

    */
    open var SafePipeHandle : dotnet.Microsoft.Win32.SafeHandles.SafePipeHandle {
        get {
            return try! get_SafePipeHandle();
        }
    }
    /**
    Gets the pipe transmission mode supported by the current pipe.

    */
    open var TransmissionMode : dotnet.System.IO.Pipes.PipeTransmissionMode {
        get {
            return try! get_TransmissionMode();
        }
    }
} // PipeStream


// type: System.IO.Pipes.PipeStreamImpersonationWorker
    /**
    Represents the method to call as the client.

    */
public final class PipeStreamImpersonationWorker
    :
    dotnet.System.Delegate
{
    public class override func get_type_handle() -> TypeHandle {
        return System_IO_Pipes_PipeStreamImpersonationWorker_get_type_handle();
    }
    public required init(hndl: NonnullHandle) { super.init(hndl: hndl); }
    public required init(gval: GVal) { super.init(gval: gval); }
    // void Invoke()
// docid: M:System.IO.Pipes.PipeStreamImpersonationWorker.Invoke
    public func Invoke() throws {
        var __thrown : NullableHandle = nil;
        System_IO_Pipes_PipeStreamImpersonationWorker_void__Invoke_0__0(&__thrown, self.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
            return;
        }
    }
    // System.IAsyncResult BeginInvoke(System.AsyncCallback, System.Object)
// docid: M:System.IO.Pipes.PipeStreamImpersonationWorker.BeginInvoke(System.AsyncCallback,System.Object)
    public func BeginInvoke(callback : Optional<dotnet.System.AsyncCallback>, object : Optional<dotnet.System.Object>) throws -> Optional<dotnet.System.IAsyncResult> {
        var __thrown : NullableHandle = nil;
        let __return = System_IO_Pipes_PipeStreamImpersonationWorker_IAsyncResult__BeginInvoke_0__2__AsyncCallback_Object(&__thrown, self.get_handle(), callback?.get_handle() ?? nil, object?.get_handle() ?? nil);
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        if let __ret_unwrapped = __return {
            return dotnet.System.IAsyncResult(hndl : __ret_unwrapped);
        } else {
            return nil;
        }
        }
    }
    // void EndInvoke(System.IAsyncResult)
// docid: M:System.IO.Pipes.PipeStreamImpersonationWorker.EndInvoke(System.IAsyncResult)
    public func EndInvoke(result : Optional<dotnet.System.IAsyncResult>) throws {
        var __thrown : NullableHandle = nil;
        System_IO_Pipes_PipeStreamImpersonationWorker_void__EndInvoke_0__1__IAsyncResult(&__thrown, self.get_handle(), result?.get_handle() ?? nil);
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
            return;
        }
    }
    public init(_ callback : @escaping () throws -> Void) throws
    {
        let __bridge : (UnsafeMutablePointer<NullableHandle>) -> Void =
        {
            (thrown : UnsafeMutablePointer<NullableHandle>) -> Void in
            do
            {
                thrown.pointee = nil;
                try callback();
            }
            catch let e as dotnet.System.Exception
            {
                thrown.pointee = __copy_handle(e.get_handle());
            }
            catch
            {
                let e = try! dotnet.System.Exception(message: "TODO fail inside closure");
                thrown.pointee = __copy_handle(e.get_handle());
            }
        };
        let cbarg = UnsafeRawPointer(Unmanaged.passRetained(__bridge as AnyObject).toOpaque());
        func __cb(cb : UnsafeRawPointer?, thrown : UnsafeMutablePointer<NullableHandle>) -> Void
        {
            let f = Unmanaged<AnyObject>.fromOpaque(cb!).takeUnretainedValue() as! (UnsafeMutablePointer<NullableHandle>) -> Void;
            f(thrown);
        }
        var __thrown : NullableHandle = nil;
        let h = System_IO_Pipes_PipeStreamImpersonationWorker_create(
            &__thrown,
            cbarg,
            nil, // TODO deinit
            __cb
            );
            // TODO check thrown
        if let __ex = __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
            super.init(hndl: h);
        }
    }
    // void Invoke()
// docid: M:System.IO.Pipes.PipeStreamImpersonationWorker.Invoke
    public func callAsFunction() throws {
        var __thrown : NullableHandle = nil;
        System_IO_Pipes_PipeStreamImpersonationWorker_void__Invoke_0__0(&__thrown, self.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
            return;
        }
    }
} // PipeStreamImpersonationWorker


// type: System.IO.Pipes.PipeTransmissionMode
    /**
    Specifies the transmission mode of the pipe.

    */
public struct PipeTransmissionMode : SGBridgeGenericValue {
    let v : Swift.Int32;
    public init(val: Swift.Int32) { self.v = val; }
    public func get_value() -> Swift.Int32 { return self.v; }
    public static func get_type_handle() -> TypeHandle {
        return System_IO_Pipes_PipeTransmissionMode_get_type_handle();
    }
    public func to_gval() -> GVal { return GVal(self.v); }
    public func dup_gval() -> GVal { return to_gval(); }
    public init(gval: GVal) { self.v = Swift.Int32(gval); }
    // static field: System.IO.Pipes.PipeTransmissionMode Byte
    /**
    Indicates that data in the pipe is transmitted and read as a stream of bytes.

    */
    public static var Byte : dotnet.System.IO.Pipes.PipeTransmissionMode {
        get {
        let __return = dotnet.System.IO.Pipes.PipeTransmissionMode(val: System_IO_Pipes_PipeTransmissionMode_get_Byte());
            return __return;
        }
    }
    // static field: System.IO.Pipes.PipeTransmissionMode Message
    /**
    Indicates that data in the pipe is transmitted and read as a stream of messages.

    */
    public static var Message : dotnet.System.IO.Pipes.PipeTransmissionMode {
        get {
        let __return = dotnet.System.IO.Pipes.PipeTransmissionMode(val: System_IO_Pipes_PipeTransmissionMode_get_Message());
            return __return;
        }
    }
} // PipeTransmissionMode


}



