// this file is automatically generated
// Copyright 2021 SourceGear

import jumptable_dotnet;

// System
// System.IO
// System.IO.IsolatedStorage
extension System.IO.IsolatedStorage {
// type: System.IO.IsolatedStorage.INormalizeForIsolatedStorage
    /**
    Enables comparisons between an isolated store and an application domain and assembly's evidence.

    */
open class INormalizeForIsolatedStorage
    :
    SGBridgeGenericValue,
    System_IO_IsolatedStorage_INormalizeForIsolatedStorage
{
    open class func get_type_handle() -> TypeHandle {
        return System_IO_IsolatedStorage_INormalizeForIsolatedStorage_get_type_handle();
    }
    let h : NonnullHandle;
    public func to_gval() -> GVal { return GVal(Swift.Int(bitPattern: self.h)); }
    public func dup_gval() -> GVal { return GVal(Swift.Int(bitPattern: __copy_handle(self.h))); }
    public required init(gval: GVal) { self.h = NonnullHandle(bitPattern: Swift.Int(truncatingIfNeeded: gval))!; }
    public required init(hndl: NonnullHandle) { self.h = hndl; }
    public func get_handle() -> NonnullHandle { return self.h; }

    deinit { __drop_handle(self.h); }

    // System.Object Normalize()
// docid: M:System.IO.IsolatedStorage.INormalizeForIsolatedStorage.Normalize
    /**
    When overridden in a derived class, returns a normalized copy of the object on which it is called.

    - Returns: A normalized object that represents the instance on which this method was called. This instance can be a string, stream, or any serializable object.

    */
    open func Normalize() throws -> dotnet.System.Object {
        var __thrown : NullableHandle = nil;
        let __return = System_IO_IsolatedStorage_INormalizeForIsolatedStorage_Object__Normalize_0__0(&__thrown, self.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return dotnet.System.Object(hndl : __return);
        }
    }
} // INormalizeForIsolatedStorage


// type: System.IO.IsolatedStorage.IsolatedStorage
    /**
    Represents the abstract base class from which all isolated storage implementations must derive.

    */
open class IsolatedStorage
    :
    dotnet.System.MarshalByRefObject
{
    open class override func get_type_handle() -> TypeHandle {
        return System_IO_IsolatedStorage_IsolatedStorage_get_type_handle();
    }
    public required init(hndl: NonnullHandle) { super.init(hndl: hndl); }
    public required init(gval: GVal) { super.init(gval: gval); }
    // bool IncreaseQuotaTo(System.Int64)
// docid: M:System.IO.IsolatedStorage.IsolatedStorage.IncreaseQuotaTo(System.Int64)
    /**
    When overridden in a derived class, prompts a user to approve a larger quota size, in bytes, for isolated storage.

    - Parameter newQuotaSize: The requested new quota size, in bytes, for the user to approve.
    - Returns: 
         in all cases.

    */
    open func IncreaseQuotaTo(newQuotaSize : Swift.Int64) throws -> Bool {
        var __thrown : NullableHandle = nil;
        let __return = System_IO_IsolatedStorage_IsolatedStorage_bool__IncreaseQuotaTo_0__1__i64(&__thrown, self.get_handle(), newQuotaSize);
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return (__return) != 0;
        }
    }
    // void Remove()
// docid: M:System.IO.IsolatedStorage.IsolatedStorage.Remove
    /**
    When overridden in a derived class, removes the individual isolated store and all contained data.

    */
    open func Remove() throws {
        var __thrown : NullableHandle = nil;
        System_IO_IsolatedStorage_IsolatedStorage_void__Remove_0__0(&__thrown, self.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
            return;
        }
    }
    // [IsSpecialName] System.Object get_ApplicationIdentity()
// docid: M:System.IO.IsolatedStorage.IsolatedStorage.get_ApplicationIdentity
    open func get_ApplicationIdentity() throws -> dotnet.System.Object {
        var __thrown : NullableHandle = nil;
        let __return = System_IO_IsolatedStorage_IsolatedStorage_Object__get_ApplicationIdentity_0__0(&__thrown, self.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return dotnet.System.Object(hndl : __return);
        }
    }
    // [IsSpecialName] System.Object get_AssemblyIdentity()
// docid: M:System.IO.IsolatedStorage.IsolatedStorage.get_AssemblyIdentity
    open func get_AssemblyIdentity() throws -> dotnet.System.Object {
        var __thrown : NullableHandle = nil;
        let __return = System_IO_IsolatedStorage_IsolatedStorage_Object__get_AssemblyIdentity_0__0(&__thrown, self.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return dotnet.System.Object(hndl : __return);
        }
    }
    // [IsSpecialName] System.Int64 get_AvailableFreeSpace()
// docid: M:System.IO.IsolatedStorage.IsolatedStorage.get_AvailableFreeSpace
    open func get_AvailableFreeSpace() throws -> Swift.Int64 {
        var __thrown : NullableHandle = nil;
        let __return = System_IO_IsolatedStorage_IsolatedStorage_i64__get_AvailableFreeSpace_0__0(&__thrown, self.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return __return;
        }
    }
    // [IsSpecialName] System.UInt64 get_CurrentSize()
// docid: M:System.IO.IsolatedStorage.IsolatedStorage.get_CurrentSize
    open func get_CurrentSize() throws -> Swift.UInt64 {
        var __thrown : NullableHandle = nil;
        let __return = System_IO_IsolatedStorage_IsolatedStorage_u64__get_CurrentSize_0__0(&__thrown, self.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return __return;
        }
    }
    // [IsSpecialName] System.Object get_DomainIdentity()
// docid: M:System.IO.IsolatedStorage.IsolatedStorage.get_DomainIdentity
    open func get_DomainIdentity() throws -> dotnet.System.Object {
        var __thrown : NullableHandle = nil;
        let __return = System_IO_IsolatedStorage_IsolatedStorage_Object__get_DomainIdentity_0__0(&__thrown, self.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return dotnet.System.Object(hndl : __return);
        }
    }
    // [IsSpecialName] System.UInt64 get_MaximumSize()
// docid: M:System.IO.IsolatedStorage.IsolatedStorage.get_MaximumSize
    open func get_MaximumSize() throws -> Swift.UInt64 {
        var __thrown : NullableHandle = nil;
        let __return = System_IO_IsolatedStorage_IsolatedStorage_u64__get_MaximumSize_0__0(&__thrown, self.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return __return;
        }
    }
    // [IsSpecialName] System.Int64 get_Quota()
// docid: M:System.IO.IsolatedStorage.IsolatedStorage.get_Quota
    open func get_Quota() throws -> Swift.Int64 {
        var __thrown : NullableHandle = nil;
        let __return = System_IO_IsolatedStorage_IsolatedStorage_i64__get_Quota_0__0(&__thrown, self.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return __return;
        }
    }
    // [IsSpecialName] System.IO.IsolatedStorage.IsolatedStorageScope get_Scope()
// docid: M:System.IO.IsolatedStorage.IsolatedStorage.get_Scope
    open func get_Scope() throws -> dotnet.System.IO.IsolatedStorage.IsolatedStorageScope {
        var __thrown : NullableHandle = nil;
        let __return = System_IO_IsolatedStorage_IsolatedStorage_IsolatedStorageScope__get_Scope_0__0(&__thrown, self.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return dotnet.System.IO.IsolatedStorage.IsolatedStorageScope(val: __return);
        }
    }
    // [IsSpecialName] System.Int64 get_UsedSize()
// docid: M:System.IO.IsolatedStorage.IsolatedStorage.get_UsedSize
    open func get_UsedSize() throws -> Swift.Int64 {
        var __thrown : NullableHandle = nil;
        let __return = System_IO_IsolatedStorage_IsolatedStorage_i64__get_UsedSize_0__0(&__thrown, self.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return __return;
        }
    }
    /**
    Gets an application identity that scopes isolated storage.

    */
    open var ApplicationIdentity : dotnet.System.Object {
        get {
            return try! get_ApplicationIdentity();
        }
    }
    /**
    Gets an assembly identity used to scope isolated storage.

    */
    open var AssemblyIdentity : dotnet.System.Object {
        get {
            return try! get_AssemblyIdentity();
        }
    }
    /**
    When overridden in a derived class, gets the available free space for isolated storage, in bytes.

    */
    open var AvailableFreeSpace : Swift.Int64 {
        get {
            return try! get_AvailableFreeSpace();
        }
    }
    /**
    Gets a value representing the current size of isolated storage.

    */
    open var CurrentSize : Swift.UInt64 {
        get {
            return try! get_CurrentSize();
        }
    }
    /**
    Gets a domain identity that scopes isolated storage.

    */
    open var DomainIdentity : dotnet.System.Object {
        get {
            return try! get_DomainIdentity();
        }
    }
    /**
    Gets a value representing the maximum amount of space available for isolated storage. When overridden in a derived class, this value can take different units of measure.

    */
    open var MaximumSize : Swift.UInt64 {
        get {
            return try! get_MaximumSize();
        }
    }
    /**
    When overridden in a derived class, gets a value that represents the maximum amount of space available for isolated storage.

    */
    open var Quota : Swift.Int64 {
        get {
            return try! get_Quota();
        }
    }
    /**
    Gets an  enumeration value specifying the scope used to isolate the store.

    */
    open var Scope : dotnet.System.IO.IsolatedStorage.IsolatedStorageScope {
        get {
            return try! get_Scope();
        }
    }
    /**
    When overridden in a derived class, gets a value that represents the amount of the space used for isolated storage.

    */
    open var UsedSize : Swift.Int64 {
        get {
            return try! get_UsedSize();
        }
    }
} // IsolatedStorage


// type: System.IO.IsolatedStorage.IsolatedStorageException
    /**
    The exception that is thrown when an operation in isolated storage fails.

    */
open class IsolatedStorageException
    :
    dotnet.System.Exception
{
    open class override func get_type_handle() -> TypeHandle {
        return System_IO_IsolatedStorage_IsolatedStorageException_get_type_handle();
    }
    public required init(hndl: NonnullHandle) { super.init(hndl: hndl); }
    public required init(gval: GVal) { super.init(gval: gval); }
    // .ctor()
// docid: M:System.IO.IsolatedStorage.IsolatedStorageException.#ctor
    /**
    Initializes a new instance of the  class with default properties.

    */
    public override init() throws {
        var __thrown : NullableHandle = nil;
        let h = System_IO_IsolatedStorage_IsolatedStorageException_ctor_0__0(&__thrown);
        if let __ex = __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
            super.init(hndl: h);
        }
    }
    // .ctor(System.String)
// docid: M:System.IO.IsolatedStorage.IsolatedStorageException.#ctor(System.String)
    /**
    Initializes a new instance of the  class with a specified error message.

    - Parameter message: The error message that explains the reason for the exception.
    */
    public override init(message : Optional<dotnet.System.String>) throws {
        var __thrown : NullableHandle = nil;
        let h = System_IO_IsolatedStorage_IsolatedStorageException_ctor_0__1__String(&__thrown, message?.get_handle() ?? nil);
        if let __ex = __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
            super.init(hndl: h);
        }
    }
    // .ctor(System.String, System.Exception)
// docid: M:System.IO.IsolatedStorage.IsolatedStorageException.#ctor(System.String,System.Exception)
    /**
    Initializes a new instance of the  class with a specified error message and a reference to the inner exception that is the cause of this exception.

    - Parameter message: The error message that explains the reason for the exception.
    - Parameter inner: The exception that is the cause of the current exception. If the  parameter is not , the current exception is raised in a  block that handles the inner exception.
    */
    public init(message : Optional<dotnet.System.String>, inner : Optional<dotnet.System.Exception>) throws {
        var __thrown : NullableHandle = nil;
        let h = System_IO_IsolatedStorage_IsolatedStorageException_ctor_0__2__String_Exception(&__thrown, message?.get_handle() ?? nil, inner?.get_handle() ?? nil);
        if let __ex = __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
            super.init(hndl: h);
        }
    }
} // IsolatedStorageException


// type: System.IO.IsolatedStorage.IsolatedStorageFile
    /**
    Represents an isolated storage area containing files and directories.

    */
public final class IsolatedStorageFile
    :
    dotnet.System.IO.IsolatedStorage.IsolatedStorage,
    System_IDisposable
{
    public class override func get_type_handle() -> TypeHandle {
        return System_IO_IsolatedStorage_IsolatedStorageFile_get_type_handle();
    }
    public required init(hndl: NonnullHandle) { super.init(hndl: hndl); }
    public required init(gval: GVal) { super.init(gval: gval); }
    // void Close()
// docid: M:System.IO.IsolatedStorage.IsolatedStorageFile.Close
    /**
    Closes a store previously opened with , , or .

    */
    public func Close() throws {
        var __thrown : NullableHandle = nil;
        System_IO_IsolatedStorage_IsolatedStorageFile_void__Close_0__0(&__thrown, self.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
            return;
        }
    }
    // void CopyFile(System.String, System.String)
// docid: M:System.IO.IsolatedStorage.IsolatedStorageFile.CopyFile(System.String,System.String)
    /**
    Copies an existing file to a new file.

    - Parameter sourceFileName: The name of the file to copy.
    - Parameter destinationFileName: The name of the destination file. This cannot be a directory or an existing file.
    */
    public func CopyFile(sourceFileName : dotnet.System.String, destinationFileName : dotnet.System.String) throws {
        var __thrown : NullableHandle = nil;
        System_IO_IsolatedStorage_IsolatedStorageFile_void__CopyFile_0__2__String_String(&__thrown, self.get_handle(), sourceFileName.get_handle(), destinationFileName.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
            return;
        }
    }
    // void CopyFile(System.String, System.String, bool)
// docid: M:System.IO.IsolatedStorage.IsolatedStorageFile.CopyFile(System.String,System.String,System.Boolean)
    /**
    Copies an existing file to a new file, and optionally overwrites an existing file.

    - Parameter sourceFileName: The name of the file to copy.
    - Parameter destinationFileName: The name of the destination file. This cannot be a directory.
    - Parameter overwrite: 
         if the destination file can be overwritten; otherwise, .
    */
    public func CopyFile(sourceFileName : dotnet.System.String, destinationFileName : dotnet.System.String, overwrite : Bool) throws {
        var __thrown : NullableHandle = nil;
        System_IO_IsolatedStorage_IsolatedStorageFile_void__CopyFile_0__3__String_String_bool(&__thrown, self.get_handle(), sourceFileName.get_handle(), destinationFileName.get_handle(), Swift.Int32(overwrite ? 1 : 0));
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
            return;
        }
    }
    // void CreateDirectory(System.String)
// docid: M:System.IO.IsolatedStorage.IsolatedStorageFile.CreateDirectory(System.String)
    /**
    Creates a directory in the isolated storage scope.

    - Parameter dir: The relative path of the directory to create within the isolated storage scope.
    */
    public func CreateDirectory(dir : dotnet.System.String) throws {
        var __thrown : NullableHandle = nil;
        System_IO_IsolatedStorage_IsolatedStorageFile_void__CreateDirectory_0__1__String(&__thrown, self.get_handle(), dir.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
            return;
        }
    }
    // System.IO.IsolatedStorage.IsolatedStorageFileStream CreateFile(System.String)
// docid: M:System.IO.IsolatedStorage.IsolatedStorageFile.CreateFile(System.String)
    /**
    Creates a file in the isolated store.

    - Parameter path: The relative path of the file to create.
    - Returns: A new isolated storage file.

    */
    public func CreateFile(path : dotnet.System.String) throws -> dotnet.System.IO.IsolatedStorage.IsolatedStorageFileStream {
        var __thrown : NullableHandle = nil;
        let __return = System_IO_IsolatedStorage_IsolatedStorageFile_IsolatedStorageFileStream__CreateFile_0__1__String(&__thrown, self.get_handle(), path.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return dotnet.System.IO.IsolatedStorage.IsolatedStorageFileStream(hndl : __return);
        }
    }
    // void DeleteDirectory(System.String)
// docid: M:System.IO.IsolatedStorage.IsolatedStorageFile.DeleteDirectory(System.String)
    /**
    Deletes a directory in the isolated storage scope.

    - Parameter dir: The relative path of the directory to delete within the isolated storage scope.
    */
    public func DeleteDirectory(dir : dotnet.System.String) throws {
        var __thrown : NullableHandle = nil;
        System_IO_IsolatedStorage_IsolatedStorageFile_void__DeleteDirectory_0__1__String(&__thrown, self.get_handle(), dir.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
            return;
        }
    }
    // void DeleteFile(System.String)
// docid: M:System.IO.IsolatedStorage.IsolatedStorageFile.DeleteFile(System.String)
    /**
    Deletes a file in the isolated storage scope.

    - Parameter file: The relative path of the file to delete within the isolated storage scope.
    */
    public func DeleteFile(file : dotnet.System.String) throws {
        var __thrown : NullableHandle = nil;
        System_IO_IsolatedStorage_IsolatedStorageFile_void__DeleteFile_0__1__String(&__thrown, self.get_handle(), file.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
            return;
        }
    }
    // bool DirectoryExists(System.String)
// docid: M:System.IO.IsolatedStorage.IsolatedStorageFile.DirectoryExists(System.String)
    /**
    Determines whether the specified path refers to an existing directory in the isolated store.

    - Parameter path: The path to test.
    - Returns: 
         if  refers to an existing directory in the isolated store and is not ; otherwise, .

    */
    public func DirectoryExists(path : dotnet.System.String) throws -> Bool {
        var __thrown : NullableHandle = nil;
        let __return = System_IO_IsolatedStorage_IsolatedStorageFile_bool__DirectoryExists_0__1__String(&__thrown, self.get_handle(), path.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return (__return) != 0;
        }
    }
    // void Dispose()
// docid: M:System.IO.IsolatedStorage.IsolatedStorageFile.Dispose
    /**
    Releases all resources used by the .

    */
    public func Dispose() throws {
        var __thrown : NullableHandle = nil;
        System_IO_IsolatedStorage_IsolatedStorageFile_void__Dispose_0__0(&__thrown, self.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
            return;
        }
    }
    // bool FileExists(System.String)
// docid: M:System.IO.IsolatedStorage.IsolatedStorageFile.FileExists(System.String)
    /**
    Determines whether the specified path refers to an existing file in the isolated store.

    - Parameter path: The path and file name to test.
    - Returns: 
         if  refers to an existing file in the isolated store and is not ; otherwise, .

    */
    public func FileExists(path : dotnet.System.String) throws -> Bool {
        var __thrown : NullableHandle = nil;
        let __return = System_IO_IsolatedStorage_IsolatedStorageFile_bool__FileExists_0__1__String(&__thrown, self.get_handle(), path.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return (__return) != 0;
        }
    }
    // System.DateTimeOffset GetCreationTime(System.String)
// docid: M:System.IO.IsolatedStorage.IsolatedStorageFile.GetCreationTime(System.String)
    /**
    Returns the creation date and time of a specified file or directory.

    - Parameter path: The path to the file or directory for which to obtain creation date and time information.
    - Returns: The creation date and time for the specified file or directory. This value is expressed in local time.

    */
    public func GetCreationTime(path : dotnet.System.String) throws -> dotnet.System.DateTimeOffset {
        var __thrown : NullableHandle = nil;
        let __return = System_IO_IsolatedStorage_IsolatedStorageFile_DateTimeOffset__GetCreationTime_0__1__String(&__thrown, self.get_handle(), path.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return dotnet.System.DateTimeOffset(hndl : __return);
        }
    }
    // System.String[] GetDirectoryNames()
// docid: M:System.IO.IsolatedStorage.IsolatedStorageFile.GetDirectoryNames
    /**
    Enumerates the directories at the root of an isolated store.

    - Returns: An array of relative paths of directories at the root of the isolated store. A zero-length array specifies that there are no directories at the root.

    */
    public func GetDirectoryNames() throws -> dotnet.System_Arr<dotnet.System.String> {
        var __thrown : NullableHandle = nil;
        let __return = System_IO_IsolatedStorage_IsolatedStorageFile_StringArray__GetDirectoryNames_0__0(&__thrown, self.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return dotnet.System_Arr<dotnet.System.String>(hndl : __return);
        }
    }
    // System.String[] GetDirectoryNames(System.String)
// docid: M:System.IO.IsolatedStorage.IsolatedStorageFile.GetDirectoryNames(System.String)
    /**
    Enumerates the directories in an isolated storage scope that match a given search pattern.

    - Parameter searchPattern: A search pattern. Both single-character ("?") and multi-character ("(ASTERISK)") wildcards are supported.
    - Returns: An array of the relative paths of directories in the isolated storage scope that match . A zero-length array specifies that there are no directories that match.

    */
    public func GetDirectoryNames(searchPattern : dotnet.System.String) throws -> dotnet.System_Arr<dotnet.System.String> {
        var __thrown : NullableHandle = nil;
        let __return = System_IO_IsolatedStorage_IsolatedStorageFile_StringArray__GetDirectoryNames_0__1__String(&__thrown, self.get_handle(), searchPattern.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return dotnet.System_Arr<dotnet.System.String>(hndl : __return);
        }
    }
    // System.Collections.IEnumerator GetEnumerator(System.IO.IsolatedStorage.IsolatedStorageScope)
// docid: M:System.IO.IsolatedStorage.IsolatedStorageFile.GetEnumerator(System.IO.IsolatedStorage.IsolatedStorageScope)
    /**
    Gets the enumerator for the  stores within an isolated storage scope.

    - Parameter scope: Represents the  for which to return isolated stores.  and  are the only  combinations supported.
    - Returns: Enumerator for the  stores within the specified isolated storage scope.

    */
    public class func GetEnumerator(scope : dotnet.System.IO.IsolatedStorage.IsolatedStorageScope) throws -> dotnet.System.Collections.IEnumerator {
        var __thrown : NullableHandle = nil;
        let __return = System_IO_IsolatedStorage_IsolatedStorageFile_IEnumerator__GetEnumerator_0__1__IsolatedStorageScope(&__thrown, scope.get_value());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return dotnet.System.Collections.IEnumerator(hndl : __return);
        }
    }
    // System.String[] GetFileNames()
// docid: M:System.IO.IsolatedStorage.IsolatedStorageFile.GetFileNames
    /**
    Enumerates the file names at the root of an isolated store.

    - Returns: An array of relative paths of files at the root of the isolated store.  A zero-length array specifies that there are no files at the root.

    */
    public func GetFileNames() throws -> dotnet.System_Arr<dotnet.System.String> {
        var __thrown : NullableHandle = nil;
        let __return = System_IO_IsolatedStorage_IsolatedStorageFile_StringArray__GetFileNames_0__0(&__thrown, self.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return dotnet.System_Arr<dotnet.System.String>(hndl : __return);
        }
    }
    // System.String[] GetFileNames(System.String)
// docid: M:System.IO.IsolatedStorage.IsolatedStorageFile.GetFileNames(System.String)
    /**
    Gets the file names that match a search pattern.

    - Parameter searchPattern: A search pattern. Both single-character ("?") and multi-character ("(ASTERISK)") wildcards are supported.
    - Returns: An array of relative paths of files in the isolated storage scope that match . A zero-length array specifies that there are no files that match.

    */
    public func GetFileNames(searchPattern : dotnet.System.String) throws -> dotnet.System_Arr<dotnet.System.String> {
        var __thrown : NullableHandle = nil;
        let __return = System_IO_IsolatedStorage_IsolatedStorageFile_StringArray__GetFileNames_0__1__String(&__thrown, self.get_handle(), searchPattern.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return dotnet.System_Arr<dotnet.System.String>(hndl : __return);
        }
    }
    // System.DateTimeOffset GetLastAccessTime(System.String)
// docid: M:System.IO.IsolatedStorage.IsolatedStorageFile.GetLastAccessTime(System.String)
    /**
    Returns the date and time a specified file or directory was last accessed.

    - Parameter path: The path to the file or directory for which to obtain last access date and time information.
    - Returns: The date and time that the specified file or directory was last accessed. This value is expressed in local time.

    */
    public func GetLastAccessTime(path : dotnet.System.String) throws -> dotnet.System.DateTimeOffset {
        var __thrown : NullableHandle = nil;
        let __return = System_IO_IsolatedStorage_IsolatedStorageFile_DateTimeOffset__GetLastAccessTime_0__1__String(&__thrown, self.get_handle(), path.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return dotnet.System.DateTimeOffset(hndl : __return);
        }
    }
    // System.DateTimeOffset GetLastWriteTime(System.String)
// docid: M:System.IO.IsolatedStorage.IsolatedStorageFile.GetLastWriteTime(System.String)
    /**
    Returns the date and time a specified file or directory was last written to.

    - Parameter path: The path to the file or directory for which to obtain last write date and time information.
    - Returns: The date and time that the specified file or directory was last written to. This value is expressed in local time.

    */
    public func GetLastWriteTime(path : dotnet.System.String) throws -> dotnet.System.DateTimeOffset {
        var __thrown : NullableHandle = nil;
        let __return = System_IO_IsolatedStorage_IsolatedStorageFile_DateTimeOffset__GetLastWriteTime_0__1__String(&__thrown, self.get_handle(), path.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return dotnet.System.DateTimeOffset(hndl : __return);
        }
    }
    // System.IO.IsolatedStorage.IsolatedStorageFile GetMachineStoreForApplication()
// docid: M:System.IO.IsolatedStorage.IsolatedStorageFile.GetMachineStoreForApplication
    /**
    Obtains machine-scoped isolated storage corresponding to the calling code's application identity.

    - Returns: An object corresponding to the isolated storage scope based on the calling code's application identity.

    */
    public class func GetMachineStoreForApplication() throws -> dotnet.System.IO.IsolatedStorage.IsolatedStorageFile {
        var __thrown : NullableHandle = nil;
        let __return = System_IO_IsolatedStorage_IsolatedStorageFile_IsolatedStorageFile__GetMachineStoreForApplication_0__0(&__thrown);
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return dotnet.System.IO.IsolatedStorage.IsolatedStorageFile(hndl : __return);
        }
    }
    // System.IO.IsolatedStorage.IsolatedStorageFile GetMachineStoreForAssembly()
// docid: M:System.IO.IsolatedStorage.IsolatedStorageFile.GetMachineStoreForAssembly
    /**
    Obtains machine-scoped isolated storage corresponding to the calling code's assembly identity.

    - Returns: An object corresponding to the isolated storage scope based on the calling code's assembly identity.

    */
    public class func GetMachineStoreForAssembly() throws -> dotnet.System.IO.IsolatedStorage.IsolatedStorageFile {
        var __thrown : NullableHandle = nil;
        let __return = System_IO_IsolatedStorage_IsolatedStorageFile_IsolatedStorageFile__GetMachineStoreForAssembly_0__0(&__thrown);
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return dotnet.System.IO.IsolatedStorage.IsolatedStorageFile(hndl : __return);
        }
    }
    // System.IO.IsolatedStorage.IsolatedStorageFile GetMachineStoreForDomain()
// docid: M:System.IO.IsolatedStorage.IsolatedStorageFile.GetMachineStoreForDomain
    /**
    Obtains machine-scoped isolated storage corresponding to the application domain identity and the assembly identity.

    - Returns: An object corresponding to the , based on a combination of the application domain identity and the assembly identity.

    */
    public class func GetMachineStoreForDomain() throws -> dotnet.System.IO.IsolatedStorage.IsolatedStorageFile {
        var __thrown : NullableHandle = nil;
        let __return = System_IO_IsolatedStorage_IsolatedStorageFile_IsolatedStorageFile__GetMachineStoreForDomain_0__0(&__thrown);
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return dotnet.System.IO.IsolatedStorage.IsolatedStorageFile(hndl : __return);
        }
    }
    // System.IO.IsolatedStorage.IsolatedStorageFile GetStore(System.IO.IsolatedStorage.IsolatedStorageScope, System.Object)
// docid: M:System.IO.IsolatedStorage.IsolatedStorageFile.GetStore(System.IO.IsolatedStorage.IsolatedStorageScope,System.Object)
    /**
    Obtains isolated storage corresponding to the given application identity.

    - Parameter scope: A bitwise combination of the enumeration values.
    - Parameter applicationIdentity: An object that contains evidence for the application identity.
    - Returns: An object that represents the parameters.

    */
    public class func GetStore(scope : dotnet.System.IO.IsolatedStorage.IsolatedStorageScope, applicationIdentity : Optional<dotnet.System.Object>) throws -> dotnet.System.IO.IsolatedStorage.IsolatedStorageFile {
        var __thrown : NullableHandle = nil;
        let __return = System_IO_IsolatedStorage_IsolatedStorageFile_IsolatedStorageFile__GetStore_0__2__IsolatedStorageScope_Object(&__thrown, scope.get_value(), applicationIdentity?.get_handle() ?? nil);
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return dotnet.System.IO.IsolatedStorage.IsolatedStorageFile(hndl : __return);
        }
    }
    // System.IO.IsolatedStorage.IsolatedStorageFile GetStore(System.IO.IsolatedStorage.IsolatedStorageScope, System.Object, System.Object)
// docid: M:System.IO.IsolatedStorage.IsolatedStorageFile.GetStore(System.IO.IsolatedStorage.IsolatedStorageScope,System.Object,System.Object)
    /**
    Obtains the isolated storage corresponding to the given application domain and assembly evidence objects.

    - Parameter scope: A bitwise combination of the enumeration values.
    - Parameter domainIdentity: An object that contains evidence for the application domain identity.
    - Parameter assemblyIdentity: An object that contains evidence for the code assembly identity.
    - Returns: An object that represents the parameters.

    */
    public class func GetStore(scope : dotnet.System.IO.IsolatedStorage.IsolatedStorageScope, domainIdentity : Optional<dotnet.System.Object>, assemblyIdentity : Optional<dotnet.System.Object>) throws -> dotnet.System.IO.IsolatedStorage.IsolatedStorageFile {
        var __thrown : NullableHandle = nil;
        let __return = System_IO_IsolatedStorage_IsolatedStorageFile_IsolatedStorageFile__GetStore_0__3__IsolatedStorageScope_Object_Object(&__thrown, scope.get_value(), domainIdentity?.get_handle() ?? nil, assemblyIdentity?.get_handle() ?? nil);
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return dotnet.System.IO.IsolatedStorage.IsolatedStorageFile(hndl : __return);
        }
    }
    // System.IO.IsolatedStorage.IsolatedStorageFile GetStore(System.IO.IsolatedStorage.IsolatedStorageScope, System.Type)
// docid: M:System.IO.IsolatedStorage.IsolatedStorageFile.GetStore(System.IO.IsolatedStorage.IsolatedStorageScope,System.Type)
    /**
    Obtains isolated storage corresponding to the isolation scope and the application identity object.

    - Parameter scope: A bitwise combination of the enumeration values.
    - Parameter applicationEvidenceType: An object that contains the application identity.
    - Returns: An object that represents the parameters.

    */
    public class func GetStore(scope : dotnet.System.IO.IsolatedStorage.IsolatedStorageScope, applicationEvidenceType : Optional<dotnet.System.Type_>) throws -> dotnet.System.IO.IsolatedStorage.IsolatedStorageFile {
        var __thrown : NullableHandle = nil;
        let __return = System_IO_IsolatedStorage_IsolatedStorageFile_IsolatedStorageFile__GetStore_0__2__IsolatedStorageScope_Type(&__thrown, scope.get_value(), applicationEvidenceType?.get_handle() ?? nil);
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return dotnet.System.IO.IsolatedStorage.IsolatedStorageFile(hndl : __return);
        }
    }
    // System.IO.IsolatedStorage.IsolatedStorageFile GetStore(System.IO.IsolatedStorage.IsolatedStorageScope, System.Type, System.Type)
// docid: M:System.IO.IsolatedStorage.IsolatedStorageFile.GetStore(System.IO.IsolatedStorage.IsolatedStorageScope,System.Type,System.Type)
    /**
    Obtains isolated storage corresponding to the isolated storage scope given the application domain and assembly evidence types.

    - Parameter scope: A bitwise combination of the enumeration values.
    - Parameter domainEvidenceType: The type of the  that you can chose from the list of  present in the domain of the calling application.  lets the  object choose the evidence.
    - Parameter assemblyEvidenceType: The type of the  that you can chose from the list of  present in the domain of the calling application.  lets the  object choose the evidence.
    - Returns: An object that represents the parameters.

    */
    public class func GetStore(scope : dotnet.System.IO.IsolatedStorage.IsolatedStorageScope, domainEvidenceType : Optional<dotnet.System.Type_>, assemblyEvidenceType : Optional<dotnet.System.Type_>) throws -> dotnet.System.IO.IsolatedStorage.IsolatedStorageFile {
        var __thrown : NullableHandle = nil;
        let __return = System_IO_IsolatedStorage_IsolatedStorageFile_IsolatedStorageFile__GetStore_0__3__IsolatedStorageScope_Type_Type(&__thrown, scope.get_value(), domainEvidenceType?.get_handle() ?? nil, assemblyEvidenceType?.get_handle() ?? nil);
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return dotnet.System.IO.IsolatedStorage.IsolatedStorageFile(hndl : __return);
        }
    }
    // System.IO.IsolatedStorage.IsolatedStorageFile GetUserStoreForApplication()
// docid: M:System.IO.IsolatedStorage.IsolatedStorageFile.GetUserStoreForApplication
    /**
    Obtains user-scoped isolated storage corresponding to the calling code's application identity.

    - Returns: An object corresponding to the isolated storage scope based on the calling code's assembly identity.

    */
    public class func GetUserStoreForApplication() throws -> dotnet.System.IO.IsolatedStorage.IsolatedStorageFile {
        var __thrown : NullableHandle = nil;
        let __return = System_IO_IsolatedStorage_IsolatedStorageFile_IsolatedStorageFile__GetUserStoreForApplication_0__0(&__thrown);
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return dotnet.System.IO.IsolatedStorage.IsolatedStorageFile(hndl : __return);
        }
    }
    // System.IO.IsolatedStorage.IsolatedStorageFile GetUserStoreForAssembly()
// docid: M:System.IO.IsolatedStorage.IsolatedStorageFile.GetUserStoreForAssembly
    /**
    Obtains user-scoped isolated storage corresponding to the calling code's assembly identity.

    - Returns: An object corresponding to the isolated storage scope based on the calling code's assembly identity.

    */
    public class func GetUserStoreForAssembly() throws -> dotnet.System.IO.IsolatedStorage.IsolatedStorageFile {
        var __thrown : NullableHandle = nil;
        let __return = System_IO_IsolatedStorage_IsolatedStorageFile_IsolatedStorageFile__GetUserStoreForAssembly_0__0(&__thrown);
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return dotnet.System.IO.IsolatedStorage.IsolatedStorageFile(hndl : __return);
        }
    }
    // System.IO.IsolatedStorage.IsolatedStorageFile GetUserStoreForDomain()
// docid: M:System.IO.IsolatedStorage.IsolatedStorageFile.GetUserStoreForDomain
    /**
    Obtains user-scoped isolated storage corresponding to the application domain identity and assembly identity.

    - Returns: An object corresponding to the , based on a combination of the application domain identity and the assembly identity.

    */
    public class func GetUserStoreForDomain() throws -> dotnet.System.IO.IsolatedStorage.IsolatedStorageFile {
        var __thrown : NullableHandle = nil;
        let __return = System_IO_IsolatedStorage_IsolatedStorageFile_IsolatedStorageFile__GetUserStoreForDomain_0__0(&__thrown);
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return dotnet.System.IO.IsolatedStorage.IsolatedStorageFile(hndl : __return);
        }
    }
    // System.IO.IsolatedStorage.IsolatedStorageFile GetUserStoreForSite()
// docid: M:System.IO.IsolatedStorage.IsolatedStorageFile.GetUserStoreForSite
    /**
    Obtains a user-scoped isolated store for use by applications in a virtual host domain.

    - Returns: The isolated storage file that corresponds to the isolated storage scope based on the calling code's application identity.

    */
    public class func GetUserStoreForSite() throws -> dotnet.System.IO.IsolatedStorage.IsolatedStorageFile {
        var __thrown : NullableHandle = nil;
        let __return = System_IO_IsolatedStorage_IsolatedStorageFile_IsolatedStorageFile__GetUserStoreForSite_0__0(&__thrown);
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return dotnet.System.IO.IsolatedStorage.IsolatedStorageFile(hndl : __return);
        }
    }
    // bool IncreaseQuotaTo(System.Int64)
// docid: M:System.IO.IsolatedStorage.IsolatedStorageFile.IncreaseQuotaTo(System.Int64)
    /**
    Enables an application to explicitly request a larger quota size, in bytes.

    - Parameter newQuotaSize: The requested size, in bytes.
    - Returns: 
         if the new quota is accepted; otherwise, .

    */
    public override func IncreaseQuotaTo(newQuotaSize : Swift.Int64) throws -> Bool {
        var __thrown : NullableHandle = nil;
        let __return = System_IO_IsolatedStorage_IsolatedStorageFile_bool__IncreaseQuotaTo_0__1__i64(&__thrown, self.get_handle(), newQuotaSize);
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return (__return) != 0;
        }
    }
    // void MoveDirectory(System.String, System.String)
// docid: M:System.IO.IsolatedStorage.IsolatedStorageFile.MoveDirectory(System.String,System.String)
    /**
    Moves a specified directory and its contents to a new location.

    - Parameter sourceDirectoryName: The name of the directory to move.
    - Parameter destinationDirectoryName: The path to the new location for . This cannot be the path to an existing directory.
    */
    public func MoveDirectory(sourceDirectoryName : dotnet.System.String, destinationDirectoryName : dotnet.System.String) throws {
        var __thrown : NullableHandle = nil;
        System_IO_IsolatedStorage_IsolatedStorageFile_void__MoveDirectory_0__2__String_String(&__thrown, self.get_handle(), sourceDirectoryName.get_handle(), destinationDirectoryName.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
            return;
        }
    }
    // void MoveFile(System.String, System.String)
// docid: M:System.IO.IsolatedStorage.IsolatedStorageFile.MoveFile(System.String,System.String)
    /**
    Moves a specified file to a new location, and optionally lets you specify a new file name.

    - Parameter sourceFileName: The name of the file to move.
    - Parameter destinationFileName: The path to the new location for the file. If a file name is included, the moved file will have that name.
    */
    public func MoveFile(sourceFileName : dotnet.System.String, destinationFileName : dotnet.System.String) throws {
        var __thrown : NullableHandle = nil;
        System_IO_IsolatedStorage_IsolatedStorageFile_void__MoveFile_0__2__String_String(&__thrown, self.get_handle(), sourceFileName.get_handle(), destinationFileName.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
            return;
        }
    }
    // System.IO.IsolatedStorage.IsolatedStorageFileStream OpenFile(System.String, System.IO.FileMode)
// docid: M:System.IO.IsolatedStorage.IsolatedStorageFile.OpenFile(System.String,System.IO.FileMode)
    /**
    Opens a file in the specified mode.

    - Parameter path: The relative path of the file within the isolated store.
    - Parameter mode: One of the enumeration values that specifies how to open the file.
    - Returns: A file that is opened in the specified mode, with read/write access, and is unshared.

    */
    public func OpenFile(path : dotnet.System.String, mode : dotnet.System.IO.FileMode) throws -> dotnet.System.IO.IsolatedStorage.IsolatedStorageFileStream {
        var __thrown : NullableHandle = nil;
        let __return = System_IO_IsolatedStorage_IsolatedStorageFile_IsolatedStorageFileStream__OpenFile_0__2__String_FileMode(&__thrown, self.get_handle(), path.get_handle(), mode.get_value());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return dotnet.System.IO.IsolatedStorage.IsolatedStorageFileStream(hndl : __return);
        }
    }
    // System.IO.IsolatedStorage.IsolatedStorageFileStream OpenFile(System.String, System.IO.FileMode, System.IO.FileAccess)
// docid: M:System.IO.IsolatedStorage.IsolatedStorageFile.OpenFile(System.String,System.IO.FileMode,System.IO.FileAccess)
    /**
    Opens a file in the specified mode with the specified read/write access.

    - Parameter path: The relative path of the file within the isolated store.
    - Parameter mode: One of the enumeration values that specifies how to open the file.
    - Parameter access: One of the enumeration values that specifies whether the file will be opened with read, write, or read/write access.
    - Returns: A file that is opened in the specified mode and access, and is unshared.

    */
    public func OpenFile(path : dotnet.System.String, mode : dotnet.System.IO.FileMode, access : dotnet.System.IO.FileAccess) throws -> dotnet.System.IO.IsolatedStorage.IsolatedStorageFileStream {
        var __thrown : NullableHandle = nil;
        let __return = System_IO_IsolatedStorage_IsolatedStorageFile_IsolatedStorageFileStream__OpenFile_0__3__String_FileMode_FileAccess(&__thrown, self.get_handle(), path.get_handle(), mode.get_value(), access.get_value());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return dotnet.System.IO.IsolatedStorage.IsolatedStorageFileStream(hndl : __return);
        }
    }
    // System.IO.IsolatedStorage.IsolatedStorageFileStream OpenFile(System.String, System.IO.FileMode, System.IO.FileAccess, System.IO.FileShare)
// docid: M:System.IO.IsolatedStorage.IsolatedStorageFile.OpenFile(System.String,System.IO.FileMode,System.IO.FileAccess,System.IO.FileShare)
    /**
    Opens a file in the specified mode, with the specified read/write access and sharing permission.

    - Parameter path: The relative path of the file within the isolated store.
    - Parameter mode: One of the enumeration values that specifies how to open or create the file.
    - Parameter access: One of the enumeration values that specifies whether the file will be opened with read, write, or read/write access
    - Parameter share: A bitwise combination of enumeration values that specify the type of access other  objects have to this file.
    - Returns: A file that is opened in the specified mode and access, and with the specified sharing options.

    */
    public func OpenFile(path : dotnet.System.String, mode : dotnet.System.IO.FileMode, access : dotnet.System.IO.FileAccess, share : dotnet.System.IO.FileShare) throws -> dotnet.System.IO.IsolatedStorage.IsolatedStorageFileStream {
        var __thrown : NullableHandle = nil;
        let __return = System_IO_IsolatedStorage_IsolatedStorageFile_IsolatedStorageFileStream__OpenFile_0__4__String_FileMode_FileAccess_FileShare(&__thrown, self.get_handle(), path.get_handle(), mode.get_value(), access.get_value(), share.get_value());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return dotnet.System.IO.IsolatedStorage.IsolatedStorageFileStream(hndl : __return);
        }
    }
    // void Remove()
// docid: M:System.IO.IsolatedStorage.IsolatedStorageFile.Remove
    /**
    Removes the isolated storage scope and all its contents.

    */
    public override func Remove() throws {
        var __thrown : NullableHandle = nil;
        System_IO_IsolatedStorage_IsolatedStorageFile_void__Remove_0__0(&__thrown, self.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
            return;
        }
    }
    // void Remove(System.IO.IsolatedStorage.IsolatedStorageScope)
// docid: M:System.IO.IsolatedStorage.IsolatedStorageFile.Remove(System.IO.IsolatedStorage.IsolatedStorageScope)
    /**
    Removes the specified isolated storage scope for all identities.

    - Parameter scope: A bitwise combination of the  values.
    */
    public class func Remove(scope : dotnet.System.IO.IsolatedStorage.IsolatedStorageScope) throws {
        var __thrown : NullableHandle = nil;
        System_IO_IsolatedStorage_IsolatedStorageFile_void__Remove_0__1__IsolatedStorageScope(&__thrown, scope.get_value());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
            return;
        }
    }
    // [IsSpecialName] System.Int64 get_AvailableFreeSpace()
// docid: M:System.IO.IsolatedStorage.IsolatedStorageFile.get_AvailableFreeSpace
    public override func get_AvailableFreeSpace() throws -> Swift.Int64 {
        var __thrown : NullableHandle = nil;
        let __return = System_IO_IsolatedStorage_IsolatedStorageFile_i64__get_AvailableFreeSpace_0__0(&__thrown, self.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return __return;
        }
    }
    // [IsSpecialName] System.UInt64 get_CurrentSize()
// docid: M:System.IO.IsolatedStorage.IsolatedStorageFile.get_CurrentSize
    public override func get_CurrentSize() throws -> Swift.UInt64 {
        var __thrown : NullableHandle = nil;
        let __return = System_IO_IsolatedStorage_IsolatedStorageFile_u64__get_CurrentSize_0__0(&__thrown, self.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return __return;
        }
    }
    // [IsSpecialName] bool get_IsEnabled()
// docid: M:System.IO.IsolatedStorage.IsolatedStorageFile.get_IsEnabled
    public class func get_IsEnabled() throws -> Bool {
        var __thrown : NullableHandle = nil;
        let __return = System_IO_IsolatedStorage_IsolatedStorageFile_bool__get_IsEnabled_0__0(&__thrown);
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return (__return) != 0;
        }
    }
    // [IsSpecialName] System.UInt64 get_MaximumSize()
// docid: M:System.IO.IsolatedStorage.IsolatedStorageFile.get_MaximumSize
    public override func get_MaximumSize() throws -> Swift.UInt64 {
        var __thrown : NullableHandle = nil;
        let __return = System_IO_IsolatedStorage_IsolatedStorageFile_u64__get_MaximumSize_0__0(&__thrown, self.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return __return;
        }
    }
    // [IsSpecialName] System.Int64 get_Quota()
// docid: M:System.IO.IsolatedStorage.IsolatedStorageFile.get_Quota
    public override func get_Quota() throws -> Swift.Int64 {
        var __thrown : NullableHandle = nil;
        let __return = System_IO_IsolatedStorage_IsolatedStorageFile_i64__get_Quota_0__0(&__thrown, self.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return __return;
        }
    }
    // [IsSpecialName] System.Int64 get_UsedSize()
// docid: M:System.IO.IsolatedStorage.IsolatedStorageFile.get_UsedSize
    public override func get_UsedSize() throws -> Swift.Int64 {
        var __thrown : NullableHandle = nil;
        let __return = System_IO_IsolatedStorage_IsolatedStorageFile_i64__get_UsedSize_0__0(&__thrown, self.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return __return;
        }
    }
    /**
    Gets a value that represents the amount of free space available for isolated storage.

    */
    public override var AvailableFreeSpace : Swift.Int64 {
        get {
            return try! get_AvailableFreeSpace();
        }
    }
    /**
    Gets the current size of the isolated storage.

    */
    public override var CurrentSize : Swift.UInt64 {
        get {
            return try! get_CurrentSize();
        }
    }
    /**
    Gets a value that indicates whether isolated storage is enabled.

    */
    public static var IsEnabled : Bool {
        get {
            return try! get_IsEnabled();
        }
    }
    /**
    Gets a value representing the maximum amount of space available for isolated storage within the limits established by the quota.

    */
    public override var MaximumSize : Swift.UInt64 {
        get {
            return try! get_MaximumSize();
        }
    }
    /**
    Gets a value that represents the maximum amount of space available for isolated storage.

    */
    public override var Quota : Swift.Int64 {
        get {
            return try! get_Quota();
        }
    }
    /**
    Gets a value that represents the amount of the space used for isolated storage.

    */
    public override var UsedSize : Swift.Int64 {
        get {
            return try! get_UsedSize();
        }
    }
} // IsolatedStorageFile


// type: System.IO.IsolatedStorage.IsolatedStorageFileStream
    /**
    Exposes a file within isolated storage.

    */
open class IsolatedStorageFileStream
    :
    dotnet.System.IO.FileStream
{
    open class override func get_type_handle() -> TypeHandle {
        return System_IO_IsolatedStorage_IsolatedStorageFileStream_get_type_handle();
    }
    public required init(hndl: NonnullHandle) { super.init(hndl: hndl); }
    public required init(gval: GVal) { super.init(gval: gval); }
    // .ctor(System.String, System.IO.FileMode)
// docid: M:System.IO.IsolatedStorage.IsolatedStorageFileStream.#ctor(System.String,System.IO.FileMode)
    /**
    Initializes a new instance of an  object giving access to the file designated by  in the specified .

    - Parameter path: The relative path of the file within isolated storage.
    - Parameter mode: One of the  values.
    */
    public override init(path : dotnet.System.String, mode : dotnet.System.IO.FileMode) throws {
        var __thrown : NullableHandle = nil;
        let h = System_IO_IsolatedStorage_IsolatedStorageFileStream_ctor_0__2__String_FileMode(&__thrown, path.get_handle(), mode.get_value());
        if let __ex = __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
            super.init(hndl: h);
        }
    }
    // .ctor(System.String, System.IO.FileMode, System.IO.FileAccess)
// docid: M:System.IO.IsolatedStorage.IsolatedStorageFileStream.#ctor(System.String,System.IO.FileMode,System.IO.FileAccess)
    /**
    Initializes a new instance of the  class giving access to the file designated by , in the specified , with the kind of  requested.

    - Parameter path: The relative path of the file within isolated storage.
    - Parameter mode: One of the  values.
    - Parameter access: A bitwise combination of the  values.
    */
    public override init(path : dotnet.System.String, mode : dotnet.System.IO.FileMode, access : dotnet.System.IO.FileAccess) throws {
        var __thrown : NullableHandle = nil;
        let h = System_IO_IsolatedStorage_IsolatedStorageFileStream_ctor_0__3__String_FileMode_FileAccess(&__thrown, path.get_handle(), mode.get_value(), access.get_value());
        if let __ex = __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
            super.init(hndl: h);
        }
    }
    // .ctor(System.String, System.IO.FileMode, System.IO.FileAccess, System.IO.FileShare)
// docid: M:System.IO.IsolatedStorage.IsolatedStorageFileStream.#ctor(System.String,System.IO.FileMode,System.IO.FileAccess,System.IO.FileShare)
    /**
    Initializes a new instance of the  class giving access to the file designated by , in the specified , with the specified file , using the file sharing mode specified by .

    - Parameter path: The relative path of the file within isolated storage.
    - Parameter mode: One of the  values.
    - Parameter access: A bitwise combination of the  values.
    - Parameter share: A bitwise combination of the  values.
    */
    public override init(path : dotnet.System.String, mode : dotnet.System.IO.FileMode, access : dotnet.System.IO.FileAccess, share : dotnet.System.IO.FileShare) throws {
        var __thrown : NullableHandle = nil;
        let h = System_IO_IsolatedStorage_IsolatedStorageFileStream_ctor_0__4__String_FileMode_FileAccess_FileShare(&__thrown, path.get_handle(), mode.get_value(), access.get_value(), share.get_value());
        if let __ex = __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
            super.init(hndl: h);
        }
    }
    // .ctor(System.String, System.IO.FileMode, System.IO.FileAccess, System.IO.FileShare, System.Int32)
// docid: M:System.IO.IsolatedStorage.IsolatedStorageFileStream.#ctor(System.String,System.IO.FileMode,System.IO.FileAccess,System.IO.FileShare,System.Int32)
    /**
    Initializes a new instance of the  class giving access to the file designated by , in the specified , with the specified file , using the file sharing mode specified by , with the  specified.

    - Parameter path: The relative path of the file within isolated storage.
    - Parameter mode: One of the  values.
    - Parameter access: A bitwise combination of the  values.
    - Parameter share: A bitwise combination of the  values.
    - Parameter bufferSize: The  buffer size.
    */
    public override init(path : dotnet.System.String, mode : dotnet.System.IO.FileMode, access : dotnet.System.IO.FileAccess, share : dotnet.System.IO.FileShare, bufferSize : Swift.Int32) throws {
        var __thrown : NullableHandle = nil;
        let h = System_IO_IsolatedStorage_IsolatedStorageFileStream_ctor_0__5__String_FileMode_FileAccess_FileShare_i32(&__thrown, path.get_handle(), mode.get_value(), access.get_value(), share.get_value(), bufferSize);
        if let __ex = __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
            super.init(hndl: h);
        }
    }
    // .ctor(System.String, System.IO.FileMode, System.IO.FileAccess, System.IO.FileShare, System.Int32, System.IO.IsolatedStorage.IsolatedStorageFile)
// docid: M:System.IO.IsolatedStorage.IsolatedStorageFileStream.#ctor(System.String,System.IO.FileMode,System.IO.FileAccess,System.IO.FileShare,System.Int32,System.IO.IsolatedStorage.IsolatedStorageFile)
    /**
    Initializes a new instance of the  class giving access to the file designated by , in the specified , with the specified file , using the file sharing mode specified by , with the  specified, and in the context of the  specified by .

    - Parameter path: The relative path of the file within isolated storage.
    - Parameter mode: One of the  values.
    - Parameter access: A bitwise combination of the  values.
    - Parameter share: A bitwise combination of the  values
    - Parameter bufferSize: The  buffer size.
    - Parameter isf: The  in which to open the .
    */
    public init(path : dotnet.System.String, mode : dotnet.System.IO.FileMode, access : dotnet.System.IO.FileAccess, share : dotnet.System.IO.FileShare, bufferSize : Swift.Int32, isf : Optional<dotnet.System.IO.IsolatedStorage.IsolatedStorageFile>) throws {
        var __thrown : NullableHandle = nil;
        let h = System_IO_IsolatedStorage_IsolatedStorageFileStream_ctor_0__6__String_FileMode_FileAccess_FileShare_i32_IsolatedStorageFile(&__thrown, path.get_handle(), mode.get_value(), access.get_value(), share.get_value(), bufferSize, isf?.get_handle() ?? nil);
        if let __ex = __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
            super.init(hndl: h);
        }
    }
    // .ctor(System.String, System.IO.FileMode, System.IO.FileAccess, System.IO.FileShare, System.IO.IsolatedStorage.IsolatedStorageFile)
// docid: M:System.IO.IsolatedStorage.IsolatedStorageFileStream.#ctor(System.String,System.IO.FileMode,System.IO.FileAccess,System.IO.FileShare,System.IO.IsolatedStorage.IsolatedStorageFile)
    /**
    Initializes a new instance of the  class giving access to the file designated by , in the specified , with the specified file , using the file sharing mode specified by , and in the context of the  specified by .

    - Parameter path: The relative path of the file within isolated storage.
    - Parameter mode: One of the  values.
    - Parameter access: A bitwise combination of the  values.
    - Parameter share: A bitwise combination of the  values.
    - Parameter isf: The  in which to open the .
    */
    public init(path : dotnet.System.String, mode : dotnet.System.IO.FileMode, access : dotnet.System.IO.FileAccess, share : dotnet.System.IO.FileShare, isf : Optional<dotnet.System.IO.IsolatedStorage.IsolatedStorageFile>) throws {
        var __thrown : NullableHandle = nil;
        let h = System_IO_IsolatedStorage_IsolatedStorageFileStream_ctor_0__5__String_FileMode_FileAccess_FileShare_IsolatedStorageFile(&__thrown, path.get_handle(), mode.get_value(), access.get_value(), share.get_value(), isf?.get_handle() ?? nil);
        if let __ex = __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
            super.init(hndl: h);
        }
    }
    // .ctor(System.String, System.IO.FileMode, System.IO.FileAccess, System.IO.IsolatedStorage.IsolatedStorageFile)
// docid: M:System.IO.IsolatedStorage.IsolatedStorageFileStream.#ctor(System.String,System.IO.FileMode,System.IO.FileAccess,System.IO.IsolatedStorage.IsolatedStorageFile)
    /**
    Initializes a new instance of the  class giving access to the file designated by  in the specified , with the specified file , and in the context of the  specified by .

    - Parameter path: The relative path of the file within isolated storage.
    - Parameter mode: One of the  values.
    - Parameter access: A bitwise combination of the  values.
    - Parameter isf: The  in which to open the .
    */
    public init(path : dotnet.System.String, mode : dotnet.System.IO.FileMode, access : dotnet.System.IO.FileAccess, isf : Optional<dotnet.System.IO.IsolatedStorage.IsolatedStorageFile>) throws {
        var __thrown : NullableHandle = nil;
        let h = System_IO_IsolatedStorage_IsolatedStorageFileStream_ctor_0__4__String_FileMode_FileAccess_IsolatedStorageFile(&__thrown, path.get_handle(), mode.get_value(), access.get_value(), isf?.get_handle() ?? nil);
        if let __ex = __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
            super.init(hndl: h);
        }
    }
    // .ctor(System.String, System.IO.FileMode, System.IO.IsolatedStorage.IsolatedStorageFile)
// docid: M:System.IO.IsolatedStorage.IsolatedStorageFileStream.#ctor(System.String,System.IO.FileMode,System.IO.IsolatedStorage.IsolatedStorageFile)
    /**
    Initializes a new instance of the  class giving access to the file designated by , in the specified , and in the context of the  specified by .

    - Parameter path: The relative path of the file within isolated storage.
    - Parameter mode: One of the  values.
    - Parameter isf: The  in which to open the .
    */
    public init(path : dotnet.System.String, mode : dotnet.System.IO.FileMode, isf : Optional<dotnet.System.IO.IsolatedStorage.IsolatedStorageFile>) throws {
        var __thrown : NullableHandle = nil;
        let h = System_IO_IsolatedStorage_IsolatedStorageFileStream_ctor_0__3__String_FileMode_IsolatedStorageFile(&__thrown, path.get_handle(), mode.get_value(), isf?.get_handle() ?? nil);
        if let __ex = __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
            super.init(hndl: h);
        }
    }
    // System.IAsyncResult BeginRead(System.Byte[], System.Int32, System.Int32, System.AsyncCallback, System.Object)
// docid: M:System.IO.IsolatedStorage.IsolatedStorageFileStream.BeginRead(System.Byte[],System.Int32,System.Int32,System.AsyncCallback,System.Object)
    /**
    Begins an asynchronous read.

    - Parameter array: 
    - Parameter offset: The byte offset in  at which to begin reading.
    - Parameter numBytes: The maximum number of bytes to read.
    - Parameter userCallback: The method to call when the asynchronous read operation is completed. This parameter is optional.
    - Parameter stateObject: The status of the asynchronous read.
    - Returns: An  object that represents the asynchronous read, which is possibly still pending. This  must be passed to this stream's  method to determine how many bytes were read. This can be done either by the same code that called  or in a callback passed to .

    */
    open func BeginRead(array : dotnet.System_Arr<Swift.UInt8>, offset : Swift.Int32, numBytes : Swift.Int32, userCallback : Optional<dotnet.System.AsyncCallback>, stateObject : Optional<dotnet.System.Object>) throws -> dotnet.System.IAsyncResult {
        var __thrown : NullableHandle = nil;
        let __return = System_IO_IsolatedStorage_IsolatedStorageFileStream_IAsyncResult__BeginRead_0__5__u8Array_i32_i32_AsyncCallback_Object(&__thrown, self.get_handle(), array.get_handle(), offset, numBytes, userCallback?.get_handle() ?? nil, stateObject?.get_handle() ?? nil);
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return dotnet.System.IAsyncResult(hndl : __return);
        }
    }
    // delegate closure overload
    open func BeginRead(array : dotnet.System_Arr<Swift.UInt8>, offset : Swift.Int32, numBytes : Swift.Int32, userCallback : @escaping (dotnet.System.IAsyncResult) throws -> Void, stateObject : Optional<dotnet.System.Object>) throws -> dotnet.System.IAsyncResult {
        let del_userCallback = try dotnet.System.AsyncCallback(userCallback);
        return try BeginRead(array: array, offset: offset, numBytes: numBytes, userCallback: del_userCallback, stateObject: stateObject);
    }
    // System.IAsyncResult BeginWrite(System.Byte[], System.Int32, System.Int32, System.AsyncCallback, System.Object)
// docid: M:System.IO.IsolatedStorage.IsolatedStorageFileStream.BeginWrite(System.Byte[],System.Int32,System.Int32,System.AsyncCallback,System.Object)
    /**
    Begins an asynchronous write.

    - Parameter array: 
    - Parameter offset: The byte offset in  at which to begin writing.
    - Parameter numBytes: The maximum number of bytes to write.
    - Parameter userCallback: The method to call when the asynchronous write operation is completed. This parameter is optional.
    - Parameter stateObject: The status of the asynchronous write.
    - Returns: An  that represents the asynchronous write, which is possibly still pending. This  must be passed to this stream's  method to ensure that the write is complete, then frees resources appropriately. This can be done either by the same code that called  or in a callback passed to .

    */
    open func BeginWrite(array : dotnet.System_Arr<Swift.UInt8>, offset : Swift.Int32, numBytes : Swift.Int32, userCallback : Optional<dotnet.System.AsyncCallback>, stateObject : Optional<dotnet.System.Object>) throws -> dotnet.System.IAsyncResult {
        var __thrown : NullableHandle = nil;
        let __return = System_IO_IsolatedStorage_IsolatedStorageFileStream_IAsyncResult__BeginWrite_0__5__u8Array_i32_i32_AsyncCallback_Object(&__thrown, self.get_handle(), array.get_handle(), offset, numBytes, userCallback?.get_handle() ?? nil, stateObject?.get_handle() ?? nil);
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return dotnet.System.IAsyncResult(hndl : __return);
        }
    }
    // delegate closure overload
    open func BeginWrite(array : dotnet.System_Arr<Swift.UInt8>, offset : Swift.Int32, numBytes : Swift.Int32, userCallback : @escaping (dotnet.System.IAsyncResult) throws -> Void, stateObject : Optional<dotnet.System.Object>) throws -> dotnet.System.IAsyncResult {
        let del_userCallback = try dotnet.System.AsyncCallback(userCallback);
        return try BeginWrite(array: array, offset: offset, numBytes: numBytes, userCallback: del_userCallback, stateObject: stateObject);
    }
    // System.Threading.Tasks.ValueTask DisposeAsync()
// docid: M:System.IO.IsolatedStorage.IsolatedStorageFileStream.DisposeAsync
    /**
    Asynchronously releases the unmanaged resources used by the .

    - Returns: A task that represents the asynchronous dispose operation.

    */
    open override func DisposeAsync() throws -> dotnet.System.Threading.Tasks.ValueTask {
        var __thrown : NullableHandle = nil;
        let __return = System_IO_IsolatedStorage_IsolatedStorageFileStream_ValueTask__DisposeAsync_0__0(&__thrown, self.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return dotnet.System.Threading.Tasks.ValueTask(hndl : __return);
        }
    }
    // System.Int32 EndRead(System.IAsyncResult)
// docid: M:System.IO.IsolatedStorage.IsolatedStorageFileStream.EndRead(System.IAsyncResult)
    /**
    Ends a pending asynchronous read request.

    - Parameter asyncResult: The pending asynchronous request.
    - Returns: The number of bytes read from the stream, between zero and the number of requested bytes. Streams will only return zero at the end of the stream. Otherwise, they will block until at least one byte is available.

    */
    open override func EndRead(asyncResult : dotnet.System.IAsyncResult) throws -> Swift.Int32 {
        var __thrown : NullableHandle = nil;
        let __return = System_IO_IsolatedStorage_IsolatedStorageFileStream_i32__EndRead_0__1__IAsyncResult(&__thrown, self.get_handle(), asyncResult.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return __return;
        }
    }
    // void EndWrite(System.IAsyncResult)
// docid: M:System.IO.IsolatedStorage.IsolatedStorageFileStream.EndWrite(System.IAsyncResult)
    /**
    Ends an asynchronous write.

    - Parameter asyncResult: The pending asynchronous I/O request to end.
    */
    open override func EndWrite(asyncResult : dotnet.System.IAsyncResult) throws {
        var __thrown : NullableHandle = nil;
        System_IO_IsolatedStorage_IsolatedStorageFileStream_void__EndWrite_0__1__IAsyncResult(&__thrown, self.get_handle(), asyncResult.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
            return;
        }
    }
    // void Flush()
// docid: M:System.IO.IsolatedStorage.IsolatedStorageFileStream.Flush
    /**
    Clears buffers for this stream and causes any buffered data to be written to the file.

    */
    open override func Flush() throws {
        var __thrown : NullableHandle = nil;
        System_IO_IsolatedStorage_IsolatedStorageFileStream_void__Flush_0__0(&__thrown, self.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
            return;
        }
    }
    // void Flush(bool)
// docid: M:System.IO.IsolatedStorage.IsolatedStorageFileStream.Flush(System.Boolean)
    /**
    Clears buffers for this stream and causes any buffered data to be written to the file, and also clears all intermediate file buffers.

    - Parameter flushToDisk: 
         to flush all intermediate file buffers; otherwise, .
    */
    open override func Flush(flushToDisk : Bool) throws {
        var __thrown : NullableHandle = nil;
        System_IO_IsolatedStorage_IsolatedStorageFileStream_void__Flush_0__1__bool(&__thrown, self.get_handle(), Swift.Int32(flushToDisk ? 1 : 0));
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
            return;
        }
    }
    // System.Threading.Tasks.Task FlushAsync(System.Threading.CancellationToken)
// docid: M:System.IO.IsolatedStorage.IsolatedStorageFileStream.FlushAsync(System.Threading.CancellationToken)
    /**
    Asynchronously clears buffers for this stream and causes any buffered data to be written to the file.

    - Parameter cancellationToken: The token to monitor for cancellation requests. The default value is .
    - Returns: A task that represents the asynchronous flush operation.

    */
    open override func FlushAsync(cancellationToken : dotnet.System.Threading.CancellationToken) throws -> dotnet.System.Threading.Tasks.Task {
        var __thrown : NullableHandle = nil;
        let __return = System_IO_IsolatedStorage_IsolatedStorageFileStream_Task__FlushAsync_0__1__CancellationToken(&__thrown, self.get_handle(), cancellationToken.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return dotnet.System.Threading.Tasks.Task(hndl : __return);
        }
    }
    // void Lock(System.Int64, System.Int64)
// docid: M:System.IO.IsolatedStorage.IsolatedStorageFileStream.Lock(System.Int64,System.Int64)
    /**
    Prevents other processes from reading from or writing to the stream.

    - Parameter position: The starting position of the range to lock. The value of this parameter must be equal to or greater than 0 (zero).
    - Parameter length: The number of bytes to lock.
    */
    open override func Lock(position : Swift.Int64, length : Swift.Int64) throws {
        var __thrown : NullableHandle = nil;
        System_IO_IsolatedStorage_IsolatedStorageFileStream_void__Lock_0__2__i64_i64(&__thrown, self.get_handle(), position, length);
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
            return;
        }
    }
    // System.Int32 Read(System.Byte[], System.Int32, System.Int32)
// docid: M:System.IO.IsolatedStorage.IsolatedStorageFileStream.Read(System.Byte[],System.Int32,System.Int32)
    /**
    Copies bytes from the current buffered  object to a byte array.

    - Parameter buffer: The buffer to write the data into.
    - Parameter offset: The offset in the buffer at which to begin writing.
    - Parameter count: The maximum number of bytes to read.
    - Returns: The total number of bytes read into the . This can be less than the number of bytes requested if that many bytes are not currently available, or zero if the end of the stream is reached.

    */
    open override func Read(buffer : dotnet.System_Arr<Swift.UInt8>, offset : Swift.Int32, count : Swift.Int32) throws -> Swift.Int32 {
        var __thrown : NullableHandle = nil;
        let __return = System_IO_IsolatedStorage_IsolatedStorageFileStream_i32__Read_0__3__u8Array_i32_i32(&__thrown, self.get_handle(), buffer.get_handle(), offset, count);
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return __return;
        }
    }
// TODO COPE (write_all_methods) (span) System.Int32 Read(System.Span<System.Byte>)
    // System.Threading.Tasks.Task<System.Int32> ReadAsync(System.Byte[], System.Int32, System.Int32, System.Threading.CancellationToken)
// docid: M:System.IO.IsolatedStorage.IsolatedStorageFileStream.ReadAsync(System.Byte[],System.Int32,System.Int32,System.Threading.CancellationToken)
    /**
    Asynchronously copies bytes from the current buffered  object to a byte array.

    - Parameter buffer: The buffer to write the data into.
    - Parameter offset: The offset in the buffer at which to begin writing.
    - Parameter count: The maximum number of bytes to read.
    - Parameter cancellationToken: The token to monitor for cancellation requests. The default value is .
    - Returns: A task that represents the asynchronous read operation. It wraps the total number of bytes read into the . This can be less than the number of bytes requested if that many bytes are not currently available, or zero if the end of the stream is reached.

    */
    open override func ReadAsync(buffer : dotnet.System_Arr<Swift.UInt8>, offset : Swift.Int32, count : Swift.Int32, cancellationToken : dotnet.System.Threading.CancellationToken) throws -> dotnet.System.Threading.Tasks.Task_1<Swift.Int32> {
        var __thrown : NullableHandle = nil;
        let __return = System_IO_IsolatedStorage_IsolatedStorageFileStream_System_Threading_Tasks_Task_i32___ReadAsync_0__4__u8Array_i32_i32_CancellationToken(&__thrown, self.get_handle(), buffer.get_handle(), offset, count, cancellationToken.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return dotnet.System.Threading.Tasks.Task_1(hndl : __return);
        }
    }
    // System.Threading.Tasks.ValueTask<System.Int32> ReadAsync(System.Memory<System.Byte>, System.Threading.CancellationToken)
// docid: M:System.IO.IsolatedStorage.IsolatedStorageFileStream.ReadAsync(System.Memory{System.Byte},System.Threading.CancellationToken)
    /**
    Asynchronously copies bytes from the current buffered  object to a byte memory range.

    - Parameter buffer: The buffer to write the data into.
    - Parameter cancellationToken: The token to monitor for cancellation requests. The default value is .
    - Returns: A task that represents the asynchronous read operation. It wraps the total number of bytes read into the . This can be less than the number of bytes requested if that many bytes are not currently available, or zero if the end of the stream is reached.

    */
    open override func ReadAsync(buffer : dotnet.System.Memory_1<Swift.UInt8>, cancellationToken : dotnet.System.Threading.CancellationToken = System.Threading.CancellationToken.None) throws -> dotnet.System.Threading.Tasks.ValueTask_1<Swift.Int32> {
        var __thrown : NullableHandle = nil;
        let __return = System_IO_IsolatedStorage_IsolatedStorageFileStream_System_Threading_Tasks_ValueTask_i32___ReadAsync_0__2__System_Memory_u8__CancellationToken(&__thrown, self.get_handle(), buffer.get_handle(), cancellationToken.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return dotnet.System.Threading.Tasks.ValueTask_1(hndl : __return);
        }
    }
    // System.Int32 ReadByte()
// docid: M:System.IO.IsolatedStorage.IsolatedStorageFileStream.ReadByte
    /**
    Reads a single byte from the  object in isolated storage.

    - Returns: The 8-bit unsigned integer value read from the isolated storage file.

    */
    open override func ReadByte() throws -> Swift.Int32 {
        var __thrown : NullableHandle = nil;
        let __return = System_IO_IsolatedStorage_IsolatedStorageFileStream_i32__ReadByte_0__0(&__thrown, self.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return __return;
        }
    }
    // System.Int64 Seek(System.Int64, System.IO.SeekOrigin)
// docid: M:System.IO.IsolatedStorage.IsolatedStorageFileStream.Seek(System.Int64,System.IO.SeekOrigin)
    /**
    Sets the current position of this  object to the specified value.

    - Parameter offset: The new position of the  object.
    - Parameter origin: One of the  values.
    - Returns: The new position in the  object.

    */
    open override func Seek(offset : Swift.Int64, origin : dotnet.System.IO.SeekOrigin) throws -> Swift.Int64 {
        var __thrown : NullableHandle = nil;
        let __return = System_IO_IsolatedStorage_IsolatedStorageFileStream_i64__Seek_0__2__i64_SeekOrigin(&__thrown, self.get_handle(), offset, origin.get_value());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return __return;
        }
    }
    // void SetLength(System.Int64)
// docid: M:System.IO.IsolatedStorage.IsolatedStorageFileStream.SetLength(System.Int64)
    /**
    Sets the length of this  object to the specified .

    - Parameter value: The new length of the  object.
    */
    open override func SetLength(value : Swift.Int64) throws {
        var __thrown : NullableHandle = nil;
        System_IO_IsolatedStorage_IsolatedStorageFileStream_void__SetLength_0__1__i64(&__thrown, self.get_handle(), value);
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
            return;
        }
    }
    // void Unlock(System.Int64, System.Int64)
// docid: M:System.IO.IsolatedStorage.IsolatedStorageFileStream.Unlock(System.Int64,System.Int64)
    /**
    Allows other processes to access all or part of a file that was previously locked.

    - Parameter position: The starting position of the range to unlock. The value of this parameter must be equal to or greater than 0 (zero).
    - Parameter length: The number of bytes to unlock.
    */
    open override func Unlock(position : Swift.Int64, length : Swift.Int64) throws {
        var __thrown : NullableHandle = nil;
        System_IO_IsolatedStorage_IsolatedStorageFileStream_void__Unlock_0__2__i64_i64(&__thrown, self.get_handle(), position, length);
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
            return;
        }
    }
    // void Write(System.Byte[], System.Int32, System.Int32)
// docid: M:System.IO.IsolatedStorage.IsolatedStorageFileStream.Write(System.Byte[],System.Int32,System.Int32)
    /**
    Writes a block of bytes to the isolated storage file stream object using data read from a buffer consisting of a byte array.

    - Parameter buffer: The byte array from which to copy bytes to the current isolated storage file stream.
    - Parameter offset: The byte offset in  from which to begin.
    - Parameter count: The maximum number of bytes to write.
    */
    open override func Write(buffer : dotnet.System_Arr<Swift.UInt8>, offset : Swift.Int32, count : Swift.Int32) throws {
        var __thrown : NullableHandle = nil;
        System_IO_IsolatedStorage_IsolatedStorageFileStream_void__Write_0__3__u8Array_i32_i32(&__thrown, self.get_handle(), buffer.get_handle(), offset, count);
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
            return;
        }
    }
// TODO COPE (write_all_methods) (span) void Write(System.ReadOnlySpan<System.Byte>)
    // System.Threading.Tasks.Task WriteAsync(System.Byte[], System.Int32, System.Int32, System.Threading.CancellationToken)
// docid: M:System.IO.IsolatedStorage.IsolatedStorageFileStream.WriteAsync(System.Byte[],System.Int32,System.Int32,System.Threading.CancellationToken)
    /**
    Asynchronously writes a block of bytes to the isolated storage file stream object using data read from a buffer consisting of a byte array.

    - Parameter buffer: The byte array from which to copy bytes to the current isolated storage file stream.
    - Parameter offset: The byte offset in  from which to begin.
    - Parameter count: The maximum number of bytes to write.
    - Parameter cancellationToken: The token to monitor for cancellation requests. The default value is .
    - Returns: A task that represents the asynchronous write operation.

    */
    open override func WriteAsync(buffer : dotnet.System_Arr<Swift.UInt8>, offset : Swift.Int32, count : Swift.Int32, cancellationToken : dotnet.System.Threading.CancellationToken) throws -> dotnet.System.Threading.Tasks.Task {
        var __thrown : NullableHandle = nil;
        let __return = System_IO_IsolatedStorage_IsolatedStorageFileStream_Task__WriteAsync_0__4__u8Array_i32_i32_CancellationToken(&__thrown, self.get_handle(), buffer.get_handle(), offset, count, cancellationToken.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return dotnet.System.Threading.Tasks.Task(hndl : __return);
        }
    }
    // System.Threading.Tasks.ValueTask WriteAsync(System.ReadOnlyMemory<System.Byte>, System.Threading.CancellationToken)
// docid: M:System.IO.IsolatedStorage.IsolatedStorageFileStream.WriteAsync(System.ReadOnlyMemory{System.Byte},System.Threading.CancellationToken)
    /**
    Asynchronously writes a block of bytes to the isolated storage file stream object using data read from a buffer consisting of a read-only byte memory range.

    - Parameter buffer: The read-only byte memory from which to copy bytes to the current isolated storage file stream.
    - Parameter cancellationToken: The token to monitor for cancellation requests. The default value is .
    - Returns: A task that represents the asynchronous write operation.

    */
    open override func WriteAsync(buffer : dotnet.System.ReadOnlyMemory_1<Swift.UInt8>, cancellationToken : dotnet.System.Threading.CancellationToken = System.Threading.CancellationToken.None) throws -> dotnet.System.Threading.Tasks.ValueTask {
        var __thrown : NullableHandle = nil;
        let __return = System_IO_IsolatedStorage_IsolatedStorageFileStream_ValueTask__WriteAsync_0__2__System_ReadOnlyMemory_u8__CancellationToken(&__thrown, self.get_handle(), buffer.get_handle(), cancellationToken.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return dotnet.System.Threading.Tasks.ValueTask(hndl : __return);
        }
    }
    // void WriteByte(System.Byte)
// docid: M:System.IO.IsolatedStorage.IsolatedStorageFileStream.WriteByte(System.Byte)
    /**
    Writes a single byte to the  object.

    - Parameter value: The byte value to write to the isolated storage file.
    */
    open override func WriteByte(value : Swift.UInt8) throws {
        var __thrown : NullableHandle = nil;
        System_IO_IsolatedStorage_IsolatedStorageFileStream_void__WriteByte_0__1__u8(&__thrown, self.get_handle(), value);
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
            return;
        }
    }
    // [IsSpecialName] bool get_CanRead()
// docid: M:System.IO.IsolatedStorage.IsolatedStorageFileStream.get_CanRead
    open override func get_CanRead() throws -> Bool {
        var __thrown : NullableHandle = nil;
        let __return = System_IO_IsolatedStorage_IsolatedStorageFileStream_bool__get_CanRead_0__0(&__thrown, self.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return (__return) != 0;
        }
    }
    // [IsSpecialName] bool get_CanSeek()
// docid: M:System.IO.IsolatedStorage.IsolatedStorageFileStream.get_CanSeek
    open override func get_CanSeek() throws -> Bool {
        var __thrown : NullableHandle = nil;
        let __return = System_IO_IsolatedStorage_IsolatedStorageFileStream_bool__get_CanSeek_0__0(&__thrown, self.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return (__return) != 0;
        }
    }
    // [IsSpecialName] bool get_CanWrite()
// docid: M:System.IO.IsolatedStorage.IsolatedStorageFileStream.get_CanWrite
    open override func get_CanWrite() throws -> Bool {
        var __thrown : NullableHandle = nil;
        let __return = System_IO_IsolatedStorage_IsolatedStorageFileStream_bool__get_CanWrite_0__0(&__thrown, self.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return (__return) != 0;
        }
    }
    // [IsSpecialName] System.IntPtr get_Handle()
// docid: M:System.IO.IsolatedStorage.IsolatedStorageFileStream.get_Handle
    open override func get_Handle() throws -> dotnet.System.IntPtr {
        var __thrown : NullableHandle = nil;
        let __return = System_IO_IsolatedStorage_IsolatedStorageFileStream_IntPtr__get_Handle_0__0(&__thrown, self.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return dotnet.System.IntPtr(val: __return);
        }
    }
    // [IsSpecialName] bool get_IsAsync()
// docid: M:System.IO.IsolatedStorage.IsolatedStorageFileStream.get_IsAsync
    open override func get_IsAsync() throws -> Bool {
        var __thrown : NullableHandle = nil;
        let __return = System_IO_IsolatedStorage_IsolatedStorageFileStream_bool__get_IsAsync_0__0(&__thrown, self.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return (__return) != 0;
        }
    }
    // [IsSpecialName] System.Int64 get_Length()
// docid: M:System.IO.IsolatedStorage.IsolatedStorageFileStream.get_Length
    open override func get_Length() throws -> Swift.Int64 {
        var __thrown : NullableHandle = nil;
        let __return = System_IO_IsolatedStorage_IsolatedStorageFileStream_i64__get_Length_0__0(&__thrown, self.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return __return;
        }
    }
    // [IsSpecialName] System.Int64 get_Position()
// docid: M:System.IO.IsolatedStorage.IsolatedStorageFileStream.get_Position
    open override func get_Position() throws -> Swift.Int64 {
        var __thrown : NullableHandle = nil;
        let __return = System_IO_IsolatedStorage_IsolatedStorageFileStream_i64__get_Position_0__0(&__thrown, self.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return __return;
        }
    }
    // [IsSpecialName] void set_Position(System.Int64)
// docid: M:System.IO.IsolatedStorage.IsolatedStorageFileStream.set_Position(System.Int64)
    open override func set_Position(value : Swift.Int64) throws {
        var __thrown : NullableHandle = nil;
        System_IO_IsolatedStorage_IsolatedStorageFileStream_void__set_Position_0__1__i64(&__thrown, self.get_handle(), value);
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
            return;
        }
    }
    // [IsSpecialName] Microsoft.Win32.SafeHandles.SafeFileHandle get_SafeFileHandle()
// docid: M:System.IO.IsolatedStorage.IsolatedStorageFileStream.get_SafeFileHandle
    open override func get_SafeFileHandle() throws -> dotnet.Microsoft.Win32.SafeHandles.SafeFileHandle {
        var __thrown : NullableHandle = nil;
        let __return = System_IO_IsolatedStorage_IsolatedStorageFileStream_SafeFileHandle__get_SafeFileHandle_0__0(&__thrown, self.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return dotnet.Microsoft.Win32.SafeHandles.SafeFileHandle(hndl : __return);
        }
    }
    /**
    Gets a Boolean value indicating whether the file can be read.

    */
    open override var CanRead : Bool {
        get {
            return try! get_CanRead();
        }
    }
    /**
    Gets a Boolean value indicating whether seek operations are supported.

    */
    open override var CanSeek : Bool {
        get {
            return try! get_CanSeek();
        }
    }
    /**
    Gets a Boolean value indicating whether you can write to the file.

    */
    open override var CanWrite : Bool {
        get {
            return try! get_CanWrite();
        }
    }
    /**
    Gets the file handle for the file that the current  object encapsulates. Accessing this property is not permitted on an  object, and throws an .

    */
    open override var Handle : dotnet.System.IntPtr {
        get {
            return try! get_Handle();
        }
    }
    /**
    Gets a Boolean value indicating whether the  object was opened asynchronously or synchronously.

    */
    open override var IsAsync : Bool {
        get {
            return try! get_IsAsync();
        }
    }
    /**
    Gets the length of the  object.

    */
    open override var Length : Swift.Int64 {
        get {
            return try! get_Length();
        }
    }
    /**
    Gets or sets the current position of the current  object.

    */
    open override var Position : Swift.Int64 {
        get {
            return try! get_Position();
        }
        set(v) {
            return try! set_Position(value: v);
        }
    }
    /**
    Gets a  object that represents the operating system file handle for the file that the current  object encapsulates.

    */
    open override var SafeFileHandle : dotnet.Microsoft.Win32.SafeHandles.SafeFileHandle {
        get {
            return try! get_SafeFileHandle();
        }
    }
} // IsolatedStorageFileStream


// type: System.IO.IsolatedStorage.IsolatedStorageScope
    /**
    Enumerates the levels of isolated storage scope that are supported by .

    */
public struct IsolatedStorageScope : SGBridgeGenericValue {
    let v : Swift.Int32;
    public init(val: Swift.Int32) { self.v = val; }
    public func get_value() -> Swift.Int32 { return self.v; }
    public static func get_type_handle() -> TypeHandle {
        return System_IO_IsolatedStorage_IsolatedStorageScope_get_type_handle();
    }
    public func to_gval() -> GVal { return GVal(self.v); }
    public func dup_gval() -> GVal { return to_gval(); }
    public init(gval: GVal) { self.v = Swift.Int32(gval); }
    // static field: System.IO.IsolatedStorage.IsolatedStorageScope None
    /**
    No isolated storage usage.

    */
    public static var None : dotnet.System.IO.IsolatedStorage.IsolatedStorageScope {
        get {
        let __return = dotnet.System.IO.IsolatedStorage.IsolatedStorageScope(val: System_IO_IsolatedStorage_IsolatedStorageScope_get_None());
            return __return;
        }
    }
    // static field: System.IO.IsolatedStorage.IsolatedStorageScope User
    /**
    Isolated storage scoped by user identity.

    */
    public static var User : dotnet.System.IO.IsolatedStorage.IsolatedStorageScope {
        get {
        let __return = dotnet.System.IO.IsolatedStorage.IsolatedStorageScope(val: System_IO_IsolatedStorage_IsolatedStorageScope_get_User());
            return __return;
        }
    }
    // static field: System.IO.IsolatedStorage.IsolatedStorageScope Domain
    /**
    Isolated storage scoped to the application domain identity.

    */
    public static var Domain : dotnet.System.IO.IsolatedStorage.IsolatedStorageScope {
        get {
        let __return = dotnet.System.IO.IsolatedStorage.IsolatedStorageScope(val: System_IO_IsolatedStorage_IsolatedStorageScope_get_Domain());
            return __return;
        }
    }
    // static field: System.IO.IsolatedStorage.IsolatedStorageScope Assembly
    /**
    Isolated storage scoped to the identity of the assembly.

    */
    public static var Assembly : dotnet.System.IO.IsolatedStorage.IsolatedStorageScope {
        get {
        let __return = dotnet.System.IO.IsolatedStorage.IsolatedStorageScope(val: System_IO_IsolatedStorage_IsolatedStorageScope_get_Assembly());
            return __return;
        }
    }
    // static field: System.IO.IsolatedStorage.IsolatedStorageScope Roaming
    /**
    The isolated store can be placed in a location on the file system that might roam (if roaming user data is enabled on the underlying operating system).

    */
    public static var Roaming : dotnet.System.IO.IsolatedStorage.IsolatedStorageScope {
        get {
        let __return = dotnet.System.IO.IsolatedStorage.IsolatedStorageScope(val: System_IO_IsolatedStorage_IsolatedStorageScope_get_Roaming());
            return __return;
        }
    }
    // static field: System.IO.IsolatedStorage.IsolatedStorageScope Machine
    /**
    Isolated storage scoped to the machine.

    */
    public static var Machine : dotnet.System.IO.IsolatedStorage.IsolatedStorageScope {
        get {
        let __return = dotnet.System.IO.IsolatedStorage.IsolatedStorageScope(val: System_IO_IsolatedStorage_IsolatedStorageScope_get_Machine());
            return __return;
        }
    }
    // static field: System.IO.IsolatedStorage.IsolatedStorageScope Application
    /**
    Isolated storage scoped to the application.

    */
    public static var Application : dotnet.System.IO.IsolatedStorage.IsolatedStorageScope {
        get {
        let __return = dotnet.System.IO.IsolatedStorage.IsolatedStorageScope(val: System_IO_IsolatedStorage_IsolatedStorageScope_get_Application());
            return __return;
        }
    }
} // IsolatedStorageScope


}



public protocol System_IO_IsolatedStorage_INormalizeForIsolatedStorage
    :
    SGBridgeGetHandle
{
}

