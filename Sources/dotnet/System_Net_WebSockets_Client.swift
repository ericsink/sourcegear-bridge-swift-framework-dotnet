// this file is automatically generated
// Copyright 2021 SourceGear

import jumptable_dotnet;

// System
// System.Net
// System.Net.WebSockets
extension System.Net.WebSockets {
// type: System.Net.WebSockets.ClientWebSocket
    /**
    Provides a client for connecting to WebSocket services.

    */
public final class ClientWebSocket
    :
    dotnet.System.Net.WebSockets.WebSocket
{
    public class override func get_type_handle() -> TypeHandle {
        return System_Net_WebSockets_ClientWebSocket_get_type_handle();
    }
    public required init(hndl: NonnullHandle) { super.init(hndl: hndl); }
    public required init(gval: GVal) { super.init(gval: gval); }
    // .ctor()
// docid: M:System.Net.WebSockets.ClientWebSocket.#ctor
    /**
    Creates an instance of the  class.

    */
    public init() throws {
        var __thrown : NullableHandle = nil;
        let h = System_Net_WebSockets_ClientWebSocket_ctor_0__0(&__thrown);
        if let __ex = __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
            super.init(hndl: h);
        }
    }
    // void Abort()
// docid: M:System.Net.WebSockets.ClientWebSocket.Abort
    /**
    Aborts the connection and cancels any pending IO operations.

    */
    public override func Abort() throws {
        var __thrown : NullableHandle = nil;
        System_Net_WebSockets_ClientWebSocket_void__Abort_0__0(&__thrown, self.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
            return;
        }
    }
    // System.Threading.Tasks.Task CloseAsync(System.Net.WebSockets.WebSocketCloseStatus, System.String, System.Threading.CancellationToken)
// docid: M:System.Net.WebSockets.ClientWebSocket.CloseAsync(System.Net.WebSockets.WebSocketCloseStatus,System.String,System.Threading.CancellationToken)
    /**
    Close the  instance as an asynchronous operation.

    - Parameter closeStatus: The WebSocket close status.
    - Parameter statusDescription: A description of the close status.
    - Parameter cancellationToken: A cancellation token used to propagate notification that this  operation should be canceled.
    - Returns: The task object representing the asynchronous operation.

    */
    public override func CloseAsync(closeStatus : dotnet.System.Net.WebSockets.WebSocketCloseStatus, statusDescription : Optional<dotnet.System.String>, cancellationToken : dotnet.System.Threading.CancellationToken) throws -> dotnet.System.Threading.Tasks.Task {
        var __thrown : NullableHandle = nil;
        let __return = System_Net_WebSockets_ClientWebSocket_Task__CloseAsync_0__3__WebSocketCloseStatus_String_CancellationToken(&__thrown, self.get_handle(), closeStatus.get_value(), statusDescription?.get_handle() ?? nil, cancellationToken.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return dotnet.System.Threading.Tasks.Task(hndl : __return);
        }
    }
    // System.Threading.Tasks.Task CloseOutputAsync(System.Net.WebSockets.WebSocketCloseStatus, System.String, System.Threading.CancellationToken)
// docid: M:System.Net.WebSockets.ClientWebSocket.CloseOutputAsync(System.Net.WebSockets.WebSocketCloseStatus,System.String,System.Threading.CancellationToken)
    /**
    Close the output for the  instance as an asynchronous operation.

    - Parameter closeStatus: The WebSocket close status.
    - Parameter statusDescription: A description of the close status.
    - Parameter cancellationToken: A cancellation token used to propagate notification that this  operation should be canceled.
    - Returns: The task object representing the asynchronous operation.

    */
    public override func CloseOutputAsync(closeStatus : dotnet.System.Net.WebSockets.WebSocketCloseStatus, statusDescription : Optional<dotnet.System.String>, cancellationToken : dotnet.System.Threading.CancellationToken) throws -> dotnet.System.Threading.Tasks.Task {
        var __thrown : NullableHandle = nil;
        let __return = System_Net_WebSockets_ClientWebSocket_Task__CloseOutputAsync_0__3__WebSocketCloseStatus_String_CancellationToken(&__thrown, self.get_handle(), closeStatus.get_value(), statusDescription?.get_handle() ?? nil, cancellationToken.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return dotnet.System.Threading.Tasks.Task(hndl : __return);
        }
    }
    // System.Threading.Tasks.Task ConnectAsync(System.Uri, System.Threading.CancellationToken)
// docid: M:System.Net.WebSockets.ClientWebSocket.ConnectAsync(System.Uri,System.Threading.CancellationToken)
    /**
    Connect to a WebSocket server as an asynchronous operation.

    - Parameter uri: The URI of the WebSocket server to connect to.
    - Parameter cancellationToken: A cancellation token used to propagate notification that the  operation should be canceled.
    - Returns: The task object representing the asynchronous operation.

    */
    public func ConnectAsync(uri : dotnet.System.Uri, cancellationToken : dotnet.System.Threading.CancellationToken) throws -> dotnet.System.Threading.Tasks.Task {
        var __thrown : NullableHandle = nil;
        let __return = System_Net_WebSockets_ClientWebSocket_Task__ConnectAsync_0__2__Uri_CancellationToken(&__thrown, self.get_handle(), uri.get_handle(), cancellationToken.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return dotnet.System.Threading.Tasks.Task(hndl : __return);
        }
    }
    // void Dispose()
// docid: M:System.Net.WebSockets.ClientWebSocket.Dispose
    /**
    Releases the unmanaged resources used by the  instance.

    */
    public override func Dispose() throws {
        var __thrown : NullableHandle = nil;
        System_Net_WebSockets_ClientWebSocket_void__Dispose_0__0(&__thrown, self.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
            return;
        }
    }
    // System.Threading.Tasks.Task<System.Net.WebSockets.WebSocketReceiveResult> ReceiveAsync(System.ArraySegment<System.Byte>, System.Threading.CancellationToken)
// docid: M:System.Net.WebSockets.ClientWebSocket.ReceiveAsync(System.ArraySegment{System.Byte},System.Threading.CancellationToken)
    /**
    Receives data on  as an asynchronous operation.

    - Parameter buffer: The buffer to receive the response.
    - Parameter cancellationToken: A cancellation token used to propagate notification that this operation should be canceled.
    - Returns: The task object representing the asynchronous operation.

    */
    public override func ReceiveAsync(buffer : dotnet.System.ArraySegment_1<Swift.UInt8>, cancellationToken : dotnet.System.Threading.CancellationToken) throws -> dotnet.System.Threading.Tasks.Task_1<dotnet.System.Net.WebSockets.WebSocketReceiveResult> {
        var __thrown : NullableHandle = nil;
        let __return = System_Net_WebSockets_ClientWebSocket_System_Threading_Tasks_Task_System_Net_WebSockets_WebSocketReceiveResult___ReceiveAsync_0__2__System_ArraySegment_u8__CancellationToken(&__thrown, self.get_handle(), buffer.get_handle(), cancellationToken.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return dotnet.System.Threading.Tasks.Task_1(hndl : __return);
        }
    }
    // System.Threading.Tasks.ValueTask<System.Net.WebSockets.ValueWebSocketReceiveResult> ReceiveAsync(System.Memory<System.Byte>, System.Threading.CancellationToken)
// docid: M:System.Net.WebSockets.ClientWebSocket.ReceiveAsync(System.Memory{System.Byte},System.Threading.CancellationToken)
    /**
    Receives data on  as an asynchronous operation.

    - Parameter buffer: The region of memory to receive the response.
    - Parameter cancellationToken: A cancellation token used to propagate notification that this operation should be canceled.
    - Returns: The task object representing the asynchronous operation.

    */
    public override func ReceiveAsync(buffer : dotnet.System.Memory_1<Swift.UInt8>, cancellationToken : dotnet.System.Threading.CancellationToken) throws -> dotnet.System.Threading.Tasks.ValueTask_1<dotnet.System.Net.WebSockets.ValueWebSocketReceiveResult> {
        var __thrown : NullableHandle = nil;
        let __return = System_Net_WebSockets_ClientWebSocket_System_Threading_Tasks_ValueTask_System_Net_WebSockets_ValueWebSocketReceiveResult___ReceiveAsync_0__2__System_Memory_u8__CancellationToken(&__thrown, self.get_handle(), buffer.get_handle(), cancellationToken.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return dotnet.System.Threading.Tasks.ValueTask_1(hndl : __return);
        }
    }
    // System.Threading.Tasks.Task SendAsync(System.ArraySegment<System.Byte>, System.Net.WebSockets.WebSocketMessageType, bool, System.Threading.CancellationToken)
// docid: M:System.Net.WebSockets.ClientWebSocket.SendAsync(System.ArraySegment{System.Byte},System.Net.WebSockets.WebSocketMessageType,System.Boolean,System.Threading.CancellationToken)
    /**
    Sends data on  as an asynchronous operation.

    - Parameter buffer: The buffer containing the message to be sent.
    - Parameter messageType: One of the enumeration values that specifies whether the buffer is clear text or in a binary format.
    - Parameter endOfMessage: 
         to indicate this is the final asynchronous send; otherwise, .
    - Parameter cancellationToken: A cancellation token used to propagate notification that this operation should be canceled.
    - Returns: The task object representing the asynchronous operation.

    */
    public override func SendAsync(buffer : dotnet.System.ArraySegment_1<Swift.UInt8>, messageType : dotnet.System.Net.WebSockets.WebSocketMessageType, endOfMessage : Bool, cancellationToken : dotnet.System.Threading.CancellationToken) throws -> dotnet.System.Threading.Tasks.Task {
        var __thrown : NullableHandle = nil;
        let __return = System_Net_WebSockets_ClientWebSocket_Task__SendAsync_0__4__System_ArraySegment_u8__WebSocketMessageType_bool_CancellationToken(&__thrown, self.get_handle(), buffer.get_handle(), messageType.get_value(), Swift.Int32(endOfMessage ? 1 : 0), cancellationToken.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return dotnet.System.Threading.Tasks.Task(hndl : __return);
        }
    }
    // System.Threading.Tasks.ValueTask SendAsync(System.ReadOnlyMemory<System.Byte>, System.Net.WebSockets.WebSocketMessageType, bool, System.Threading.CancellationToken)
// docid: M:System.Net.WebSockets.ClientWebSocket.SendAsync(System.ReadOnlyMemory{System.Byte},System.Net.WebSockets.WebSocketMessageType,System.Boolean,System.Threading.CancellationToken)
    /**
    Sends data on  from a read-only byte memory range as an asynchronous operation.

    - Parameter buffer: The region of memory containing the message to be sent.
    - Parameter messageType: One of the enumeration values that specifies whether the buffer is clear text or in a binary format.
    - Parameter endOfMessage: 
         to indicate this is the final asynchronous send; otherwise, .
    - Parameter cancellationToken: A cancellation token used to propagate notification that this operation should be canceled.
    - Returns: The task object representing the asynchronous operation.

    */
    public override func SendAsync(buffer : dotnet.System.ReadOnlyMemory_1<Swift.UInt8>, messageType : dotnet.System.Net.WebSockets.WebSocketMessageType, endOfMessage : Bool, cancellationToken : dotnet.System.Threading.CancellationToken) throws -> dotnet.System.Threading.Tasks.ValueTask {
        var __thrown : NullableHandle = nil;
        let __return = System_Net_WebSockets_ClientWebSocket_ValueTask__SendAsync_0__4__System_ReadOnlyMemory_u8__WebSocketMessageType_bool_CancellationToken(&__thrown, self.get_handle(), buffer.get_handle(), messageType.get_value(), Swift.Int32(endOfMessage ? 1 : 0), cancellationToken.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return dotnet.System.Threading.Tasks.ValueTask(hndl : __return);
        }
    }
    // [IsSpecialName] System.Nullable<System.Net.WebSockets.WebSocketCloseStatus> get_CloseStatus()
// docid: M:System.Net.WebSockets.ClientWebSocket.get_CloseStatus
    public override func get_CloseStatus() throws -> Optional<dotnet.System.Net.WebSockets.WebSocketCloseStatus> {
        var __thrown : NullableHandle = nil;
        let __return = System_Net_WebSockets_ClientWebSocket_System_Nullable_System_Net_WebSockets_WebSocketCloseStatus___get_CloseStatus_0__0(&__thrown, self.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
            return (__return != nil) ? dotnet.System.Net.WebSockets.WebSocketCloseStatus(val: System_Int32_unbox(__return!)) : nil;
        }
    }
    // [IsSpecialName] System.String get_CloseStatusDescription()
// docid: M:System.Net.WebSockets.ClientWebSocket.get_CloseStatusDescription
    public override func get_CloseStatusDescription() throws -> Optional<dotnet.System.String> {
        var __thrown : NullableHandle = nil;
        let __return = System_Net_WebSockets_ClientWebSocket_String__get_CloseStatusDescription_0__0(&__thrown, self.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        if let __ret_unwrapped = __return {
            return dotnet.System.String(hndl : __ret_unwrapped);
        } else {
            return nil;
        }
        }
    }
    // [IsSpecialName] System.Net.WebSockets.ClientWebSocketOptions get_Options()
// docid: M:System.Net.WebSockets.ClientWebSocket.get_Options
    public func get_Options() throws -> dotnet.System.Net.WebSockets.ClientWebSocketOptions {
        var __thrown : NullableHandle = nil;
        let __return = System_Net_WebSockets_ClientWebSocket_ClientWebSocketOptions__get_Options_0__0(&__thrown, self.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return dotnet.System.Net.WebSockets.ClientWebSocketOptions(hndl : __return);
        }
    }
    // [IsSpecialName] System.Net.WebSockets.WebSocketState get_State()
// docid: M:System.Net.WebSockets.ClientWebSocket.get_State
    public override func get_State() throws -> dotnet.System.Net.WebSockets.WebSocketState {
        var __thrown : NullableHandle = nil;
        let __return = System_Net_WebSockets_ClientWebSocket_WebSocketState__get_State_0__0(&__thrown, self.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return dotnet.System.Net.WebSockets.WebSocketState(val: __return);
        }
    }
    // [IsSpecialName] System.String get_SubProtocol()
// docid: M:System.Net.WebSockets.ClientWebSocket.get_SubProtocol
    public override func get_SubProtocol() throws -> Optional<dotnet.System.String> {
        var __thrown : NullableHandle = nil;
        let __return = System_Net_WebSockets_ClientWebSocket_String__get_SubProtocol_0__0(&__thrown, self.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        if let __ret_unwrapped = __return {
            return dotnet.System.String(hndl : __ret_unwrapped);
        } else {
            return nil;
        }
        }
    }
// TODO COPE (is_override_notoptional_with_optional) [IsSpecialName] System.Nullable<System.Net.WebSockets.WebSocketCloseStatus> get_CloseStatus()
    /**
    Gets a description of the reason why the  instance was closed.

    */
    public override var CloseStatusDescription : Optional<dotnet.System.String> {
        get {
            return try! get_CloseStatusDescription();
        }
    }
    /**
    Gets the WebSocket options for the  instance.

    */
    public var Options : dotnet.System.Net.WebSockets.ClientWebSocketOptions {
        get {
            return try! get_Options();
        }
    }
    /**
    Gets the WebSocket state of the  instance.

    */
    public override var State : dotnet.System.Net.WebSockets.WebSocketState {
        get {
            return try! get_State();
        }
    }
    /**
    Gets the supported WebSocket sub-protocol for the  instance.

    */
    public override var SubProtocol : Optional<dotnet.System.String> {
        get {
            return try! get_SubProtocol();
        }
    }
} // ClientWebSocket


// type: System.Net.WebSockets.ClientWebSocketOptions
    /**
    Options to use with a   object.

    */
public final class ClientWebSocketOptions
    :
    dotnet.System.Object
{
    public class override func get_type_handle() -> TypeHandle {
        return System_Net_WebSockets_ClientWebSocketOptions_get_type_handle();
    }
    public required init(hndl: NonnullHandle) { super.init(hndl: hndl); }
    public required init(gval: GVal) { super.init(gval: gval); }
    // void AddSubProtocol(System.String)
// docid: M:System.Net.WebSockets.ClientWebSocketOptions.AddSubProtocol(System.String)
    /**
    Adds a sub-protocol to be negotiated during the WebSocket connection handshake.

    - Parameter subProtocol: The WebSocket sub-protocol to add.
    */
    public func AddSubProtocol(subProtocol : dotnet.System.String) throws {
        var __thrown : NullableHandle = nil;
        System_Net_WebSockets_ClientWebSocketOptions_void__AddSubProtocol_0__1__String(&__thrown, self.get_handle(), subProtocol.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
            return;
        }
    }
    // void SetBuffer(System.Int32, System.Int32)
// docid: M:System.Net.WebSockets.ClientWebSocketOptions.SetBuffer(System.Int32,System.Int32)
    /**
    Sets the client buffer parameters.

    - Parameter receiveBufferSize: The size, in bytes, of the client receive buffer.
    - Parameter sendBufferSize: The size, in bytes, of the client send buffer.
    */
    public func SetBuffer(receiveBufferSize : Swift.Int32, sendBufferSize : Swift.Int32) throws {
        var __thrown : NullableHandle = nil;
        System_Net_WebSockets_ClientWebSocketOptions_void__SetBuffer_0__2__i32_i32(&__thrown, self.get_handle(), receiveBufferSize, sendBufferSize);
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
            return;
        }
    }
    // void SetBuffer(System.Int32, System.Int32, System.ArraySegment<System.Byte>)
// docid: M:System.Net.WebSockets.ClientWebSocketOptions.SetBuffer(System.Int32,System.Int32,System.ArraySegment{System.Byte})
    /**
    Sets client buffer parameters.

    - Parameter receiveBufferSize: The size, in bytes, of the client receive buffer.
    - Parameter sendBufferSize: The size, in bytes, of the client send buffer.
    - Parameter buffer: The receive buffer to use.
    */
    public func SetBuffer(receiveBufferSize : Swift.Int32, sendBufferSize : Swift.Int32, buffer : dotnet.System.ArraySegment_1<Swift.UInt8>) throws {
        var __thrown : NullableHandle = nil;
        System_Net_WebSockets_ClientWebSocketOptions_void__SetBuffer_0__3__i32_i32_System_ArraySegment_u8_(&__thrown, self.get_handle(), receiveBufferSize, sendBufferSize, buffer.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
            return;
        }
    }
    // void SetRequestHeader(System.String, System.String)
// docid: M:System.Net.WebSockets.ClientWebSocketOptions.SetRequestHeader(System.String,System.String)
    /**
    Creates a HTTP request header and its value.

    - Parameter headerName: The name of the HTTP header.
    - Parameter headerValue: The value of the HTTP header.
    */
    public func SetRequestHeader(headerName : dotnet.System.String, headerValue : Optional<dotnet.System.String>) throws {
        var __thrown : NullableHandle = nil;
        System_Net_WebSockets_ClientWebSocketOptions_void__SetRequestHeader_0__2__String_String(&__thrown, self.get_handle(), headerName.get_handle(), headerValue?.get_handle() ?? nil);
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
            return;
        }
    }
    // [IsSpecialName] System.Security.Cryptography.X509Certificates.X509CertificateCollection get_ClientCertificates()
// docid: M:System.Net.WebSockets.ClientWebSocketOptions.get_ClientCertificates
    public func get_ClientCertificates() throws -> dotnet.System.Security.Cryptography.X509Certificates.X509CertificateCollection {
        var __thrown : NullableHandle = nil;
        let __return = System_Net_WebSockets_ClientWebSocketOptions_X509CertificateCollection__get_ClientCertificates_0__0(&__thrown, self.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return dotnet.System.Security.Cryptography.X509Certificates.X509CertificateCollection(hndl : __return);
        }
    }
    // [IsSpecialName] void set_ClientCertificates(System.Security.Cryptography.X509Certificates.X509CertificateCollection)
// docid: M:System.Net.WebSockets.ClientWebSocketOptions.set_ClientCertificates(System.Security.Cryptography.X509Certificates.X509CertificateCollection)
    public func set_ClientCertificates(value : dotnet.System.Security.Cryptography.X509Certificates.X509CertificateCollection) throws {
        var __thrown : NullableHandle = nil;
        System_Net_WebSockets_ClientWebSocketOptions_void__set_ClientCertificates_0__1__X509CertificateCollection(&__thrown, self.get_handle(), value.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
            return;
        }
    }
    // [IsSpecialName] System.Net.CookieContainer get_Cookies()
// docid: M:System.Net.WebSockets.ClientWebSocketOptions.get_Cookies
    public func get_Cookies() throws -> Optional<dotnet.System.Net.CookieContainer> {
        var __thrown : NullableHandle = nil;
        let __return = System_Net_WebSockets_ClientWebSocketOptions_CookieContainer__get_Cookies_0__0(&__thrown, self.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        if let __ret_unwrapped = __return {
            return dotnet.System.Net.CookieContainer(hndl : __ret_unwrapped);
        } else {
            return nil;
        }
        }
    }
    // [IsSpecialName] void set_Cookies(System.Net.CookieContainer)
// docid: M:System.Net.WebSockets.ClientWebSocketOptions.set_Cookies(System.Net.CookieContainer)
    public func set_Cookies(value : Optional<dotnet.System.Net.CookieContainer>) throws {
        var __thrown : NullableHandle = nil;
        System_Net_WebSockets_ClientWebSocketOptions_void__set_Cookies_0__1__CookieContainer(&__thrown, self.get_handle(), value?.get_handle() ?? nil);
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
            return;
        }
    }
    // [IsSpecialName] System.Net.ICredentials get_Credentials()
// docid: M:System.Net.WebSockets.ClientWebSocketOptions.get_Credentials
    public func get_Credentials() throws -> Optional<dotnet.System.Net.ICredentials> {
        var __thrown : NullableHandle = nil;
        let __return = System_Net_WebSockets_ClientWebSocketOptions_ICredentials__get_Credentials_0__0(&__thrown, self.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        if let __ret_unwrapped = __return {
            return dotnet.System.Net.ICredentials(hndl : __ret_unwrapped);
        } else {
            return nil;
        }
        }
    }
    // [IsSpecialName] void set_Credentials(System.Net.ICredentials)
// docid: M:System.Net.WebSockets.ClientWebSocketOptions.set_Credentials(System.Net.ICredentials)
    public func set_Credentials(value : Optional<dotnet.System.Net.ICredentials>) throws {
        var __thrown : NullableHandle = nil;
        System_Net_WebSockets_ClientWebSocketOptions_void__set_Credentials_0__1__ICredentials(&__thrown, self.get_handle(), value?.get_handle() ?? nil);
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
            return;
        }
    }
    // [IsSpecialName] System.TimeSpan get_KeepAliveInterval()
// docid: M:System.Net.WebSockets.ClientWebSocketOptions.get_KeepAliveInterval
    public func get_KeepAliveInterval() throws -> dotnet.System.TimeSpan {
        var __thrown : NullableHandle = nil;
        let __return = System_Net_WebSockets_ClientWebSocketOptions_TimeSpan__get_KeepAliveInterval_0__0(&__thrown, self.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return dotnet.System.TimeSpan(hndl : __return);
        }
    }
// TODO COPE (write_all_methods) (span) [IsSpecialName] void set_KeepAliveInterval(System.TimeSpan)
    // [IsSpecialName] System.Net.WebSockets.WebSocketDeflateOptions get_DangerousDeflateOptions()
// docid: M:System.Net.WebSockets.ClientWebSocketOptions.get_DangerousDeflateOptions
    public func get_DangerousDeflateOptions() throws -> Optional<dotnet.System.Net.WebSockets.WebSocketDeflateOptions> {
        var __thrown : NullableHandle = nil;
        let __return = System_Net_WebSockets_ClientWebSocketOptions_WebSocketDeflateOptions__get_DangerousDeflateOptions_0__0(&__thrown, self.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        if let __ret_unwrapped = __return {
            return dotnet.System.Net.WebSockets.WebSocketDeflateOptions(hndl : __ret_unwrapped);
        } else {
            return nil;
        }
        }
    }
    // [IsSpecialName] void set_DangerousDeflateOptions(System.Net.WebSockets.WebSocketDeflateOptions)
// docid: M:System.Net.WebSockets.ClientWebSocketOptions.set_DangerousDeflateOptions(System.Net.WebSockets.WebSocketDeflateOptions)
    public func set_DangerousDeflateOptions(value : Optional<dotnet.System.Net.WebSockets.WebSocketDeflateOptions>) throws {
        var __thrown : NullableHandle = nil;
        System_Net_WebSockets_ClientWebSocketOptions_void__set_DangerousDeflateOptions_0__1__WebSocketDeflateOptions(&__thrown, self.get_handle(), value?.get_handle() ?? nil);
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
            return;
        }
    }
    // [IsSpecialName] System.Net.IWebProxy get_Proxy()
// docid: M:System.Net.WebSockets.ClientWebSocketOptions.get_Proxy
    public func get_Proxy() throws -> Optional<dotnet.System.Net.IWebProxy> {
        var __thrown : NullableHandle = nil;
        let __return = System_Net_WebSockets_ClientWebSocketOptions_IWebProxy__get_Proxy_0__0(&__thrown, self.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        if let __ret_unwrapped = __return {
            return dotnet.System.Net.IWebProxy(hndl : __ret_unwrapped);
        } else {
            return nil;
        }
        }
    }
    // [IsSpecialName] void set_Proxy(System.Net.IWebProxy)
// docid: M:System.Net.WebSockets.ClientWebSocketOptions.set_Proxy(System.Net.IWebProxy)
    public func set_Proxy(value : Optional<dotnet.System.Net.IWebProxy>) throws {
        var __thrown : NullableHandle = nil;
        System_Net_WebSockets_ClientWebSocketOptions_void__set_Proxy_0__1__IWebProxy(&__thrown, self.get_handle(), value?.get_handle() ?? nil);
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
            return;
        }
    }
    // [IsSpecialName] System.Net.Security.RemoteCertificateValidationCallback get_RemoteCertificateValidationCallback()
// docid: M:System.Net.WebSockets.ClientWebSocketOptions.get_RemoteCertificateValidationCallback
    public func get_RemoteCertificateValidationCallback() throws -> Optional<dotnet.System.Net.Security.RemoteCertificateValidationCallback> {
        var __thrown : NullableHandle = nil;
        let __return = System_Net_WebSockets_ClientWebSocketOptions_RemoteCertificateValidationCallback__get_RemoteCertificateValidationCallback_0__0(&__thrown, self.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        if let __ret_unwrapped = __return {
            return dotnet.System.Net.Security.RemoteCertificateValidationCallback(hndl : __ret_unwrapped);
        } else {
            return nil;
        }
        }
    }
    // [IsSpecialName] void set_RemoteCertificateValidationCallback(System.Net.Security.RemoteCertificateValidationCallback)
// docid: M:System.Net.WebSockets.ClientWebSocketOptions.set_RemoteCertificateValidationCallback(System.Net.Security.RemoteCertificateValidationCallback)
    public func set_RemoteCertificateValidationCallback(value : Optional<dotnet.System.Net.Security.RemoteCertificateValidationCallback>) throws {
        var __thrown : NullableHandle = nil;
        System_Net_WebSockets_ClientWebSocketOptions_void__set_RemoteCertificateValidationCallback_0__1__RemoteCertificateValidationCallback(&__thrown, self.get_handle(), value?.get_handle() ?? nil);
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
            return;
        }
    }
    // delegate closure overload
    public func set_RemoteCertificateValidationCallback(value : @escaping (dotnet.System.Object, Optional<dotnet.System.Security.Cryptography.X509Certificates.X509Certificate>, Optional<dotnet.System.Security.Cryptography.X509Certificates.X509Chain>, dotnet.System.Net.Security.SslPolicyErrors) throws -> Bool) throws {
        let del_value = try dotnet.System.Net.Security.RemoteCertificateValidationCallback(value);
        return try set_RemoteCertificateValidationCallback(value: del_value);
    }
    // [IsSpecialName] bool get_UseDefaultCredentials()
// docid: M:System.Net.WebSockets.ClientWebSocketOptions.get_UseDefaultCredentials
    public func get_UseDefaultCredentials() throws -> Bool {
        var __thrown : NullableHandle = nil;
        let __return = System_Net_WebSockets_ClientWebSocketOptions_bool__get_UseDefaultCredentials_0__0(&__thrown, self.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return (__return) != 0;
        }
    }
    // [IsSpecialName] void set_UseDefaultCredentials(bool)
// docid: M:System.Net.WebSockets.ClientWebSocketOptions.set_UseDefaultCredentials(System.Boolean)
    public func set_UseDefaultCredentials(value : Bool) throws {
        var __thrown : NullableHandle = nil;
        System_Net_WebSockets_ClientWebSocketOptions_void__set_UseDefaultCredentials_0__1__bool(&__thrown, self.get_handle(), Swift.Int32(value ? 1 : 0));
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
            return;
        }
    }
    /**
    Gets or sets a collection of client side certificates.

    */
    public var ClientCertificates : dotnet.System.Security.Cryptography.X509Certificates.X509CertificateCollection {
        get {
            return try! get_ClientCertificates();
        }
        set(v) {
            return try! set_ClientCertificates(value: v);
        }
    }
    /**
    Gets or sets the cookies associated with the request.

    */
    public var Cookies : Optional<dotnet.System.Net.CookieContainer> {
        get {
            return try! get_Cookies();
        }
        set(v) {
            return try! set_Cookies(value: v!);
        }
    }
    /**
    Gets or sets the credential information for the client.

    */
    public var Credentials : Optional<dotnet.System.Net.ICredentials> {
        get {
            return try! get_Credentials();
        }
        set(v) {
            return try! set_Credentials(value: v!);
        }
    }
    public var DangerousDeflateOptions : Optional<dotnet.System.Net.WebSockets.WebSocketDeflateOptions> {
        get {
            return try! get_DangerousDeflateOptions();
        }
        set(v) {
            return try! set_DangerousDeflateOptions(value: v!);
        }
    }
    /**
    Gets or sets the WebSocket protocol keep-alive interval.

    */
    public var KeepAliveInterval : dotnet.System.TimeSpan {
        get {
            return try! get_KeepAliveInterval();
        }
// TODO COPE prop set (span) [IsSpecialName] void set_KeepAliveInterval(System.TimeSpan)
    }
    /**
    Gets or sets the proxy for WebSocket requests.

    */
    public var Proxy : Optional<dotnet.System.Net.IWebProxy> {
        get {
            return try! get_Proxy();
        }
        set(v) {
            return try! set_Proxy(value: v!);
        }
    }
    /**
    Gets or sets the callback to validate a server certificate.

    */
    public var RemoteCertificateValidationCallback : Optional<dotnet.System.Net.Security.RemoteCertificateValidationCallback> {
        get {
            return try! get_RemoteCertificateValidationCallback();
        }
        set(v) {
            return try! set_RemoteCertificateValidationCallback(value: v!);
        }
    }
    /**
    Gets or sets a  value that indicates if default credentials should be used during WebSocket handshake.

    */
    public var UseDefaultCredentials : Bool {
        get {
            return try! get_UseDefaultCredentials();
        }
        set(v) {
            return try! set_UseDefaultCredentials(value: v);
        }
    }
} // ClientWebSocketOptions


}



