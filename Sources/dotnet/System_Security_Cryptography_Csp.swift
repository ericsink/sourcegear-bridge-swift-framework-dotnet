// this file is automatically generated
// Copyright 2021 SourceGear

import jumptable_dotnet;

// System
// System.Security
// System.Security.Cryptography
extension System.Security.Cryptography {
// type: System.Security.Cryptography.AesCryptoServiceProvider
    /**
    Performs symmetric encryption and decryption using the Cryptographic Application Programming Interfaces (CAPI) implementation of the Advanced Encryption Standard (AES) algorithm.

    */
public final class AesCryptoServiceProvider
    :
    dotnet.System.Security.Cryptography.Aes
{
    public class override func get_type_handle() -> TypeHandle {
        return System_Security_Cryptography_AesCryptoServiceProvider_get_type_handle();
    }
    public required init(hndl: NonnullHandle) { super.init(hndl: hndl); }
    public required init(gval: GVal) { super.init(gval: gval); }
    // .ctor()
// docid: M:System.Security.Cryptography.AesCryptoServiceProvider.#ctor
    /**
    Initializes a new instance of the  class.

    */
    public init() throws {
        var __thrown : NullableHandle = nil;
        let h = System_Security_Cryptography_AesCryptoServiceProvider_ctor_0__0(&__thrown);
        if let __ex = __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
            super.init(hndl: h);
        }
    }
    // System.Security.Cryptography.ICryptoTransform CreateDecryptor()
// docid: M:System.Security.Cryptography.AesCryptoServiceProvider.CreateDecryptor
    /**
    Creates a symmetric AES decryptor object using the current key and initialization vector (IV).

    - Returns: A symmetric AES decryptor object.

    */
    public override func CreateDecryptor() throws -> dotnet.System.Security.Cryptography.ICryptoTransform {
        var __thrown : NullableHandle = nil;
        let __return = System_Security_Cryptography_AesCryptoServiceProvider_ICryptoTransform__CreateDecryptor_0__0(&__thrown, self.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return dotnet.System.Security.Cryptography.ICryptoTransform(hndl : __return);
        }
    }
    // System.Security.Cryptography.ICryptoTransform CreateDecryptor(System.Byte[], System.Byte[])
// docid: M:System.Security.Cryptography.AesCryptoServiceProvider.CreateDecryptor(System.Byte[],System.Byte[])
    /**
    Creates a symmetric AES decryptor object using the specified key and initialization vector (IV).

    - Parameter rgbKey: The secret key to use for the symmetric algorithm.
    - Parameter rgbIV: The initialization vector to use for the symmetric algorithm.
    - Returns: A symmetric AES decryptor object.

    */
    public override func CreateDecryptor(rgbKey : dotnet.System_Arr<Swift.UInt8>, rgbIV : Optional<dotnet.System_Arr<Swift.UInt8>>) throws -> dotnet.System.Security.Cryptography.ICryptoTransform {
        var __thrown : NullableHandle = nil;
        let __return = System_Security_Cryptography_AesCryptoServiceProvider_ICryptoTransform__CreateDecryptor_0__2__u8Array_u8Array(&__thrown, self.get_handle(), rgbKey.get_handle(), (rgbIV?.get_handle()));
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return dotnet.System.Security.Cryptography.ICryptoTransform(hndl : __return);
        }
    }
    // System.Security.Cryptography.ICryptoTransform CreateEncryptor()
// docid: M:System.Security.Cryptography.AesCryptoServiceProvider.CreateEncryptor
    /**
    Creates a symmetric AES encryptor object using the current key and initialization vector (IV).

    - Returns: A symmetric AES encryptor object.

    */
    public override func CreateEncryptor() throws -> dotnet.System.Security.Cryptography.ICryptoTransform {
        var __thrown : NullableHandle = nil;
        let __return = System_Security_Cryptography_AesCryptoServiceProvider_ICryptoTransform__CreateEncryptor_0__0(&__thrown, self.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return dotnet.System.Security.Cryptography.ICryptoTransform(hndl : __return);
        }
    }
    // System.Security.Cryptography.ICryptoTransform CreateEncryptor(System.Byte[], System.Byte[])
// docid: M:System.Security.Cryptography.AesCryptoServiceProvider.CreateEncryptor(System.Byte[],System.Byte[])
    /**
    Creates a symmetric encryptor object using the specified key and initialization vector (IV).

    - Parameter rgbKey: The secret key to use for the symmetric algorithm.
    - Parameter rgbIV: The initialization vector to use for the symmetric algorithm.
    - Returns: A symmetric AES encryptor object.

    */
    public override func CreateEncryptor(rgbKey : dotnet.System_Arr<Swift.UInt8>, rgbIV : Optional<dotnet.System_Arr<Swift.UInt8>>) throws -> dotnet.System.Security.Cryptography.ICryptoTransform {
        var __thrown : NullableHandle = nil;
        let __return = System_Security_Cryptography_AesCryptoServiceProvider_ICryptoTransform__CreateEncryptor_0__2__u8Array_u8Array(&__thrown, self.get_handle(), rgbKey.get_handle(), (rgbIV?.get_handle()));
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return dotnet.System.Security.Cryptography.ICryptoTransform(hndl : __return);
        }
    }
    // void GenerateIV()
// docid: M:System.Security.Cryptography.AesCryptoServiceProvider.GenerateIV
    /**
    Generates a random initialization vector (IV) to use for the algorithm.

    */
    public override func GenerateIV() throws {
        var __thrown : NullableHandle = nil;
        System_Security_Cryptography_AesCryptoServiceProvider_void__GenerateIV_0__0(&__thrown, self.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
            return;
        }
    }
    // void GenerateKey()
// docid: M:System.Security.Cryptography.AesCryptoServiceProvider.GenerateKey
    /**
    Generates a random key to use for the algorithm.

    */
    public override func GenerateKey() throws {
        var __thrown : NullableHandle = nil;
        System_Security_Cryptography_AesCryptoServiceProvider_void__GenerateKey_0__0(&__thrown, self.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
            return;
        }
    }
    // [IsSpecialName] System.Int32 get_BlockSize()
// docid: M:System.Security.Cryptography.AesCryptoServiceProvider.get_BlockSize
    public override func get_BlockSize() throws -> Swift.Int32 {
        var __thrown : NullableHandle = nil;
        let __return = System_Security_Cryptography_AesCryptoServiceProvider_i32__get_BlockSize_0__0(&__thrown, self.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return __return;
        }
    }
    // [IsSpecialName] void set_BlockSize(System.Int32)
// docid: M:System.Security.Cryptography.AesCryptoServiceProvider.set_BlockSize(System.Int32)
    public override func set_BlockSize(value : Swift.Int32) throws {
        var __thrown : NullableHandle = nil;
        System_Security_Cryptography_AesCryptoServiceProvider_void__set_BlockSize_0__1__i32(&__thrown, self.get_handle(), value);
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
            return;
        }
    }
    // [IsSpecialName] System.Int32 get_FeedbackSize()
// docid: M:System.Security.Cryptography.AesCryptoServiceProvider.get_FeedbackSize
    public override func get_FeedbackSize() throws -> Swift.Int32 {
        var __thrown : NullableHandle = nil;
        let __return = System_Security_Cryptography_AesCryptoServiceProvider_i32__get_FeedbackSize_0__0(&__thrown, self.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return __return;
        }
    }
    // [IsSpecialName] void set_FeedbackSize(System.Int32)
// docid: M:System.Security.Cryptography.AesCryptoServiceProvider.set_FeedbackSize(System.Int32)
    public override func set_FeedbackSize(value : Swift.Int32) throws {
        var __thrown : NullableHandle = nil;
        System_Security_Cryptography_AesCryptoServiceProvider_void__set_FeedbackSize_0__1__i32(&__thrown, self.get_handle(), value);
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
            return;
        }
    }
    // [IsSpecialName] System.Byte[] get_IV()
// docid: M:System.Security.Cryptography.AesCryptoServiceProvider.get_IV
    public override func get_IV() throws -> dotnet.System_Arr<Swift.UInt8> {
        var __thrown : NullableHandle = nil;
        let __return = System_Security_Cryptography_AesCryptoServiceProvider_u8Array__get_IV_0__0(&__thrown, self.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return dotnet.System_Arr<Swift.UInt8>(hndl : __return);
        }
    }
    // [IsSpecialName] void set_IV(System.Byte[])
// docid: M:System.Security.Cryptography.AesCryptoServiceProvider.set_IV(System.Byte[])
    public override func set_IV(value : dotnet.System_Arr<Swift.UInt8>) throws {
        var __thrown : NullableHandle = nil;
        System_Security_Cryptography_AesCryptoServiceProvider_void__set_IV_0__1__u8Array(&__thrown, self.get_handle(), value.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
            return;
        }
    }
    // [IsSpecialName] System.Byte[] get_Key()
// docid: M:System.Security.Cryptography.AesCryptoServiceProvider.get_Key
    public override func get_Key() throws -> dotnet.System_Arr<Swift.UInt8> {
        var __thrown : NullableHandle = nil;
        let __return = System_Security_Cryptography_AesCryptoServiceProvider_u8Array__get_Key_0__0(&__thrown, self.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return dotnet.System_Arr<Swift.UInt8>(hndl : __return);
        }
    }
    // [IsSpecialName] void set_Key(System.Byte[])
// docid: M:System.Security.Cryptography.AesCryptoServiceProvider.set_Key(System.Byte[])
    public override func set_Key(value : dotnet.System_Arr<Swift.UInt8>) throws {
        var __thrown : NullableHandle = nil;
        System_Security_Cryptography_AesCryptoServiceProvider_void__set_Key_0__1__u8Array(&__thrown, self.get_handle(), value.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
            return;
        }
    }
    // [IsSpecialName] System.Int32 get_KeySize()
// docid: M:System.Security.Cryptography.AesCryptoServiceProvider.get_KeySize
    public override func get_KeySize() throws -> Swift.Int32 {
        var __thrown : NullableHandle = nil;
        let __return = System_Security_Cryptography_AesCryptoServiceProvider_i32__get_KeySize_0__0(&__thrown, self.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return __return;
        }
    }
    // [IsSpecialName] void set_KeySize(System.Int32)
// docid: M:System.Security.Cryptography.AesCryptoServiceProvider.set_KeySize(System.Int32)
    public override func set_KeySize(value : Swift.Int32) throws {
        var __thrown : NullableHandle = nil;
        System_Security_Cryptography_AesCryptoServiceProvider_void__set_KeySize_0__1__i32(&__thrown, self.get_handle(), value);
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
            return;
        }
    }
    // [IsSpecialName] System.Security.Cryptography.KeySizes[] get_LegalBlockSizes()
// docid: M:System.Security.Cryptography.AesCryptoServiceProvider.get_LegalBlockSizes
    public override func get_LegalBlockSizes() throws -> dotnet.System_Arr<dotnet.System.Security.Cryptography.KeySizes> {
        var __thrown : NullableHandle = nil;
        let __return = System_Security_Cryptography_AesCryptoServiceProvider_KeySizesArray__get_LegalBlockSizes_0__0(&__thrown, self.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return dotnet.System_Arr<dotnet.System.Security.Cryptography.KeySizes>(hndl : __return);
        }
    }
    // [IsSpecialName] System.Security.Cryptography.KeySizes[] get_LegalKeySizes()
// docid: M:System.Security.Cryptography.AesCryptoServiceProvider.get_LegalKeySizes
    public override func get_LegalKeySizes() throws -> dotnet.System_Arr<dotnet.System.Security.Cryptography.KeySizes> {
        var __thrown : NullableHandle = nil;
        let __return = System_Security_Cryptography_AesCryptoServiceProvider_KeySizesArray__get_LegalKeySizes_0__0(&__thrown, self.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return dotnet.System_Arr<dotnet.System.Security.Cryptography.KeySizes>(hndl : __return);
        }
    }
    // [IsSpecialName] System.Security.Cryptography.CipherMode get_Mode()
// docid: M:System.Security.Cryptography.AesCryptoServiceProvider.get_Mode
    public override func get_Mode() throws -> dotnet.System.Security.Cryptography.CipherMode {
        var __thrown : NullableHandle = nil;
        let __return = System_Security_Cryptography_AesCryptoServiceProvider_CipherMode__get_Mode_0__0(&__thrown, self.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return dotnet.System.Security.Cryptography.CipherMode(val: __return);
        }
    }
    // [IsSpecialName] void set_Mode(System.Security.Cryptography.CipherMode)
// docid: M:System.Security.Cryptography.AesCryptoServiceProvider.set_Mode(System.Security.Cryptography.CipherMode)
    public override func set_Mode(value : dotnet.System.Security.Cryptography.CipherMode) throws {
        var __thrown : NullableHandle = nil;
        System_Security_Cryptography_AesCryptoServiceProvider_void__set_Mode_0__1__CipherMode(&__thrown, self.get_handle(), value.get_value());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
            return;
        }
    }
    // [IsSpecialName] System.Security.Cryptography.PaddingMode get_Padding()
// docid: M:System.Security.Cryptography.AesCryptoServiceProvider.get_Padding
    public override func get_Padding() throws -> dotnet.System.Security.Cryptography.PaddingMode {
        var __thrown : NullableHandle = nil;
        let __return = System_Security_Cryptography_AesCryptoServiceProvider_PaddingMode__get_Padding_0__0(&__thrown, self.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return dotnet.System.Security.Cryptography.PaddingMode(val: __return);
        }
    }
    // [IsSpecialName] void set_Padding(System.Security.Cryptography.PaddingMode)
// docid: M:System.Security.Cryptography.AesCryptoServiceProvider.set_Padding(System.Security.Cryptography.PaddingMode)
    public override func set_Padding(value : dotnet.System.Security.Cryptography.PaddingMode) throws {
        var __thrown : NullableHandle = nil;
        System_Security_Cryptography_AesCryptoServiceProvider_void__set_Padding_0__1__PaddingMode(&__thrown, self.get_handle(), value.get_value());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
            return;
        }
    }
    /**
    Gets or sets the block size, in bits, of the cryptographic operation.

    */
    public override var BlockSize : Swift.Int32 {
        get {
            return try! get_BlockSize();
        }
        set(v) {
            return try! set_BlockSize(value: v);
        }
    }
    /**
    Gets or sets the feedback size, in bits, of the cryptographic operation for the Cipher Feedback (CFB) and Output Feedback (OFB) cipher modes.

    */
    public override var FeedbackSize : Swift.Int32 {
        get {
            return try! get_FeedbackSize();
        }
        set(v) {
            return try! set_FeedbackSize(value: v);
        }
    }
    /**
    Gets or sets the initialization vector () for the symmetric algorithm.

    */
    public override var IV : dotnet.System_Arr<Swift.UInt8> {
        get {
            return try! get_IV();
        }
        set(v) {
            return try! set_IV(value: v);
        }
    }
    /**
    Gets or sets the symmetric key that is used for encryption and decryption.

    */
    public override var Key : dotnet.System_Arr<Swift.UInt8> {
        get {
            return try! get_Key();
        }
        set(v) {
            return try! set_Key(value: v);
        }
    }
    /**
    Gets or sets the size, in bits, of the secret key.

    */
    public override var KeySize : Swift.Int32 {
        get {
            return try! get_KeySize();
        }
        set(v) {
            return try! set_KeySize(value: v);
        }
    }
    /**
    Gets the block sizes, in bits, that are supported by the symmetric algorithm.

    */
    public override var LegalBlockSizes : dotnet.System_Arr<dotnet.System.Security.Cryptography.KeySizes> {
        get {
            return try! get_LegalBlockSizes();
        }
    }
    /**
    Gets the key sizes, in bits, that are supported by the symmetric algorithm.

    */
    public override var LegalKeySizes : dotnet.System_Arr<dotnet.System.Security.Cryptography.KeySizes> {
        get {
            return try! get_LegalKeySizes();
        }
    }
    /**
    Gets or sets the mode for operation of the symmetric algorithm.

    */
    public override var Mode : dotnet.System.Security.Cryptography.CipherMode {
        get {
            return try! get_Mode();
        }
        set(v) {
            return try! set_Mode(value: v);
        }
    }
    /**
    Gets or sets the padding mode used in the symmetric algorithm.

    */
    public override var Padding : dotnet.System.Security.Cryptography.PaddingMode {
        get {
            return try! get_Padding();
        }
        set(v) {
            return try! set_Padding(value: v);
        }
    }
} // AesCryptoServiceProvider


// type: System.Security.Cryptography.CspKeyContainerInfo
    /**
    Provides additional information about a cryptographic key pair. This class cannot be inherited.

    */
public final class CspKeyContainerInfo
    :
    dotnet.System.Object
{
    public class override func get_type_handle() -> TypeHandle {
        return System_Security_Cryptography_CspKeyContainerInfo_get_type_handle();
    }
    public required init(hndl: NonnullHandle) { super.init(hndl: hndl); }
    public required init(gval: GVal) { super.init(gval: gval); }
    // .ctor(System.Security.Cryptography.CspParameters)
// docid: M:System.Security.Cryptography.CspKeyContainerInfo.#ctor(System.Security.Cryptography.CspParameters)
    /**
    Initializes a new instance of the  class using the specified parameters.

    - Parameter parameters: A  object that provides information about the key.
    */
    public init(parameters : dotnet.System.Security.Cryptography.CspParameters) throws {
        var __thrown : NullableHandle = nil;
        let h = System_Security_Cryptography_CspKeyContainerInfo_ctor_0__1__CspParameters(&__thrown, parameters.get_handle());
        if let __ex = __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
            super.init(hndl: h);
        }
    }
    // [IsSpecialName] bool get_Accessible()
// docid: M:System.Security.Cryptography.CspKeyContainerInfo.get_Accessible
    public func get_Accessible() throws -> Bool {
        var __thrown : NullableHandle = nil;
        let __return = System_Security_Cryptography_CspKeyContainerInfo_bool__get_Accessible_0__0(&__thrown, self.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return (__return) != 0;
        }
    }
    // [IsSpecialName] bool get_Exportable()
// docid: M:System.Security.Cryptography.CspKeyContainerInfo.get_Exportable
    public func get_Exportable() throws -> Bool {
        var __thrown : NullableHandle = nil;
        let __return = System_Security_Cryptography_CspKeyContainerInfo_bool__get_Exportable_0__0(&__thrown, self.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return (__return) != 0;
        }
    }
    // [IsSpecialName] bool get_HardwareDevice()
// docid: M:System.Security.Cryptography.CspKeyContainerInfo.get_HardwareDevice
    public func get_HardwareDevice() throws -> Bool {
        var __thrown : NullableHandle = nil;
        let __return = System_Security_Cryptography_CspKeyContainerInfo_bool__get_HardwareDevice_0__0(&__thrown, self.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return (__return) != 0;
        }
    }
    // [IsSpecialName] System.String get_KeyContainerName()
// docid: M:System.Security.Cryptography.CspKeyContainerInfo.get_KeyContainerName
    public func get_KeyContainerName() throws -> Optional<dotnet.System.String> {
        var __thrown : NullableHandle = nil;
        let __return = System_Security_Cryptography_CspKeyContainerInfo_String__get_KeyContainerName_0__0(&__thrown, self.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        if let __ret_unwrapped = __return {
            return dotnet.System.String(hndl : __ret_unwrapped);
        } else {
            return nil;
        }
        }
    }
    // [IsSpecialName] System.Security.Cryptography.KeyNumber get_KeyNumber()
// docid: M:System.Security.Cryptography.CspKeyContainerInfo.get_KeyNumber
    public func get_KeyNumber() throws -> dotnet.System.Security.Cryptography.KeyNumber {
        var __thrown : NullableHandle = nil;
        let __return = System_Security_Cryptography_CspKeyContainerInfo_KeyNumber__get_KeyNumber_0__0(&__thrown, self.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return dotnet.System.Security.Cryptography.KeyNumber(val: __return);
        }
    }
    // [IsSpecialName] bool get_MachineKeyStore()
// docid: M:System.Security.Cryptography.CspKeyContainerInfo.get_MachineKeyStore
    public func get_MachineKeyStore() throws -> Bool {
        var __thrown : NullableHandle = nil;
        let __return = System_Security_Cryptography_CspKeyContainerInfo_bool__get_MachineKeyStore_0__0(&__thrown, self.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return (__return) != 0;
        }
    }
    // [IsSpecialName] bool get_Protected()
// docid: M:System.Security.Cryptography.CspKeyContainerInfo.get_Protected
    public func get_Protected() throws -> Bool {
        var __thrown : NullableHandle = nil;
        let __return = System_Security_Cryptography_CspKeyContainerInfo_bool__get_Protected_0__0(&__thrown, self.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return (__return) != 0;
        }
    }
    // [IsSpecialName] System.String get_ProviderName()
// docid: M:System.Security.Cryptography.CspKeyContainerInfo.get_ProviderName
    public func get_ProviderName() throws -> Optional<dotnet.System.String> {
        var __thrown : NullableHandle = nil;
        let __return = System_Security_Cryptography_CspKeyContainerInfo_String__get_ProviderName_0__0(&__thrown, self.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        if let __ret_unwrapped = __return {
            return dotnet.System.String(hndl : __ret_unwrapped);
        } else {
            return nil;
        }
        }
    }
    // [IsSpecialName] System.Int32 get_ProviderType()
// docid: M:System.Security.Cryptography.CspKeyContainerInfo.get_ProviderType
    public func get_ProviderType() throws -> Swift.Int32 {
        var __thrown : NullableHandle = nil;
        let __return = System_Security_Cryptography_CspKeyContainerInfo_i32__get_ProviderType_0__0(&__thrown, self.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return __return;
        }
    }
    // [IsSpecialName] bool get_RandomlyGenerated()
// docid: M:System.Security.Cryptography.CspKeyContainerInfo.get_RandomlyGenerated
    public func get_RandomlyGenerated() throws -> Bool {
        var __thrown : NullableHandle = nil;
        let __return = System_Security_Cryptography_CspKeyContainerInfo_bool__get_RandomlyGenerated_0__0(&__thrown, self.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return (__return) != 0;
        }
    }
    // [IsSpecialName] bool get_Removable()
// docid: M:System.Security.Cryptography.CspKeyContainerInfo.get_Removable
    public func get_Removable() throws -> Bool {
        var __thrown : NullableHandle = nil;
        let __return = System_Security_Cryptography_CspKeyContainerInfo_bool__get_Removable_0__0(&__thrown, self.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return (__return) != 0;
        }
    }
    // [IsSpecialName] System.String get_UniqueKeyContainerName()
// docid: M:System.Security.Cryptography.CspKeyContainerInfo.get_UniqueKeyContainerName
    public func get_UniqueKeyContainerName() throws -> dotnet.System.String {
        var __thrown : NullableHandle = nil;
        let __return = System_Security_Cryptography_CspKeyContainerInfo_String__get_UniqueKeyContainerName_0__0(&__thrown, self.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return dotnet.System.String(hndl : __return);
        }
    }
    /**
    Gets a value indicating whether a key in a key container is accessible.

    */
    public var Accessible : Bool {
        get {
            return try! get_Accessible();
        }
    }
    /**
    Gets a value indicating whether a key can be exported from a key container.

    */
    public var Exportable : Bool {
        get {
            return try! get_Exportable();
        }
    }
    /**
    Gets a value indicating whether a key is a hardware key.

    */
    public var HardwareDevice : Bool {
        get {
            return try! get_HardwareDevice();
        }
    }
    /**
    Gets a key container name.

    */
    public var KeyContainerName : Optional<dotnet.System.String> {
        get {
            return try! get_KeyContainerName();
        }
    }
    /**
    Gets a value that describes whether an asymmetric key was created as a signature key or an exchange key.

    */
    public var KeyNumber : dotnet.System.Security.Cryptography.KeyNumber {
        get {
            return try! get_KeyNumber();
        }
    }
    /**
    Gets a value indicating whether a key is from a machine key set.

    */
    public var MachineKeyStore : Bool {
        get {
            return try! get_MachineKeyStore();
        }
    }
    /**
    Gets a value indicating whether a key pair is protected.

    */
    public var Protected : Bool {
        get {
            return try! get_Protected();
        }
    }
    /**
    Gets the provider name of a key.

    */
    public var ProviderName : Optional<dotnet.System.String> {
        get {
            return try! get_ProviderName();
        }
    }
    /**
    Gets the provider type of a key.

    */
    public var ProviderType : Swift.Int32 {
        get {
            return try! get_ProviderType();
        }
    }
    /**
    Gets a value indicating whether a key container was randomly generated by a managed cryptography class.

    */
    public var RandomlyGenerated : Bool {
        get {
            return try! get_RandomlyGenerated();
        }
    }
    /**
    Gets a value indicating whether a key can be removed from a key container.

    */
    public var Removable : Bool {
        get {
            return try! get_Removable();
        }
    }
    /**
    Gets a unique key container name.

    */
    public var UniqueKeyContainerName : dotnet.System.String {
        get {
            return try! get_UniqueKeyContainerName();
        }
    }
} // CspKeyContainerInfo


// type: System.Security.Cryptography.CspParameters
    /**
    Contains parameters that are passed to the cryptographic service provider (CSP) that performs cryptographic computations. This class cannot be inherited.

    */
public final class CspParameters
    :
    dotnet.System.Object
{
    public class override func get_type_handle() -> TypeHandle {
        return System_Security_Cryptography_CspParameters_get_type_handle();
    }
    public required init(hndl: NonnullHandle) { super.init(hndl: hndl); }
    public required init(gval: GVal) { super.init(gval: gval); }
    // instance field: System.String KeyContainerName
    /**
    Represents the key container name for .

    */
    public var KeyContainerName : Optional<dotnet.System.String> {
        get {
        let __h = System_Security_Cryptography_CspParameters_get_KeyContainerName(self.get_handle());
        let __return = (__h != nil) ? dotnet.System.String(hndl: __h!) : nil;
            return __return;
        }
        set(v) {
            System_Security_Cryptography_CspParameters_set_KeyContainerName(self.get_handle(), v?.get_handle());
        }
    }
    // instance field: System.Int32 KeyNumber
    /**
    Specifies whether an asymmetric key is created as a signature key or an exchange key.

    */
    public var KeyNumber : Swift.Int32 {
        get {
        let __return = System_Security_Cryptography_CspParameters_get_KeyNumber(self.get_handle());
            return __return;
        }
        set(v) {
            System_Security_Cryptography_CspParameters_set_KeyNumber(self.get_handle(), v);
        }
    }
    // instance field: System.String ProviderName
    /**
    Represents the provider name for .

    */
    public var ProviderName : Optional<dotnet.System.String> {
        get {
        let __h = System_Security_Cryptography_CspParameters_get_ProviderName(self.get_handle());
        let __return = (__h != nil) ? dotnet.System.String(hndl: __h!) : nil;
            return __return;
        }
        set(v) {
            System_Security_Cryptography_CspParameters_set_ProviderName(self.get_handle(), v?.get_handle());
        }
    }
    // instance field: System.Int32 ProviderType
    /**
    Represents the provider type code for .

    */
    public var ProviderType : Swift.Int32 {
        get {
        let __return = System_Security_Cryptography_CspParameters_get_ProviderType(self.get_handle());
            return __return;
        }
        set(v) {
            System_Security_Cryptography_CspParameters_set_ProviderType(self.get_handle(), v);
        }
    }
    // .ctor()
// docid: M:System.Security.Cryptography.CspParameters.#ctor
    /**
    Initializes a new instance of the  class.

    */
    public override init() throws {
        var __thrown : NullableHandle = nil;
        let h = System_Security_Cryptography_CspParameters_ctor_0__0(&__thrown);
        if let __ex = __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
            super.init(hndl: h);
        }
    }
    // .ctor(System.Int32)
// docid: M:System.Security.Cryptography.CspParameters.#ctor(System.Int32)
    /**
    Initializes a new instance of the  class with the specified provider type code.

    - Parameter dwTypeIn: A provider type code that specifies the kind of provider to create.
    */
    public init(dwTypeIn : Swift.Int32) throws {
        var __thrown : NullableHandle = nil;
        let h = System_Security_Cryptography_CspParameters_ctor_0__1__i32(&__thrown, dwTypeIn);
        if let __ex = __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
            super.init(hndl: h);
        }
    }
    // .ctor(System.Int32, System.String)
// docid: M:System.Security.Cryptography.CspParameters.#ctor(System.Int32,System.String)
    /**
    Initializes a new instance of the  class with the specified provider type code and name.

    - Parameter dwTypeIn: A provider type code that specifies the kind of provider to create.
    - Parameter strProviderNameIn: A provider name.
    */
    public init(dwTypeIn : Swift.Int32, strProviderNameIn : Optional<dotnet.System.String>) throws {
        var __thrown : NullableHandle = nil;
        let h = System_Security_Cryptography_CspParameters_ctor_0__2__i32_String(&__thrown, dwTypeIn, strProviderNameIn?.get_handle() ?? nil);
        if let __ex = __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
            super.init(hndl: h);
        }
    }
    // .ctor(System.Int32, System.String, System.String)
// docid: M:System.Security.Cryptography.CspParameters.#ctor(System.Int32,System.String,System.String)
    /**
    Initializes a new instance of the  class with the specified provider type code and name, and the specified container name.

    - Parameter dwTypeIn: The provider type code that specifies the kind of provider to create.
    - Parameter strProviderNameIn: A provider name.
    - Parameter strContainerNameIn: A container name.
    */
    public init(dwTypeIn : Swift.Int32, strProviderNameIn : Optional<dotnet.System.String>, strContainerNameIn : Optional<dotnet.System.String>) throws {
        var __thrown : NullableHandle = nil;
        let h = System_Security_Cryptography_CspParameters_ctor_0__3__i32_String_String(&__thrown, dwTypeIn, strProviderNameIn?.get_handle() ?? nil, strContainerNameIn?.get_handle() ?? nil);
        if let __ex = __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
            super.init(hndl: h);
        }
    }
    // [IsSpecialName] System.Security.Cryptography.CspProviderFlags get_Flags()
// docid: M:System.Security.Cryptography.CspParameters.get_Flags
    public func get_Flags() throws -> dotnet.System.Security.Cryptography.CspProviderFlags {
        var __thrown : NullableHandle = nil;
        let __return = System_Security_Cryptography_CspParameters_CspProviderFlags__get_Flags_0__0(&__thrown, self.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return dotnet.System.Security.Cryptography.CspProviderFlags(val: __return);
        }
    }
    // [IsSpecialName] void set_Flags(System.Security.Cryptography.CspProviderFlags)
// docid: M:System.Security.Cryptography.CspParameters.set_Flags(System.Security.Cryptography.CspProviderFlags)
    public func set_Flags(value : dotnet.System.Security.Cryptography.CspProviderFlags) throws {
        var __thrown : NullableHandle = nil;
        System_Security_Cryptography_CspParameters_void__set_Flags_0__1__CspProviderFlags(&__thrown, self.get_handle(), value.get_value());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
            return;
        }
    }
    // [IsSpecialName] System.Security.SecureString get_KeyPassword()
// docid: M:System.Security.Cryptography.CspParameters.get_KeyPassword
    public func get_KeyPassword() throws -> Optional<dotnet.System.Security.SecureString> {
        var __thrown : NullableHandle = nil;
        let __return = System_Security_Cryptography_CspParameters_SecureString__get_KeyPassword_0__0(&__thrown, self.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        if let __ret_unwrapped = __return {
            return dotnet.System.Security.SecureString(hndl : __ret_unwrapped);
        } else {
            return nil;
        }
        }
    }
    // [IsSpecialName] void set_KeyPassword(System.Security.SecureString)
// docid: M:System.Security.Cryptography.CspParameters.set_KeyPassword(System.Security.SecureString)
    public func set_KeyPassword(value : Optional<dotnet.System.Security.SecureString>) throws {
        var __thrown : NullableHandle = nil;
        System_Security_Cryptography_CspParameters_void__set_KeyPassword_0__1__SecureString(&__thrown, self.get_handle(), value?.get_handle() ?? nil);
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
            return;
        }
    }
    // [IsSpecialName] System.IntPtr get_ParentWindowHandle()
// docid: M:System.Security.Cryptography.CspParameters.get_ParentWindowHandle
    public func get_ParentWindowHandle() throws -> dotnet.System.IntPtr {
        var __thrown : NullableHandle = nil;
        let __return = System_Security_Cryptography_CspParameters_IntPtr__get_ParentWindowHandle_0__0(&__thrown, self.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return dotnet.System.IntPtr(val: __return);
        }
    }
    // [IsSpecialName] void set_ParentWindowHandle(System.IntPtr)
// docid: M:System.Security.Cryptography.CspParameters.set_ParentWindowHandle(System.IntPtr)
    public func set_ParentWindowHandle(value : dotnet.System.IntPtr) throws {
        var __thrown : NullableHandle = nil;
        System_Security_Cryptography_CspParameters_void__set_ParentWindowHandle_0__1__IntPtr(&__thrown, self.get_handle(), value.get_value());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
            return;
        }
    }
    /**
    Represents the flags for  that modify the behavior of the cryptographic service provider (CSP).

    */
    public var Flags : dotnet.System.Security.Cryptography.CspProviderFlags {
        get {
            return try! get_Flags();
        }
        set(v) {
            return try! set_Flags(value: v);
        }
    }
    /**
    Gets or sets a password associated with a smart card key.

    */
    public var KeyPassword : Optional<dotnet.System.Security.SecureString> {
        get {
            return try! get_KeyPassword();
        }
        set(v) {
            return try! set_KeyPassword(value: v!);
        }
    }
    /**
    Gets or sets a handle to the unmanaged parent window for a smart card password dialog box.

    */
    public var ParentWindowHandle : dotnet.System.IntPtr {
        get {
            return try! get_ParentWindowHandle();
        }
        set(v) {
            return try! set_ParentWindowHandle(value: v);
        }
    }
} // CspParameters


// type: System.Security.Cryptography.CspProviderFlags
    /**
    Specifies flags that modify the behavior of the cryptographic service providers (CSP).

    */
public struct CspProviderFlags : SGBridgeGenericValue {
    let v : Swift.Int32;
    public init(val: Swift.Int32) { self.v = val; }
    public func get_value() -> Swift.Int32 { return self.v; }
    public static func get_type_handle() -> TypeHandle {
        return System_Security_Cryptography_CspProviderFlags_get_type_handle();
    }
    public func to_gval() -> GVal { return GVal(self.v); }
    public func dup_gval() -> GVal { return to_gval(); }
    public init(gval: GVal) { self.v = Swift.Int32(gval); }
    // static field: System.Security.Cryptography.CspProviderFlags NoFlags
    /**
    Do not specify any settings.

    */
    public static var NoFlags : dotnet.System.Security.Cryptography.CspProviderFlags {
        get {
        let __return = dotnet.System.Security.Cryptography.CspProviderFlags(val: System_Security_Cryptography_CspProviderFlags_get_NoFlags());
            return __return;
        }
    }
    // static field: System.Security.Cryptography.CspProviderFlags UseMachineKeyStore
    /**
    Use key information from the computer's key store.

    */
    public static var UseMachineKeyStore : dotnet.System.Security.Cryptography.CspProviderFlags {
        get {
        let __return = dotnet.System.Security.Cryptography.CspProviderFlags(val: System_Security_Cryptography_CspProviderFlags_get_UseMachineKeyStore());
            return __return;
        }
    }
    // static field: System.Security.Cryptography.CspProviderFlags UseDefaultKeyContainer
    /**
    Use key information from the default key container.

    */
    public static var UseDefaultKeyContainer : dotnet.System.Security.Cryptography.CspProviderFlags {
        get {
        let __return = dotnet.System.Security.Cryptography.CspProviderFlags(val: System_Security_Cryptography_CspProviderFlags_get_UseDefaultKeyContainer());
            return __return;
        }
    }
    // static field: System.Security.Cryptography.CspProviderFlags UseNonExportableKey
    /**
    Use key information that cannot be exported.

    */
    public static var UseNonExportableKey : dotnet.System.Security.Cryptography.CspProviderFlags {
        get {
        let __return = dotnet.System.Security.Cryptography.CspProviderFlags(val: System_Security_Cryptography_CspProviderFlags_get_UseNonExportableKey());
            return __return;
        }
    }
    // static field: System.Security.Cryptography.CspProviderFlags UseExistingKey
    /**
    Use key information from the current key.

    */
    public static var UseExistingKey : dotnet.System.Security.Cryptography.CspProviderFlags {
        get {
        let __return = dotnet.System.Security.Cryptography.CspProviderFlags(val: System_Security_Cryptography_CspProviderFlags_get_UseExistingKey());
            return __return;
        }
    }
    // static field: System.Security.Cryptography.CspProviderFlags UseArchivableKey
    /**
    Allow a key to be exported for archival or recovery.

    */
    public static var UseArchivableKey : dotnet.System.Security.Cryptography.CspProviderFlags {
        get {
        let __return = dotnet.System.Security.Cryptography.CspProviderFlags(val: System_Security_Cryptography_CspProviderFlags_get_UseArchivableKey());
            return __return;
        }
    }
    // static field: System.Security.Cryptography.CspProviderFlags UseUserProtectedKey
    /**
    Notify the user through a dialog box or another method when certain actions are attempting to use a key.  This flag is not compatible with the  flag.

    */
    public static var UseUserProtectedKey : dotnet.System.Security.Cryptography.CspProviderFlags {
        get {
        let __return = dotnet.System.Security.Cryptography.CspProviderFlags(val: System_Security_Cryptography_CspProviderFlags_get_UseUserProtectedKey());
            return __return;
        }
    }
    // static field: System.Security.Cryptography.CspProviderFlags NoPrompt
    /**
    Prevent the CSP from displaying any user interface (UI) for this context.

    */
    public static var NoPrompt : dotnet.System.Security.Cryptography.CspProviderFlags {
        get {
        let __return = dotnet.System.Security.Cryptography.CspProviderFlags(val: System_Security_Cryptography_CspProviderFlags_get_NoPrompt());
            return __return;
        }
    }
    // static field: System.Security.Cryptography.CspProviderFlags CreateEphemeralKey
    /**
    Create a temporary key that is released when the associated Rivest-Shamir-Adleman (RSA) object is closed. Do not use this flag if you want your key to be independent of the RSA object.

    */
    public static var CreateEphemeralKey : dotnet.System.Security.Cryptography.CspProviderFlags {
        get {
        let __return = dotnet.System.Security.Cryptography.CspProviderFlags(val: System_Security_Cryptography_CspProviderFlags_get_CreateEphemeralKey());
            return __return;
        }
    }
} // CspProviderFlags


// type: System.Security.Cryptography.DESCryptoServiceProvider
    /**
    Defines a wrapper object to access the cryptographic service provider (CSP) version of the Data Encryption Standard () algorithm. This class cannot be inherited.

    */
public final class DESCryptoServiceProvider
    :
    dotnet.System.Security.Cryptography.DES
{
    public class override func get_type_handle() -> TypeHandle {
        return System_Security_Cryptography_DESCryptoServiceProvider_get_type_handle();
    }
    public required init(hndl: NonnullHandle) { super.init(hndl: hndl); }
    public required init(gval: GVal) { super.init(gval: gval); }
    // .ctor()
// docid: M:System.Security.Cryptography.DESCryptoServiceProvider.#ctor
    /**
    Initializes a new instance of the  class.

    */
    public init() throws {
        var __thrown : NullableHandle = nil;
        let h = System_Security_Cryptography_DESCryptoServiceProvider_ctor_0__0(&__thrown);
        if let __ex = __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
            super.init(hndl: h);
        }
    }
    // System.Security.Cryptography.ICryptoTransform CreateDecryptor()
// docid: M:System.Security.Cryptography.DESCryptoServiceProvider.CreateDecryptor
    /**
    Creates a symmetric decryptor object with the current  property and initialization vector ().

    - Returns: A symmetric decryptor object.

    */
    public override func CreateDecryptor() throws -> dotnet.System.Security.Cryptography.ICryptoTransform {
        var __thrown : NullableHandle = nil;
        let __return = System_Security_Cryptography_DESCryptoServiceProvider_ICryptoTransform__CreateDecryptor_0__0(&__thrown, self.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return dotnet.System.Security.Cryptography.ICryptoTransform(hndl : __return);
        }
    }
    // System.Security.Cryptography.ICryptoTransform CreateDecryptor(System.Byte[], System.Byte[])
// docid: M:System.Security.Cryptography.DESCryptoServiceProvider.CreateDecryptor(System.Byte[],System.Byte[])
    /**
    Creates a symmetric Data Encryption Standard () decryptor object with the specified key () and initialization vector ().

    - Parameter rgbKey: The secret key to use for the symmetric algorithm.
    - Parameter rgbIV: The initialization vector to use for the symmetric algorithm.
    - Returns: A symmetric  decryptor object.

    */
    public override func CreateDecryptor(rgbKey : dotnet.System_Arr<Swift.UInt8>, rgbIV : Optional<dotnet.System_Arr<Swift.UInt8>>) throws -> dotnet.System.Security.Cryptography.ICryptoTransform {
        var __thrown : NullableHandle = nil;
        let __return = System_Security_Cryptography_DESCryptoServiceProvider_ICryptoTransform__CreateDecryptor_0__2__u8Array_u8Array(&__thrown, self.get_handle(), rgbKey.get_handle(), (rgbIV?.get_handle()));
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return dotnet.System.Security.Cryptography.ICryptoTransform(hndl : __return);
        }
    }
    // System.Security.Cryptography.ICryptoTransform CreateEncryptor()
// docid: M:System.Security.Cryptography.DESCryptoServiceProvider.CreateEncryptor
    /**
    Creates a symmetric encryptor object with the current  property and initialization vector ().

    - Returns: A symmetric encryptor object.

    */
    public override func CreateEncryptor() throws -> dotnet.System.Security.Cryptography.ICryptoTransform {
        var __thrown : NullableHandle = nil;
        let __return = System_Security_Cryptography_DESCryptoServiceProvider_ICryptoTransform__CreateEncryptor_0__0(&__thrown, self.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return dotnet.System.Security.Cryptography.ICryptoTransform(hndl : __return);
        }
    }
    // System.Security.Cryptography.ICryptoTransform CreateEncryptor(System.Byte[], System.Byte[])
// docid: M:System.Security.Cryptography.DESCryptoServiceProvider.CreateEncryptor(System.Byte[],System.Byte[])
    /**
    Creates a symmetric Data Encryption Standard () encryptor object with the specified key () and initialization vector ().

    - Parameter rgbKey: The secret key to use for the symmetric algorithm.
    - Parameter rgbIV: The initialization vector to use for the symmetric algorithm.
    - Returns: A symmetric  encryptor object.

    */
    public override func CreateEncryptor(rgbKey : dotnet.System_Arr<Swift.UInt8>, rgbIV : Optional<dotnet.System_Arr<Swift.UInt8>>) throws -> dotnet.System.Security.Cryptography.ICryptoTransform {
        var __thrown : NullableHandle = nil;
        let __return = System_Security_Cryptography_DESCryptoServiceProvider_ICryptoTransform__CreateEncryptor_0__2__u8Array_u8Array(&__thrown, self.get_handle(), rgbKey.get_handle(), (rgbIV?.get_handle()));
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return dotnet.System.Security.Cryptography.ICryptoTransform(hndl : __return);
        }
    }
    // void GenerateIV()
// docid: M:System.Security.Cryptography.DESCryptoServiceProvider.GenerateIV
    /**
    Generates a random initialization vector () to use for the algorithm.

    */
    public override func GenerateIV() throws {
        var __thrown : NullableHandle = nil;
        System_Security_Cryptography_DESCryptoServiceProvider_void__GenerateIV_0__0(&__thrown, self.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
            return;
        }
    }
    // void GenerateKey()
// docid: M:System.Security.Cryptography.DESCryptoServiceProvider.GenerateKey
    /**
    Generates a random key () to be used for the algorithm.

    */
    public override func GenerateKey() throws {
        var __thrown : NullableHandle = nil;
        System_Security_Cryptography_DESCryptoServiceProvider_void__GenerateKey_0__0(&__thrown, self.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
            return;
        }
    }
} // DESCryptoServiceProvider


// type: System.Security.Cryptography.DSACryptoServiceProvider
    /**
    Defines a wrapper object to access the cryptographic service provider (CSP) implementation of the  algorithm. This class cannot be inherited.

    */
public final class DSACryptoServiceProvider
    :
    dotnet.System.Security.Cryptography.DSA,
    System_Security_Cryptography_ICspAsymmetricAlgorithm
{
    public class override func get_type_handle() -> TypeHandle {
        return System_Security_Cryptography_DSACryptoServiceProvider_get_type_handle();
    }
    public required init(hndl: NonnullHandle) { super.init(hndl: hndl); }
    public required init(gval: GVal) { super.init(gval: gval); }
    // .ctor()
// docid: M:System.Security.Cryptography.DSACryptoServiceProvider.#ctor
    /**
    Initializes a new instance of the  class.

    */
    public init() throws {
        var __thrown : NullableHandle = nil;
        let h = System_Security_Cryptography_DSACryptoServiceProvider_ctor_0__0(&__thrown);
        if let __ex = __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
            super.init(hndl: h);
        }
    }
    // .ctor(System.Int32)
// docid: M:System.Security.Cryptography.DSACryptoServiceProvider.#ctor(System.Int32)
    /**
    Initializes a new instance of the  class with the specified key size.

    - Parameter dwKeySize: The size of the key for the asymmetric algorithm in bits.
    */
    public init(dwKeySize : Swift.Int32) throws {
        var __thrown : NullableHandle = nil;
        let h = System_Security_Cryptography_DSACryptoServiceProvider_ctor_0__1__i32(&__thrown, dwKeySize);
        if let __ex = __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
            super.init(hndl: h);
        }
    }
    // .ctor(System.Int32, System.Security.Cryptography.CspParameters)
// docid: M:System.Security.Cryptography.DSACryptoServiceProvider.#ctor(System.Int32,System.Security.Cryptography.CspParameters)
    /**
    Initializes a new instance of the  class with the specified key size and parameters for the cryptographic service provider (CSP).

    - Parameter dwKeySize: The size of the key for the cryptographic algorithm in bits.
    - Parameter parameters: The parameters for the CSP.
    */
    public init(dwKeySize : Swift.Int32, parameters : Optional<dotnet.System.Security.Cryptography.CspParameters>) throws {
        var __thrown : NullableHandle = nil;
        let h = System_Security_Cryptography_DSACryptoServiceProvider_ctor_0__2__i32_CspParameters(&__thrown, dwKeySize, parameters?.get_handle() ?? nil);
        if let __ex = __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
            super.init(hndl: h);
        }
    }
    // .ctor(System.Security.Cryptography.CspParameters)
// docid: M:System.Security.Cryptography.DSACryptoServiceProvider.#ctor(System.Security.Cryptography.CspParameters)
    /**
    Initializes a new instance of the  class with the specified parameters for the cryptographic service provider (CSP).

    - Parameter parameters: The parameters for the CSP.
    */
    public init(parameters : Optional<dotnet.System.Security.Cryptography.CspParameters>) throws {
        var __thrown : NullableHandle = nil;
        let h = System_Security_Cryptography_DSACryptoServiceProvider_ctor_0__1__CspParameters(&__thrown, parameters?.get_handle() ?? nil);
        if let __ex = __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
            super.init(hndl: h);
        }
    }
    // System.Byte[] CreateSignature(System.Byte[])
// docid: M:System.Security.Cryptography.DSACryptoServiceProvider.CreateSignature(System.Byte[])
    /**
    Creates the  signature for the specified data.

    - Parameter rgbHash: The data to be signed.
    - Returns: The digital signature for the specified data.

    */
    public override func CreateSignature(rgbHash : dotnet.System_Arr<Swift.UInt8>) throws -> dotnet.System_Arr<Swift.UInt8> {
        var __thrown : NullableHandle = nil;
        let __return = System_Security_Cryptography_DSACryptoServiceProvider_u8Array__CreateSignature_0__1__u8Array(&__thrown, self.get_handle(), rgbHash.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return dotnet.System_Arr<Swift.UInt8>(hndl : __return);
        }
    }
    // System.Byte[] ExportCspBlob(bool)
// docid: M:System.Security.Cryptography.DSACryptoServiceProvider.ExportCspBlob(System.Boolean)
    /**
    Exports a blob containing the key information associated with a  object.

    - Parameter includePrivateParameters: 
         to include the private key; otherwise, .
    - Returns: A byte array containing the key information associated with a  object.

    */
    public func ExportCspBlob(includePrivateParameters : Bool) throws -> dotnet.System_Arr<Swift.UInt8> {
        var __thrown : NullableHandle = nil;
        let __return = System_Security_Cryptography_DSACryptoServiceProvider_u8Array__ExportCspBlob_0__1__bool(&__thrown, self.get_handle(), Swift.Int32(includePrivateParameters ? 1 : 0));
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return dotnet.System_Arr<Swift.UInt8>(hndl : __return);
        }
    }
    // System.Security.Cryptography.DSAParameters ExportParameters(bool)
// docid: M:System.Security.Cryptography.DSACryptoServiceProvider.ExportParameters(System.Boolean)
    /**
    Exports the .

    - Parameter includePrivateParameters: 
         to include private parameters; otherwise, .
    - Returns: The parameters for .

    */
    public override func ExportParameters(includePrivateParameters : Bool) throws -> dotnet.System.Security.Cryptography.DSAParameters {
        var __thrown : NullableHandle = nil;
        let __return = System_Security_Cryptography_DSACryptoServiceProvider_DSAParameters__ExportParameters_0__1__bool(&__thrown, self.get_handle(), Swift.Int32(includePrivateParameters ? 1 : 0));
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return dotnet.System.Security.Cryptography.DSAParameters(hndl : __return);
        }
    }
    // void ImportCspBlob(System.Byte[])
// docid: M:System.Security.Cryptography.DSACryptoServiceProvider.ImportCspBlob(System.Byte[])
    /**
    Imports a blob that represents DSA key information.

    - Parameter keyBlob: A byte array that represents a DSA key blob.
    */
    public func ImportCspBlob(keyBlob : dotnet.System_Arr<Swift.UInt8>) throws {
        var __thrown : NullableHandle = nil;
        System_Security_Cryptography_DSACryptoServiceProvider_void__ImportCspBlob_0__1__u8Array(&__thrown, self.get_handle(), keyBlob.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
            return;
        }
    }
    // void ImportParameters(System.Security.Cryptography.DSAParameters)
// docid: M:System.Security.Cryptography.DSACryptoServiceProvider.ImportParameters(System.Security.Cryptography.DSAParameters)
    /**
    Imports the specified .

    - Parameter parameters: The parameters for .
    */
    public override func ImportParameters(parameters : dotnet.System.Security.Cryptography.DSAParameters) throws {
        var __thrown : NullableHandle = nil;
        System_Security_Cryptography_DSACryptoServiceProvider_void__ImportParameters_0__1__DSAParameters(&__thrown, self.get_handle(), parameters.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
            return;
        }
    }
    // System.Byte[] SignData(System.Byte[])
// docid: M:System.Security.Cryptography.DSACryptoServiceProvider.SignData(System.Byte[])
    /**
    Computes the hash value of the specified byte array and signs the resulting hash value.

    - Parameter buffer: The input data for which to compute the hash.
    - Returns: The  signature for the specified data.

    */
    public func SignData(buffer : dotnet.System_Arr<Swift.UInt8>) throws -> dotnet.System_Arr<Swift.UInt8> {
        var __thrown : NullableHandle = nil;
        let __return = System_Security_Cryptography_DSACryptoServiceProvider_u8Array__SignData_0__1__u8Array(&__thrown, self.get_handle(), buffer.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return dotnet.System_Arr<Swift.UInt8>(hndl : __return);
        }
    }
    // System.Byte[] SignData(System.Byte[], System.Int32, System.Int32)
// docid: M:System.Security.Cryptography.DSACryptoServiceProvider.SignData(System.Byte[],System.Int32,System.Int32)
    /**
    Signs a byte array from the specified start point to the specified end point.

    - Parameter buffer: The input data to sign.
    - Parameter offset: The offset into the array from which to begin using data.
    - Parameter count: The number of bytes in the array to use as data.
    - Returns: The  signature for the specified data.

    */
    public func SignData(buffer : dotnet.System_Arr<Swift.UInt8>, offset : Swift.Int32, count : Swift.Int32) throws -> dotnet.System_Arr<Swift.UInt8> {
        var __thrown : NullableHandle = nil;
        let __return = System_Security_Cryptography_DSACryptoServiceProvider_u8Array__SignData_0__3__u8Array_i32_i32(&__thrown, self.get_handle(), buffer.get_handle(), offset, count);
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return dotnet.System_Arr<Swift.UInt8>(hndl : __return);
        }
    }
    // System.Byte[] SignData(System.IO.Stream)
// docid: M:System.Security.Cryptography.DSACryptoServiceProvider.SignData(System.IO.Stream)
    /**
    Computes the hash value of the specified input stream and signs the resulting hash value.

    - Parameter inputStream: The input data for which to compute the hash.
    - Returns: The  signature for the specified data.

    */
    public func SignData(inputStream : dotnet.System.IO.Stream) throws -> dotnet.System_Arr<Swift.UInt8> {
        var __thrown : NullableHandle = nil;
        let __return = System_Security_Cryptography_DSACryptoServiceProvider_u8Array__SignData_0__1__Stream(&__thrown, self.get_handle(), inputStream.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return dotnet.System_Arr<Swift.UInt8>(hndl : __return);
        }
    }
    // System.Byte[] SignHash(System.Byte[], System.String)
// docid: M:System.Security.Cryptography.DSACryptoServiceProvider.SignHash(System.Byte[],System.String)
    /**
    Computes the signature for the specified hash value by encrypting it with the private key.

    - Parameter rgbHash: The hash value of the data to be signed.
    - Parameter str: The name of the hash algorithm used to create the hash value of the data.
    - Returns: The  signature for the specified hash value.

    */
    public func SignHash(rgbHash : dotnet.System_Arr<Swift.UInt8>, str : Optional<dotnet.System.String>) throws -> dotnet.System_Arr<Swift.UInt8> {
        var __thrown : NullableHandle = nil;
        let __return = System_Security_Cryptography_DSACryptoServiceProvider_u8Array__SignHash_0__2__u8Array_String(&__thrown, self.get_handle(), rgbHash.get_handle(), str?.get_handle() ?? nil);
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return dotnet.System_Arr<Swift.UInt8>(hndl : __return);
        }
    }
    // bool VerifyData(System.Byte[], System.Byte[])
// docid: M:System.Security.Cryptography.DSACryptoServiceProvider.VerifyData(System.Byte[],System.Byte[])
    /**
    Verifies the specified signature data by comparing it to the signature computed for the specified data.

    - Parameter rgbData: The data that was signed.
    - Parameter rgbSignature: The signature data to be verified.
    - Returns: 
         if the signature verifies as valid; otherwise, .

    */
    public func VerifyData(rgbData : dotnet.System_Arr<Swift.UInt8>, rgbSignature : dotnet.System_Arr<Swift.UInt8>) throws -> Bool {
        var __thrown : NullableHandle = nil;
        let __return = System_Security_Cryptography_DSACryptoServiceProvider_bool__VerifyData_0__2__u8Array_u8Array(&__thrown, self.get_handle(), rgbData.get_handle(), rgbSignature.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return (__return) != 0;
        }
    }
    // bool VerifyHash(System.Byte[], System.String, System.Byte[])
// docid: M:System.Security.Cryptography.DSACryptoServiceProvider.VerifyHash(System.Byte[],System.String,System.Byte[])
    /**
    Verifies the specified signature data by comparing it to the signature computed for the specified hash value.

    - Parameter rgbHash: The hash value of the data to be signed.
    - Parameter str: The name of the hash algorithm used to create the hash value of the data.
    - Parameter rgbSignature: The signature data to be verified.
    - Returns: 
         if the signature verifies as valid; otherwise, .

    */
    public func VerifyHash(rgbHash : dotnet.System_Arr<Swift.UInt8>, str : Optional<dotnet.System.String>, rgbSignature : dotnet.System_Arr<Swift.UInt8>) throws -> Bool {
        var __thrown : NullableHandle = nil;
        let __return = System_Security_Cryptography_DSACryptoServiceProvider_bool__VerifyHash_0__3__u8Array_String_u8Array(&__thrown, self.get_handle(), rgbHash.get_handle(), str?.get_handle() ?? nil, rgbSignature.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return (__return) != 0;
        }
    }
    // bool VerifySignature(System.Byte[], System.Byte[])
// docid: M:System.Security.Cryptography.DSACryptoServiceProvider.VerifySignature(System.Byte[],System.Byte[])
    /**
    Verifies the  signature for the specified data.

    - Parameter rgbHash: The data signed with .
    - Parameter rgbSignature: The signature to be verified for .
    - Returns: 
         if  matches the signature computed using the specified hash algorithm and key on ; otherwise, .

    */
    public override func VerifySignature(rgbHash : dotnet.System_Arr<Swift.UInt8>, rgbSignature : dotnet.System_Arr<Swift.UInt8>) throws -> Bool {
        var __thrown : NullableHandle = nil;
        let __return = System_Security_Cryptography_DSACryptoServiceProvider_bool__VerifySignature_0__2__u8Array_u8Array(&__thrown, self.get_handle(), rgbHash.get_handle(), rgbSignature.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return (__return) != 0;
        }
    }
    // [IsSpecialName] System.Security.Cryptography.CspKeyContainerInfo get_CspKeyContainerInfo()
// docid: M:System.Security.Cryptography.DSACryptoServiceProvider.get_CspKeyContainerInfo
    public func get_CspKeyContainerInfo() throws -> dotnet.System.Security.Cryptography.CspKeyContainerInfo {
        var __thrown : NullableHandle = nil;
        let __return = System_Security_Cryptography_DSACryptoServiceProvider_CspKeyContainerInfo__get_CspKeyContainerInfo_0__0(&__thrown, self.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return dotnet.System.Security.Cryptography.CspKeyContainerInfo(hndl : __return);
        }
    }
    // [IsSpecialName] System.String get_KeyExchangeAlgorithm()
// docid: M:System.Security.Cryptography.DSACryptoServiceProvider.get_KeyExchangeAlgorithm
    public override func get_KeyExchangeAlgorithm() throws -> Optional<dotnet.System.String> {
        var __thrown : NullableHandle = nil;
        let __return = System_Security_Cryptography_DSACryptoServiceProvider_String__get_KeyExchangeAlgorithm_0__0(&__thrown, self.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        if let __ret_unwrapped = __return {
            return dotnet.System.String(hndl : __ret_unwrapped);
        } else {
            return nil;
        }
        }
    }
    // [IsSpecialName] System.Int32 get_KeySize()
// docid: M:System.Security.Cryptography.DSACryptoServiceProvider.get_KeySize
    public override func get_KeySize() throws -> Swift.Int32 {
        var __thrown : NullableHandle = nil;
        let __return = System_Security_Cryptography_DSACryptoServiceProvider_i32__get_KeySize_0__0(&__thrown, self.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return __return;
        }
    }
    // [IsSpecialName] System.Security.Cryptography.KeySizes[] get_LegalKeySizes()
// docid: M:System.Security.Cryptography.DSACryptoServiceProvider.get_LegalKeySizes
    public override func get_LegalKeySizes() throws -> dotnet.System_Arr<dotnet.System.Security.Cryptography.KeySizes> {
        var __thrown : NullableHandle = nil;
        let __return = System_Security_Cryptography_DSACryptoServiceProvider_KeySizesArray__get_LegalKeySizes_0__0(&__thrown, self.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return dotnet.System_Arr<dotnet.System.Security.Cryptography.KeySizes>(hndl : __return);
        }
    }
    // [IsSpecialName] bool get_PersistKeyInCsp()
// docid: M:System.Security.Cryptography.DSACryptoServiceProvider.get_PersistKeyInCsp
    public func get_PersistKeyInCsp() throws -> Bool {
        var __thrown : NullableHandle = nil;
        let __return = System_Security_Cryptography_DSACryptoServiceProvider_bool__get_PersistKeyInCsp_0__0(&__thrown, self.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return (__return) != 0;
        }
    }
    // [IsSpecialName] void set_PersistKeyInCsp(bool)
// docid: M:System.Security.Cryptography.DSACryptoServiceProvider.set_PersistKeyInCsp(System.Boolean)
    public func set_PersistKeyInCsp(value : Bool) throws {
        var __thrown : NullableHandle = nil;
        System_Security_Cryptography_DSACryptoServiceProvider_void__set_PersistKeyInCsp_0__1__bool(&__thrown, self.get_handle(), Swift.Int32(value ? 1 : 0));
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
            return;
        }
    }
    // [IsSpecialName] bool get_PublicOnly()
// docid: M:System.Security.Cryptography.DSACryptoServiceProvider.get_PublicOnly
    public func get_PublicOnly() throws -> Bool {
        var __thrown : NullableHandle = nil;
        let __return = System_Security_Cryptography_DSACryptoServiceProvider_bool__get_PublicOnly_0__0(&__thrown, self.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return (__return) != 0;
        }
    }
    // [IsSpecialName] System.String get_SignatureAlgorithm()
// docid: M:System.Security.Cryptography.DSACryptoServiceProvider.get_SignatureAlgorithm
    public override func get_SignatureAlgorithm() throws -> dotnet.System.String {
        var __thrown : NullableHandle = nil;
        let __return = System_Security_Cryptography_DSACryptoServiceProvider_String__get_SignatureAlgorithm_0__0(&__thrown, self.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return dotnet.System.String(hndl : __return);
        }
    }
    // [IsSpecialName] bool get_UseMachineKeyStore()
// docid: M:System.Security.Cryptography.DSACryptoServiceProvider.get_UseMachineKeyStore
    public class func get_UseMachineKeyStore() throws -> Bool {
        var __thrown : NullableHandle = nil;
        let __return = System_Security_Cryptography_DSACryptoServiceProvider_bool__get_UseMachineKeyStore_0__0(&__thrown);
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return (__return) != 0;
        }
    }
    // [IsSpecialName] void set_UseMachineKeyStore(bool)
// docid: M:System.Security.Cryptography.DSACryptoServiceProvider.set_UseMachineKeyStore(System.Boolean)
    public class func set_UseMachineKeyStore(value : Bool) throws {
        var __thrown : NullableHandle = nil;
        System_Security_Cryptography_DSACryptoServiceProvider_void__set_UseMachineKeyStore_0__1__bool(&__thrown, Swift.Int32(value ? 1 : 0));
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
            return;
        }
    }
    /**
    Gets a  object that describes additional information about a cryptographic key pair.

    */
    public var CspKeyContainerInfo : dotnet.System.Security.Cryptography.CspKeyContainerInfo {
        get {
            return try! get_CspKeyContainerInfo();
        }
    }
    /**
    Gets the name of the key exchange algorithm.

    */
    public override var KeyExchangeAlgorithm : Optional<dotnet.System.String> {
        get {
            return try! get_KeyExchangeAlgorithm();
        }
    }
// TODO COPE (is_override_mutable_with_readonly ) [IsSpecialName] System.Int32 get_KeySize()
    /**
    Gets the key sizes that are supported by the asymmetric algorithm.

    */
    public override var LegalKeySizes : dotnet.System_Arr<dotnet.System.Security.Cryptography.KeySizes> {
        get {
            return try! get_LegalKeySizes();
        }
    }
    /**
    Gets or sets a value indicating whether the key should be persisted in the cryptographic service provider (CSP).

    */
    public var PersistKeyInCsp : Bool {
        get {
            return try! get_PersistKeyInCsp();
        }
        set(v) {
            return try! set_PersistKeyInCsp(value: v);
        }
    }
    /**
    Gets a value that indicates whether the  object contains only a public key.

    */
    public var PublicOnly : Bool {
        get {
            return try! get_PublicOnly();
        }
    }
    /**
    Gets the name of the signature algorithm.

    */
    public override var SignatureAlgorithm : dotnet.System.String {
        get {
            return try! get_SignatureAlgorithm();
        }
    }
    /**
    Gets or sets a value indicating whether the key should be persisted in the computer's key store instead of the user profile store.

    */
    public static var UseMachineKeyStore : Bool {
        get {
            return try! get_UseMachineKeyStore();
        }
        set(v) {
            return try! set_UseMachineKeyStore(value: v);
        }
    }
} // DSACryptoServiceProvider


// type: System.Security.Cryptography.ICspAsymmetricAlgorithm
    /**
    Defines methods that allow an  class to enumerate key container information, and import and export Microsoft Cryptographic API (CAPI)-compatible key blobs.

    */
open class ICspAsymmetricAlgorithm
    :
    SGBridgeGenericValue,
    System_Security_Cryptography_ICspAsymmetricAlgorithm
{
    open class func get_type_handle() -> TypeHandle {
        return System_Security_Cryptography_ICspAsymmetricAlgorithm_get_type_handle();
    }
    let h : NonnullHandle;
    public func to_gval() -> GVal { return GVal(Swift.Int(bitPattern: self.h)); }
    public func dup_gval() -> GVal { return GVal(Swift.Int(bitPattern: __copy_handle(self.h))); }
    public required init(gval: GVal) { self.h = NonnullHandle(bitPattern: Swift.Int(truncatingIfNeeded: gval))!; }
    public required init(hndl: NonnullHandle) { self.h = hndl; }
    public func get_handle() -> NonnullHandle { return self.h; }

    deinit { __drop_handle(self.h); }

    // System.Byte[] ExportCspBlob(bool)
// docid: M:System.Security.Cryptography.ICspAsymmetricAlgorithm.ExportCspBlob(System.Boolean)
    /**
    Exports a blob that contains the key information associated with an  object.

    - Parameter includePrivateParameters: 
         to include the private key; otherwise, .
    - Returns: A byte array that contains the key information associated with an  object.

    */
    open func ExportCspBlob(includePrivateParameters : Bool) throws -> dotnet.System_Arr<Swift.UInt8> {
        var __thrown : NullableHandle = nil;
        let __return = System_Security_Cryptography_ICspAsymmetricAlgorithm_u8Array__ExportCspBlob_0__1__bool(&__thrown, self.get_handle(), Swift.Int32(includePrivateParameters ? 1 : 0));
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return dotnet.System_Arr<Swift.UInt8>(hndl : __return);
        }
    }
    // void ImportCspBlob(System.Byte[])
// docid: M:System.Security.Cryptography.ICspAsymmetricAlgorithm.ImportCspBlob(System.Byte[])
    /**
    Imports a blob that represents asymmetric key information.

    - Parameter rawData: A byte array that represents an asymmetric key blob.
    */
    open func ImportCspBlob(rawData : dotnet.System_Arr<Swift.UInt8>) throws {
        var __thrown : NullableHandle = nil;
        System_Security_Cryptography_ICspAsymmetricAlgorithm_void__ImportCspBlob_0__1__u8Array(&__thrown, self.get_handle(), rawData.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
            return;
        }
    }
    // [IsSpecialName] System.Security.Cryptography.CspKeyContainerInfo get_CspKeyContainerInfo()
// docid: M:System.Security.Cryptography.ICspAsymmetricAlgorithm.get_CspKeyContainerInfo
    open func get_CspKeyContainerInfo() throws -> dotnet.System.Security.Cryptography.CspKeyContainerInfo {
        var __thrown : NullableHandle = nil;
        let __return = System_Security_Cryptography_ICspAsymmetricAlgorithm_CspKeyContainerInfo__get_CspKeyContainerInfo_0__0(&__thrown, self.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return dotnet.System.Security.Cryptography.CspKeyContainerInfo(hndl : __return);
        }
    }
} // ICspAsymmetricAlgorithm


// type: System.Security.Cryptography.KeyNumber
    /**
    Specifies whether to create an asymmetric signature key or an asymmetric exchange key.

    */
public struct KeyNumber : SGBridgeGenericValue {
    let v : Swift.Int32;
    public init(val: Swift.Int32) { self.v = val; }
    public func get_value() -> Swift.Int32 { return self.v; }
    public static func get_type_handle() -> TypeHandle {
        return System_Security_Cryptography_KeyNumber_get_type_handle();
    }
    public func to_gval() -> GVal { return GVal(self.v); }
    public func dup_gval() -> GVal { return to_gval(); }
    public init(gval: GVal) { self.v = Swift.Int32(gval); }
    // static field: System.Security.Cryptography.KeyNumber Exchange
    /**
    An exchange key pair used to encrypt session keys so that they can be safely stored and exchanged with other users. This value corresponds to the AT_KEYEXCHANGE value used in the unmanaged Microsoft Cryptographic API (CAPI).

    */
    public static var Exchange : dotnet.System.Security.Cryptography.KeyNumber {
        get {
        let __return = dotnet.System.Security.Cryptography.KeyNumber(val: System_Security_Cryptography_KeyNumber_get_Exchange());
            return __return;
        }
    }
    // static field: System.Security.Cryptography.KeyNumber Signature
    /**
    A signature key pair used for authenticating digitally signed messages or files. This value corresponds to the AT_SIGNATURE value used in the unmanaged Microsoft Cryptographic API (CAPI).

    */
    public static var Signature : dotnet.System.Security.Cryptography.KeyNumber {
        get {
        let __return = dotnet.System.Security.Cryptography.KeyNumber(val: System_Security_Cryptography_KeyNumber_get_Signature());
            return __return;
        }
    }
} // KeyNumber


// type: System.Security.Cryptography.MD5CryptoServiceProvider
    /**
    Computes the  hash value for the input data using the implementation provided by the cryptographic service provider (CSP). This class cannot be inherited.

    */
public final class MD5CryptoServiceProvider
    :
    dotnet.System.Security.Cryptography.MD5
{
    public class override func get_type_handle() -> TypeHandle {
        return System_Security_Cryptography_MD5CryptoServiceProvider_get_type_handle();
    }
    public required init(hndl: NonnullHandle) { super.init(hndl: hndl); }
    public required init(gval: GVal) { super.init(gval: gval); }
    // .ctor()
// docid: M:System.Security.Cryptography.MD5CryptoServiceProvider.#ctor
    /**
    Initializes a new instance of the  class.

    */
    public init() throws {
        var __thrown : NullableHandle = nil;
        let h = System_Security_Cryptography_MD5CryptoServiceProvider_ctor_0__0(&__thrown);
        if let __ex = __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
            super.init(hndl: h);
        }
    }
    // void Initialize()
// docid: M:System.Security.Cryptography.MD5CryptoServiceProvider.Initialize
    /**
    Initializes an instance of .

    */
    public override func Initialize() throws {
        var __thrown : NullableHandle = nil;
        System_Security_Cryptography_MD5CryptoServiceProvider_void__Initialize_0__0(&__thrown, self.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
            return;
        }
    }
} // MD5CryptoServiceProvider


// type: System.Security.Cryptography.PasswordDeriveBytes
    /**
    Derives a key from a password using an extension of the PBKDF1 algorithm.

    */
open class PasswordDeriveBytes
    :
    dotnet.System.Security.Cryptography.DeriveBytes
{
    open class override func get_type_handle() -> TypeHandle {
        return System_Security_Cryptography_PasswordDeriveBytes_get_type_handle();
    }
    public required init(hndl: NonnullHandle) { super.init(hndl: hndl); }
    public required init(gval: GVal) { super.init(gval: gval); }
    // .ctor(System.Byte[], System.Byte[])
// docid: M:System.Security.Cryptography.PasswordDeriveBytes.#ctor(System.Byte[],System.Byte[])
    /**
    Initializes a new instance of the  class specifying the password and key salt to use to derive the key.

    - Parameter password: The password to derive the key for.
    - Parameter salt: The key salt to use to derive the key.
    */
    public init(password : dotnet.System_Arr<Swift.UInt8>, salt : Optional<dotnet.System_Arr<Swift.UInt8>>) throws {
        var __thrown : NullableHandle = nil;
        let h = System_Security_Cryptography_PasswordDeriveBytes_ctor_0__2__u8Array_u8Array(&__thrown, password.get_handle(), (salt?.get_handle()));
        if let __ex = __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
            super.init(hndl: h);
        }
    }
    // .ctor(System.Byte[], System.Byte[], System.Security.Cryptography.CspParameters)
// docid: M:System.Security.Cryptography.PasswordDeriveBytes.#ctor(System.Byte[],System.Byte[],System.Security.Cryptography.CspParameters)
    /**
    Initializes a new instance of the  class specifying the password, key salt, and cryptographic service provider (CSP) to use to derive the key.

    - Parameter password: The password to derive the key for.
    - Parameter salt: The key salt to use to derive the key.
    - Parameter cspParams: The cryptographic service provider (CSP) parameters for the operation.
    */
    public init(password : dotnet.System_Arr<Swift.UInt8>, salt : Optional<dotnet.System_Arr<Swift.UInt8>>, cspParams : Optional<dotnet.System.Security.Cryptography.CspParameters>) throws {
        var __thrown : NullableHandle = nil;
        let h = System_Security_Cryptography_PasswordDeriveBytes_ctor_0__3__u8Array_u8Array_CspParameters(&__thrown, password.get_handle(), (salt?.get_handle()), cspParams?.get_handle() ?? nil);
        if let __ex = __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
            super.init(hndl: h);
        }
    }
    // .ctor(System.Byte[], System.Byte[], System.String, System.Int32)
// docid: M:System.Security.Cryptography.PasswordDeriveBytes.#ctor(System.Byte[],System.Byte[],System.String,System.Int32)
    /**
    Initializes a new instance of the  class specifying the password, key salt, hash name, and iterations to use to derive the key.

    - Parameter password: The password to derive the key for.
    - Parameter salt: The key salt to use to derive the key.
    - Parameter hashName: The hash algorithm to use to derive the key.
    - Parameter iterations: The iteration count to use to derive the key.
    */
    public init(password : dotnet.System_Arr<Swift.UInt8>, salt : Optional<dotnet.System_Arr<Swift.UInt8>>, hashName : dotnet.System.String, iterations : Swift.Int32) throws {
        var __thrown : NullableHandle = nil;
        let h = System_Security_Cryptography_PasswordDeriveBytes_ctor_0__4__u8Array_u8Array_String_i32(&__thrown, password.get_handle(), (salt?.get_handle()), hashName.get_handle(), iterations);
        if let __ex = __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
            super.init(hndl: h);
        }
    }
    // .ctor(System.Byte[], System.Byte[], System.String, System.Int32, System.Security.Cryptography.CspParameters)
// docid: M:System.Security.Cryptography.PasswordDeriveBytes.#ctor(System.Byte[],System.Byte[],System.String,System.Int32,System.Security.Cryptography.CspParameters)
    /**
    Initializes a new instance of the  class specifying the password, key salt, hash name, iterations, and cryptographic service provider (CSP) to use to derive the key.

    - Parameter password: The password to derive the key for.
    - Parameter salt: The key salt to use to derive the key.
    - Parameter hashName: The hash algorithm to use to derive the key.
    - Parameter iterations: The iteration count to use to derive the key.
    - Parameter cspParams: The cryptographic service provider (CSP) parameters for the operation.
    */
    public init(password : dotnet.System_Arr<Swift.UInt8>, salt : Optional<dotnet.System_Arr<Swift.UInt8>>, hashName : dotnet.System.String, iterations : Swift.Int32, cspParams : Optional<dotnet.System.Security.Cryptography.CspParameters>) throws {
        var __thrown : NullableHandle = nil;
        let h = System_Security_Cryptography_PasswordDeriveBytes_ctor_0__5__u8Array_u8Array_String_i32_CspParameters(&__thrown, password.get_handle(), (salt?.get_handle()), hashName.get_handle(), iterations, cspParams?.get_handle() ?? nil);
        if let __ex = __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
            super.init(hndl: h);
        }
    }
    // .ctor(System.String, System.Byte[])
// docid: M:System.Security.Cryptography.PasswordDeriveBytes.#ctor(System.String,System.Byte[])
    /**
    Initializes a new instance of the  class with the password and key salt to use to derive the key.

    - Parameter strPassword: The password for which to derive the key.
    - Parameter rgbSalt: The key salt to use to derive the key.
    */
    public init(strPassword : dotnet.System.String, rgbSalt : Optional<dotnet.System_Arr<Swift.UInt8>>) throws {
        var __thrown : NullableHandle = nil;
        let h = System_Security_Cryptography_PasswordDeriveBytes_ctor_0__2__String_u8Array(&__thrown, strPassword.get_handle(), (rgbSalt?.get_handle()));
        if let __ex = __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
            super.init(hndl: h);
        }
    }
    // .ctor(System.String, System.Byte[], System.Security.Cryptography.CspParameters)
// docid: M:System.Security.Cryptography.PasswordDeriveBytes.#ctor(System.String,System.Byte[],System.Security.Cryptography.CspParameters)
    /**
    Initializes a new instance of the  class with the password, key salt, and cryptographic service provider (CSP) parameters to use to derive the key.

    - Parameter strPassword: The password for which to derive the key.
    - Parameter rgbSalt: The key salt to use to derive the key.
    - Parameter cspParams: The CSP parameters for the operation.
    */
    public init(strPassword : dotnet.System.String, rgbSalt : Optional<dotnet.System_Arr<Swift.UInt8>>, cspParams : Optional<dotnet.System.Security.Cryptography.CspParameters>) throws {
        var __thrown : NullableHandle = nil;
        let h = System_Security_Cryptography_PasswordDeriveBytes_ctor_0__3__String_u8Array_CspParameters(&__thrown, strPassword.get_handle(), (rgbSalt?.get_handle()), cspParams?.get_handle() ?? nil);
        if let __ex = __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
            super.init(hndl: h);
        }
    }
    // .ctor(System.String, System.Byte[], System.String, System.Int32)
// docid: M:System.Security.Cryptography.PasswordDeriveBytes.#ctor(System.String,System.Byte[],System.String,System.Int32)
    /**
    Initializes a new instance of the  class with the password, key salt, hash name, and number of iterations to use to derive the key.

    - Parameter strPassword: The password for which to derive the key.
    - Parameter rgbSalt: The key salt to use to derive the key.
    - Parameter strHashName: The name of the hash algorithm for the operation.
    - Parameter iterations: The number of iterations for the operation.
    */
    public init(strPassword : dotnet.System.String, rgbSalt : Optional<dotnet.System_Arr<Swift.UInt8>>, strHashName : dotnet.System.String, iterations : Swift.Int32) throws {
        var __thrown : NullableHandle = nil;
        let h = System_Security_Cryptography_PasswordDeriveBytes_ctor_0__4__String_u8Array_String_i32(&__thrown, strPassword.get_handle(), (rgbSalt?.get_handle()), strHashName.get_handle(), iterations);
        if let __ex = __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
            super.init(hndl: h);
        }
    }
    // .ctor(System.String, System.Byte[], System.String, System.Int32, System.Security.Cryptography.CspParameters)
// docid: M:System.Security.Cryptography.PasswordDeriveBytes.#ctor(System.String,System.Byte[],System.String,System.Int32,System.Security.Cryptography.CspParameters)
    /**
    Initializes a new instance of the  class with the password, key salt, hash name, number of iterations, and cryptographic service provider (CSP) parameters to use to derive the key.

    - Parameter strPassword: The password for which to derive the key.
    - Parameter rgbSalt: The key salt to use to derive the key.
    - Parameter strHashName: The name of the hash algorithm for the operation.
    - Parameter iterations: The number of iterations for the operation.
    - Parameter cspParams: The CSP parameters for the operation.
    */
    public init(strPassword : dotnet.System.String, rgbSalt : Optional<dotnet.System_Arr<Swift.UInt8>>, strHashName : dotnet.System.String, iterations : Swift.Int32, cspParams : Optional<dotnet.System.Security.Cryptography.CspParameters>) throws {
        var __thrown : NullableHandle = nil;
        let h = System_Security_Cryptography_PasswordDeriveBytes_ctor_0__5__String_u8Array_String_i32_CspParameters(&__thrown, strPassword.get_handle(), (rgbSalt?.get_handle()), strHashName.get_handle(), iterations, cspParams?.get_handle() ?? nil);
        if let __ex = __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
            super.init(hndl: h);
        }
    }
    // System.Byte[] CryptDeriveKey(System.String, System.String, System.Int32, System.Byte[])
// docid: M:System.Security.Cryptography.PasswordDeriveBytes.CryptDeriveKey(System.String,System.String,System.Int32,System.Byte[])
    /**
    Derives a cryptographic key from the  object.

    - Parameter algname: The algorithm name for which to derive the key.
    - Parameter alghashname: The hash algorithm name to use to derive the key.
    - Parameter keySize: The size of the key, in bits, to derive.
    - Parameter rgbIV: The initialization vector (IV) to use to derive the key.
    - Returns: The derived key.

    */
    open func CryptDeriveKey(algname : Optional<dotnet.System.String>, alghashname : Optional<dotnet.System.String>, keySize : Swift.Int32, rgbIV : dotnet.System_Arr<Swift.UInt8>) throws -> dotnet.System_Arr<Swift.UInt8> {
        var __thrown : NullableHandle = nil;
        let __return = System_Security_Cryptography_PasswordDeriveBytes_u8Array__CryptDeriveKey_0__4__String_String_i32_u8Array(&__thrown, self.get_handle(), algname?.get_handle() ?? nil, alghashname?.get_handle() ?? nil, keySize, rgbIV.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return dotnet.System_Arr<Swift.UInt8>(hndl : __return);
        }
    }
    // System.Byte[] GetBytes(System.Int32)
// docid: M:System.Security.Cryptography.PasswordDeriveBytes.GetBytes(System.Int32)
    /**
    Returns pseudo-random key bytes.

    - Parameter cb: The number of pseudo-random key bytes to generate.
    - Returns: A byte array filled with pseudo-random key bytes.

    */
    open override func GetBytes(cb : Swift.Int32) throws -> dotnet.System_Arr<Swift.UInt8> {
        var __thrown : NullableHandle = nil;
        let __return = System_Security_Cryptography_PasswordDeriveBytes_u8Array__GetBytes_0__1__i32(&__thrown, self.get_handle(), cb);
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return dotnet.System_Arr<Swift.UInt8>(hndl : __return);
        }
    }
    // void Reset()
// docid: M:System.Security.Cryptography.PasswordDeriveBytes.Reset
    /**
    Resets the state of the operation.

    */
    open override func Reset() throws {
        var __thrown : NullableHandle = nil;
        System_Security_Cryptography_PasswordDeriveBytes_void__Reset_0__0(&__thrown, self.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
            return;
        }
    }
    // [IsSpecialName] System.String get_HashName()
// docid: M:System.Security.Cryptography.PasswordDeriveBytes.get_HashName
    open func get_HashName() throws -> dotnet.System.String {
        var __thrown : NullableHandle = nil;
        let __return = System_Security_Cryptography_PasswordDeriveBytes_String__get_HashName_0__0(&__thrown, self.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return dotnet.System.String(hndl : __return);
        }
    }
    // [IsSpecialName] void set_HashName(System.String)
// docid: M:System.Security.Cryptography.PasswordDeriveBytes.set_HashName(System.String)
    open func set_HashName(value : dotnet.System.String) throws {
        var __thrown : NullableHandle = nil;
        System_Security_Cryptography_PasswordDeriveBytes_void__set_HashName_0__1__String(&__thrown, self.get_handle(), value.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
            return;
        }
    }
    // [IsSpecialName] System.Int32 get_IterationCount()
// docid: M:System.Security.Cryptography.PasswordDeriveBytes.get_IterationCount
    open func get_IterationCount() throws -> Swift.Int32 {
        var __thrown : NullableHandle = nil;
        let __return = System_Security_Cryptography_PasswordDeriveBytes_i32__get_IterationCount_0__0(&__thrown, self.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return __return;
        }
    }
    // [IsSpecialName] void set_IterationCount(System.Int32)
// docid: M:System.Security.Cryptography.PasswordDeriveBytes.set_IterationCount(System.Int32)
    open func set_IterationCount(value : Swift.Int32) throws {
        var __thrown : NullableHandle = nil;
        System_Security_Cryptography_PasswordDeriveBytes_void__set_IterationCount_0__1__i32(&__thrown, self.get_handle(), value);
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
            return;
        }
    }
    // [IsSpecialName] System.Byte[] get_Salt()
// docid: M:System.Security.Cryptography.PasswordDeriveBytes.get_Salt
    open func get_Salt() throws -> Optional<dotnet.System_Arr<Swift.UInt8>> {
        var __thrown : NullableHandle = nil;
        let __return = System_Security_Cryptography_PasswordDeriveBytes_u8Array__get_Salt_0__0(&__thrown, self.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        if let __ret_unwrapped = __return {
            return dotnet.System_Arr<Swift.UInt8>(hndl : __ret_unwrapped);
        } else {
            return nil;
        }
        }
    }
    // [IsSpecialName] void set_Salt(System.Byte[])
// docid: M:System.Security.Cryptography.PasswordDeriveBytes.set_Salt(System.Byte[])
    open func set_Salt(value : Optional<dotnet.System_Arr<Swift.UInt8>>) throws {
        var __thrown : NullableHandle = nil;
        System_Security_Cryptography_PasswordDeriveBytes_void__set_Salt_0__1__u8Array(&__thrown, self.get_handle(), (value?.get_handle()));
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
            return;
        }
    }
    /**
    Gets or sets the name of the hash algorithm for the operation.

    */
    open var HashName : dotnet.System.String {
        get {
            return try! get_HashName();
        }
        set(v) {
            return try! set_HashName(value: v);
        }
    }
    /**
    Gets or sets the number of iterations for the operation.

    */
    open var IterationCount : Swift.Int32 {
        get {
            return try! get_IterationCount();
        }
        set(v) {
            return try! set_IterationCount(value: v);
        }
    }
    /**
    Gets or sets the key salt value for the operation.

    */
    open var Salt : Optional<dotnet.System_Arr<Swift.UInt8>> {
        get {
            return try! get_Salt();
        }
        set(v) {
            return try! set_Salt(value: v!);
        }
    }
} // PasswordDeriveBytes


// type: System.Security.Cryptography.RC2CryptoServiceProvider
    /**
    Defines a wrapper object to access the cryptographic service provider (CSP) implementation of the  algorithm. This class cannot be inherited.

    */
public final class RC2CryptoServiceProvider
    :
    dotnet.System.Security.Cryptography.RC2
{
    public class override func get_type_handle() -> TypeHandle {
        return System_Security_Cryptography_RC2CryptoServiceProvider_get_type_handle();
    }
    public required init(hndl: NonnullHandle) { super.init(hndl: hndl); }
    public required init(gval: GVal) { super.init(gval: gval); }
    // .ctor()
// docid: M:System.Security.Cryptography.RC2CryptoServiceProvider.#ctor
    /**
    Initializes a new instance of the  class.

    */
    public init() throws {
        var __thrown : NullableHandle = nil;
        let h = System_Security_Cryptography_RC2CryptoServiceProvider_ctor_0__0(&__thrown);
        if let __ex = __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
            super.init(hndl: h);
        }
    }
    // System.Security.Cryptography.ICryptoTransform CreateDecryptor(System.Byte[], System.Byte[])
// docid: M:System.Security.Cryptography.RC2CryptoServiceProvider.CreateDecryptor(System.Byte[],System.Byte[])
    /**
    Creates a symmetric  decryptor object with the specified key () and initialization vector ().

    - Parameter rgbKey: The secret key to use for the symmetric algorithm.
    - Parameter rgbIV: The initialization vector to use for the symmetric algorithm.
    - Returns: A symmetric  decryptor object.

    */
    public override func CreateDecryptor(rgbKey : dotnet.System_Arr<Swift.UInt8>, rgbIV : Optional<dotnet.System_Arr<Swift.UInt8>>) throws -> dotnet.System.Security.Cryptography.ICryptoTransform {
        var __thrown : NullableHandle = nil;
        let __return = System_Security_Cryptography_RC2CryptoServiceProvider_ICryptoTransform__CreateDecryptor_0__2__u8Array_u8Array(&__thrown, self.get_handle(), rgbKey.get_handle(), (rgbIV?.get_handle()));
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return dotnet.System.Security.Cryptography.ICryptoTransform(hndl : __return);
        }
    }
    // System.Security.Cryptography.ICryptoTransform CreateEncryptor(System.Byte[], System.Byte[])
// docid: M:System.Security.Cryptography.RC2CryptoServiceProvider.CreateEncryptor(System.Byte[],System.Byte[])
    /**
    Creates a symmetric  encryptor object with the specified key () and initialization vector ().

    - Parameter rgbKey: The secret key to use for the symmetric algorithm.
    - Parameter rgbIV: The initialization vector to use for the symmetric algorithm.
    - Returns: A symmetric  encryptor object.

    */
    public override func CreateEncryptor(rgbKey : dotnet.System_Arr<Swift.UInt8>, rgbIV : Optional<dotnet.System_Arr<Swift.UInt8>>) throws -> dotnet.System.Security.Cryptography.ICryptoTransform {
        var __thrown : NullableHandle = nil;
        let __return = System_Security_Cryptography_RC2CryptoServiceProvider_ICryptoTransform__CreateEncryptor_0__2__u8Array_u8Array(&__thrown, self.get_handle(), rgbKey.get_handle(), (rgbIV?.get_handle()));
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return dotnet.System.Security.Cryptography.ICryptoTransform(hndl : __return);
        }
    }
    // void GenerateIV()
// docid: M:System.Security.Cryptography.RC2CryptoServiceProvider.GenerateIV
    /**
    Generates a random initialization vector () to use for the algorithm.

    */
    public override func GenerateIV() throws {
        var __thrown : NullableHandle = nil;
        System_Security_Cryptography_RC2CryptoServiceProvider_void__GenerateIV_0__0(&__thrown, self.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
            return;
        }
    }
    // void GenerateKey()
// docid: M:System.Security.Cryptography.RC2CryptoServiceProvider.GenerateKey
    /**
    Generates a random key () to be used for the algorithm.

    */
    public override func GenerateKey() throws {
        var __thrown : NullableHandle = nil;
        System_Security_Cryptography_RC2CryptoServiceProvider_void__GenerateKey_0__0(&__thrown, self.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
            return;
        }
    }
    // [IsSpecialName] System.Int32 get_EffectiveKeySize()
// docid: M:System.Security.Cryptography.RC2CryptoServiceProvider.get_EffectiveKeySize
    public override func get_EffectiveKeySize() throws -> Swift.Int32 {
        var __thrown : NullableHandle = nil;
        let __return = System_Security_Cryptography_RC2CryptoServiceProvider_i32__get_EffectiveKeySize_0__0(&__thrown, self.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return __return;
        }
    }
    // [IsSpecialName] void set_EffectiveKeySize(System.Int32)
// docid: M:System.Security.Cryptography.RC2CryptoServiceProvider.set_EffectiveKeySize(System.Int32)
    public override func set_EffectiveKeySize(value : Swift.Int32) throws {
        var __thrown : NullableHandle = nil;
        System_Security_Cryptography_RC2CryptoServiceProvider_void__set_EffectiveKeySize_0__1__i32(&__thrown, self.get_handle(), value);
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
            return;
        }
    }
    // [IsSpecialName] bool get_UseSalt()
// docid: M:System.Security.Cryptography.RC2CryptoServiceProvider.get_UseSalt
    public func get_UseSalt() throws -> Bool {
        var __thrown : NullableHandle = nil;
        let __return = System_Security_Cryptography_RC2CryptoServiceProvider_bool__get_UseSalt_0__0(&__thrown, self.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return (__return) != 0;
        }
    }
    // [IsSpecialName] void set_UseSalt(bool)
// docid: M:System.Security.Cryptography.RC2CryptoServiceProvider.set_UseSalt(System.Boolean)
    public func set_UseSalt(value : Bool) throws {
        var __thrown : NullableHandle = nil;
        System_Security_Cryptography_RC2CryptoServiceProvider_void__set_UseSalt_0__1__bool(&__thrown, self.get_handle(), Swift.Int32(value ? 1 : 0));
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
            return;
        }
    }
    /**
    Gets or sets the effective size, in bits, of the secret key used by the  algorithm.

    */
    public override var EffectiveKeySize : Swift.Int32 {
        get {
            return try! get_EffectiveKeySize();
        }
        set(v) {
            return try! set_EffectiveKeySize(value: v);
        }
    }
    /**
    Gets or sets a value that determines whether to create a key with an 11-byte-long, zero-value salt.

    */
    public var UseSalt : Bool {
        get {
            return try! get_UseSalt();
        }
        set(v) {
            return try! set_UseSalt(value: v);
        }
    }
} // RC2CryptoServiceProvider


// type: System.Security.Cryptography.RNGCryptoServiceProvider
    /**
    Implements a cryptographic Random Number Generator (RNG) using the implementation provided by the cryptographic service provider (CSP). This class cannot be inherited.

    */
public final class RNGCryptoServiceProvider
    :
    dotnet.System.Security.Cryptography.RandomNumberGenerator
{
    public class override func get_type_handle() -> TypeHandle {
        return System_Security_Cryptography_RNGCryptoServiceProvider_get_type_handle();
    }
    public required init(hndl: NonnullHandle) { super.init(hndl: hndl); }
    public required init(gval: GVal) { super.init(gval: gval); }
    // .ctor()
// docid: M:System.Security.Cryptography.RNGCryptoServiceProvider.#ctor
    /**
    Initializes a new instance of the  class.

    */
    public init() throws {
        var __thrown : NullableHandle = nil;
        let h = System_Security_Cryptography_RNGCryptoServiceProvider_ctor_0__0(&__thrown);
        if let __ex = __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
            super.init(hndl: h);
        }
    }
    // .ctor(System.Byte[])
// docid: M:System.Security.Cryptography.RNGCryptoServiceProvider.#ctor(System.Byte[])
    /**
    Initializes a new instance of the  class.

    - Parameter rgb: A byte array. This value is ignored.
    */
    public init(rgb : dotnet.System_Arr<Swift.UInt8>) throws {
        var __thrown : NullableHandle = nil;
        let h = System_Security_Cryptography_RNGCryptoServiceProvider_ctor_0__1__u8Array(&__thrown, rgb.get_handle());
        if let __ex = __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
            super.init(hndl: h);
        }
    }
    // .ctor(System.Security.Cryptography.CspParameters)
// docid: M:System.Security.Cryptography.RNGCryptoServiceProvider.#ctor(System.Security.Cryptography.CspParameters)
    /**
    Initializes a new instance of the  class with the specified parameters.

    - Parameter cspParams: The parameters to pass to the cryptographic service provider (CSP).
    */
    public init(cspParams : Optional<dotnet.System.Security.Cryptography.CspParameters>) throws {
        var __thrown : NullableHandle = nil;
        let h = System_Security_Cryptography_RNGCryptoServiceProvider_ctor_0__1__CspParameters(&__thrown, cspParams?.get_handle() ?? nil);
        if let __ex = __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
            super.init(hndl: h);
        }
    }
    // .ctor(System.String)
// docid: M:System.Security.Cryptography.RNGCryptoServiceProvider.#ctor(System.String)
    /**
    Initializes a new instance of the  class.

    - Parameter str: The string input. This parameter is ignored.
    */
    public init(str : dotnet.System.String) throws {
        var __thrown : NullableHandle = nil;
        let h = System_Security_Cryptography_RNGCryptoServiceProvider_ctor_0__1__String(&__thrown, str.get_handle());
        if let __ex = __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
            super.init(hndl: h);
        }
    }
    // void GetBytes(System.Byte[])
// docid: M:System.Security.Cryptography.RNGCryptoServiceProvider.GetBytes(System.Byte[])
    /**
    Fills an array of bytes with a cryptographically strong sequence of random values.

    - Parameter data: The array to fill with a cryptographically strong sequence of random values.
    */
    public override func GetBytes(data : dotnet.System_Arr<Swift.UInt8>) throws {
        var __thrown : NullableHandle = nil;
        System_Security_Cryptography_RNGCryptoServiceProvider_void__GetBytes_0__1__u8Array(&__thrown, self.get_handle(), data.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
            return;
        }
    }
    // void GetBytes(System.Byte[], System.Int32, System.Int32)
// docid: M:System.Security.Cryptography.RNGCryptoServiceProvider.GetBytes(System.Byte[],System.Int32,System.Int32)
    /**
    Fills the specified byte array with a cryptographically strong random sequence of values starting at a specified index for a specified number of bytes.

    - Parameter data: The array to fill with cryptographically strong random bytes.
    - Parameter offset: The index of the array to start the fill operation.
    - Parameter count: The number of bytes to fill.
    */
    public override func GetBytes(data : dotnet.System_Arr<Swift.UInt8>, offset : Swift.Int32, count : Swift.Int32) throws {
        var __thrown : NullableHandle = nil;
        System_Security_Cryptography_RNGCryptoServiceProvider_void__GetBytes_0__3__u8Array_i32_i32(&__thrown, self.get_handle(), data.get_handle(), offset, count);
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
            return;
        }
    }
// TODO COPE (write_all_methods) (span) void GetBytes(System.Span<System.Byte>)
    // void GetNonZeroBytes(System.Byte[])
// docid: M:System.Security.Cryptography.RNGCryptoServiceProvider.GetNonZeroBytes(System.Byte[])
    /**
    Fills an array of bytes with a cryptographically strong sequence of random nonzero values.

    - Parameter data: The array to fill with a cryptographically strong sequence of random nonzero values.
    */
    public override func GetNonZeroBytes(data : dotnet.System_Arr<Swift.UInt8>) throws {
        var __thrown : NullableHandle = nil;
        System_Security_Cryptography_RNGCryptoServiceProvider_void__GetNonZeroBytes_0__1__u8Array(&__thrown, self.get_handle(), data.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
            return;
        }
    }
// TODO COPE (write_all_methods) (span) void GetNonZeroBytes(System.Span<System.Byte>)
} // RNGCryptoServiceProvider


// type: System.Security.Cryptography.RSACryptoServiceProvider
    /**
    Performs asymmetric encryption and decryption using the implementation of the  algorithm provided by the cryptographic service provider (CSP). This class cannot be inherited.

    */
public final class RSACryptoServiceProvider
    :
    dotnet.System.Security.Cryptography.RSA,
    System_Security_Cryptography_ICspAsymmetricAlgorithm
{
    public class override func get_type_handle() -> TypeHandle {
        return System_Security_Cryptography_RSACryptoServiceProvider_get_type_handle();
    }
    public required init(hndl: NonnullHandle) { super.init(hndl: hndl); }
    public required init(gval: GVal) { super.init(gval: gval); }
    // .ctor()
// docid: M:System.Security.Cryptography.RSACryptoServiceProvider.#ctor
    /**
    Initializes a new instance of the  class with a random key pair.

    */
    public init() throws {
        var __thrown : NullableHandle = nil;
        let h = System_Security_Cryptography_RSACryptoServiceProvider_ctor_0__0(&__thrown);
        if let __ex = __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
            super.init(hndl: h);
        }
    }
    // .ctor(System.Int32)
// docid: M:System.Security.Cryptography.RSACryptoServiceProvider.#ctor(System.Int32)
    /**
    Initializes a new instance of the  class with a random key pair of the specified key size.

    - Parameter dwKeySize: The size of the key to use in bits.
    */
    public init(dwKeySize : Swift.Int32) throws {
        var __thrown : NullableHandle = nil;
        let h = System_Security_Cryptography_RSACryptoServiceProvider_ctor_0__1__i32(&__thrown, dwKeySize);
        if let __ex = __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
            super.init(hndl: h);
        }
    }
    // .ctor(System.Int32, System.Security.Cryptography.CspParameters)
// docid: M:System.Security.Cryptography.RSACryptoServiceProvider.#ctor(System.Int32,System.Security.Cryptography.CspParameters)
    /**
    Initializes a new instance of the  class with the specified key size and parameters.

    - Parameter dwKeySize: The size of the key to use in bits.
    - Parameter parameters: The parameters to be passed to the cryptographic service provider (CSP).
    */
    public init(dwKeySize : Swift.Int32, parameters : Optional<dotnet.System.Security.Cryptography.CspParameters>) throws {
        var __thrown : NullableHandle = nil;
        let h = System_Security_Cryptography_RSACryptoServiceProvider_ctor_0__2__i32_CspParameters(&__thrown, dwKeySize, parameters?.get_handle() ?? nil);
        if let __ex = __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
            super.init(hndl: h);
        }
    }
    // .ctor(System.Security.Cryptography.CspParameters)
// docid: M:System.Security.Cryptography.RSACryptoServiceProvider.#ctor(System.Security.Cryptography.CspParameters)
    /**
    Initializes a new instance of the  class with the specified parameters.

    - Parameter parameters: The parameters to be passed to the cryptographic service provider (CSP).
    */
    public init(parameters : Optional<dotnet.System.Security.Cryptography.CspParameters>) throws {
        var __thrown : NullableHandle = nil;
        let h = System_Security_Cryptography_RSACryptoServiceProvider_ctor_0__1__CspParameters(&__thrown, parameters?.get_handle() ?? nil);
        if let __ex = __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
            super.init(hndl: h);
        }
    }
    // System.Byte[] Decrypt(System.Byte[], bool)
// docid: M:System.Security.Cryptography.RSACryptoServiceProvider.Decrypt(System.Byte[],System.Boolean)
    /**
    Decrypts data with the  algorithm.

    - Parameter rgb: The data to be decrypted.
    - Parameter fOAEP: 
         to perform direct  decryption using OAEP padding; otherwise,  to use PKCS#1 v1.5 padding.
    - Returns: The decrypted data, which is the original plain text before encryption.

    */
    public func Decrypt(rgb : dotnet.System_Arr<Swift.UInt8>, fOAEP : Bool) throws -> dotnet.System_Arr<Swift.UInt8> {
        var __thrown : NullableHandle = nil;
        let __return = System_Security_Cryptography_RSACryptoServiceProvider_u8Array__Decrypt_0__2__u8Array_bool(&__thrown, self.get_handle(), rgb.get_handle(), Swift.Int32(fOAEP ? 1 : 0));
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return dotnet.System_Arr<Swift.UInt8>(hndl : __return);
        }
    }
    // System.Byte[] Decrypt(System.Byte[], System.Security.Cryptography.RSAEncryptionPadding)
// docid: M:System.Security.Cryptography.RSACryptoServiceProvider.Decrypt(System.Byte[],System.Security.Cryptography.RSAEncryptionPadding)
    /**
    Decrypts data that was previously encrypted with the  algorithm by using the specified padding.

    - Parameter data: The data to decrypt.
    - Parameter padding: The padding.
    - Returns: The decrypted data.

    */
    public override func Decrypt(data : dotnet.System_Arr<Swift.UInt8>, padding : dotnet.System.Security.Cryptography.RSAEncryptionPadding) throws -> dotnet.System_Arr<Swift.UInt8> {
        var __thrown : NullableHandle = nil;
        let __return = System_Security_Cryptography_RSACryptoServiceProvider_u8Array__Decrypt_0__2__u8Array_RSAEncryptionPadding(&__thrown, self.get_handle(), data.get_handle(), padding.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return dotnet.System_Arr<Swift.UInt8>(hndl : __return);
        }
    }
    // System.Byte[] DecryptValue(System.Byte[])
// docid: M:System.Security.Cryptography.RSACryptoServiceProvider.DecryptValue(System.Byte[])
    /**
    This method is not supported in the current version.

    - Parameter rgb: The data to be decrypted.
    - Returns: The decrypted data, which is the original plain text before encryption.

    */
    public override func DecryptValue(rgb : dotnet.System_Arr<Swift.UInt8>) throws -> dotnet.System_Arr<Swift.UInt8> {
        var __thrown : NullableHandle = nil;
        let __return = System_Security_Cryptography_RSACryptoServiceProvider_u8Array__DecryptValue_0__1__u8Array(&__thrown, self.get_handle(), rgb.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return dotnet.System_Arr<Swift.UInt8>(hndl : __return);
        }
    }
    // System.Byte[] Encrypt(System.Byte[], bool)
// docid: M:System.Security.Cryptography.RSACryptoServiceProvider.Encrypt(System.Byte[],System.Boolean)
    /**
    Encrypts data with the  algorithm.

    - Parameter rgb: The data to be encrypted.
    - Parameter fOAEP: 
         to perform direct  encryption using OAEP padding (only available on a computer running Windows XP or later); otherwise,  to use PKCS#1 v1.5 padding.
    - Returns: The encrypted data.

    */
    public func Encrypt(rgb : dotnet.System_Arr<Swift.UInt8>, fOAEP : Bool) throws -> dotnet.System_Arr<Swift.UInt8> {
        var __thrown : NullableHandle = nil;
        let __return = System_Security_Cryptography_RSACryptoServiceProvider_u8Array__Encrypt_0__2__u8Array_bool(&__thrown, self.get_handle(), rgb.get_handle(), Swift.Int32(fOAEP ? 1 : 0));
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return dotnet.System_Arr<Swift.UInt8>(hndl : __return);
        }
    }
    // System.Byte[] Encrypt(System.Byte[], System.Security.Cryptography.RSAEncryptionPadding)
// docid: M:System.Security.Cryptography.RSACryptoServiceProvider.Encrypt(System.Byte[],System.Security.Cryptography.RSAEncryptionPadding)
    /**
    Encrypts data with the  algorithm using the specified padding.

    - Parameter data: The data to encrypt.
    - Parameter padding: The padding.
    - Returns: The encrypted data.

    */
    public override func Encrypt(data : dotnet.System_Arr<Swift.UInt8>, padding : dotnet.System.Security.Cryptography.RSAEncryptionPadding) throws -> dotnet.System_Arr<Swift.UInt8> {
        var __thrown : NullableHandle = nil;
        let __return = System_Security_Cryptography_RSACryptoServiceProvider_u8Array__Encrypt_0__2__u8Array_RSAEncryptionPadding(&__thrown, self.get_handle(), data.get_handle(), padding.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return dotnet.System_Arr<Swift.UInt8>(hndl : __return);
        }
    }
    // System.Byte[] EncryptValue(System.Byte[])
// docid: M:System.Security.Cryptography.RSACryptoServiceProvider.EncryptValue(System.Byte[])
    /**
    This method is not supported in the current version.

    - Parameter rgb: The data to be encrypted.
    - Returns: The encrypted data.

    */
    public override func EncryptValue(rgb : dotnet.System_Arr<Swift.UInt8>) throws -> dotnet.System_Arr<Swift.UInt8> {
        var __thrown : NullableHandle = nil;
        let __return = System_Security_Cryptography_RSACryptoServiceProvider_u8Array__EncryptValue_0__1__u8Array(&__thrown, self.get_handle(), rgb.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return dotnet.System_Arr<Swift.UInt8>(hndl : __return);
        }
    }
    // System.Byte[] ExportCspBlob(bool)
// docid: M:System.Security.Cryptography.RSACryptoServiceProvider.ExportCspBlob(System.Boolean)
    /**
    Exports a blob containing the key information associated with an  object.

    - Parameter includePrivateParameters: 
         to include the private key; otherwise, .
    - Returns: A byte array containing the key information associated with an  object.

    */
    public func ExportCspBlob(includePrivateParameters : Bool) throws -> dotnet.System_Arr<Swift.UInt8> {
        var __thrown : NullableHandle = nil;
        let __return = System_Security_Cryptography_RSACryptoServiceProvider_u8Array__ExportCspBlob_0__1__bool(&__thrown, self.get_handle(), Swift.Int32(includePrivateParameters ? 1 : 0));
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return dotnet.System_Arr<Swift.UInt8>(hndl : __return);
        }
    }
    // System.Security.Cryptography.RSAParameters ExportParameters(bool)
// docid: M:System.Security.Cryptography.RSACryptoServiceProvider.ExportParameters(System.Boolean)
    /**
    Exports the .

    - Parameter includePrivateParameters: 
         to include private parameters; otherwise, .
    - Returns: The parameters for .

    */
    public override func ExportParameters(includePrivateParameters : Bool) throws -> dotnet.System.Security.Cryptography.RSAParameters {
        var __thrown : NullableHandle = nil;
        let __return = System_Security_Cryptography_RSACryptoServiceProvider_RSAParameters__ExportParameters_0__1__bool(&__thrown, self.get_handle(), Swift.Int32(includePrivateParameters ? 1 : 0));
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return dotnet.System.Security.Cryptography.RSAParameters(hndl : __return);
        }
    }
    // void ImportCspBlob(System.Byte[])
// docid: M:System.Security.Cryptography.RSACryptoServiceProvider.ImportCspBlob(System.Byte[])
    /**
    Imports a blob that represents RSA key information.

    - Parameter keyBlob: A byte array that represents an RSA key blob.
    */
    public func ImportCspBlob(keyBlob : dotnet.System_Arr<Swift.UInt8>) throws {
        var __thrown : NullableHandle = nil;
        System_Security_Cryptography_RSACryptoServiceProvider_void__ImportCspBlob_0__1__u8Array(&__thrown, self.get_handle(), keyBlob.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
            return;
        }
    }
    // void ImportParameters(System.Security.Cryptography.RSAParameters)
// docid: M:System.Security.Cryptography.RSACryptoServiceProvider.ImportParameters(System.Security.Cryptography.RSAParameters)
    /**
    Imports the specified .

    - Parameter parameters: The parameters for .
    */
    public override func ImportParameters(parameters : dotnet.System.Security.Cryptography.RSAParameters) throws {
        var __thrown : NullableHandle = nil;
        System_Security_Cryptography_RSACryptoServiceProvider_void__ImportParameters_0__1__RSAParameters(&__thrown, self.get_handle(), parameters.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
            return;
        }
    }
    // System.Byte[] SignData(System.Byte[], System.Int32, System.Int32, System.Object)
// docid: M:System.Security.Cryptography.RSACryptoServiceProvider.SignData(System.Byte[],System.Int32,System.Int32,System.Object)
    /**
    Computes the hash value of a subset of the specified byte array using the specified hash algorithm, and signs the resulting hash value.

    - Parameter buffer: The input data to hash and sign.
    - Parameter offset: The offset into the array from which to begin using data.
    - Parameter count: The number of bytes in the array to use as data.
    - Parameter halg: The hash algorithm to use to create the hash value.
    - Returns: The  signature for the specified data.

    */
    public func SignData(buffer : dotnet.System_Arr<Swift.UInt8>, offset : Swift.Int32, count : Swift.Int32, halg : dotnet.System.Object) throws -> dotnet.System_Arr<Swift.UInt8> {
        var __thrown : NullableHandle = nil;
        let __return = System_Security_Cryptography_RSACryptoServiceProvider_u8Array__SignData_0__4__u8Array_i32_i32_Object(&__thrown, self.get_handle(), buffer.get_handle(), offset, count, halg.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return dotnet.System_Arr<Swift.UInt8>(hndl : __return);
        }
    }
    // System.Byte[] SignData(System.Byte[], System.Object)
// docid: M:System.Security.Cryptography.RSACryptoServiceProvider.SignData(System.Byte[],System.Object)
    /**
    Computes the hash value of the specified byte array using the specified hash algorithm, and signs the resulting hash value.

    - Parameter buffer: The input data to hash and sign.
    - Parameter halg: The hash algorithm to use to create the hash value.
    - Returns: The  signature for the specified data.

    */
    public func SignData(buffer : dotnet.System_Arr<Swift.UInt8>, halg : dotnet.System.Object) throws -> dotnet.System_Arr<Swift.UInt8> {
        var __thrown : NullableHandle = nil;
        let __return = System_Security_Cryptography_RSACryptoServiceProvider_u8Array__SignData_0__2__u8Array_Object(&__thrown, self.get_handle(), buffer.get_handle(), halg.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return dotnet.System_Arr<Swift.UInt8>(hndl : __return);
        }
    }
    // System.Byte[] SignData(System.IO.Stream, System.Object)
// docid: M:System.Security.Cryptography.RSACryptoServiceProvider.SignData(System.IO.Stream,System.Object)
    /**
    Computes the hash value of the specified input stream using the specified hash algorithm, and signs the resulting hash value.

    - Parameter inputStream: The input stream to hash and sign.
    - Parameter halg: The hash algorithm to use to create the hash value.
    - Returns: The  signature for the specified data.

    */
    public func SignData(inputStream : dotnet.System.IO.Stream, halg : dotnet.System.Object) throws -> dotnet.System_Arr<Swift.UInt8> {
        var __thrown : NullableHandle = nil;
        let __return = System_Security_Cryptography_RSACryptoServiceProvider_u8Array__SignData_0__2__Stream_Object(&__thrown, self.get_handle(), inputStream.get_handle(), halg.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return dotnet.System_Arr<Swift.UInt8>(hndl : __return);
        }
    }
    // System.Byte[] SignHash(System.Byte[], System.Security.Cryptography.HashAlgorithmName, System.Security.Cryptography.RSASignaturePadding)
// docid: M:System.Security.Cryptography.RSACryptoServiceProvider.SignHash(System.Byte[],System.Security.Cryptography.HashAlgorithmName,System.Security.Cryptography.RSASignaturePadding)
    /**
    Computes the signature for the specified hash value using the specified padding.

    - Parameter hash: The hash value of the data to be signed.
    - Parameter hashAlgorithm: The hash algorithm name used to create the hash value of the data.
    - Parameter padding: The padding.
    - Returns: The  signature for the specified hash value.

    */
    public override func SignHash(hash : dotnet.System_Arr<Swift.UInt8>, hashAlgorithm : dotnet.System.Security.Cryptography.HashAlgorithmName, padding : dotnet.System.Security.Cryptography.RSASignaturePadding) throws -> dotnet.System_Arr<Swift.UInt8> {
        var __thrown : NullableHandle = nil;
        let __return = System_Security_Cryptography_RSACryptoServiceProvider_u8Array__SignHash_0__3__u8Array_HashAlgorithmName_RSASignaturePadding(&__thrown, self.get_handle(), hash.get_handle(), hashAlgorithm.get_handle(), padding.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return dotnet.System_Arr<Swift.UInt8>(hndl : __return);
        }
    }
    // System.Byte[] SignHash(System.Byte[], System.String)
// docid: M:System.Security.Cryptography.RSACryptoServiceProvider.SignHash(System.Byte[],System.String)
    /**
    Computes the signature for the specified hash value.

    - Parameter rgbHash: The hash value of the data to be signed.
    - Parameter str: The hash algorithm identifier (OID) used to create the hash value of the data.
    - Returns: The  signature for the specified hash value.

    */
    public func SignHash(rgbHash : dotnet.System_Arr<Swift.UInt8>, str : Optional<dotnet.System.String>) throws -> dotnet.System_Arr<Swift.UInt8> {
        var __thrown : NullableHandle = nil;
        let __return = System_Security_Cryptography_RSACryptoServiceProvider_u8Array__SignHash_0__2__u8Array_String(&__thrown, self.get_handle(), rgbHash.get_handle(), str?.get_handle() ?? nil);
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return dotnet.System_Arr<Swift.UInt8>(hndl : __return);
        }
    }
    // bool VerifyData(System.Byte[], System.Object, System.Byte[])
// docid: M:System.Security.Cryptography.RSACryptoServiceProvider.VerifyData(System.Byte[],System.Object,System.Byte[])
    /**
    Verifies that a digital signature is valid by determining the hash value in the signature using the provided public key and comparing it to the hash value of the provided data.

    - Parameter buffer: The data that was signed.
    - Parameter halg: The name of the hash algorithm used to create the hash value of the data.
    - Parameter signature: The signature data to be verified.
    - Returns: 
         if the signature is valid; otherwise, .

    */
    public func VerifyData(buffer : dotnet.System_Arr<Swift.UInt8>, halg : dotnet.System.Object, signature : dotnet.System_Arr<Swift.UInt8>) throws -> Bool {
        var __thrown : NullableHandle = nil;
        let __return = System_Security_Cryptography_RSACryptoServiceProvider_bool__VerifyData_0__3__u8Array_Object_u8Array(&__thrown, self.get_handle(), buffer.get_handle(), halg.get_handle(), signature.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return (__return) != 0;
        }
    }
    // bool VerifyHash(System.Byte[], System.Byte[], System.Security.Cryptography.HashAlgorithmName, System.Security.Cryptography.RSASignaturePadding)
// docid: M:System.Security.Cryptography.RSACryptoServiceProvider.VerifyHash(System.Byte[],System.Byte[],System.Security.Cryptography.HashAlgorithmName,System.Security.Cryptography.RSASignaturePadding)
    /**
    Verifies that a digital signature is valid by determining the hash value in the signature using the specified hashing algorithm and padding, and comparing it to the provided hash value.

    - Parameter hash: The hash value of the signed data.
    - Parameter signature: The signature data to be verified.
    - Parameter hashAlgorithm: The hash algorithm name used to create the hash value.
    - Parameter padding: The padding.
    - Returns: 
         if the signature is valid; otherwise, .

    */
    public override func VerifyHash(hash : dotnet.System_Arr<Swift.UInt8>, signature : dotnet.System_Arr<Swift.UInt8>, hashAlgorithm : dotnet.System.Security.Cryptography.HashAlgorithmName, padding : dotnet.System.Security.Cryptography.RSASignaturePadding) throws -> Bool {
        var __thrown : NullableHandle = nil;
        let __return = System_Security_Cryptography_RSACryptoServiceProvider_bool__VerifyHash_0__4__u8Array_u8Array_HashAlgorithmName_RSASignaturePadding(&__thrown, self.get_handle(), hash.get_handle(), signature.get_handle(), hashAlgorithm.get_handle(), padding.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return (__return) != 0;
        }
    }
    // bool VerifyHash(System.Byte[], System.String, System.Byte[])
// docid: M:System.Security.Cryptography.RSACryptoServiceProvider.VerifyHash(System.Byte[],System.String,System.Byte[])
    /**
    Verifies that a digital signature is valid by determining the hash value in the signature using the provided public key and comparing it to the provided hash value.

    - Parameter rgbHash: The hash value of the signed data.
    - Parameter str: The hash algorithm identifier (OID) used to create the hash value of the data.
    - Parameter rgbSignature: The signature data to be verified.
    - Returns: 
         if the signature is valid; otherwise, .

    */
    public func VerifyHash(rgbHash : dotnet.System_Arr<Swift.UInt8>, str : dotnet.System.String, rgbSignature : dotnet.System_Arr<Swift.UInt8>) throws -> Bool {
        var __thrown : NullableHandle = nil;
        let __return = System_Security_Cryptography_RSACryptoServiceProvider_bool__VerifyHash_0__3__u8Array_String_u8Array(&__thrown, self.get_handle(), rgbHash.get_handle(), str.get_handle(), rgbSignature.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return (__return) != 0;
        }
    }
    // [IsSpecialName] System.Security.Cryptography.CspKeyContainerInfo get_CspKeyContainerInfo()
// docid: M:System.Security.Cryptography.RSACryptoServiceProvider.get_CspKeyContainerInfo
    public func get_CspKeyContainerInfo() throws -> dotnet.System.Security.Cryptography.CspKeyContainerInfo {
        var __thrown : NullableHandle = nil;
        let __return = System_Security_Cryptography_RSACryptoServiceProvider_CspKeyContainerInfo__get_CspKeyContainerInfo_0__0(&__thrown, self.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return dotnet.System.Security.Cryptography.CspKeyContainerInfo(hndl : __return);
        }
    }
    // [IsSpecialName] System.String get_KeyExchangeAlgorithm()
// docid: M:System.Security.Cryptography.RSACryptoServiceProvider.get_KeyExchangeAlgorithm
    public override func get_KeyExchangeAlgorithm() throws -> Optional<dotnet.System.String> {
        var __thrown : NullableHandle = nil;
        let __return = System_Security_Cryptography_RSACryptoServiceProvider_String__get_KeyExchangeAlgorithm_0__0(&__thrown, self.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        if let __ret_unwrapped = __return {
            return dotnet.System.String(hndl : __ret_unwrapped);
        } else {
            return nil;
        }
        }
    }
    // [IsSpecialName] System.Int32 get_KeySize()
// docid: M:System.Security.Cryptography.RSACryptoServiceProvider.get_KeySize
    public override func get_KeySize() throws -> Swift.Int32 {
        var __thrown : NullableHandle = nil;
        let __return = System_Security_Cryptography_RSACryptoServiceProvider_i32__get_KeySize_0__0(&__thrown, self.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return __return;
        }
    }
    // [IsSpecialName] System.Security.Cryptography.KeySizes[] get_LegalKeySizes()
// docid: M:System.Security.Cryptography.RSACryptoServiceProvider.get_LegalKeySizes
    public override func get_LegalKeySizes() throws -> dotnet.System_Arr<dotnet.System.Security.Cryptography.KeySizes> {
        var __thrown : NullableHandle = nil;
        let __return = System_Security_Cryptography_RSACryptoServiceProvider_KeySizesArray__get_LegalKeySizes_0__0(&__thrown, self.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return dotnet.System_Arr<dotnet.System.Security.Cryptography.KeySizes>(hndl : __return);
        }
    }
    // [IsSpecialName] bool get_PersistKeyInCsp()
// docid: M:System.Security.Cryptography.RSACryptoServiceProvider.get_PersistKeyInCsp
    public func get_PersistKeyInCsp() throws -> Bool {
        var __thrown : NullableHandle = nil;
        let __return = System_Security_Cryptography_RSACryptoServiceProvider_bool__get_PersistKeyInCsp_0__0(&__thrown, self.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return (__return) != 0;
        }
    }
    // [IsSpecialName] void set_PersistKeyInCsp(bool)
// docid: M:System.Security.Cryptography.RSACryptoServiceProvider.set_PersistKeyInCsp(System.Boolean)
    public func set_PersistKeyInCsp(value : Bool) throws {
        var __thrown : NullableHandle = nil;
        System_Security_Cryptography_RSACryptoServiceProvider_void__set_PersistKeyInCsp_0__1__bool(&__thrown, self.get_handle(), Swift.Int32(value ? 1 : 0));
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
            return;
        }
    }
    // [IsSpecialName] bool get_PublicOnly()
// docid: M:System.Security.Cryptography.RSACryptoServiceProvider.get_PublicOnly
    public func get_PublicOnly() throws -> Bool {
        var __thrown : NullableHandle = nil;
        let __return = System_Security_Cryptography_RSACryptoServiceProvider_bool__get_PublicOnly_0__0(&__thrown, self.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return (__return) != 0;
        }
    }
    // [IsSpecialName] System.String get_SignatureAlgorithm()
// docid: M:System.Security.Cryptography.RSACryptoServiceProvider.get_SignatureAlgorithm
    public override func get_SignatureAlgorithm() throws -> dotnet.System.String {
        var __thrown : NullableHandle = nil;
        let __return = System_Security_Cryptography_RSACryptoServiceProvider_String__get_SignatureAlgorithm_0__0(&__thrown, self.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return dotnet.System.String(hndl : __return);
        }
    }
    // [IsSpecialName] bool get_UseMachineKeyStore()
// docid: M:System.Security.Cryptography.RSACryptoServiceProvider.get_UseMachineKeyStore
    public class func get_UseMachineKeyStore() throws -> Bool {
        var __thrown : NullableHandle = nil;
        let __return = System_Security_Cryptography_RSACryptoServiceProvider_bool__get_UseMachineKeyStore_0__0(&__thrown);
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return (__return) != 0;
        }
    }
    // [IsSpecialName] void set_UseMachineKeyStore(bool)
// docid: M:System.Security.Cryptography.RSACryptoServiceProvider.set_UseMachineKeyStore(System.Boolean)
    public class func set_UseMachineKeyStore(value : Bool) throws {
        var __thrown : NullableHandle = nil;
        System_Security_Cryptography_RSACryptoServiceProvider_void__set_UseMachineKeyStore_0__1__bool(&__thrown, Swift.Int32(value ? 1 : 0));
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
            return;
        }
    }
    /**
    Gets a  object that describes additional information about a cryptographic key pair.

    */
    public var CspKeyContainerInfo : dotnet.System.Security.Cryptography.CspKeyContainerInfo {
        get {
            return try! get_CspKeyContainerInfo();
        }
    }
    /**
    Gets the name of the key exchange algorithm available with this implementation of .

    */
    public override var KeyExchangeAlgorithm : Optional<dotnet.System.String> {
        get {
            return try! get_KeyExchangeAlgorithm();
        }
    }
// TODO COPE (is_override_mutable_with_readonly ) [IsSpecialName] System.Int32 get_KeySize()
    /**
    Gets the key sizes that are supported by the asymmetric algorithm.

    */
    public override var LegalKeySizes : dotnet.System_Arr<dotnet.System.Security.Cryptography.KeySizes> {
        get {
            return try! get_LegalKeySizes();
        }
    }
    /**
    Gets or sets a value indicating whether the key should be persisted in the cryptographic service provider (CSP).

    */
    public var PersistKeyInCsp : Bool {
        get {
            return try! get_PersistKeyInCsp();
        }
        set(v) {
            return try! set_PersistKeyInCsp(value: v);
        }
    }
    /**
    Gets a value that indicates whether the  object contains only a public key.

    */
    public var PublicOnly : Bool {
        get {
            return try! get_PublicOnly();
        }
    }
    /**
    Gets the name of the signature algorithm available with this implementation of .

    */
    public override var SignatureAlgorithm : dotnet.System.String {
        get {
            return try! get_SignatureAlgorithm();
        }
    }
    /**
    Gets or sets a value indicating whether the key should be persisted in the computer's key store instead of the user profile store.

    */
    public static var UseMachineKeyStore : Bool {
        get {
            return try! get_UseMachineKeyStore();
        }
        set(v) {
            return try! set_UseMachineKeyStore(value: v);
        }
    }
} // RSACryptoServiceProvider


// type: System.Security.Cryptography.SHA1CryptoServiceProvider
    /**
    Computes the  hash value for the input data using the implementation provided by the cryptographic service provider (CSP). This class cannot be inherited.

    */
public final class SHA1CryptoServiceProvider
    :
    dotnet.System.Security.Cryptography.SHA1
{
    public class override func get_type_handle() -> TypeHandle {
        return System_Security_Cryptography_SHA1CryptoServiceProvider_get_type_handle();
    }
    public required init(hndl: NonnullHandle) { super.init(hndl: hndl); }
    public required init(gval: GVal) { super.init(gval: gval); }
    // .ctor()
// docid: M:System.Security.Cryptography.SHA1CryptoServiceProvider.#ctor
    /**
    Initializes a new instance of the  class.

    */
    public init() throws {
        var __thrown : NullableHandle = nil;
        let h = System_Security_Cryptography_SHA1CryptoServiceProvider_ctor_0__0(&__thrown);
        if let __ex = __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
            super.init(hndl: h);
        }
    }
    // void Initialize()
// docid: M:System.Security.Cryptography.SHA1CryptoServiceProvider.Initialize
    /**
    Initializes an instance of .

    */
    public override func Initialize() throws {
        var __thrown : NullableHandle = nil;
        System_Security_Cryptography_SHA1CryptoServiceProvider_void__Initialize_0__0(&__thrown, self.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
            return;
        }
    }
} // SHA1CryptoServiceProvider


// type: System.Security.Cryptography.SHA256CryptoServiceProvider
    /**
    Defines a wrapper object to access the cryptographic service provider (CSP) implementation of the  algorithm.

    */
public final class SHA256CryptoServiceProvider
    :
    dotnet.System.Security.Cryptography.SHA256
{
    public class override func get_type_handle() -> TypeHandle {
        return System_Security_Cryptography_SHA256CryptoServiceProvider_get_type_handle();
    }
    public required init(hndl: NonnullHandle) { super.init(hndl: hndl); }
    public required init(gval: GVal) { super.init(gval: gval); }
    // .ctor()
// docid: M:System.Security.Cryptography.SHA256CryptoServiceProvider.#ctor
    /**
    Initializes a new instance of the  class.

    */
    public init() throws {
        var __thrown : NullableHandle = nil;
        let h = System_Security_Cryptography_SHA256CryptoServiceProvider_ctor_0__0(&__thrown);
        if let __ex = __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
            super.init(hndl: h);
        }
    }
    // void Initialize()
// docid: M:System.Security.Cryptography.SHA256CryptoServiceProvider.Initialize
    /**
    Initializes, or reinitializes, an instance of a hash algorithm.

    */
    public override func Initialize() throws {
        var __thrown : NullableHandle = nil;
        System_Security_Cryptography_SHA256CryptoServiceProvider_void__Initialize_0__0(&__thrown, self.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
            return;
        }
    }
} // SHA256CryptoServiceProvider


// type: System.Security.Cryptography.SHA384CryptoServiceProvider
    /**
    Defines a wrapper object to access the cryptographic service provider (CSP) implementation of the  algorithm.

    */
public final class SHA384CryptoServiceProvider
    :
    dotnet.System.Security.Cryptography.SHA384
{
    public class override func get_type_handle() -> TypeHandle {
        return System_Security_Cryptography_SHA384CryptoServiceProvider_get_type_handle();
    }
    public required init(hndl: NonnullHandle) { super.init(hndl: hndl); }
    public required init(gval: GVal) { super.init(gval: gval); }
    // .ctor()
// docid: M:System.Security.Cryptography.SHA384CryptoServiceProvider.#ctor
    /**
    Initializes a new instance of the  class.

    */
    public init() throws {
        var __thrown : NullableHandle = nil;
        let h = System_Security_Cryptography_SHA384CryptoServiceProvider_ctor_0__0(&__thrown);
        if let __ex = __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
            super.init(hndl: h);
        }
    }
    // void Initialize()
// docid: M:System.Security.Cryptography.SHA384CryptoServiceProvider.Initialize
    /**
    Initializes, or reinitializes, an instance of a hash algorithm.

    */
    public override func Initialize() throws {
        var __thrown : NullableHandle = nil;
        System_Security_Cryptography_SHA384CryptoServiceProvider_void__Initialize_0__0(&__thrown, self.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
            return;
        }
    }
} // SHA384CryptoServiceProvider


// type: System.Security.Cryptography.SHA512CryptoServiceProvider
    /**
    Defines a wrapper object to access the cryptographic service provider (CSP) implementation of the  algorithm.

    */
public final class SHA512CryptoServiceProvider
    :
    dotnet.System.Security.Cryptography.SHA512
{
    public class override func get_type_handle() -> TypeHandle {
        return System_Security_Cryptography_SHA512CryptoServiceProvider_get_type_handle();
    }
    public required init(hndl: NonnullHandle) { super.init(hndl: hndl); }
    public required init(gval: GVal) { super.init(gval: gval); }
    // .ctor()
// docid: M:System.Security.Cryptography.SHA512CryptoServiceProvider.#ctor
    /**
    Initializes a new instance of the  class.

    */
    public init() throws {
        var __thrown : NullableHandle = nil;
        let h = System_Security_Cryptography_SHA512CryptoServiceProvider_ctor_0__0(&__thrown);
        if let __ex = __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
            super.init(hndl: h);
        }
    }
    // void Initialize()
// docid: M:System.Security.Cryptography.SHA512CryptoServiceProvider.Initialize
    /**
    Initializes, or reinitializes, an instance of a hash algorithm.

    */
    public override func Initialize() throws {
        var __thrown : NullableHandle = nil;
        System_Security_Cryptography_SHA512CryptoServiceProvider_void__Initialize_0__0(&__thrown, self.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
            return;
        }
    }
} // SHA512CryptoServiceProvider


// type: System.Security.Cryptography.TripleDESCryptoServiceProvider
    /**
    Defines a wrapper object to access the cryptographic service provider (CSP) version of the  algorithm. This class cannot be inherited.

    */
public final class TripleDESCryptoServiceProvider
    :
    dotnet.System.Security.Cryptography.TripleDES
{
    public class override func get_type_handle() -> TypeHandle {
        return System_Security_Cryptography_TripleDESCryptoServiceProvider_get_type_handle();
    }
    public required init(hndl: NonnullHandle) { super.init(hndl: hndl); }
    public required init(gval: GVal) { super.init(gval: gval); }
    // .ctor()
// docid: M:System.Security.Cryptography.TripleDESCryptoServiceProvider.#ctor
    /**
    Initializes a new instance of the  class.

    */
    public init() throws {
        var __thrown : NullableHandle = nil;
        let h = System_Security_Cryptography_TripleDESCryptoServiceProvider_ctor_0__0(&__thrown);
        if let __ex = __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
            super.init(hndl: h);
        }
    }
    // System.Security.Cryptography.ICryptoTransform CreateDecryptor()
// docid: M:System.Security.Cryptography.TripleDESCryptoServiceProvider.CreateDecryptor
    /**
    Creates a symmetric decryptor object with the current  property and initialization vector ().

    - Returns: A symmetric decryptor object.

    */
    public override func CreateDecryptor() throws -> dotnet.System.Security.Cryptography.ICryptoTransform {
        var __thrown : NullableHandle = nil;
        let __return = System_Security_Cryptography_TripleDESCryptoServiceProvider_ICryptoTransform__CreateDecryptor_0__0(&__thrown, self.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return dotnet.System.Security.Cryptography.ICryptoTransform(hndl : __return);
        }
    }
    // System.Security.Cryptography.ICryptoTransform CreateDecryptor(System.Byte[], System.Byte[])
// docid: M:System.Security.Cryptography.TripleDESCryptoServiceProvider.CreateDecryptor(System.Byte[],System.Byte[])
    /**
    Creates a symmetric  decryptor object with the specified key () and initialization vector ().

    - Parameter rgbKey: The secret key to use for the symmetric algorithm.
    - Parameter rgbIV: The initialization vector to use for the symmetric algorithm.
    - Returns: A symmetric  decryptor object.

    */
    public override func CreateDecryptor(rgbKey : dotnet.System_Arr<Swift.UInt8>, rgbIV : Optional<dotnet.System_Arr<Swift.UInt8>>) throws -> dotnet.System.Security.Cryptography.ICryptoTransform {
        var __thrown : NullableHandle = nil;
        let __return = System_Security_Cryptography_TripleDESCryptoServiceProvider_ICryptoTransform__CreateDecryptor_0__2__u8Array_u8Array(&__thrown, self.get_handle(), rgbKey.get_handle(), (rgbIV?.get_handle()));
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return dotnet.System.Security.Cryptography.ICryptoTransform(hndl : __return);
        }
    }
    // System.Security.Cryptography.ICryptoTransform CreateEncryptor()
// docid: M:System.Security.Cryptography.TripleDESCryptoServiceProvider.CreateEncryptor
    /**
    Creates a symmetric encryptor object with the current  property and initialization vector ().

    - Returns: A symmetric encryptor object.

    */
    public override func CreateEncryptor() throws -> dotnet.System.Security.Cryptography.ICryptoTransform {
        var __thrown : NullableHandle = nil;
        let __return = System_Security_Cryptography_TripleDESCryptoServiceProvider_ICryptoTransform__CreateEncryptor_0__0(&__thrown, self.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return dotnet.System.Security.Cryptography.ICryptoTransform(hndl : __return);
        }
    }
    // System.Security.Cryptography.ICryptoTransform CreateEncryptor(System.Byte[], System.Byte[])
// docid: M:System.Security.Cryptography.TripleDESCryptoServiceProvider.CreateEncryptor(System.Byte[],System.Byte[])
    /**
    Creates a symmetric  encryptor object with the specified key () and initialization vector ().

    - Parameter rgbKey: The secret key to use for the symmetric algorithm.
    - Parameter rgbIV: The initialization vector to use for the symmetric algorithm.  
  
 Note: The initialization vector must be 8 bytes long. If it is longer than 8 bytes, it is truncated and an exception is not thrown. Before you call , check the length of the initialization vector and throw an exception if it is too long.
    - Returns: A symmetric  encryptor object.

    */
    public override func CreateEncryptor(rgbKey : dotnet.System_Arr<Swift.UInt8>, rgbIV : Optional<dotnet.System_Arr<Swift.UInt8>>) throws -> dotnet.System.Security.Cryptography.ICryptoTransform {
        var __thrown : NullableHandle = nil;
        let __return = System_Security_Cryptography_TripleDESCryptoServiceProvider_ICryptoTransform__CreateEncryptor_0__2__u8Array_u8Array(&__thrown, self.get_handle(), rgbKey.get_handle(), (rgbIV?.get_handle()));
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return dotnet.System.Security.Cryptography.ICryptoTransform(hndl : __return);
        }
    }
    // void GenerateIV()
// docid: M:System.Security.Cryptography.TripleDESCryptoServiceProvider.GenerateIV
    /**
    Generates a random initialization vector () to use for the algorithm.

    */
    public override func GenerateIV() throws {
        var __thrown : NullableHandle = nil;
        System_Security_Cryptography_TripleDESCryptoServiceProvider_void__GenerateIV_0__0(&__thrown, self.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
            return;
        }
    }
    // void GenerateKey()
// docid: M:System.Security.Cryptography.TripleDESCryptoServiceProvider.GenerateKey
    /**
    Generates a random  to be used for the algorithm.

    */
    public override func GenerateKey() throws {
        var __thrown : NullableHandle = nil;
        System_Security_Cryptography_TripleDESCryptoServiceProvider_void__GenerateKey_0__0(&__thrown, self.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
            return;
        }
    }
    // [IsSpecialName] System.Int32 get_BlockSize()
// docid: M:System.Security.Cryptography.TripleDESCryptoServiceProvider.get_BlockSize
    public override func get_BlockSize() throws -> Swift.Int32 {
        var __thrown : NullableHandle = nil;
        let __return = System_Security_Cryptography_TripleDESCryptoServiceProvider_i32__get_BlockSize_0__0(&__thrown, self.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return __return;
        }
    }
    // [IsSpecialName] void set_BlockSize(System.Int32)
// docid: M:System.Security.Cryptography.TripleDESCryptoServiceProvider.set_BlockSize(System.Int32)
    public override func set_BlockSize(value : Swift.Int32) throws {
        var __thrown : NullableHandle = nil;
        System_Security_Cryptography_TripleDESCryptoServiceProvider_void__set_BlockSize_0__1__i32(&__thrown, self.get_handle(), value);
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
            return;
        }
    }
    // [IsSpecialName] System.Int32 get_FeedbackSize()
// docid: M:System.Security.Cryptography.TripleDESCryptoServiceProvider.get_FeedbackSize
    public override func get_FeedbackSize() throws -> Swift.Int32 {
        var __thrown : NullableHandle = nil;
        let __return = System_Security_Cryptography_TripleDESCryptoServiceProvider_i32__get_FeedbackSize_0__0(&__thrown, self.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return __return;
        }
    }
    // [IsSpecialName] void set_FeedbackSize(System.Int32)
// docid: M:System.Security.Cryptography.TripleDESCryptoServiceProvider.set_FeedbackSize(System.Int32)
    public override func set_FeedbackSize(value : Swift.Int32) throws {
        var __thrown : NullableHandle = nil;
        System_Security_Cryptography_TripleDESCryptoServiceProvider_void__set_FeedbackSize_0__1__i32(&__thrown, self.get_handle(), value);
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
            return;
        }
    }
    // [IsSpecialName] System.Byte[] get_IV()
// docid: M:System.Security.Cryptography.TripleDESCryptoServiceProvider.get_IV
    public override func get_IV() throws -> dotnet.System_Arr<Swift.UInt8> {
        var __thrown : NullableHandle = nil;
        let __return = System_Security_Cryptography_TripleDESCryptoServiceProvider_u8Array__get_IV_0__0(&__thrown, self.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return dotnet.System_Arr<Swift.UInt8>(hndl : __return);
        }
    }
    // [IsSpecialName] void set_IV(System.Byte[])
// docid: M:System.Security.Cryptography.TripleDESCryptoServiceProvider.set_IV(System.Byte[])
    public override func set_IV(value : dotnet.System_Arr<Swift.UInt8>) throws {
        var __thrown : NullableHandle = nil;
        System_Security_Cryptography_TripleDESCryptoServiceProvider_void__set_IV_0__1__u8Array(&__thrown, self.get_handle(), value.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
            return;
        }
    }
    // [IsSpecialName] System.Byte[] get_Key()
// docid: M:System.Security.Cryptography.TripleDESCryptoServiceProvider.get_Key
    public override func get_Key() throws -> dotnet.System_Arr<Swift.UInt8> {
        var __thrown : NullableHandle = nil;
        let __return = System_Security_Cryptography_TripleDESCryptoServiceProvider_u8Array__get_Key_0__0(&__thrown, self.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return dotnet.System_Arr<Swift.UInt8>(hndl : __return);
        }
    }
    // [IsSpecialName] void set_Key(System.Byte[])
// docid: M:System.Security.Cryptography.TripleDESCryptoServiceProvider.set_Key(System.Byte[])
    public override func set_Key(value : dotnet.System_Arr<Swift.UInt8>) throws {
        var __thrown : NullableHandle = nil;
        System_Security_Cryptography_TripleDESCryptoServiceProvider_void__set_Key_0__1__u8Array(&__thrown, self.get_handle(), value.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
            return;
        }
    }
    // [IsSpecialName] System.Int32 get_KeySize()
// docid: M:System.Security.Cryptography.TripleDESCryptoServiceProvider.get_KeySize
    public override func get_KeySize() throws -> Swift.Int32 {
        var __thrown : NullableHandle = nil;
        let __return = System_Security_Cryptography_TripleDESCryptoServiceProvider_i32__get_KeySize_0__0(&__thrown, self.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return __return;
        }
    }
    // [IsSpecialName] void set_KeySize(System.Int32)
// docid: M:System.Security.Cryptography.TripleDESCryptoServiceProvider.set_KeySize(System.Int32)
    public override func set_KeySize(value : Swift.Int32) throws {
        var __thrown : NullableHandle = nil;
        System_Security_Cryptography_TripleDESCryptoServiceProvider_void__set_KeySize_0__1__i32(&__thrown, self.get_handle(), value);
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
            return;
        }
    }
    // [IsSpecialName] System.Security.Cryptography.KeySizes[] get_LegalBlockSizes()
// docid: M:System.Security.Cryptography.TripleDESCryptoServiceProvider.get_LegalBlockSizes
    public override func get_LegalBlockSizes() throws -> dotnet.System_Arr<dotnet.System.Security.Cryptography.KeySizes> {
        var __thrown : NullableHandle = nil;
        let __return = System_Security_Cryptography_TripleDESCryptoServiceProvider_KeySizesArray__get_LegalBlockSizes_0__0(&__thrown, self.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return dotnet.System_Arr<dotnet.System.Security.Cryptography.KeySizes>(hndl : __return);
        }
    }
    // [IsSpecialName] System.Security.Cryptography.KeySizes[] get_LegalKeySizes()
// docid: M:System.Security.Cryptography.TripleDESCryptoServiceProvider.get_LegalKeySizes
    public override func get_LegalKeySizes() throws -> dotnet.System_Arr<dotnet.System.Security.Cryptography.KeySizes> {
        var __thrown : NullableHandle = nil;
        let __return = System_Security_Cryptography_TripleDESCryptoServiceProvider_KeySizesArray__get_LegalKeySizes_0__0(&__thrown, self.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return dotnet.System_Arr<dotnet.System.Security.Cryptography.KeySizes>(hndl : __return);
        }
    }
    // [IsSpecialName] System.Security.Cryptography.CipherMode get_Mode()
// docid: M:System.Security.Cryptography.TripleDESCryptoServiceProvider.get_Mode
    public override func get_Mode() throws -> dotnet.System.Security.Cryptography.CipherMode {
        var __thrown : NullableHandle = nil;
        let __return = System_Security_Cryptography_TripleDESCryptoServiceProvider_CipherMode__get_Mode_0__0(&__thrown, self.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return dotnet.System.Security.Cryptography.CipherMode(val: __return);
        }
    }
    // [IsSpecialName] void set_Mode(System.Security.Cryptography.CipherMode)
// docid: M:System.Security.Cryptography.TripleDESCryptoServiceProvider.set_Mode(System.Security.Cryptography.CipherMode)
    public override func set_Mode(value : dotnet.System.Security.Cryptography.CipherMode) throws {
        var __thrown : NullableHandle = nil;
        System_Security_Cryptography_TripleDESCryptoServiceProvider_void__set_Mode_0__1__CipherMode(&__thrown, self.get_handle(), value.get_value());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
            return;
        }
    }
    // [IsSpecialName] System.Security.Cryptography.PaddingMode get_Padding()
// docid: M:System.Security.Cryptography.TripleDESCryptoServiceProvider.get_Padding
    public override func get_Padding() throws -> dotnet.System.Security.Cryptography.PaddingMode {
        var __thrown : NullableHandle = nil;
        let __return = System_Security_Cryptography_TripleDESCryptoServiceProvider_PaddingMode__get_Padding_0__0(&__thrown, self.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return dotnet.System.Security.Cryptography.PaddingMode(val: __return);
        }
    }
    // [IsSpecialName] void set_Padding(System.Security.Cryptography.PaddingMode)
// docid: M:System.Security.Cryptography.TripleDESCryptoServiceProvider.set_Padding(System.Security.Cryptography.PaddingMode)
    public override func set_Padding(value : dotnet.System.Security.Cryptography.PaddingMode) throws {
        var __thrown : NullableHandle = nil;
        System_Security_Cryptography_TripleDESCryptoServiceProvider_void__set_Padding_0__1__PaddingMode(&__thrown, self.get_handle(), value.get_value());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
            return;
        }
    }
    /**
    Gets or sets the block size, in bits, of the cryptographic operation.

    */
    public override var BlockSize : Swift.Int32 {
        get {
            return try! get_BlockSize();
        }
        set(v) {
            return try! set_BlockSize(value: v);
        }
    }
    /**
    Gets or sets the feedback size, in bits, of the cryptographic operation for the Cipher Feedback (CFB) and Output Feedback (OFB) cipher modes.

    */
    public override var FeedbackSize : Swift.Int32 {
        get {
            return try! get_FeedbackSize();
        }
        set(v) {
            return try! set_FeedbackSize(value: v);
        }
    }
    /**
    Gets or sets the initialization vector () for the symmetric algorithm.

    */
    public override var IV : dotnet.System_Arr<Swift.UInt8> {
        get {
            return try! get_IV();
        }
        set(v) {
            return try! set_IV(value: v);
        }
    }
    /**
    Gets or sets the secret key for the  algorithm.

    */
    public override var Key : dotnet.System_Arr<Swift.UInt8> {
        get {
            return try! get_Key();
        }
        set(v) {
            return try! set_Key(value: v);
        }
    }
    /**
    Gets or sets the size, in bits, of the secret key.

    */
    public override var KeySize : Swift.Int32 {
        get {
            return try! get_KeySize();
        }
        set(v) {
            return try! set_KeySize(value: v);
        }
    }
    /**
    Gets the block sizes, in bits, that are supported by the symmetric algorithm.

    */
    public override var LegalBlockSizes : dotnet.System_Arr<dotnet.System.Security.Cryptography.KeySizes> {
        get {
            return try! get_LegalBlockSizes();
        }
    }
    /**
    Gets the key sizes, in bits, that are supported by the symmetric algorithm.

    */
    public override var LegalKeySizes : dotnet.System_Arr<dotnet.System.Security.Cryptography.KeySizes> {
        get {
            return try! get_LegalKeySizes();
        }
    }
    /**
    Gets or sets the mode for operation of the symmetric algorithm.

    */
    public override var Mode : dotnet.System.Security.Cryptography.CipherMode {
        get {
            return try! get_Mode();
        }
        set(v) {
            return try! set_Mode(value: v);
        }
    }
    /**
    Gets or sets the padding mode used in the symmetric algorithm.

    */
    public override var Padding : dotnet.System.Security.Cryptography.PaddingMode {
        get {
            return try! get_Padding();
        }
        set(v) {
            return try! set_Padding(value: v);
        }
    }
} // TripleDESCryptoServiceProvider


}



public protocol System_Security_Cryptography_ICspAsymmetricAlgorithm
    :
    SGBridgeGetHandle
{
}

