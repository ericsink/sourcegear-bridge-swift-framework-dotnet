// this file is automatically generated
// Copyright 2021 SourceGear

import jumptable_dotnet;

// System
// System.Diagnostics
extension System.Diagnostics {
// type: System.Diagnostics.StackFrame
    /**
    Provides information about a , which represents a function call on the call stack for the current thread.

    */
open class StackFrame
    :
    dotnet.System.Object
{
    open class override func get_type_handle() -> TypeHandle {
        return System_Diagnostics_StackFrame_get_type_handle();
    }
    public required init(hndl: NonnullHandle) { super.init(hndl: hndl); }
    public required init(gval: GVal) { super.init(gval: gval); }
    // static field: System.Int32 OFFSET_UNKNOWN
    /**
    Defines the value that is returned from the  or  method when the native or Microsoft intermediate language (MSIL) offset is unknown. This field is constant.

    */
    open class var OFFSET_UNKNOWN : Swift.Int32 {
        get {
        let __return = System_Diagnostics_StackFrame_get_OFFSET_UNKNOWN();
            return __return;
        }
    }
    // .ctor()
// docid: M:System.Diagnostics.StackFrame.#ctor
    /**
    Initializes a new instance of the  class.

    */
    public override init() throws {
        var __thrown : NullableHandle = nil;
        let h = System_Diagnostics_StackFrame_ctor_0__0(&__thrown);
        if let __ex = __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
            super.init(hndl: h);
        }
    }
    // .ctor(bool)
// docid: M:System.Diagnostics.StackFrame.#ctor(System.Boolean)
    /**
    Initializes a new instance of the  class, optionally capturing source information.

    - Parameter needFileInfo: 
    */
    public init(needFileInfo : Bool) throws {
        var __thrown : NullableHandle = nil;
        let h = System_Diagnostics_StackFrame_ctor_0__1__bool(&__thrown, Swift.Int32(needFileInfo ? 1 : 0));
        if let __ex = __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
            super.init(hndl: h);
        }
    }
    // .ctor(System.Int32)
// docid: M:System.Diagnostics.StackFrame.#ctor(System.Int32)
    /**
    Initializes a new instance of the  class that corresponds to a frame above the current stack frame.

    - Parameter skipFrames: The number of frames up the stack to skip.
    */
    public init(skipFrames : Swift.Int32) throws {
        var __thrown : NullableHandle = nil;
        let h = System_Diagnostics_StackFrame_ctor_0__1__i32(&__thrown, skipFrames);
        if let __ex = __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
            super.init(hndl: h);
        }
    }
    // .ctor(System.Int32, bool)
// docid: M:System.Diagnostics.StackFrame.#ctor(System.Int32,System.Boolean)
    /**
    Initializes a new instance of the  class that corresponds to a frame above the current stack frame, optionally capturing source information.

    - Parameter skipFrames: The number of frames up the stack to skip.
    - Parameter needFileInfo: 
    */
    public init(skipFrames : Swift.Int32, needFileInfo : Bool) throws {
        var __thrown : NullableHandle = nil;
        let h = System_Diagnostics_StackFrame_ctor_0__2__i32_bool(&__thrown, skipFrames, Swift.Int32(needFileInfo ? 1 : 0));
        if let __ex = __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
            super.init(hndl: h);
        }
    }
    // .ctor(System.String, System.Int32)
// docid: M:System.Diagnostics.StackFrame.#ctor(System.String,System.Int32)
    /**
    Initializes a new instance of the  class that contains only the given file name and line number.

    - Parameter fileName: The file name.
    - Parameter lineNumber: The line number in the specified file.
    */
    public init(fileName : Optional<dotnet.System.String>, lineNumber : Swift.Int32) throws {
        var __thrown : NullableHandle = nil;
        let h = System_Diagnostics_StackFrame_ctor_0__2__String_i32(&__thrown, fileName?.get_handle() ?? nil, lineNumber);
        if let __ex = __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
            super.init(hndl: h);
        }
    }
    // .ctor(System.String, System.Int32, System.Int32)
// docid: M:System.Diagnostics.StackFrame.#ctor(System.String,System.Int32,System.Int32)
    /**
    Initializes a new instance of the  class that contains only the given file name, line number, and column number.

    - Parameter fileName: The file name.
    - Parameter lineNumber: The line number in the specified file.
    - Parameter colNumber: The column number in the specified file.
    */
    public init(fileName : Optional<dotnet.System.String>, lineNumber : Swift.Int32, colNumber : Swift.Int32) throws {
        var __thrown : NullableHandle = nil;
        let h = System_Diagnostics_StackFrame_ctor_0__3__String_i32_i32(&__thrown, fileName?.get_handle() ?? nil, lineNumber, colNumber);
        if let __ex = __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
            super.init(hndl: h);
        }
    }
    // System.Int32 GetFileColumnNumber()
// docid: M:System.Diagnostics.StackFrame.GetFileColumnNumber
    /**
    Gets the column number in the file that contains the code that is executing. This information is typically extracted from the debugging symbols for the executable.

    - Returns: The file column number, or 0 (zero) if the file column number cannot be determined.

    */
    open func GetFileColumnNumber() throws -> Swift.Int32 {
        var __thrown : NullableHandle = nil;
        let __return = System_Diagnostics_StackFrame_i32__GetFileColumnNumber_0__0(&__thrown, self.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return __return;
        }
    }
    // System.Int32 GetFileLineNumber()
// docid: M:System.Diagnostics.StackFrame.GetFileLineNumber
    /**
    Gets the line number in the file that contains the code that is executing. This information is typically extracted from the debugging symbols for the executable.

    - Returns: The file line number, or 0 (zero) if the file line number cannot be determined.

    */
    open func GetFileLineNumber() throws -> Swift.Int32 {
        var __thrown : NullableHandle = nil;
        let __return = System_Diagnostics_StackFrame_i32__GetFileLineNumber_0__0(&__thrown, self.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return __return;
        }
    }
    // System.String GetFileName()
// docid: M:System.Diagnostics.StackFrame.GetFileName
    /**
    Gets the file name that contains the code that is executing. This information is typically extracted from the debugging symbols for the executable.

    - Returns: The file name, or  if the file name cannot be determined.

    */
    open func GetFileName() throws -> Optional<dotnet.System.String> {
        var __thrown : NullableHandle = nil;
        let __return = System_Diagnostics_StackFrame_String__GetFileName_0__0(&__thrown, self.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        if let __ret_unwrapped = __return {
            return dotnet.System.String(hndl : __ret_unwrapped);
        } else {
            return nil;
        }
        }
    }
    // System.Int32 GetILOffset()
// docid: M:System.Diagnostics.StackFrame.GetILOffset
    /**
    Gets the offset from the start of the Microsoft intermediate language (MSIL) code for the method that is executing. This offset might be an approximation depending on whether or not the just-in-time (JIT) compiler is generating debugging code. The generation of this debugging information is controlled by the .

    - Returns: The offset from the start of the MSIL code for the method that is executing.

    */
    open func GetILOffset() throws -> Swift.Int32 {
        var __thrown : NullableHandle = nil;
        let __return = System_Diagnostics_StackFrame_i32__GetILOffset_0__0(&__thrown, self.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return __return;
        }
    }
    // System.Reflection.MethodBase GetMethod()
// docid: M:System.Diagnostics.StackFrame.GetMethod
    /**
    Gets the method in which the frame is executing.

    - Returns: The method in which the frame is executing.

    */
    open func GetMethod() throws -> Optional<dotnet.System.Reflection.MethodBase> {
        var __thrown : NullableHandle = nil;
        let __return = System_Diagnostics_StackFrame_MethodBase__GetMethod_0__0(&__thrown, self.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        if let __ret_unwrapped = __return {
            return dotnet.System.Reflection.MethodBase(hndl : __ret_unwrapped);
        } else {
            return nil;
        }
        }
    }
    // System.Int32 GetNativeOffset()
// docid: M:System.Diagnostics.StackFrame.GetNativeOffset
    /**
    Gets the offset from the start of the native just-in-time (JIT)-compiled code for the method that is being executed. The generation of this debugging information is controlled by the  class.

    - Returns: The offset from the start of the JIT-compiled code for the method that is being executed.

    */
    open func GetNativeOffset() throws -> Swift.Int32 {
        var __thrown : NullableHandle = nil;
        let __return = System_Diagnostics_StackFrame_i32__GetNativeOffset_0__0(&__thrown, self.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return __return;
        }
    }
    // System.String ToString()
// docid: M:System.Diagnostics.StackFrame.ToString
    /**
    Builds a readable representation of the stack trace.

    - Returns: A readable representation of the stack trace.

    */
    open override func ToString() throws -> dotnet.System.String {
        var __thrown : NullableHandle = nil;
        let __return = System_Diagnostics_StackFrame_String__ToString_0__0(&__thrown, self.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return dotnet.System.String(hndl : __return);
        }
    }
} // StackFrame


// type: System.Diagnostics.StackFrameExtensions
public struct StackFrameExtensions {
    // System.IntPtr GetNativeImageBase(System.Diagnostics.StackFrame)
// docid: M:System.Diagnostics.StackFrameExtensions.GetNativeImageBase(System.Diagnostics.StackFrame)
    /**
    Returns a pointer to the base address of the native image that this stack frame is executing.

    - Parameter stackFrame: A stack frame.
    - Returns: A pointer to the base address of the native image or  if you're targeting the .NET Framework.

    */
    public static func GetNativeImageBase(stackFrame : dotnet.System.Diagnostics.StackFrame) throws -> dotnet.System.IntPtr {
        var __thrown : NullableHandle = nil;
        let __return = System_Diagnostics_StackFrameExtensions_IntPtr__GetNativeImageBase_0__1__StackFrame(&__thrown, stackFrame.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return dotnet.System.IntPtr(val: __return);
        }
    }
    // System.IntPtr GetNativeIP(System.Diagnostics.StackFrame)
// docid: M:System.Diagnostics.StackFrameExtensions.GetNativeIP(System.Diagnostics.StackFrame)
    /**
    Gets an interface pointer to the start of the native code for the method that is being executed.

    - Parameter stackFrame: A stack frame.
    - Returns: An interface pointer to the start of the native code for the method that is being executed or  if you're targeting the .NET Framework.

    */
    public static func GetNativeIP(stackFrame : dotnet.System.Diagnostics.StackFrame) throws -> dotnet.System.IntPtr {
        var __thrown : NullableHandle = nil;
        let __return = System_Diagnostics_StackFrameExtensions_IntPtr__GetNativeIP_0__1__StackFrame(&__thrown, stackFrame.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return dotnet.System.IntPtr(val: __return);
        }
    }
    // bool HasILOffset(System.Diagnostics.StackFrame)
// docid: M:System.Diagnostics.StackFrameExtensions.HasILOffset(System.Diagnostics.StackFrame)
    /**
    Indicates whether an offset from the start of the IL code for the method that is executing is available.

    - Parameter stackFrame: A stack frame.
    - Returns: 
         if the offset is available; otherwise, .

    */
    public static func HasILOffset(stackFrame : dotnet.System.Diagnostics.StackFrame) throws -> Bool {
        var __thrown : NullableHandle = nil;
        let __return = System_Diagnostics_StackFrameExtensions_bool__HasILOffset_0__1__StackFrame(&__thrown, stackFrame.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return (__return) != 0;
        }
    }
    // bool HasMethod(System.Diagnostics.StackFrame)
// docid: M:System.Diagnostics.StackFrameExtensions.HasMethod(System.Diagnostics.StackFrame)
    /**
    Indicates whether information about the method in which the specified frame is executing is available.

    - Parameter stackFrame: A stack frame.
    - Returns: 
         if information about the method in which the current frame is executing is available; otherwise, .

    */
    public static func HasMethod(stackFrame : dotnet.System.Diagnostics.StackFrame) throws -> Bool {
        var __thrown : NullableHandle = nil;
        let __return = System_Diagnostics_StackFrameExtensions_bool__HasMethod_0__1__StackFrame(&__thrown, stackFrame.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return (__return) != 0;
        }
    }
    // bool HasNativeImage(System.Diagnostics.StackFrame)
// docid: M:System.Diagnostics.StackFrameExtensions.HasNativeImage(System.Diagnostics.StackFrame)
    /**
    Indicates whether the native image is available for the specified stack frame.

    - Parameter stackFrame: A stack frame.
    - Returns: 
         if a native image is available for this stack frame; otherwise, .

    */
    public static func HasNativeImage(stackFrame : dotnet.System.Diagnostics.StackFrame) throws -> Bool {
        var __thrown : NullableHandle = nil;
        let __return = System_Diagnostics_StackFrameExtensions_bool__HasNativeImage_0__1__StackFrame(&__thrown, stackFrame.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return (__return) != 0;
        }
    }
    // bool HasSource(System.Diagnostics.StackFrame)
// docid: M:System.Diagnostics.StackFrameExtensions.HasSource(System.Diagnostics.StackFrame)
    /**
    Indicates whether the file that contains the code that the specified stack frame is executing is available.

    - Parameter stackFrame: A stack frame.
    - Returns: 
         if the code that the specified stack frame is executing is available; otherwise, .

    */
    public static func HasSource(stackFrame : dotnet.System.Diagnostics.StackFrame) throws -> Bool {
        var __thrown : NullableHandle = nil;
        let __return = System_Diagnostics_StackFrameExtensions_bool__HasSource_0__1__StackFrame(&__thrown, stackFrame.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return (__return) != 0;
        }
    }
} // StackFrameExtensions


// type: System.Diagnostics.StackTrace
    /**
    Represents a stack trace, which is an ordered collection of one or more stack frames.

    */
open class StackTrace
    :
    dotnet.System.Object
{
    open class override func get_type_handle() -> TypeHandle {
        return System_Diagnostics_StackTrace_get_type_handle();
    }
    public required init(hndl: NonnullHandle) { super.init(hndl: hndl); }
    public required init(gval: GVal) { super.init(gval: gval); }
    // static field: System.Int32 METHODS_TO_SKIP
    /**
    Defines the default for the number of methods to omit from the stack trace. This field is constant.

    */
    open class var METHODS_TO_SKIP : Swift.Int32 {
        get {
        let __return = System_Diagnostics_StackTrace_get_METHODS_TO_SKIP();
            return __return;
        }
    }
    // .ctor()
// docid: M:System.Diagnostics.StackTrace.#ctor
    /**
    Initializes a new instance of the  class from the caller's frame.

    */
    public override init() throws {
        var __thrown : NullableHandle = nil;
        let h = System_Diagnostics_StackTrace_ctor_0__0(&__thrown);
        if let __ex = __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
            super.init(hndl: h);
        }
    }
    // .ctor(bool)
// docid: M:System.Diagnostics.StackTrace.#ctor(System.Boolean)
    /**
    Initializes a new instance of the  class from the caller's frame, optionally capturing source information.

    - Parameter fNeedFileInfo: 
         to capture the file name, line number, and column number; otherwise, .
    */
    public init(fNeedFileInfo : Bool) throws {
        var __thrown : NullableHandle = nil;
        let h = System_Diagnostics_StackTrace_ctor_0__1__bool(&__thrown, Swift.Int32(fNeedFileInfo ? 1 : 0));
        if let __ex = __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
            super.init(hndl: h);
        }
    }
    // .ctor(System.Diagnostics.StackFrame)
// docid: M:System.Diagnostics.StackTrace.#ctor(System.Diagnostics.StackFrame)
    /**
    Initializes a new instance of the  class that contains a single frame.

    - Parameter frame: The frame that the  object should contain.
    */
    public init(frame : dotnet.System.Diagnostics.StackFrame) throws {
        var __thrown : NullableHandle = nil;
        let h = System_Diagnostics_StackTrace_ctor_0__1__StackFrame(&__thrown, frame.get_handle());
        if let __ex = __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
            super.init(hndl: h);
        }
    }
    // .ctor(System.Exception)
// docid: M:System.Diagnostics.StackTrace.#ctor(System.Exception)
    /**
    Initializes a new instance of the  class using the provided exception object.

    - Parameter e: The exception object from which to construct the stack trace.
    */
    public init(e : dotnet.System.Exception) throws {
        var __thrown : NullableHandle = nil;
        let h = System_Diagnostics_StackTrace_ctor_0__1__Exception(&__thrown, e.get_handle());
        if let __ex = __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
            super.init(hndl: h);
        }
    }
    // .ctor(System.Exception, bool)
// docid: M:System.Diagnostics.StackTrace.#ctor(System.Exception,System.Boolean)
    /**
    Initializes a new instance of the  class, using the provided exception object and optionally capturing source information.

    - Parameter e: The exception object from which to construct the stack trace.
    - Parameter fNeedFileInfo: 
         to capture the file name, line number, and column number; otherwise, .
    */
    public init(e : dotnet.System.Exception, fNeedFileInfo : Bool) throws {
        var __thrown : NullableHandle = nil;
        let h = System_Diagnostics_StackTrace_ctor_0__2__Exception_bool(&__thrown, e.get_handle(), Swift.Int32(fNeedFileInfo ? 1 : 0));
        if let __ex = __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
            super.init(hndl: h);
        }
    }
    // .ctor(System.Exception, System.Int32)
// docid: M:System.Diagnostics.StackTrace.#ctor(System.Exception,System.Int32)
    /**
    Initializes a new instance of the  class using the provided exception object and skipping the specified number of frames.

    - Parameter e: The exception object from which to construct the stack trace.
    - Parameter skipFrames: The number of frames up the stack from which to start the trace.
    */
    public init(e : dotnet.System.Exception, skipFrames : Swift.Int32) throws {
        var __thrown : NullableHandle = nil;
        let h = System_Diagnostics_StackTrace_ctor_0__2__Exception_i32(&__thrown, e.get_handle(), skipFrames);
        if let __ex = __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
            super.init(hndl: h);
        }
    }
    // .ctor(System.Exception, System.Int32, bool)
// docid: M:System.Diagnostics.StackTrace.#ctor(System.Exception,System.Int32,System.Boolean)
    /**
    Initializes a new instance of the  class using the provided exception object, skipping the specified number of frames and optionally capturing source information.

    - Parameter e: The exception object from which to construct the stack trace.
    - Parameter skipFrames: The number of frames up the stack from which to start the trace.
    - Parameter fNeedFileInfo: 
         to capture the file name, line number, and column number; otherwise, .
    */
    public init(e : dotnet.System.Exception, skipFrames : Swift.Int32, fNeedFileInfo : Bool) throws {
        var __thrown : NullableHandle = nil;
        let h = System_Diagnostics_StackTrace_ctor_0__3__Exception_i32_bool(&__thrown, e.get_handle(), skipFrames, Swift.Int32(fNeedFileInfo ? 1 : 0));
        if let __ex = __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
            super.init(hndl: h);
        }
    }
    // .ctor(System.Int32)
// docid: M:System.Diagnostics.StackTrace.#ctor(System.Int32)
    /**
    Initializes a new instance of the  class from the caller's frame, skipping the specified number of frames.

    - Parameter skipFrames: The number of frames up the stack from which to start the trace.
    */
    public init(skipFrames : Swift.Int32) throws {
        var __thrown : NullableHandle = nil;
        let h = System_Diagnostics_StackTrace_ctor_0__1__i32(&__thrown, skipFrames);
        if let __ex = __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
            super.init(hndl: h);
        }
    }
    // .ctor(System.Int32, bool)
// docid: M:System.Diagnostics.StackTrace.#ctor(System.Int32,System.Boolean)
    /**
    Initializes a new instance of the  class from the caller's frame, skipping the specified number of frames and optionally capturing source information.

    - Parameter skipFrames: The number of frames up the stack from which to start the trace.
    - Parameter fNeedFileInfo: 
         to capture the file name, line number, and column number; otherwise, .
    */
    public init(skipFrames : Swift.Int32, fNeedFileInfo : Bool) throws {
        var __thrown : NullableHandle = nil;
        let h = System_Diagnostics_StackTrace_ctor_0__2__i32_bool(&__thrown, skipFrames, Swift.Int32(fNeedFileInfo ? 1 : 0));
        if let __ex = __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
            super.init(hndl: h);
        }
    }
    // System.Diagnostics.StackFrame GetFrame(System.Int32)
// docid: M:System.Diagnostics.StackTrace.GetFrame(System.Int32)
    /**
    Gets the specified stack frame.

    - Parameter index: The index of the stack frame requested.
    - Returns: The specified stack frame.

    */
    open func GetFrame(index : Swift.Int32) throws -> Optional<dotnet.System.Diagnostics.StackFrame> {
        var __thrown : NullableHandle = nil;
        let __return = System_Diagnostics_StackTrace_StackFrame__GetFrame_0__1__i32(&__thrown, self.get_handle(), index);
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        if let __ret_unwrapped = __return {
            return dotnet.System.Diagnostics.StackFrame(hndl : __ret_unwrapped);
        } else {
            return nil;
        }
        }
    }
    // System.Diagnostics.StackFrame[] GetFrames()
// docid: M:System.Diagnostics.StackTrace.GetFrames
    /**
    Returns a copy of all stack frames in the current stack trace.

    - Returns: An array of type  representing the function calls in the stack trace.

    */
    open func GetFrames() throws -> dotnet.System_Arr<dotnet.System.Diagnostics.StackFrame> {
        var __thrown : NullableHandle = nil;
        let __return = System_Diagnostics_StackTrace_StackFrameArray__GetFrames_0__0(&__thrown, self.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return dotnet.System_Arr<dotnet.System.Diagnostics.StackFrame>(hndl : __return);
        }
    }
    // System.String ToString()
// docid: M:System.Diagnostics.StackTrace.ToString
    /**
    Builds a readable representation of the stack trace.

    - Returns: A readable representation of the stack trace.

    */
    open override func ToString() throws -> dotnet.System.String {
        var __thrown : NullableHandle = nil;
        let __return = System_Diagnostics_StackTrace_String__ToString_0__0(&__thrown, self.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return dotnet.System.String(hndl : __return);
        }
    }
    // [IsSpecialName] System.Int32 get_FrameCount()
// docid: M:System.Diagnostics.StackTrace.get_FrameCount
    open func get_FrameCount() throws -> Swift.Int32 {
        var __thrown : NullableHandle = nil;
        let __return = System_Diagnostics_StackTrace_i32__get_FrameCount_0__0(&__thrown, self.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return __return;
        }
    }
    /**
    Gets the number of frames in the stack trace.

    */
    open var FrameCount : Swift.Int32 {
        get {
            return try! get_FrameCount();
        }
    }
} // StackTrace


}
// System.Diagnostics.SymbolStore
extension System.Diagnostics.SymbolStore {
// type: System.Diagnostics.SymbolStore.ISymbolBinder
    /**
    Represents a symbol binder for managed code.

    */
open class ISymbolBinder
    :
    SGBridgeGenericValue,
    System_Diagnostics_SymbolStore_ISymbolBinder
{
    open class func get_type_handle() -> TypeHandle {
        return System_Diagnostics_SymbolStore_ISymbolBinder_get_type_handle();
    }
    let h : NonnullHandle;
    public func to_gval() -> GVal { return GVal(Swift.Int(bitPattern: self.h)); }
    public func dup_gval() -> GVal { return GVal(Swift.Int(bitPattern: __copy_handle(self.h))); }
    public required init(gval: GVal) { self.h = NonnullHandle(bitPattern: Swift.Int(truncatingIfNeeded: gval))!; }
    public required init(hndl: NonnullHandle) { self.h = hndl; }
    public func get_handle() -> NonnullHandle { return self.h; }

    deinit { __drop_handle(self.h); }

    // System.Diagnostics.SymbolStore.ISymbolReader GetReader(System.Int32, System.String, System.String)
// docid: M:System.Diagnostics.SymbolStore.ISymbolBinder.GetReader(System.Int32,System.String,System.String)
    /**
    Gets the interface of the symbol reader for the current file.

    - Parameter importer: The metadata import interface.
    - Parameter filename: The name of the file for which the reader interface is required.
    - Parameter searchPath: The search path used to locate the symbol file.
    - Returns: The  interface that reads the debugging symbols.

    */
    open func GetReader(importer : Swift.Int32, filename : dotnet.System.String, searchPath : dotnet.System.String) throws -> Optional<dotnet.System.Diagnostics.SymbolStore.ISymbolReader> {
        var __thrown : NullableHandle = nil;
        let __return = System_Diagnostics_SymbolStore_ISymbolBinder_ISymbolReader__GetReader_0__3__i32_String_String(&__thrown, self.get_handle(), importer, filename.get_handle(), searchPath.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        if let __ret_unwrapped = __return {
            return dotnet.System.Diagnostics.SymbolStore.ISymbolReader(hndl : __ret_unwrapped);
        } else {
            return nil;
        }
        }
    }
} // ISymbolBinder


// type: System.Diagnostics.SymbolStore.ISymbolBinder1
    /**
    Represents a symbol binder for managed code.

    */
open class ISymbolBinder1
    :
    SGBridgeGenericValue,
    System_Diagnostics_SymbolStore_ISymbolBinder1
{
    open class func get_type_handle() -> TypeHandle {
        return System_Diagnostics_SymbolStore_ISymbolBinder1_get_type_handle();
    }
    let h : NonnullHandle;
    public func to_gval() -> GVal { return GVal(Swift.Int(bitPattern: self.h)); }
    public func dup_gval() -> GVal { return GVal(Swift.Int(bitPattern: __copy_handle(self.h))); }
    public required init(gval: GVal) { self.h = NonnullHandle(bitPattern: Swift.Int(truncatingIfNeeded: gval))!; }
    public required init(hndl: NonnullHandle) { self.h = hndl; }
    public func get_handle() -> NonnullHandle { return self.h; }

    deinit { __drop_handle(self.h); }

    // System.Diagnostics.SymbolStore.ISymbolReader GetReader(System.IntPtr, System.String, System.String)
// docid: M:System.Diagnostics.SymbolStore.ISymbolBinder1.GetReader(System.IntPtr,System.String,System.String)
    /**
    Gets the interface of the symbol reader for the current file.

    - Parameter importer: An  that refers to the metadata import interface.
    - Parameter filename: The name of the file for which the reader interface is required.
    - Parameter searchPath: The search path used to locate the symbol file.
    - Returns: The  interface that reads the debugging symbols.

    */
    open func GetReader(importer : dotnet.System.IntPtr, filename : dotnet.System.String, searchPath : dotnet.System.String) throws -> Optional<dotnet.System.Diagnostics.SymbolStore.ISymbolReader> {
        var __thrown : NullableHandle = nil;
        let __return = System_Diagnostics_SymbolStore_ISymbolBinder1_ISymbolReader__GetReader_0__3__IntPtr_String_String(&__thrown, self.get_handle(), importer.get_value(), filename.get_handle(), searchPath.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        if let __ret_unwrapped = __return {
            return dotnet.System.Diagnostics.SymbolStore.ISymbolReader(hndl : __ret_unwrapped);
        } else {
            return nil;
        }
        }
    }
} // ISymbolBinder1


// type: System.Diagnostics.SymbolStore.ISymbolDocument
    /**
    Represents a document referenced by a symbol store.

    */
open class ISymbolDocument
    :
    SGBridgeGenericValue,
    System_Diagnostics_SymbolStore_ISymbolDocument
{
    open class func get_type_handle() -> TypeHandle {
        return System_Diagnostics_SymbolStore_ISymbolDocument_get_type_handle();
    }
    let h : NonnullHandle;
    public func to_gval() -> GVal { return GVal(Swift.Int(bitPattern: self.h)); }
    public func dup_gval() -> GVal { return GVal(Swift.Int(bitPattern: __copy_handle(self.h))); }
    public required init(gval: GVal) { self.h = NonnullHandle(bitPattern: Swift.Int(truncatingIfNeeded: gval))!; }
    public required init(hndl: NonnullHandle) { self.h = hndl; }
    public func get_handle() -> NonnullHandle { return self.h; }

    deinit { __drop_handle(self.h); }

    // System.Int32 FindClosestLine(System.Int32)
// docid: M:System.Diagnostics.SymbolStore.ISymbolDocument.FindClosestLine(System.Int32)
    /**
    Returns the closest line that is a sequence point, given a line in the current document that might or might not be a sequence point.

    - Parameter line: The specified line in the document.
    - Returns: The closest line that is a sequence point.

    */
    open func FindClosestLine(line : Swift.Int32) throws -> Swift.Int32 {
        var __thrown : NullableHandle = nil;
        let __return = System_Diagnostics_SymbolStore_ISymbolDocument_i32__FindClosestLine_0__1__i32(&__thrown, self.get_handle(), line);
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return __return;
        }
    }
    // System.Byte[] GetCheckSum()
// docid: M:System.Diagnostics.SymbolStore.ISymbolDocument.GetCheckSum
    /**
    Gets the checksum.

    - Returns: The checksum.

    */
    open func GetCheckSum() throws -> dotnet.System_Arr<Swift.UInt8> {
        var __thrown : NullableHandle = nil;
        let __return = System_Diagnostics_SymbolStore_ISymbolDocument_u8Array__GetCheckSum_0__0(&__thrown, self.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return dotnet.System_Arr<Swift.UInt8>(hndl : __return);
        }
    }
    // System.Byte[] GetSourceRange(System.Int32, System.Int32, System.Int32, System.Int32)
// docid: M:System.Diagnostics.SymbolStore.ISymbolDocument.GetSourceRange(System.Int32,System.Int32,System.Int32,System.Int32)
    /**
    Gets the embedded document source for the specified range.

    - Parameter startLine: The starting line in the current document.
    - Parameter startColumn: The starting column in the current document.
    - Parameter endLine: The ending line in the current document.
    - Parameter endColumn: The ending column in the current document.
    - Returns: The document source for the specified range.

    */
    open func GetSourceRange(startLine : Swift.Int32, startColumn : Swift.Int32, endLine : Swift.Int32, endColumn : Swift.Int32) throws -> dotnet.System_Arr<Swift.UInt8> {
        var __thrown : NullableHandle = nil;
        let __return = System_Diagnostics_SymbolStore_ISymbolDocument_u8Array__GetSourceRange_0__4__i32_i32_i32_i32(&__thrown, self.get_handle(), startLine, startColumn, endLine, endColumn);
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return dotnet.System_Arr<Swift.UInt8>(hndl : __return);
        }
    }
    // [IsSpecialName] System.Guid get_CheckSumAlgorithmId()
// docid: M:System.Diagnostics.SymbolStore.ISymbolDocument.get_CheckSumAlgorithmId
    open func get_CheckSumAlgorithmId() throws -> dotnet.System.Guid {
        var __thrown : NullableHandle = nil;
        let __return = System_Diagnostics_SymbolStore_ISymbolDocument_Guid__get_CheckSumAlgorithmId_0__0(&__thrown, self.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return dotnet.System.Guid(hndl : __return);
        }
    }
    // [IsSpecialName] System.Guid get_DocumentType()
// docid: M:System.Diagnostics.SymbolStore.ISymbolDocument.get_DocumentType
    open func get_DocumentType() throws -> dotnet.System.Guid {
        var __thrown : NullableHandle = nil;
        let __return = System_Diagnostics_SymbolStore_ISymbolDocument_Guid__get_DocumentType_0__0(&__thrown, self.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return dotnet.System.Guid(hndl : __return);
        }
    }
    // [IsSpecialName] bool get_HasEmbeddedSource()
// docid: M:System.Diagnostics.SymbolStore.ISymbolDocument.get_HasEmbeddedSource
    open func get_HasEmbeddedSource() throws -> Bool {
        var __thrown : NullableHandle = nil;
        let __return = System_Diagnostics_SymbolStore_ISymbolDocument_bool__get_HasEmbeddedSource_0__0(&__thrown, self.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return (__return) != 0;
        }
    }
    // [IsSpecialName] System.Guid get_Language()
// docid: M:System.Diagnostics.SymbolStore.ISymbolDocument.get_Language
    open func get_Language() throws -> dotnet.System.Guid {
        var __thrown : NullableHandle = nil;
        let __return = System_Diagnostics_SymbolStore_ISymbolDocument_Guid__get_Language_0__0(&__thrown, self.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return dotnet.System.Guid(hndl : __return);
        }
    }
    // [IsSpecialName] System.Guid get_LanguageVendor()
// docid: M:System.Diagnostics.SymbolStore.ISymbolDocument.get_LanguageVendor
    open func get_LanguageVendor() throws -> dotnet.System.Guid {
        var __thrown : NullableHandle = nil;
        let __return = System_Diagnostics_SymbolStore_ISymbolDocument_Guid__get_LanguageVendor_0__0(&__thrown, self.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return dotnet.System.Guid(hndl : __return);
        }
    }
    // [IsSpecialName] System.Int32 get_SourceLength()
// docid: M:System.Diagnostics.SymbolStore.ISymbolDocument.get_SourceLength
    open func get_SourceLength() throws -> Swift.Int32 {
        var __thrown : NullableHandle = nil;
        let __return = System_Diagnostics_SymbolStore_ISymbolDocument_i32__get_SourceLength_0__0(&__thrown, self.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return __return;
        }
    }
    // [IsSpecialName] System.String get_URL()
// docid: M:System.Diagnostics.SymbolStore.ISymbolDocument.get_URL
    open func get_URL() throws -> dotnet.System.String {
        var __thrown : NullableHandle = nil;
        let __return = System_Diagnostics_SymbolStore_ISymbolDocument_String__get_URL_0__0(&__thrown, self.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return dotnet.System.String(hndl : __return);
        }
    }
} // ISymbolDocument


// type: System.Diagnostics.SymbolStore.ISymbolDocumentWriter
    /**
    Represents a document referenced by a symbol store.

    */
open class ISymbolDocumentWriter
    :
    SGBridgeGenericValue,
    System_Diagnostics_SymbolStore_ISymbolDocumentWriter
{
    open class func get_type_handle() -> TypeHandle {
        return System_Diagnostics_SymbolStore_ISymbolDocumentWriter_get_type_handle();
    }
    let h : NonnullHandle;
    public func to_gval() -> GVal { return GVal(Swift.Int(bitPattern: self.h)); }
    public func dup_gval() -> GVal { return GVal(Swift.Int(bitPattern: __copy_handle(self.h))); }
    public required init(gval: GVal) { self.h = NonnullHandle(bitPattern: Swift.Int(truncatingIfNeeded: gval))!; }
    public required init(hndl: NonnullHandle) { self.h = hndl; }
    public func get_handle() -> NonnullHandle { return self.h; }

    deinit { __drop_handle(self.h); }

    // void SetCheckSum(System.Guid, System.Byte[])
// docid: M:System.Diagnostics.SymbolStore.ISymbolDocumentWriter.SetCheckSum(System.Guid,System.Byte[])
    /**
    Sets checksum information.

    - Parameter algorithmId: The GUID representing the algorithm ID.
    - Parameter checkSum: The checksum.
    */
    open func SetCheckSum(algorithmId : dotnet.System.Guid, checkSum : dotnet.System_Arr<Swift.UInt8>) throws {
        var __thrown : NullableHandle = nil;
        System_Diagnostics_SymbolStore_ISymbolDocumentWriter_void__SetCheckSum_0__2__Guid_u8Array(&__thrown, self.get_handle(), algorithmId.get_handle(), checkSum.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
            return;
        }
    }
    // void SetSource(System.Byte[])
// docid: M:System.Diagnostics.SymbolStore.ISymbolDocumentWriter.SetSource(System.Byte[])
    /**
    Stores the raw source for a document in the symbol store.

    - Parameter source: The document source represented as unsigned bytes.
    */
    open func SetSource(source : dotnet.System_Arr<Swift.UInt8>) throws {
        var __thrown : NullableHandle = nil;
        System_Diagnostics_SymbolStore_ISymbolDocumentWriter_void__SetSource_0__1__u8Array(&__thrown, self.get_handle(), source.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
            return;
        }
    }
} // ISymbolDocumentWriter


// type: System.Diagnostics.SymbolStore.ISymbolMethod
    /**
    Represents a method within a symbol store.

    */
open class ISymbolMethod
    :
    SGBridgeGenericValue,
    System_Diagnostics_SymbolStore_ISymbolMethod
{
    open class func get_type_handle() -> TypeHandle {
        return System_Diagnostics_SymbolStore_ISymbolMethod_get_type_handle();
    }
    let h : NonnullHandle;
    public func to_gval() -> GVal { return GVal(Swift.Int(bitPattern: self.h)); }
    public func dup_gval() -> GVal { return GVal(Swift.Int(bitPattern: __copy_handle(self.h))); }
    public required init(gval: GVal) { self.h = NonnullHandle(bitPattern: Swift.Int(truncatingIfNeeded: gval))!; }
    public required init(hndl: NonnullHandle) { self.h = hndl; }
    public func get_handle() -> NonnullHandle { return self.h; }

    deinit { __drop_handle(self.h); }

    // System.Diagnostics.SymbolStore.ISymbolNamespace GetNamespace()
// docid: M:System.Diagnostics.SymbolStore.ISymbolMethod.GetNamespace
    /**
    Gets the namespace that the current method is defined within.

    - Returns: The namespace that the current method is defined within.

    */
    open func GetNamespace() throws -> dotnet.System.Diagnostics.SymbolStore.ISymbolNamespace {
        var __thrown : NullableHandle = nil;
        let __return = System_Diagnostics_SymbolStore_ISymbolMethod_ISymbolNamespace__GetNamespace_0__0(&__thrown, self.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return dotnet.System.Diagnostics.SymbolStore.ISymbolNamespace(hndl : __return);
        }
    }
    // System.Int32 GetOffset(System.Diagnostics.SymbolStore.ISymbolDocument, System.Int32, System.Int32)
// docid: M:System.Diagnostics.SymbolStore.ISymbolMethod.GetOffset(System.Diagnostics.SymbolStore.ISymbolDocument,System.Int32,System.Int32)
    /**
    Gets the Microsoft intermediate language (MSIL) offset within the method that corresponds to the specified position.

    - Parameter document: The document for which the offset is requested.
    - Parameter line: The document line corresponding to the offset.
    - Parameter column: The document column corresponding to the offset.
    - Returns: The offset within the specified document.

    */
    open func GetOffset(document : dotnet.System.Diagnostics.SymbolStore.ISymbolDocument, line : Swift.Int32, column : Swift.Int32) throws -> Swift.Int32 {
        var __thrown : NullableHandle = nil;
        let __return = System_Diagnostics_SymbolStore_ISymbolMethod_i32__GetOffset_0__3__ISymbolDocument_i32_i32(&__thrown, self.get_handle(), document.get_handle(), line, column);
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return __return;
        }
    }
    // System.Diagnostics.SymbolStore.ISymbolVariable[] GetParameters()
// docid: M:System.Diagnostics.SymbolStore.ISymbolMethod.GetParameters
    /**
    Gets the parameters for the current method.

    - Returns: The array of parameters for the current method.

    */
    open func GetParameters() throws -> dotnet.System_Arr<dotnet.System.Diagnostics.SymbolStore.ISymbolVariable> {
        var __thrown : NullableHandle = nil;
        let __return = System_Diagnostics_SymbolStore_ISymbolMethod_ISymbolVariableArray__GetParameters_0__0(&__thrown, self.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return dotnet.System_Arr<dotnet.System.Diagnostics.SymbolStore.ISymbolVariable>(hndl : __return);
        }
    }
    // System.Int32[] GetRanges(System.Diagnostics.SymbolStore.ISymbolDocument, System.Int32, System.Int32)
// docid: M:System.Diagnostics.SymbolStore.ISymbolMethod.GetRanges(System.Diagnostics.SymbolStore.ISymbolDocument,System.Int32,System.Int32)
    /**
    Gets an array of start and end offset pairs that correspond to the ranges of Microsoft intermediate language (MSIL) that a given position covers within this method.

    - Parameter document: The document for which the offset is requested.
    - Parameter line: The document line corresponding to the ranges.
    - Parameter column: The document column corresponding to the ranges.
    - Returns: An array of start and end offset pairs.

    */
    open func GetRanges(document : dotnet.System.Diagnostics.SymbolStore.ISymbolDocument, line : Swift.Int32, column : Swift.Int32) throws -> dotnet.System_Arr<Swift.Int32> {
        var __thrown : NullableHandle = nil;
        let __return = System_Diagnostics_SymbolStore_ISymbolMethod_i32Array__GetRanges_0__3__ISymbolDocument_i32_i32(&__thrown, self.get_handle(), document.get_handle(), line, column);
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return dotnet.System_Arr<Swift.Int32>(hndl : __return);
        }
    }
    // System.Diagnostics.SymbolStore.ISymbolScope GetScope(System.Int32)
// docid: M:System.Diagnostics.SymbolStore.ISymbolMethod.GetScope(System.Int32)
    /**
    Returns the most enclosing lexical scope when given an offset within a method.

    - Parameter offset: The byte offset within the method of the lexical scope.
    - Returns: The most enclosing lexical scope for the given byte offset within the method.

    */
    open func GetScope(offset : Swift.Int32) throws -> dotnet.System.Diagnostics.SymbolStore.ISymbolScope {
        var __thrown : NullableHandle = nil;
        let __return = System_Diagnostics_SymbolStore_ISymbolMethod_ISymbolScope__GetScope_0__1__i32(&__thrown, self.get_handle(), offset);
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return dotnet.System.Diagnostics.SymbolStore.ISymbolScope(hndl : __return);
        }
    }
    // void GetSequencePoints(System.Int32[], System.Diagnostics.SymbolStore.ISymbolDocument[], System.Int32[], System.Int32[], System.Int32[], System.Int32[])
// docid: M:System.Diagnostics.SymbolStore.ISymbolMethod.GetSequencePoints(System.Int32[],System.Diagnostics.SymbolStore.ISymbolDocument[],System.Int32[],System.Int32[],System.Int32[],System.Int32[])
    /**
    Gets the sequence points for the current method.

    - Parameter offsets: The array of byte offsets from the beginning of the method for the sequence points.
    - Parameter documents: The array of documents in which the sequence points are located.
    - Parameter lines: The array of lines in the documents at which the sequence points are located.
    - Parameter columns: The array of columns in the documents at which the sequence points are located.
    - Parameter endLines: The array of lines in the documents at which the sequence points end.
    - Parameter endColumns: The array of columns in the documents at which the sequence points end.
    */
    open func GetSequencePoints(offsets : Optional<dotnet.System_Arr<Swift.Int32>>, documents : Optional<dotnet.System_Arr<dotnet.System.Diagnostics.SymbolStore.ISymbolDocument>>, lines : Optional<dotnet.System_Arr<Swift.Int32>>, columns : Optional<dotnet.System_Arr<Swift.Int32>>, endLines : Optional<dotnet.System_Arr<Swift.Int32>>, endColumns : Optional<dotnet.System_Arr<Swift.Int32>>) throws {
        var __thrown : NullableHandle = nil;
        System_Diagnostics_SymbolStore_ISymbolMethod_void__GetSequencePoints_0__6__i32Array_ISymbolDocumentArray_i32Array_i32Array_i32Array_i32Array(&__thrown, self.get_handle(), (offsets?.get_handle()), (documents?.get_handle()), (lines?.get_handle()), (columns?.get_handle()), (endLines?.get_handle()), (endColumns?.get_handle()));
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
            return;
        }
    }
    // bool GetSourceStartEnd(System.Diagnostics.SymbolStore.ISymbolDocument[], System.Int32[], System.Int32[])
// docid: M:System.Diagnostics.SymbolStore.ISymbolMethod.GetSourceStartEnd(System.Diagnostics.SymbolStore.ISymbolDocument[],System.Int32[],System.Int32[])
    /**
    Gets the start and end positions for the source of the current method.

    - Parameter docs: The starting and ending source documents.
    - Parameter lines: The starting and ending lines in the corresponding source documents.
    - Parameter columns: The starting and ending columns in the corresponding source documents.
    - Returns: 
         if the positions were defined; otherwise, .

    */
    open func GetSourceStartEnd(docs : Optional<dotnet.System_Arr<dotnet.System.Diagnostics.SymbolStore.ISymbolDocument>>, lines : Optional<dotnet.System_Arr<Swift.Int32>>, columns : Optional<dotnet.System_Arr<Swift.Int32>>) throws -> Bool {
        var __thrown : NullableHandle = nil;
        let __return = System_Diagnostics_SymbolStore_ISymbolMethod_bool__GetSourceStartEnd_0__3__ISymbolDocumentArray_i32Array_i32Array(&__thrown, self.get_handle(), (docs?.get_handle()), (lines?.get_handle()), (columns?.get_handle()));
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return (__return) != 0;
        }
    }
    // [IsSpecialName] System.Diagnostics.SymbolStore.ISymbolScope get_RootScope()
// docid: M:System.Diagnostics.SymbolStore.ISymbolMethod.get_RootScope
    open func get_RootScope() throws -> dotnet.System.Diagnostics.SymbolStore.ISymbolScope {
        var __thrown : NullableHandle = nil;
        let __return = System_Diagnostics_SymbolStore_ISymbolMethod_ISymbolScope__get_RootScope_0__0(&__thrown, self.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return dotnet.System.Diagnostics.SymbolStore.ISymbolScope(hndl : __return);
        }
    }
    // [IsSpecialName] System.Int32 get_SequencePointCount()
// docid: M:System.Diagnostics.SymbolStore.ISymbolMethod.get_SequencePointCount
    open func get_SequencePointCount() throws -> Swift.Int32 {
        var __thrown : NullableHandle = nil;
        let __return = System_Diagnostics_SymbolStore_ISymbolMethod_i32__get_SequencePointCount_0__0(&__thrown, self.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return __return;
        }
    }
    // [IsSpecialName] System.Diagnostics.SymbolStore.SymbolToken get_Token()
// docid: M:System.Diagnostics.SymbolStore.ISymbolMethod.get_Token
    open func get_Token() throws -> dotnet.System.Diagnostics.SymbolStore.SymbolToken {
        var __thrown : NullableHandle = nil;
        let __return = System_Diagnostics_SymbolStore_ISymbolMethod_SymbolToken__get_Token_0__0(&__thrown, self.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return dotnet.System.Diagnostics.SymbolStore.SymbolToken(hndl : __return);
        }
    }
} // ISymbolMethod


// type: System.Diagnostics.SymbolStore.ISymbolNamespace
    /**
    Represents a namespace within a symbol store.

    */
open class ISymbolNamespace
    :
    SGBridgeGenericValue,
    System_Diagnostics_SymbolStore_ISymbolNamespace
{
    open class func get_type_handle() -> TypeHandle {
        return System_Diagnostics_SymbolStore_ISymbolNamespace_get_type_handle();
    }
    let h : NonnullHandle;
    public func to_gval() -> GVal { return GVal(Swift.Int(bitPattern: self.h)); }
    public func dup_gval() -> GVal { return GVal(Swift.Int(bitPattern: __copy_handle(self.h))); }
    public required init(gval: GVal) { self.h = NonnullHandle(bitPattern: Swift.Int(truncatingIfNeeded: gval))!; }
    public required init(hndl: NonnullHandle) { self.h = hndl; }
    public func get_handle() -> NonnullHandle { return self.h; }

    deinit { __drop_handle(self.h); }

    // System.Diagnostics.SymbolStore.ISymbolNamespace[] GetNamespaces()
// docid: M:System.Diagnostics.SymbolStore.ISymbolNamespace.GetNamespaces
    /**
    Gets the child members of the current namespace.

    - Returns: The child members of the current namespace.

    */
    open func GetNamespaces() throws -> dotnet.System_Arr<dotnet.System.Diagnostics.SymbolStore.ISymbolNamespace> {
        var __thrown : NullableHandle = nil;
        let __return = System_Diagnostics_SymbolStore_ISymbolNamespace_ISymbolNamespaceArray__GetNamespaces_0__0(&__thrown, self.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return dotnet.System_Arr<dotnet.System.Diagnostics.SymbolStore.ISymbolNamespace>(hndl : __return);
        }
    }
    // System.Diagnostics.SymbolStore.ISymbolVariable[] GetVariables()
// docid: M:System.Diagnostics.SymbolStore.ISymbolNamespace.GetVariables
    /**
    Gets all the variables defined at global scope within the current namespace.

    - Returns: The variables defined at global scope within the current namespace.

    */
    open func GetVariables() throws -> dotnet.System_Arr<dotnet.System.Diagnostics.SymbolStore.ISymbolVariable> {
        var __thrown : NullableHandle = nil;
        let __return = System_Diagnostics_SymbolStore_ISymbolNamespace_ISymbolVariableArray__GetVariables_0__0(&__thrown, self.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return dotnet.System_Arr<dotnet.System.Diagnostics.SymbolStore.ISymbolVariable>(hndl : __return);
        }
    }
    // [IsSpecialName] System.String get_Name()
// docid: M:System.Diagnostics.SymbolStore.ISymbolNamespace.get_Name
    open func get_Name() throws -> dotnet.System.String {
        var __thrown : NullableHandle = nil;
        let __return = System_Diagnostics_SymbolStore_ISymbolNamespace_String__get_Name_0__0(&__thrown, self.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return dotnet.System.String(hndl : __return);
        }
    }
} // ISymbolNamespace


// type: System.Diagnostics.SymbolStore.ISymbolReader
    /**
    Represents a symbol reader for managed code.

    */
open class ISymbolReader
    :
    SGBridgeGenericValue,
    System_Diagnostics_SymbolStore_ISymbolReader
{
    open class func get_type_handle() -> TypeHandle {
        return System_Diagnostics_SymbolStore_ISymbolReader_get_type_handle();
    }
    let h : NonnullHandle;
    public func to_gval() -> GVal { return GVal(Swift.Int(bitPattern: self.h)); }
    public func dup_gval() -> GVal { return GVal(Swift.Int(bitPattern: __copy_handle(self.h))); }
    public required init(gval: GVal) { self.h = NonnullHandle(bitPattern: Swift.Int(truncatingIfNeeded: gval))!; }
    public required init(hndl: NonnullHandle) { self.h = hndl; }
    public func get_handle() -> NonnullHandle { return self.h; }

    deinit { __drop_handle(self.h); }

    // System.Diagnostics.SymbolStore.ISymbolDocument GetDocument(System.String, System.Guid, System.Guid, System.Guid)
// docid: M:System.Diagnostics.SymbolStore.ISymbolReader.GetDocument(System.String,System.Guid,System.Guid,System.Guid)
    /**
    Gets a document specified by the language, vendor, and type.

    - Parameter url: The URL that identifies the document.
    - Parameter language: The document language. You can specify this parameter as .
    - Parameter languageVendor: The identity of the vendor for the document language. You can specify this parameter as .
    - Parameter documentType: The type of the document. You can specify this parameter as .
    - Returns: The specified document.

    */
    open func GetDocument(url : dotnet.System.String, language : dotnet.System.Guid, languageVendor : dotnet.System.Guid, documentType : dotnet.System.Guid) throws -> Optional<dotnet.System.Diagnostics.SymbolStore.ISymbolDocument> {
        var __thrown : NullableHandle = nil;
        let __return = System_Diagnostics_SymbolStore_ISymbolReader_ISymbolDocument__GetDocument_0__4__String_Guid_Guid_Guid(&__thrown, self.get_handle(), url.get_handle(), language.get_handle(), languageVendor.get_handle(), documentType.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        if let __ret_unwrapped = __return {
            return dotnet.System.Diagnostics.SymbolStore.ISymbolDocument(hndl : __ret_unwrapped);
        } else {
            return nil;
        }
        }
    }
    // System.Diagnostics.SymbolStore.ISymbolDocument[] GetDocuments()
// docid: M:System.Diagnostics.SymbolStore.ISymbolReader.GetDocuments
    /**
    Gets an array of all documents defined in the symbol store.

    - Returns: An array of all documents defined in the symbol store.

    */
    open func GetDocuments() throws -> dotnet.System_Arr<dotnet.System.Diagnostics.SymbolStore.ISymbolDocument> {
        var __thrown : NullableHandle = nil;
        let __return = System_Diagnostics_SymbolStore_ISymbolReader_ISymbolDocumentArray__GetDocuments_0__0(&__thrown, self.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return dotnet.System_Arr<dotnet.System.Diagnostics.SymbolStore.ISymbolDocument>(hndl : __return);
        }
    }
    // System.Diagnostics.SymbolStore.ISymbolVariable[] GetGlobalVariables()
// docid: M:System.Diagnostics.SymbolStore.ISymbolReader.GetGlobalVariables
    /**
    Gets all global variables in the module.

    - Returns: An array of all variables in the module.

    */
    open func GetGlobalVariables() throws -> dotnet.System_Arr<dotnet.System.Diagnostics.SymbolStore.ISymbolVariable> {
        var __thrown : NullableHandle = nil;
        let __return = System_Diagnostics_SymbolStore_ISymbolReader_ISymbolVariableArray__GetGlobalVariables_0__0(&__thrown, self.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return dotnet.System_Arr<dotnet.System.Diagnostics.SymbolStore.ISymbolVariable>(hndl : __return);
        }
    }
    // System.Diagnostics.SymbolStore.ISymbolMethod GetMethod(System.Diagnostics.SymbolStore.SymbolToken)
// docid: M:System.Diagnostics.SymbolStore.ISymbolReader.GetMethod(System.Diagnostics.SymbolStore.SymbolToken)
    /**
    Gets a symbol reader method object when given the identifier of a method.

    - Parameter method: The metadata token of the method.
    - Returns: The symbol reader method object for the specified method identifier.

    */
    open func GetMethod(method : dotnet.System.Diagnostics.SymbolStore.SymbolToken) throws -> Optional<dotnet.System.Diagnostics.SymbolStore.ISymbolMethod> {
        var __thrown : NullableHandle = nil;
        let __return = System_Diagnostics_SymbolStore_ISymbolReader_ISymbolMethod__GetMethod_0__1__SymbolToken(&__thrown, self.get_handle(), method.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        if let __ret_unwrapped = __return {
            return dotnet.System.Diagnostics.SymbolStore.ISymbolMethod(hndl : __ret_unwrapped);
        } else {
            return nil;
        }
        }
    }
    // System.Diagnostics.SymbolStore.ISymbolMethod GetMethod(System.Diagnostics.SymbolStore.SymbolToken, System.Int32)
// docid: M:System.Diagnostics.SymbolStore.ISymbolReader.GetMethod(System.Diagnostics.SymbolStore.SymbolToken,System.Int32)
    /**
    Gets a symbol reader method object when given the identifier of a method and its edit and continue version.

    - Parameter method: The metadata token of the method.
    - Parameter version: The edit and continue version of the method.
    - Returns: The symbol reader method object for the specified method identifier.

    */
    open func GetMethod(method : dotnet.System.Diagnostics.SymbolStore.SymbolToken, version : Swift.Int32) throws -> Optional<dotnet.System.Diagnostics.SymbolStore.ISymbolMethod> {
        var __thrown : NullableHandle = nil;
        let __return = System_Diagnostics_SymbolStore_ISymbolReader_ISymbolMethod__GetMethod_0__2__SymbolToken_i32(&__thrown, self.get_handle(), method.get_handle(), version);
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        if let __ret_unwrapped = __return {
            return dotnet.System.Diagnostics.SymbolStore.ISymbolMethod(hndl : __ret_unwrapped);
        } else {
            return nil;
        }
        }
    }
    // System.Diagnostics.SymbolStore.ISymbolMethod GetMethodFromDocumentPosition(System.Diagnostics.SymbolStore.ISymbolDocument, System.Int32, System.Int32)
// docid: M:System.Diagnostics.SymbolStore.ISymbolReader.GetMethodFromDocumentPosition(System.Diagnostics.SymbolStore.ISymbolDocument,System.Int32,System.Int32)
    /**
    Gets a symbol reader method object that contains a specified position in a document.

    - Parameter document: The document in which the method is located.
    - Parameter line: The position of the line within the document. The lines are numbered, beginning with 1.
    - Parameter column: The position of column within the document. The columns are numbered, beginning with 1.
    - Returns: The reader method object for the specified position in the document.

    */
    open func GetMethodFromDocumentPosition(document : dotnet.System.Diagnostics.SymbolStore.ISymbolDocument, line : Swift.Int32, column : Swift.Int32) throws -> dotnet.System.Diagnostics.SymbolStore.ISymbolMethod {
        var __thrown : NullableHandle = nil;
        let __return = System_Diagnostics_SymbolStore_ISymbolReader_ISymbolMethod__GetMethodFromDocumentPosition_0__3__ISymbolDocument_i32_i32(&__thrown, self.get_handle(), document.get_handle(), line, column);
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return dotnet.System.Diagnostics.SymbolStore.ISymbolMethod(hndl : __return);
        }
    }
    // System.Diagnostics.SymbolStore.ISymbolNamespace[] GetNamespaces()
// docid: M:System.Diagnostics.SymbolStore.ISymbolReader.GetNamespaces
    /**
    Gets the namespaces that are defined in the global scope within the current symbol store.

    - Returns: The namespaces defined in the global scope within the current symbol store.

    */
    open func GetNamespaces() throws -> dotnet.System_Arr<dotnet.System.Diagnostics.SymbolStore.ISymbolNamespace> {
        var __thrown : NullableHandle = nil;
        let __return = System_Diagnostics_SymbolStore_ISymbolReader_ISymbolNamespaceArray__GetNamespaces_0__0(&__thrown, self.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return dotnet.System_Arr<dotnet.System.Diagnostics.SymbolStore.ISymbolNamespace>(hndl : __return);
        }
    }
    // System.Byte[] GetSymAttribute(System.Diagnostics.SymbolStore.SymbolToken, System.String)
// docid: M:System.Diagnostics.SymbolStore.ISymbolReader.GetSymAttribute(System.Diagnostics.SymbolStore.SymbolToken,System.String)
    /**
    Gets an attribute value when given the attribute name.

    - Parameter parent: The metadata token for the object for which the attribute is requested.
    - Parameter name: The attribute name.
    - Returns: The value of the attribute.

    */
    open func GetSymAttribute(parent : dotnet.System.Diagnostics.SymbolStore.SymbolToken, name : dotnet.System.String) throws -> dotnet.System_Arr<Swift.UInt8> {
        var __thrown : NullableHandle = nil;
        let __return = System_Diagnostics_SymbolStore_ISymbolReader_u8Array__GetSymAttribute_0__2__SymbolToken_String(&__thrown, self.get_handle(), parent.get_handle(), name.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return dotnet.System_Arr<Swift.UInt8>(hndl : __return);
        }
    }
    // System.Diagnostics.SymbolStore.ISymbolVariable[] GetVariables(System.Diagnostics.SymbolStore.SymbolToken)
// docid: M:System.Diagnostics.SymbolStore.ISymbolReader.GetVariables(System.Diagnostics.SymbolStore.SymbolToken)
    /**
    Gets the variables that are not local when given the parent.

    - Parameter parent: The metadata token for the type for which the variables are requested.
    - Returns: An array of variables for the parent.

    */
    open func GetVariables(parent : dotnet.System.Diagnostics.SymbolStore.SymbolToken) throws -> dotnet.System_Arr<dotnet.System.Diagnostics.SymbolStore.ISymbolVariable> {
        var __thrown : NullableHandle = nil;
        let __return = System_Diagnostics_SymbolStore_ISymbolReader_ISymbolVariableArray__GetVariables_0__1__SymbolToken(&__thrown, self.get_handle(), parent.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return dotnet.System_Arr<dotnet.System.Diagnostics.SymbolStore.ISymbolVariable>(hndl : __return);
        }
    }
    // [IsSpecialName] System.Diagnostics.SymbolStore.SymbolToken get_UserEntryPoint()
// docid: M:System.Diagnostics.SymbolStore.ISymbolReader.get_UserEntryPoint
    open func get_UserEntryPoint() throws -> dotnet.System.Diagnostics.SymbolStore.SymbolToken {
        var __thrown : NullableHandle = nil;
        let __return = System_Diagnostics_SymbolStore_ISymbolReader_SymbolToken__get_UserEntryPoint_0__0(&__thrown, self.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return dotnet.System.Diagnostics.SymbolStore.SymbolToken(hndl : __return);
        }
    }
} // ISymbolReader


// type: System.Diagnostics.SymbolStore.ISymbolScope
    /**
    Represents a lexical scope within , providing access to the start and end offsets of the scope, as well as its child and parent scopes.

    */
open class ISymbolScope
    :
    SGBridgeGenericValue,
    System_Diagnostics_SymbolStore_ISymbolScope
{
    open class func get_type_handle() -> TypeHandle {
        return System_Diagnostics_SymbolStore_ISymbolScope_get_type_handle();
    }
    let h : NonnullHandle;
    public func to_gval() -> GVal { return GVal(Swift.Int(bitPattern: self.h)); }
    public func dup_gval() -> GVal { return GVal(Swift.Int(bitPattern: __copy_handle(self.h))); }
    public required init(gval: GVal) { self.h = NonnullHandle(bitPattern: Swift.Int(truncatingIfNeeded: gval))!; }
    public required init(hndl: NonnullHandle) { self.h = hndl; }
    public func get_handle() -> NonnullHandle { return self.h; }

    deinit { __drop_handle(self.h); }

    // System.Diagnostics.SymbolStore.ISymbolScope[] GetChildren()
// docid: M:System.Diagnostics.SymbolStore.ISymbolScope.GetChildren
    /**
    Gets the child lexical scopes of the current lexical scope.

    - Returns: The child lexical scopes that of the current lexical scope.

    */
    open func GetChildren() throws -> dotnet.System_Arr<dotnet.System.Diagnostics.SymbolStore.ISymbolScope> {
        var __thrown : NullableHandle = nil;
        let __return = System_Diagnostics_SymbolStore_ISymbolScope_ISymbolScopeArray__GetChildren_0__0(&__thrown, self.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return dotnet.System_Arr<dotnet.System.Diagnostics.SymbolStore.ISymbolScope>(hndl : __return);
        }
    }
    // System.Diagnostics.SymbolStore.ISymbolVariable[] GetLocals()
// docid: M:System.Diagnostics.SymbolStore.ISymbolScope.GetLocals
    /**
    Gets the local variables within the current lexical scope.

    - Returns: The local variables within the current lexical scope.

    */
    open func GetLocals() throws -> dotnet.System_Arr<dotnet.System.Diagnostics.SymbolStore.ISymbolVariable> {
        var __thrown : NullableHandle = nil;
        let __return = System_Diagnostics_SymbolStore_ISymbolScope_ISymbolVariableArray__GetLocals_0__0(&__thrown, self.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return dotnet.System_Arr<dotnet.System.Diagnostics.SymbolStore.ISymbolVariable>(hndl : __return);
        }
    }
    // System.Diagnostics.SymbolStore.ISymbolNamespace[] GetNamespaces()
// docid: M:System.Diagnostics.SymbolStore.ISymbolScope.GetNamespaces
    /**
    Gets the namespaces that are used within the current scope.

    - Returns: The namespaces that are used within the current scope.

    */
    open func GetNamespaces() throws -> dotnet.System_Arr<dotnet.System.Diagnostics.SymbolStore.ISymbolNamespace> {
        var __thrown : NullableHandle = nil;
        let __return = System_Diagnostics_SymbolStore_ISymbolScope_ISymbolNamespaceArray__GetNamespaces_0__0(&__thrown, self.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return dotnet.System_Arr<dotnet.System.Diagnostics.SymbolStore.ISymbolNamespace>(hndl : __return);
        }
    }
    // [IsSpecialName] System.Int32 get_EndOffset()
// docid: M:System.Diagnostics.SymbolStore.ISymbolScope.get_EndOffset
    open func get_EndOffset() throws -> Swift.Int32 {
        var __thrown : NullableHandle = nil;
        let __return = System_Diagnostics_SymbolStore_ISymbolScope_i32__get_EndOffset_0__0(&__thrown, self.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return __return;
        }
    }
    // [IsSpecialName] System.Diagnostics.SymbolStore.ISymbolMethod get_Method()
// docid: M:System.Diagnostics.SymbolStore.ISymbolScope.get_Method
    open func get_Method() throws -> dotnet.System.Diagnostics.SymbolStore.ISymbolMethod {
        var __thrown : NullableHandle = nil;
        let __return = System_Diagnostics_SymbolStore_ISymbolScope_ISymbolMethod__get_Method_0__0(&__thrown, self.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return dotnet.System.Diagnostics.SymbolStore.ISymbolMethod(hndl : __return);
        }
    }
    // [IsSpecialName] System.Diagnostics.SymbolStore.ISymbolScope get_Parent()
// docid: M:System.Diagnostics.SymbolStore.ISymbolScope.get_Parent
    open func get_Parent() throws -> dotnet.System.Diagnostics.SymbolStore.ISymbolScope {
        var __thrown : NullableHandle = nil;
        let __return = System_Diagnostics_SymbolStore_ISymbolScope_ISymbolScope__get_Parent_0__0(&__thrown, self.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return dotnet.System.Diagnostics.SymbolStore.ISymbolScope(hndl : __return);
        }
    }
    // [IsSpecialName] System.Int32 get_StartOffset()
// docid: M:System.Diagnostics.SymbolStore.ISymbolScope.get_StartOffset
    open func get_StartOffset() throws -> Swift.Int32 {
        var __thrown : NullableHandle = nil;
        let __return = System_Diagnostics_SymbolStore_ISymbolScope_i32__get_StartOffset_0__0(&__thrown, self.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return __return;
        }
    }
} // ISymbolScope


// type: System.Diagnostics.SymbolStore.ISymbolVariable
    /**
    Represents a variable within a symbol store.

    */
open class ISymbolVariable
    :
    SGBridgeGenericValue,
    System_Diagnostics_SymbolStore_ISymbolVariable
{
    open class func get_type_handle() -> TypeHandle {
        return System_Diagnostics_SymbolStore_ISymbolVariable_get_type_handle();
    }
    let h : NonnullHandle;
    public func to_gval() -> GVal { return GVal(Swift.Int(bitPattern: self.h)); }
    public func dup_gval() -> GVal { return GVal(Swift.Int(bitPattern: __copy_handle(self.h))); }
    public required init(gval: GVal) { self.h = NonnullHandle(bitPattern: Swift.Int(truncatingIfNeeded: gval))!; }
    public required init(hndl: NonnullHandle) { self.h = hndl; }
    public func get_handle() -> NonnullHandle { return self.h; }

    deinit { __drop_handle(self.h); }

    // System.Byte[] GetSignature()
// docid: M:System.Diagnostics.SymbolStore.ISymbolVariable.GetSignature
    /**
    Gets the variable signature.

    - Returns: The variable signature as an opaque blob.

    */
    open func GetSignature() throws -> dotnet.System_Arr<Swift.UInt8> {
        var __thrown : NullableHandle = nil;
        let __return = System_Diagnostics_SymbolStore_ISymbolVariable_u8Array__GetSignature_0__0(&__thrown, self.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return dotnet.System_Arr<Swift.UInt8>(hndl : __return);
        }
    }
    // [IsSpecialName] System.Int32 get_AddressField1()
// docid: M:System.Diagnostics.SymbolStore.ISymbolVariable.get_AddressField1
    open func get_AddressField1() throws -> Swift.Int32 {
        var __thrown : NullableHandle = nil;
        let __return = System_Diagnostics_SymbolStore_ISymbolVariable_i32__get_AddressField1_0__0(&__thrown, self.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return __return;
        }
    }
    // [IsSpecialName] System.Int32 get_AddressField2()
// docid: M:System.Diagnostics.SymbolStore.ISymbolVariable.get_AddressField2
    open func get_AddressField2() throws -> Swift.Int32 {
        var __thrown : NullableHandle = nil;
        let __return = System_Diagnostics_SymbolStore_ISymbolVariable_i32__get_AddressField2_0__0(&__thrown, self.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return __return;
        }
    }
    // [IsSpecialName] System.Int32 get_AddressField3()
// docid: M:System.Diagnostics.SymbolStore.ISymbolVariable.get_AddressField3
    open func get_AddressField3() throws -> Swift.Int32 {
        var __thrown : NullableHandle = nil;
        let __return = System_Diagnostics_SymbolStore_ISymbolVariable_i32__get_AddressField3_0__0(&__thrown, self.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return __return;
        }
    }
    // [IsSpecialName] System.Diagnostics.SymbolStore.SymAddressKind get_AddressKind()
// docid: M:System.Diagnostics.SymbolStore.ISymbolVariable.get_AddressKind
    open func get_AddressKind() throws -> dotnet.System.Diagnostics.SymbolStore.SymAddressKind {
        var __thrown : NullableHandle = nil;
        let __return = System_Diagnostics_SymbolStore_ISymbolVariable_SymAddressKind__get_AddressKind_0__0(&__thrown, self.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return dotnet.System.Diagnostics.SymbolStore.SymAddressKind(val: __return);
        }
    }
    // [IsSpecialName] System.Object get_Attributes()
// docid: M:System.Diagnostics.SymbolStore.ISymbolVariable.get_Attributes
    open func get_Attributes() throws -> dotnet.System.Object {
        var __thrown : NullableHandle = nil;
        let __return = System_Diagnostics_SymbolStore_ISymbolVariable_Object__get_Attributes_0__0(&__thrown, self.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return dotnet.System.Object(hndl : __return);
        }
    }
    // [IsSpecialName] System.Int32 get_EndOffset()
// docid: M:System.Diagnostics.SymbolStore.ISymbolVariable.get_EndOffset
    open func get_EndOffset() throws -> Swift.Int32 {
        var __thrown : NullableHandle = nil;
        let __return = System_Diagnostics_SymbolStore_ISymbolVariable_i32__get_EndOffset_0__0(&__thrown, self.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return __return;
        }
    }
    // [IsSpecialName] System.String get_Name()
// docid: M:System.Diagnostics.SymbolStore.ISymbolVariable.get_Name
    open func get_Name() throws -> dotnet.System.String {
        var __thrown : NullableHandle = nil;
        let __return = System_Diagnostics_SymbolStore_ISymbolVariable_String__get_Name_0__0(&__thrown, self.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return dotnet.System.String(hndl : __return);
        }
    }
    // [IsSpecialName] System.Int32 get_StartOffset()
// docid: M:System.Diagnostics.SymbolStore.ISymbolVariable.get_StartOffset
    open func get_StartOffset() throws -> Swift.Int32 {
        var __thrown : NullableHandle = nil;
        let __return = System_Diagnostics_SymbolStore_ISymbolVariable_i32__get_StartOffset_0__0(&__thrown, self.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return __return;
        }
    }
} // ISymbolVariable


// type: System.Diagnostics.SymbolStore.ISymbolWriter
    /**
    Represents a symbol writer for managed code.

    */
open class ISymbolWriter
    :
    SGBridgeGenericValue,
    System_Diagnostics_SymbolStore_ISymbolWriter
{
    open class func get_type_handle() -> TypeHandle {
        return System_Diagnostics_SymbolStore_ISymbolWriter_get_type_handle();
    }
    let h : NonnullHandle;
    public func to_gval() -> GVal { return GVal(Swift.Int(bitPattern: self.h)); }
    public func dup_gval() -> GVal { return GVal(Swift.Int(bitPattern: __copy_handle(self.h))); }
    public required init(gval: GVal) { self.h = NonnullHandle(bitPattern: Swift.Int(truncatingIfNeeded: gval))!; }
    public required init(hndl: NonnullHandle) { self.h = hndl; }
    public func get_handle() -> NonnullHandle { return self.h; }

    deinit { __drop_handle(self.h); }

    // void Close()
// docid: M:System.Diagnostics.SymbolStore.ISymbolWriter.Close
    /**
    Closes  and commits the symbols to the symbol store.

    */
    open func Close() throws {
        var __thrown : NullableHandle = nil;
        System_Diagnostics_SymbolStore_ISymbolWriter_void__Close_0__0(&__thrown, self.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
            return;
        }
    }
    // void CloseMethod()
// docid: M:System.Diagnostics.SymbolStore.ISymbolWriter.CloseMethod
    /**
    Closes the current method.

    */
    open func CloseMethod() throws {
        var __thrown : NullableHandle = nil;
        System_Diagnostics_SymbolStore_ISymbolWriter_void__CloseMethod_0__0(&__thrown, self.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
            return;
        }
    }
    // void CloseNamespace()
// docid: M:System.Diagnostics.SymbolStore.ISymbolWriter.CloseNamespace
    /**
    Closes the most recent namespace.

    */
    open func CloseNamespace() throws {
        var __thrown : NullableHandle = nil;
        System_Diagnostics_SymbolStore_ISymbolWriter_void__CloseNamespace_0__0(&__thrown, self.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
            return;
        }
    }
    // void CloseScope(System.Int32)
// docid: M:System.Diagnostics.SymbolStore.ISymbolWriter.CloseScope(System.Int32)
    /**
    Closes the current lexical scope.

    - Parameter endOffset: The points past the last instruction in the scope.
    */
    open func CloseScope(endOffset : Swift.Int32) throws {
        var __thrown : NullableHandle = nil;
        System_Diagnostics_SymbolStore_ISymbolWriter_void__CloseScope_0__1__i32(&__thrown, self.get_handle(), endOffset);
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
            return;
        }
    }
    // System.Diagnostics.SymbolStore.ISymbolDocumentWriter DefineDocument(System.String, System.Guid, System.Guid, System.Guid)
// docid: M:System.Diagnostics.SymbolStore.ISymbolWriter.DefineDocument(System.String,System.Guid,System.Guid,System.Guid)
    /**
    Defines a source document.

    - Parameter url: The URL that identifies the document.
    - Parameter language: The document language. This parameter can be .
    - Parameter languageVendor: The identity of the vendor for the document language. This parameter can be .
    - Parameter documentType: The type of the document. This parameter can be .
    - Returns: The object that represents the document.

    */
    open func DefineDocument(url : dotnet.System.String, language : dotnet.System.Guid, languageVendor : dotnet.System.Guid, documentType : dotnet.System.Guid) throws -> dotnet.System.Diagnostics.SymbolStore.ISymbolDocumentWriter {
        var __thrown : NullableHandle = nil;
        let __return = System_Diagnostics_SymbolStore_ISymbolWriter_ISymbolDocumentWriter__DefineDocument_0__4__String_Guid_Guid_Guid(&__thrown, self.get_handle(), url.get_handle(), language.get_handle(), languageVendor.get_handle(), documentType.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return dotnet.System.Diagnostics.SymbolStore.ISymbolDocumentWriter(hndl : __return);
        }
    }
    // void DefineField(System.Diagnostics.SymbolStore.SymbolToken, System.String, System.Reflection.FieldAttributes, System.Byte[], System.Diagnostics.SymbolStore.SymAddressKind, System.Int32, System.Int32, System.Int32)
// docid: M:System.Diagnostics.SymbolStore.ISymbolWriter.DefineField(System.Diagnostics.SymbolStore.SymbolToken,System.String,System.Reflection.FieldAttributes,System.Byte[],System.Diagnostics.SymbolStore.SymAddressKind,System.Int32,System.Int32,System.Int32)
    /**
    Defines a field in a type or a global field.

    - Parameter parent: The metadata type or method token.
    - Parameter name: The field name.
    - Parameter attributes: A bitwise combination of the field attributes.
    - Parameter signature: The field signature.
    - Parameter addrKind: The address types for  and .
    - Parameter addr1: The first address for the field specification.
    - Parameter addr2: The second address for the field specification.
    - Parameter addr3: The third address for the field specification.
    */
    open func DefineField(parent : dotnet.System.Diagnostics.SymbolStore.SymbolToken, name : dotnet.System.String, attributes : dotnet.System.Reflection.FieldAttributes, signature : dotnet.System_Arr<Swift.UInt8>, addrKind : dotnet.System.Diagnostics.SymbolStore.SymAddressKind, addr1 : Swift.Int32, addr2 : Swift.Int32, addr3 : Swift.Int32) throws {
        var __thrown : NullableHandle = nil;
        System_Diagnostics_SymbolStore_ISymbolWriter_void__DefineField_0__8__SymbolToken_String_FieldAttributes_u8Array_SymAddressKind_i32_i32_i32(&__thrown, self.get_handle(), parent.get_handle(), name.get_handle(), attributes.get_value(), signature.get_handle(), addrKind.get_value(), addr1, addr2, addr3);
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
            return;
        }
    }
    // void DefineGlobalVariable(System.String, System.Reflection.FieldAttributes, System.Byte[], System.Diagnostics.SymbolStore.SymAddressKind, System.Int32, System.Int32, System.Int32)
// docid: M:System.Diagnostics.SymbolStore.ISymbolWriter.DefineGlobalVariable(System.String,System.Reflection.FieldAttributes,System.Byte[],System.Diagnostics.SymbolStore.SymAddressKind,System.Int32,System.Int32,System.Int32)
    /**
    Defines a single global variable.

    - Parameter name: The global variable name.
    - Parameter attributes: A bitwise combination of the global variable attributes.
    - Parameter signature: The global variable signature.
    - Parameter addrKind: The address types for , , and .
    - Parameter addr1: The first address for the global variable specification.
    - Parameter addr2: The second address for the global variable specification.
    - Parameter addr3: The third address for the global variable specification.
    */
    open func DefineGlobalVariable(name : dotnet.System.String, attributes : dotnet.System.Reflection.FieldAttributes, signature : dotnet.System_Arr<Swift.UInt8>, addrKind : dotnet.System.Diagnostics.SymbolStore.SymAddressKind, addr1 : Swift.Int32, addr2 : Swift.Int32, addr3 : Swift.Int32) throws {
        var __thrown : NullableHandle = nil;
        System_Diagnostics_SymbolStore_ISymbolWriter_void__DefineGlobalVariable_0__7__String_FieldAttributes_u8Array_SymAddressKind_i32_i32_i32(&__thrown, self.get_handle(), name.get_handle(), attributes.get_value(), signature.get_handle(), addrKind.get_value(), addr1, addr2, addr3);
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
            return;
        }
    }
    // void DefineLocalVariable(System.String, System.Reflection.FieldAttributes, System.Byte[], System.Diagnostics.SymbolStore.SymAddressKind, System.Int32, System.Int32, System.Int32, System.Int32, System.Int32)
// docid: M:System.Diagnostics.SymbolStore.ISymbolWriter.DefineLocalVariable(System.String,System.Reflection.FieldAttributes,System.Byte[],System.Diagnostics.SymbolStore.SymAddressKind,System.Int32,System.Int32,System.Int32,System.Int32,System.Int32)
    /**
    Defines a single variable in the current lexical scope.

    - Parameter name: The local variable name.
    - Parameter attributes: A bitwise combination of the local variable attributes.
    - Parameter signature: The local variable signature.
    - Parameter addrKind: The address types for , , and .
    - Parameter addr1: The first address for the local variable specification.
    - Parameter addr2: The second address for the local variable specification.
    - Parameter addr3: The third address for the local variable specification.
    - Parameter startOffset: The start offset for the variable. If this parameter is zero, it is ignored and the variable is defined throughout the entire scope. If the parameter is nonzero, the variable falls within the offsets of the current scope.
    - Parameter endOffset: The end offset for the variable. If this parameter is zero, it is ignored and the variable is defined throughout the entire scope. If the parameter is nonzero, the variable falls within the offsets of the current scope.
    */
    open func DefineLocalVariable(name : dotnet.System.String, attributes : dotnet.System.Reflection.FieldAttributes, signature : dotnet.System_Arr<Swift.UInt8>, addrKind : dotnet.System.Diagnostics.SymbolStore.SymAddressKind, addr1 : Swift.Int32, addr2 : Swift.Int32, addr3 : Swift.Int32, startOffset : Swift.Int32, endOffset : Swift.Int32) throws {
        var __thrown : NullableHandle = nil;
        System_Diagnostics_SymbolStore_ISymbolWriter_void__DefineLocalVariable_0__9__String_FieldAttributes_u8Array_SymAddressKind_i32_i32_i32_i32_i32(&__thrown, self.get_handle(), name.get_handle(), attributes.get_value(), signature.get_handle(), addrKind.get_value(), addr1, addr2, addr3, startOffset, endOffset);
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
            return;
        }
    }
    // void DefineParameter(System.String, System.Reflection.ParameterAttributes, System.Int32, System.Diagnostics.SymbolStore.SymAddressKind, System.Int32, System.Int32, System.Int32)
// docid: M:System.Diagnostics.SymbolStore.ISymbolWriter.DefineParameter(System.String,System.Reflection.ParameterAttributes,System.Int32,System.Diagnostics.SymbolStore.SymAddressKind,System.Int32,System.Int32,System.Int32)
    /**
    Defines a single parameter in the current method. The type of each parameter is taken from its position within the signature of the method.

    - Parameter name: The parameter name.
    - Parameter attributes: A bitwise combination of the parameter attributes.
    - Parameter sequence: The parameter signature.
    - Parameter addrKind: The address types for , , and .
    - Parameter addr1: The first address for the parameter specification.
    - Parameter addr2: The second address for the parameter specification.
    - Parameter addr3: The third address for the parameter specification.
    */
    open func DefineParameter(name : dotnet.System.String, attributes : dotnet.System.Reflection.ParameterAttributes, sequence : Swift.Int32, addrKind : dotnet.System.Diagnostics.SymbolStore.SymAddressKind, addr1 : Swift.Int32, addr2 : Swift.Int32, addr3 : Swift.Int32) throws {
        var __thrown : NullableHandle = nil;
        System_Diagnostics_SymbolStore_ISymbolWriter_void__DefineParameter_0__7__String_ParameterAttributes_i32_SymAddressKind_i32_i32_i32(&__thrown, self.get_handle(), name.get_handle(), attributes.get_value(), sequence, addrKind.get_value(), addr1, addr2, addr3);
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
            return;
        }
    }
    // void DefineSequencePoints(System.Diagnostics.SymbolStore.ISymbolDocumentWriter, System.Int32[], System.Int32[], System.Int32[], System.Int32[], System.Int32[])
// docid: M:System.Diagnostics.SymbolStore.ISymbolWriter.DefineSequencePoints(System.Diagnostics.SymbolStore.ISymbolDocumentWriter,System.Int32[],System.Int32[],System.Int32[],System.Int32[],System.Int32[])
    /**
    Defines a group of sequence points within the current method.

    - Parameter document: The document object for which the sequence points are being defined.
    - Parameter offsets: The sequence point offsets measured from the beginning of methods.
    - Parameter lines: The document lines for the sequence points.
    - Parameter columns: The document positions for the sequence points.
    - Parameter endLines: The document end lines for the sequence points.
    - Parameter endColumns: The document end positions for the sequence points.
    */
    open func DefineSequencePoints(document : dotnet.System.Diagnostics.SymbolStore.ISymbolDocumentWriter, offsets : dotnet.System_Arr<Swift.Int32>, lines : dotnet.System_Arr<Swift.Int32>, columns : dotnet.System_Arr<Swift.Int32>, endLines : dotnet.System_Arr<Swift.Int32>, endColumns : dotnet.System_Arr<Swift.Int32>) throws {
        var __thrown : NullableHandle = nil;
        System_Diagnostics_SymbolStore_ISymbolWriter_void__DefineSequencePoints_0__6__ISymbolDocumentWriter_i32Array_i32Array_i32Array_i32Array_i32Array(&__thrown, self.get_handle(), document.get_handle(), offsets.get_handle(), lines.get_handle(), columns.get_handle(), endLines.get_handle(), endColumns.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
            return;
        }
    }
    // void Initialize(System.IntPtr, System.String, bool)
// docid: M:System.Diagnostics.SymbolStore.ISymbolWriter.Initialize(System.IntPtr,System.String,System.Boolean)
    /**
    Sets the metadata emitter interface to associate with a writer.

    - Parameter emitter: The metadata emitter interface.
    - Parameter filename: The file name for which the debugging symbols are written. Some writers require a file name, and others do not. If a file name is specified for a writer that does not use file names, this parameter is ignored.
    - Parameter fFullBuild: 
         indicates that this is a full rebuild;  indicates that this is an incremental compilation.
    */
    open func Initialize(emitter : dotnet.System.IntPtr, filename : dotnet.System.String, fFullBuild : Bool) throws {
        var __thrown : NullableHandle = nil;
        System_Diagnostics_SymbolStore_ISymbolWriter_void__Initialize_0__3__IntPtr_String_bool(&__thrown, self.get_handle(), emitter.get_value(), filename.get_handle(), Swift.Int32(fFullBuild ? 1 : 0));
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
            return;
        }
    }
    // void OpenMethod(System.Diagnostics.SymbolStore.SymbolToken)
// docid: M:System.Diagnostics.SymbolStore.ISymbolWriter.OpenMethod(System.Diagnostics.SymbolStore.SymbolToken)
    /**
    Opens a method to place symbol information into.

    - Parameter method: The metadata token for the method to be opened.
    */
    open func OpenMethod(method : dotnet.System.Diagnostics.SymbolStore.SymbolToken) throws {
        var __thrown : NullableHandle = nil;
        System_Diagnostics_SymbolStore_ISymbolWriter_void__OpenMethod_0__1__SymbolToken(&__thrown, self.get_handle(), method.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
            return;
        }
    }
    // void OpenNamespace(System.String)
// docid: M:System.Diagnostics.SymbolStore.ISymbolWriter.OpenNamespace(System.String)
    /**
    Opens a new namespace.

    - Parameter name: The name of the new namespace.
    */
    open func OpenNamespace(name : dotnet.System.String) throws {
        var __thrown : NullableHandle = nil;
        System_Diagnostics_SymbolStore_ISymbolWriter_void__OpenNamespace_0__1__String(&__thrown, self.get_handle(), name.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
            return;
        }
    }
    // System.Int32 OpenScope(System.Int32)
// docid: M:System.Diagnostics.SymbolStore.ISymbolWriter.OpenScope(System.Int32)
    /**
    Opens a new lexical scope in the current method.

    - Parameter startOffset: The offset, in bytes, from the beginning of the method to the first instruction in the lexical scope.
    - Returns: An opaque scope identifier that can be used with  to define the start and end offsets of a scope at a later time. In this case, the offsets passed to  and  are ignored. A scope identifier is valid only in the current method.

    */
    open func OpenScope(startOffset : Swift.Int32) throws -> Swift.Int32 {
        var __thrown : NullableHandle = nil;
        let __return = System_Diagnostics_SymbolStore_ISymbolWriter_i32__OpenScope_0__1__i32(&__thrown, self.get_handle(), startOffset);
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return __return;
        }
    }
    // void SetMethodSourceRange(System.Diagnostics.SymbolStore.ISymbolDocumentWriter, System.Int32, System.Int32, System.Diagnostics.SymbolStore.ISymbolDocumentWriter, System.Int32, System.Int32)
// docid: M:System.Diagnostics.SymbolStore.ISymbolWriter.SetMethodSourceRange(System.Diagnostics.SymbolStore.ISymbolDocumentWriter,System.Int32,System.Int32,System.Diagnostics.SymbolStore.ISymbolDocumentWriter,System.Int32,System.Int32)
    /**
    Specifies the true start and end of a method within a source file. Use  to specify the extent of a method, independent of the sequence points that exist within the method.

    - Parameter startDoc: The document that contains the starting position.
    - Parameter startLine: The starting line number.
    - Parameter startColumn: The starting column.
    - Parameter endDoc: The document that contains the ending position.
    - Parameter endLine: The ending line number.
    - Parameter endColumn: The ending column number.
    */
    open func SetMethodSourceRange(startDoc : dotnet.System.Diagnostics.SymbolStore.ISymbolDocumentWriter, startLine : Swift.Int32, startColumn : Swift.Int32, endDoc : dotnet.System.Diagnostics.SymbolStore.ISymbolDocumentWriter, endLine : Swift.Int32, endColumn : Swift.Int32) throws {
        var __thrown : NullableHandle = nil;
        System_Diagnostics_SymbolStore_ISymbolWriter_void__SetMethodSourceRange_0__6__ISymbolDocumentWriter_i32_i32_ISymbolDocumentWriter_i32_i32(&__thrown, self.get_handle(), startDoc.get_handle(), startLine, startColumn, endDoc.get_handle(), endLine, endColumn);
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
            return;
        }
    }
    // void SetScopeRange(System.Int32, System.Int32, System.Int32)
// docid: M:System.Diagnostics.SymbolStore.ISymbolWriter.SetScopeRange(System.Int32,System.Int32,System.Int32)
    /**
    Defines the offset range for the specified lexical scope.

    - Parameter scopeID: The identifier of the lexical scope.
    - Parameter startOffset: The byte offset of the beginning of the lexical scope.
    - Parameter endOffset: The byte offset of the end of the lexical scope.
    */
    open func SetScopeRange(scopeID : Swift.Int32, startOffset : Swift.Int32, endOffset : Swift.Int32) throws {
        var __thrown : NullableHandle = nil;
        System_Diagnostics_SymbolStore_ISymbolWriter_void__SetScopeRange_0__3__i32_i32_i32(&__thrown, self.get_handle(), scopeID, startOffset, endOffset);
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
            return;
        }
    }
    // void SetSymAttribute(System.Diagnostics.SymbolStore.SymbolToken, System.String, System.Byte[])
// docid: M:System.Diagnostics.SymbolStore.ISymbolWriter.SetSymAttribute(System.Diagnostics.SymbolStore.SymbolToken,System.String,System.Byte[])
    /**
    Defines an attribute when given the attribute name and the attribute value.

    - Parameter parent: The metadata token for which the attribute is being defined.
    - Parameter name: The attribute name.
    - Parameter data: The attribute value.
    */
    open func SetSymAttribute(parent : dotnet.System.Diagnostics.SymbolStore.SymbolToken, name : dotnet.System.String, data : dotnet.System_Arr<Swift.UInt8>) throws {
        var __thrown : NullableHandle = nil;
        System_Diagnostics_SymbolStore_ISymbolWriter_void__SetSymAttribute_0__3__SymbolToken_String_u8Array(&__thrown, self.get_handle(), parent.get_handle(), name.get_handle(), data.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
            return;
        }
    }
    // void SetUnderlyingWriter(System.IntPtr)
// docid: M:System.Diagnostics.SymbolStore.ISymbolWriter.SetUnderlyingWriter(System.IntPtr)
    /**
    Sets the underlying  (the corresponding unmanaged interface) that a managed  uses to emit symbols.

    - Parameter underlyingWriter: A pointer to code that represents the underlying writer.
    */
    open func SetUnderlyingWriter(underlyingWriter : dotnet.System.IntPtr) throws {
        var __thrown : NullableHandle = nil;
        System_Diagnostics_SymbolStore_ISymbolWriter_void__SetUnderlyingWriter_0__1__IntPtr(&__thrown, self.get_handle(), underlyingWriter.get_value());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
            return;
        }
    }
    // void SetUserEntryPoint(System.Diagnostics.SymbolStore.SymbolToken)
// docid: M:System.Diagnostics.SymbolStore.ISymbolWriter.SetUserEntryPoint(System.Diagnostics.SymbolStore.SymbolToken)
    /**
    Identifies the user-defined method as the entry point for the current module.

    - Parameter entryMethod: The metadata token for the method that is the user entry point.
    */
    open func SetUserEntryPoint(entryMethod : dotnet.System.Diagnostics.SymbolStore.SymbolToken) throws {
        var __thrown : NullableHandle = nil;
        System_Diagnostics_SymbolStore_ISymbolWriter_void__SetUserEntryPoint_0__1__SymbolToken(&__thrown, self.get_handle(), entryMethod.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
            return;
        }
    }
    // void UsingNamespace(System.String)
// docid: M:System.Diagnostics.SymbolStore.ISymbolWriter.UsingNamespace(System.String)
    /**
    Specifies that the given, fully qualified namespace name is used within the open lexical scope.

    - Parameter fullName: The fully qualified name of the namespace.
    */
    open func UsingNamespace(fullName : dotnet.System.String) throws {
        var __thrown : NullableHandle = nil;
        System_Diagnostics_SymbolStore_ISymbolWriter_void__UsingNamespace_0__1__String(&__thrown, self.get_handle(), fullName.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
            return;
        }
    }
} // ISymbolWriter


// type: System.Diagnostics.SymbolStore.SymAddressKind
    /**
    Specifies address types for local variables, parameters, and fields in the methods , , and  of the  interface.

    */
public struct SymAddressKind : SGBridgeGenericValue {
    let v : Swift.Int32;
    public init(val: Swift.Int32) { self.v = val; }
    public func get_value() -> Swift.Int32 { return self.v; }
    public static func get_type_handle() -> TypeHandle {
        return System_Diagnostics_SymbolStore_SymAddressKind_get_type_handle();
    }
    public func to_gval() -> GVal { return GVal(self.v); }
    public func dup_gval() -> GVal { return to_gval(); }
    public init(gval: GVal) { self.v = Swift.Int32(gval); }
    // static field: System.Diagnostics.SymbolStore.SymAddressKind ILOffset
    /**
    A Microsoft intermediate language (MSIL) offset. The  parameter is the MSIL local variable or parameter index.

    */
    public static var ILOffset : dotnet.System.Diagnostics.SymbolStore.SymAddressKind {
        get {
        let __return = dotnet.System.Diagnostics.SymbolStore.SymAddressKind(val: System_Diagnostics_SymbolStore_SymAddressKind_get_ILOffset());
            return __return;
        }
    }
    // static field: System.Diagnostics.SymbolStore.SymAddressKind NativeRVA
    /**
    A native Relevant Virtual Address (RVA). The  parameter is the RVA in the module.

    */
    public static var NativeRVA : dotnet.System.Diagnostics.SymbolStore.SymAddressKind {
        get {
        let __return = dotnet.System.Diagnostics.SymbolStore.SymAddressKind(val: System_Diagnostics_SymbolStore_SymAddressKind_get_NativeRVA());
            return __return;
        }
    }
    // static field: System.Diagnostics.SymbolStore.SymAddressKind NativeRegister
    /**
    A native register address. The  parameter is the register in which the variable is stored.

    */
    public static var NativeRegister : dotnet.System.Diagnostics.SymbolStore.SymAddressKind {
        get {
        let __return = dotnet.System.Diagnostics.SymbolStore.SymAddressKind(val: System_Diagnostics_SymbolStore_SymAddressKind_get_NativeRegister());
            return __return;
        }
    }
    // static field: System.Diagnostics.SymbolStore.SymAddressKind NativeRegisterRelative
    /**
    A register-relative address. The  parameter is the register, and the  parameter is the offset.

    */
    public static var NativeRegisterRelative : dotnet.System.Diagnostics.SymbolStore.SymAddressKind {
        get {
        let __return = dotnet.System.Diagnostics.SymbolStore.SymAddressKind(val: System_Diagnostics_SymbolStore_SymAddressKind_get_NativeRegisterRelative());
            return __return;
        }
    }
    // static field: System.Diagnostics.SymbolStore.SymAddressKind NativeOffset
    /**
    A native offset. The  parameter is the offset from the start of the parent.

    */
    public static var NativeOffset : dotnet.System.Diagnostics.SymbolStore.SymAddressKind {
        get {
        let __return = dotnet.System.Diagnostics.SymbolStore.SymAddressKind(val: System_Diagnostics_SymbolStore_SymAddressKind_get_NativeOffset());
            return __return;
        }
    }
    // static field: System.Diagnostics.SymbolStore.SymAddressKind NativeRegisterRegister
    /**
    A register-relative address. The  parameter is the low-order register, and the  parameter is the high-order register.

    */
    public static var NativeRegisterRegister : dotnet.System.Diagnostics.SymbolStore.SymAddressKind {
        get {
        let __return = dotnet.System.Diagnostics.SymbolStore.SymAddressKind(val: System_Diagnostics_SymbolStore_SymAddressKind_get_NativeRegisterRegister());
            return __return;
        }
    }
    // static field: System.Diagnostics.SymbolStore.SymAddressKind NativeRegisterStack
    /**
    A register-relative address. The  parameter is the low-order register, the  parameter is the stack register, and the  parameter is the offset from the stack pointer to the high-order part of the value.

    */
    public static var NativeRegisterStack : dotnet.System.Diagnostics.SymbolStore.SymAddressKind {
        get {
        let __return = dotnet.System.Diagnostics.SymbolStore.SymAddressKind(val: System_Diagnostics_SymbolStore_SymAddressKind_get_NativeRegisterStack());
            return __return;
        }
    }
    // static field: System.Diagnostics.SymbolStore.SymAddressKind NativeStackRegister
    /**
    A register-relative address. The  parameter is the stack register, the  parameter is the offset from the stack pointer to the low-order part of the value, and the  parameter is the high-order register.

    */
    public static var NativeStackRegister : dotnet.System.Diagnostics.SymbolStore.SymAddressKind {
        get {
        let __return = dotnet.System.Diagnostics.SymbolStore.SymAddressKind(val: System_Diagnostics_SymbolStore_SymAddressKind_get_NativeStackRegister());
            return __return;
        }
    }
    // static field: System.Diagnostics.SymbolStore.SymAddressKind BitField
    /**
    A bit field. The  parameter is the position where the field starts, and the  parameter is the field length.

    */
    public static var BitField : dotnet.System.Diagnostics.SymbolStore.SymAddressKind {
        get {
        let __return = dotnet.System.Diagnostics.SymbolStore.SymAddressKind(val: System_Diagnostics_SymbolStore_SymAddressKind_get_BitField());
            return __return;
        }
    }
    // static field: System.Diagnostics.SymbolStore.SymAddressKind NativeSectionOffset
    /**
    A native section offset. The  parameter is the section, and the  parameter is the offset.

    */
    public static var NativeSectionOffset : dotnet.System.Diagnostics.SymbolStore.SymAddressKind {
        get {
        let __return = dotnet.System.Diagnostics.SymbolStore.SymAddressKind(val: System_Diagnostics_SymbolStore_SymAddressKind_get_NativeSectionOffset());
            return __return;
        }
    }
} // SymAddressKind


// type: System.Diagnostics.SymbolStore.SymDocumentType
    /**
    Holds the public GUIDs for document types to be used with the symbol store.

    */
open class SymDocumentType
    :
    dotnet.System.Object
{
    open class override func get_type_handle() -> TypeHandle {
        return System_Diagnostics_SymbolStore_SymDocumentType_get_type_handle();
    }
    public required init(hndl: NonnullHandle) { super.init(hndl: hndl); }
    public required init(gval: GVal) { super.init(gval: gval); }
    // static field: System.Guid Text
    /**
    Specifies the GUID of the document type to be used with the symbol store.

    */
    open class var Text : dotnet.System.Guid {
        get {
        let __return = dotnet.System.Guid(hndl: System_Diagnostics_SymbolStore_SymDocumentType_get_Text());
            return __return;
        }
    }
    // .ctor()
// docid: M:System.Diagnostics.SymbolStore.SymDocumentType.#ctor
    /**
    Initializes a new instance of the  class.

    */
    public override init() throws {
        var __thrown : NullableHandle = nil;
        let h = System_Diagnostics_SymbolStore_SymDocumentType_ctor_0__0(&__thrown);
        if let __ex = __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
            super.init(hndl: h);
        }
    }
} // SymDocumentType


// type: System.Diagnostics.SymbolStore.SymLanguageType
    /**
    Holds the public GUIDs for language types to be used with the symbol store.

    */
open class SymLanguageType
    :
    dotnet.System.Object
{
    open class override func get_type_handle() -> TypeHandle {
        return System_Diagnostics_SymbolStore_SymLanguageType_get_type_handle();
    }
    public required init(hndl: NonnullHandle) { super.init(hndl: hndl); }
    public required init(gval: GVal) { super.init(gval: gval); }
    // static field: System.Guid Basic
    /**
    Specifies the GUID of the Basic language type to be used with the symbol store.

    */
    open class var Basic : dotnet.System.Guid {
        get {
        let __return = dotnet.System.Guid(hndl: System_Diagnostics_SymbolStore_SymLanguageType_get_Basic());
            return __return;
        }
    }
    // static field: System.Guid C
    /**
    Specifies the GUID of the C language type to be used with the symbol store.

    */
    open class var C : dotnet.System.Guid {
        get {
        let __return = dotnet.System.Guid(hndl: System_Diagnostics_SymbolStore_SymLanguageType_get_C());
            return __return;
        }
    }
    // static field: System.Guid Cobol
    /**
    Specifies the GUID of the Cobol language type to be used with the symbol store.

    */
    open class var Cobol : dotnet.System.Guid {
        get {
        let __return = dotnet.System.Guid(hndl: System_Diagnostics_SymbolStore_SymLanguageType_get_Cobol());
            return __return;
        }
    }
    // static field: System.Guid CPlusPlus
    /**
    Specifies the GUID of the C++ language type to be used with the symbol store.

    */
    open class var CPlusPlus : dotnet.System.Guid {
        get {
        let __return = dotnet.System.Guid(hndl: System_Diagnostics_SymbolStore_SymLanguageType_get_CPlusPlus());
            return __return;
        }
    }
    // static field: System.Guid CSharp
    /**
    Specifies the GUID of the C# language type to be used with the symbol store.

    */
    open class var CSharp : dotnet.System.Guid {
        get {
        let __return = dotnet.System.Guid(hndl: System_Diagnostics_SymbolStore_SymLanguageType_get_CSharp());
            return __return;
        }
    }
    // static field: System.Guid ILAssembly
    /**
    Specifies the GUID of the ILAssembly language type to be used with the symbol store.

    */
    open class var ILAssembly : dotnet.System.Guid {
        get {
        let __return = dotnet.System.Guid(hndl: System_Diagnostics_SymbolStore_SymLanguageType_get_ILAssembly());
            return __return;
        }
    }
    // static field: System.Guid Java
    /**
    Specifies the GUID of the Java language type to be used with the symbol store.

    */
    open class var Java : dotnet.System.Guid {
        get {
        let __return = dotnet.System.Guid(hndl: System_Diagnostics_SymbolStore_SymLanguageType_get_Java());
            return __return;
        }
    }
    // static field: System.Guid JScript
    /**
    Specifies the GUID of the JScript language type to be used with the symbol store.

    */
    open class var JScript : dotnet.System.Guid {
        get {
        let __return = dotnet.System.Guid(hndl: System_Diagnostics_SymbolStore_SymLanguageType_get_JScript());
            return __return;
        }
    }
    // static field: System.Guid MCPlusPlus
    /**
    Specifies the GUID of the C++ language type to be used with the symbol store.

    */
    open class var MCPlusPlus : dotnet.System.Guid {
        get {
        let __return = dotnet.System.Guid(hndl: System_Diagnostics_SymbolStore_SymLanguageType_get_MCPlusPlus());
            return __return;
        }
    }
    // static field: System.Guid Pascal
    /**
    Specifies the GUID of the Pascal language type to be used with the symbol store.

    */
    open class var Pascal : dotnet.System.Guid {
        get {
        let __return = dotnet.System.Guid(hndl: System_Diagnostics_SymbolStore_SymLanguageType_get_Pascal());
            return __return;
        }
    }
    // static field: System.Guid SMC
    /**
    Specifies the GUID of the SMC language type to be used with the symbol store.

    */
    open class var SMC : dotnet.System.Guid {
        get {
        let __return = dotnet.System.Guid(hndl: System_Diagnostics_SymbolStore_SymLanguageType_get_SMC());
            return __return;
        }
    }
    // .ctor()
// docid: M:System.Diagnostics.SymbolStore.SymLanguageType.#ctor
    /**
    Initializes a new instance of the  class.

    */
    public override init() throws {
        var __thrown : NullableHandle = nil;
        let h = System_Diagnostics_SymbolStore_SymLanguageType_ctor_0__0(&__thrown);
        if let __ex = __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
            super.init(hndl: h);
        }
    }
} // SymLanguageType


// type: System.Diagnostics.SymbolStore.SymLanguageVendor
    /**
    Holds the public GUIDs for language vendors to be used with the symbol store.

    */
open class SymLanguageVendor
    :
    dotnet.System.Object
{
    open class override func get_type_handle() -> TypeHandle {
        return System_Diagnostics_SymbolStore_SymLanguageVendor_get_type_handle();
    }
    public required init(hndl: NonnullHandle) { super.init(hndl: hndl); }
    public required init(gval: GVal) { super.init(gval: gval); }
    // static field: System.Guid Microsoft
    /**
    Specifies the GUID of the Microsoft language vendor.

    */
    open class var Microsoft : dotnet.System.Guid {
        get {
        let __return = dotnet.System.Guid(hndl: System_Diagnostics_SymbolStore_SymLanguageVendor_get_Microsoft());
            return __return;
        }
    }
    // .ctor()
// docid: M:System.Diagnostics.SymbolStore.SymLanguageVendor.#ctor
    /**
    Initializes a new instance of the  class.

    */
    public override init() throws {
        var __thrown : NullableHandle = nil;
        let h = System_Diagnostics_SymbolStore_SymLanguageVendor_ctor_0__0(&__thrown);
        if let __ex = __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
            super.init(hndl: h);
        }
    }
} // SymLanguageVendor


// type: System.Diagnostics.SymbolStore.SymbolToken
// boxed value type
    /**
    The  structure is an object representation of a token that represents symbolic information.

    */
public final class SymbolToken
    :
    dotnet.System.Object
{
    public class override func get_type_handle() -> TypeHandle {
        return System_Diagnostics_SymbolStore_SymbolToken_get_type_handle();
    }
    public required init(hndl: NonnullHandle) { super.init(hndl: hndl); }
    public required init(gval: GVal) { super.init(gval: gval); }
    // .ctor(System.Int32)
// docid: M:System.Diagnostics.SymbolStore.SymbolToken.#ctor(System.Int32)
    /**
    Initializes a new instance of the  structure when given a value.

    - Parameter val: The value to be used for the token.
    */
    public init(val : Swift.Int32) throws {
        var __thrown : NullableHandle = nil;
        let h = System_Diagnostics_SymbolStore_SymbolToken_ctor_0__1__i32(&__thrown, val);
        if let __ex = __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
            super.init(hndl: h);
        }
    }
    public override init() {
        let h = System_Diagnostics_SymbolStore_SymbolToken_implicit_ctor();
            super.init(hndl: h);
    }
    // bool Equals(System.Diagnostics.SymbolStore.SymbolToken)
// docid: M:System.Diagnostics.SymbolStore.SymbolToken.Equals(System.Diagnostics.SymbolStore.SymbolToken)
    /**
    Determines whether  is equal to this instance.

    - Parameter obj: The  to check.
    - Returns: 
         if  is equal to this instance; otherwise, .

    */
    public func Equals(obj : dotnet.System.Diagnostics.SymbolStore.SymbolToken) throws -> Bool {
        var __thrown : NullableHandle = nil;
        let __return = System_Diagnostics_SymbolStore_SymbolToken_bool__Equals_0__1__SymbolToken(&__thrown, self.get_handle(), obj.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return (__return) != 0;
        }
    }
    // bool Equals(System.Object)
// docid: M:System.Diagnostics.SymbolStore.SymbolToken.Equals(System.Object)
    /**
    Determines whether  is an instance of  and is equal to this instance.

    - Parameter obj: The object to check.
    - Returns: 
         if  is an instance of  and is equal to this instance; otherwise, .

    */
    public override func Equals(obj : Optional<dotnet.System.Object>) throws -> Bool {
        var __thrown : NullableHandle = nil;
        let __return = System_Diagnostics_SymbolStore_SymbolToken_bool__Equals_0__1__Object(&__thrown, self.get_handle(), obj?.get_handle() ?? nil);
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return (__return) != 0;
        }
    }
    // System.Int32 GetHashCode()
// docid: M:System.Diagnostics.SymbolStore.SymbolToken.GetHashCode
    /**
    Generates the hash code for the current token.

    - Returns: The hash code for the current token.

    */
    public override func GetHashCode() throws -> Swift.Int32 {
        var __thrown : NullableHandle = nil;
        let __return = System_Diagnostics_SymbolStore_SymbolToken_i32__GetHashCode_0__0(&__thrown, self.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return __return;
        }
    }
    // System.Int32 GetToken()
// docid: M:System.Diagnostics.SymbolStore.SymbolToken.GetToken
    /**
    Gets the value of the current token.

    - Returns: The value of the current token.

    */
    public func GetToken() throws -> Swift.Int32 {
        var __thrown : NullableHandle = nil;
        let __return = System_Diagnostics_SymbolStore_SymbolToken_i32__GetToken_0__0(&__thrown, self.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return __return;
        }
    }
    // [IsSpecialName] bool op_Equality(System.Diagnostics.SymbolStore.SymbolToken, System.Diagnostics.SymbolStore.SymbolToken)
// docid: M:System.Diagnostics.SymbolStore.SymbolToken.op_Equality(System.Diagnostics.SymbolStore.SymbolToken,System.Diagnostics.SymbolStore.SymbolToken)
    /**
    Returns a value indicating whether two  objects are equal.

    - Parameter a: A  structure.
    - Parameter b: A  structure.
    - Returns: 
         if  and  are equal; otherwise, .

    */
    public class func op_Equality(a : dotnet.System.Diagnostics.SymbolStore.SymbolToken, b : dotnet.System.Diagnostics.SymbolStore.SymbolToken) throws -> Bool {
        var __thrown : NullableHandle = nil;
        let __return = System_Diagnostics_SymbolStore_SymbolToken_bool__op_Equality_0__2__SymbolToken_SymbolToken(&__thrown, a.get_handle(), b.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return (__return) != 0;
        }
    }
    // [IsSpecialName] bool op_Inequality(System.Diagnostics.SymbolStore.SymbolToken, System.Diagnostics.SymbolStore.SymbolToken)
// docid: M:System.Diagnostics.SymbolStore.SymbolToken.op_Inequality(System.Diagnostics.SymbolStore.SymbolToken,System.Diagnostics.SymbolStore.SymbolToken)
    /**
    Returns a value indicating whether two  objects are not equal.

    - Parameter a: A  structure.
    - Parameter b: A  structure.
    - Returns: 
         if  and  are not equal; otherwise, .

    */
    public class func op_Inequality(a : dotnet.System.Diagnostics.SymbolStore.SymbolToken, b : dotnet.System.Diagnostics.SymbolStore.SymbolToken) throws -> Bool {
        var __thrown : NullableHandle = nil;
        let __return = System_Diagnostics_SymbolStore_SymbolToken_bool__op_Inequality_0__2__SymbolToken_SymbolToken(&__thrown, a.get_handle(), b.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return (__return) != 0;
        }
    }
} // SymbolToken


}



public protocol System_Diagnostics_SymbolStore_ISymbolBinder
    :
    SGBridgeGetHandle
{
}

public protocol System_Diagnostics_SymbolStore_ISymbolBinder1
    :
    SGBridgeGetHandle
{
}

public protocol System_Diagnostics_SymbolStore_ISymbolDocument
    :
    SGBridgeGetHandle
{
}

public protocol System_Diagnostics_SymbolStore_ISymbolDocumentWriter
    :
    SGBridgeGetHandle
{
}

public protocol System_Diagnostics_SymbolStore_ISymbolMethod
    :
    SGBridgeGetHandle
{
}

public protocol System_Diagnostics_SymbolStore_ISymbolNamespace
    :
    SGBridgeGetHandle
{
}

public protocol System_Diagnostics_SymbolStore_ISymbolReader
    :
    SGBridgeGetHandle
{
}

public protocol System_Diagnostics_SymbolStore_ISymbolScope
    :
    SGBridgeGetHandle
{
}

public protocol System_Diagnostics_SymbolStore_ISymbolVariable
    :
    SGBridgeGetHandle
{
}

public protocol System_Diagnostics_SymbolStore_ISymbolWriter
    :
    SGBridgeGetHandle
{
}

// EXTENSION METHOD System.IntPtr GetNativeImageBase(System.Diagnostics.StackFrame)
extension dotnet.System.Diagnostics.StackFrame {
    public func GetNativeImageBase() throws -> dotnet.System.IntPtr {
        return try dotnet.System.Diagnostics.StackFrameExtensions.GetNativeImageBase(stackFrame: self);
    }
}

// EXTENSION METHOD System.IntPtr GetNativeIP(System.Diagnostics.StackFrame)
extension dotnet.System.Diagnostics.StackFrame {
    public func GetNativeIP() throws -> dotnet.System.IntPtr {
        return try dotnet.System.Diagnostics.StackFrameExtensions.GetNativeIP(stackFrame: self);
    }
}

// EXTENSION METHOD bool HasILOffset(System.Diagnostics.StackFrame)
extension dotnet.System.Diagnostics.StackFrame {
    public func HasILOffset() throws -> Bool {
        return try dotnet.System.Diagnostics.StackFrameExtensions.HasILOffset(stackFrame: self);
    }
}

// EXTENSION METHOD bool HasMethod(System.Diagnostics.StackFrame)
extension dotnet.System.Diagnostics.StackFrame {
    public func HasMethod() throws -> Bool {
        return try dotnet.System.Diagnostics.StackFrameExtensions.HasMethod(stackFrame: self);
    }
}

// EXTENSION METHOD bool HasNativeImage(System.Diagnostics.StackFrame)
extension dotnet.System.Diagnostics.StackFrame {
    public func HasNativeImage() throws -> Bool {
        return try dotnet.System.Diagnostics.StackFrameExtensions.HasNativeImage(stackFrame: self);
    }
}

// EXTENSION METHOD bool HasSource(System.Diagnostics.StackFrame)
extension dotnet.System.Diagnostics.StackFrame {
    public func HasSource() throws -> Bool {
        return try dotnet.System.Diagnostics.StackFrameExtensions.HasSource(stackFrame: self);
    }
}

