// this file is automatically generated
// Copyright 2021 SourceGear

import jumptable_dotnet;

// System
// System.Security
// System.Security.Cryptography
extension System.Security.Cryptography {
// type: System.Security.Cryptography.AsymmetricAlgorithm
    /**
    Represents the abstract base class from which all implementations of asymmetric algorithms must inherit.

    */
open class AsymmetricAlgorithm
    :
    dotnet.System.Object,
    System_IDisposable
{
    open class override func get_type_handle() -> TypeHandle {
        return System_Security_Cryptography_AsymmetricAlgorithm_get_type_handle();
    }
    public required init(hndl: NonnullHandle) { super.init(hndl: hndl); }
    public required init(gval: GVal) { super.init(gval: gval); }
    // void Clear()
// docid: M:System.Security.Cryptography.AsymmetricAlgorithm.Clear
    /**
    Releases all resources used by the  class.

    */
    open func Clear() throws {
        var __thrown : NullableHandle = nil;
        System_Security_Cryptography_AsymmetricAlgorithm_void__Clear_0__0(&__thrown, self.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
            return;
        }
    }
    // System.Security.Cryptography.AsymmetricAlgorithm Create()
// docid: M:System.Security.Cryptography.AsymmetricAlgorithm.Create
    /**
    Creates a default cryptographic object used to perform the asymmetric algorithm.

    - Returns: A new  instance, unless the default settings have been changed with the <cryptoClass> element.

    */
    open class func Create() throws -> dotnet.System.Security.Cryptography.AsymmetricAlgorithm {
        var __thrown : NullableHandle = nil;
        let __return = System_Security_Cryptography_AsymmetricAlgorithm_AsymmetricAlgorithm__Create_0__0(&__thrown);
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return dotnet.System.Security.Cryptography.AsymmetricAlgorithm(hndl : __return);
        }
    }
    // System.Security.Cryptography.AsymmetricAlgorithm Create(System.String)
// docid: M:System.Security.Cryptography.AsymmetricAlgorithm.Create(System.String)
    /**
    Creates an instance of the specified implementation of an asymmetric algorithm.

    - Parameter algName: The asymmetric algorithm implementation to use. The following table shows the valid values for the  parameter and the algorithms they map to.  
  
  Parameter value Implements System.Security.Cryptography.AsymmetricAlgorithm RSA System.Security.Cryptography.RSA DSA System.Security.Cryptography.DSA ECDsa ECDsaCng System.Security.Cryptography.ECDsaCng ECDH ECDiffieHellman ECDiffieHellmanCng System.Security.Cryptography.ECDiffieHellmanCng
    - Returns: A new instance of the specified asymmetric algorithm implementation.

    */
    open class func Create(algName : dotnet.System.String) throws -> Optional<dotnet.System.Security.Cryptography.AsymmetricAlgorithm> {
        var __thrown : NullableHandle = nil;
        let __return = System_Security_Cryptography_AsymmetricAlgorithm_AsymmetricAlgorithm__Create_0__1__String(&__thrown, algName.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        if let __ret_unwrapped = __return {
            return dotnet.System.Security.Cryptography.AsymmetricAlgorithm(hndl : __ret_unwrapped);
        } else {
            return nil;
        }
        }
    }
    // void Dispose()
// docid: M:System.Security.Cryptography.AsymmetricAlgorithm.Dispose
    /**
    Releases all resources used by the current instance of the  class.

    */
    open /* method final */ func Dispose() throws {
        var __thrown : NullableHandle = nil;
        System_Security_Cryptography_AsymmetricAlgorithm_void__Dispose_0__0(&__thrown, self.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
            return;
        }
    }
// TODO COPE (write_all_methods) (span) System.Byte[] ExportEncryptedPkcs8PrivateKey(System.ReadOnlySpan<System.Byte>, System.Security.Cryptography.PbeParameters)
// TODO COPE (write_all_methods) (span) System.Byte[] ExportEncryptedPkcs8PrivateKey(System.ReadOnlySpan<System.Char>, System.Security.Cryptography.PbeParameters)
    // System.Byte[] ExportPkcs8PrivateKey()
// docid: M:System.Security.Cryptography.AsymmetricAlgorithm.ExportPkcs8PrivateKey
    /**
    Exports the current key in the PKCS#8 PrivateKeyInfo format.

    - Returns: A byte array containing the PKCS#8 PrivateKeyInfo representation of this key.

    */
    open func ExportPkcs8PrivateKey() throws -> dotnet.System_Arr<Swift.UInt8> {
        var __thrown : NullableHandle = nil;
        let __return = System_Security_Cryptography_AsymmetricAlgorithm_u8Array__ExportPkcs8PrivateKey_0__0(&__thrown, self.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return dotnet.System_Arr<Swift.UInt8>(hndl : __return);
        }
    }
    // System.Byte[] ExportSubjectPublicKeyInfo()
// docid: M:System.Security.Cryptography.AsymmetricAlgorithm.ExportSubjectPublicKeyInfo
    /**
    Exports the public-key portion of the current key in the X.509 SubjectPublicKeyInfo format.

    - Returns: A byte array containing the X.509 SubjectPublicKeyInfo representation of the public-key portion of this key.

    */
    open func ExportSubjectPublicKeyInfo() throws -> dotnet.System_Arr<Swift.UInt8> {
        var __thrown : NullableHandle = nil;
        let __return = System_Security_Cryptography_AsymmetricAlgorithm_u8Array__ExportSubjectPublicKeyInfo_0__0(&__thrown, self.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return dotnet.System_Arr<Swift.UInt8>(hndl : __return);
        }
    }
    // void FromXmlString(System.String)
// docid: M:System.Security.Cryptography.AsymmetricAlgorithm.FromXmlString(System.String)
    /**
    When overridden in a derived class, reconstructs an  object from an XML string. Otherwise, throws a .

    - Parameter xmlString: The XML string to use to reconstruct the  object.
    */
    open func FromXmlString(xmlString : dotnet.System.String) throws {
        var __thrown : NullableHandle = nil;
        System_Security_Cryptography_AsymmetricAlgorithm_void__FromXmlString_0__1__String(&__thrown, self.get_handle(), xmlString.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
            return;
        }
    }
// TODO COPE (write_all_methods) (span) void ImportEncryptedPkcs8PrivateKey(System.ReadOnlySpan<System.Byte>, System.ReadOnlySpan<System.Byte>, ref System.Int32)
// TODO COPE (write_all_methods) (span) void ImportEncryptedPkcs8PrivateKey(System.ReadOnlySpan<System.Char>, System.ReadOnlySpan<System.Byte>, ref System.Int32)
// TODO COPE (write_all_methods) (span) void ImportFromEncryptedPem(System.ReadOnlySpan<System.Char>, System.ReadOnlySpan<System.Byte>)
// TODO COPE (write_all_methods) (span) void ImportFromEncryptedPem(System.ReadOnlySpan<System.Char>, System.ReadOnlySpan<System.Char>)
// TODO COPE (write_all_methods) (span) void ImportFromPem(System.ReadOnlySpan<System.Char>)
// TODO COPE (write_all_methods) (span) void ImportPkcs8PrivateKey(System.ReadOnlySpan<System.Byte>, ref System.Int32)
// TODO COPE (write_all_methods) (span) void ImportSubjectPublicKeyInfo(System.ReadOnlySpan<System.Byte>, ref System.Int32)
    // System.String ToXmlString(bool)
// docid: M:System.Security.Cryptography.AsymmetricAlgorithm.ToXmlString(System.Boolean)
    /**
    When overridden in a derived class, creates and returns an XML string representation of the current  object. Otherwise, throws a .

    - Parameter includePrivateParameters: 
         to include private parameters; otherwise, .
    - Returns: An XML string encoding of the current  object.

    */
    open func ToXmlString(includePrivateParameters : Bool) throws -> dotnet.System.String {
        var __thrown : NullableHandle = nil;
        let __return = System_Security_Cryptography_AsymmetricAlgorithm_String__ToXmlString_0__1__bool(&__thrown, self.get_handle(), Swift.Int32(includePrivateParameters ? 1 : 0));
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return dotnet.System.String(hndl : __return);
        }
    }
// TODO COPE (write_all_methods) (span) bool TryExportEncryptedPkcs8PrivateKey(System.ReadOnlySpan<System.Byte>, System.Security.Cryptography.PbeParameters, System.Span<System.Byte>, ref System.Int32)
// TODO COPE (write_all_methods) (span) bool TryExportEncryptedPkcs8PrivateKey(System.ReadOnlySpan<System.Char>, System.Security.Cryptography.PbeParameters, System.Span<System.Byte>, ref System.Int32)
// TODO COPE (write_all_methods) (span) bool TryExportPkcs8PrivateKey(System.Span<System.Byte>, ref System.Int32)
// TODO COPE (write_all_methods) (span) bool TryExportSubjectPublicKeyInfo(System.Span<System.Byte>, ref System.Int32)
    // [IsSpecialName] System.String get_KeyExchangeAlgorithm()
// docid: M:System.Security.Cryptography.AsymmetricAlgorithm.get_KeyExchangeAlgorithm
    open func get_KeyExchangeAlgorithm() throws -> Optional<dotnet.System.String> {
        var __thrown : NullableHandle = nil;
        let __return = System_Security_Cryptography_AsymmetricAlgorithm_String__get_KeyExchangeAlgorithm_0__0(&__thrown, self.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        if let __ret_unwrapped = __return {
            return dotnet.System.String(hndl : __ret_unwrapped);
        } else {
            return nil;
        }
        }
    }
    // [IsSpecialName] System.Int32 get_KeySize()
// docid: M:System.Security.Cryptography.AsymmetricAlgorithm.get_KeySize
    open func get_KeySize() throws -> Swift.Int32 {
        var __thrown : NullableHandle = nil;
        let __return = System_Security_Cryptography_AsymmetricAlgorithm_i32__get_KeySize_0__0(&__thrown, self.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return __return;
        }
    }
    // [IsSpecialName] void set_KeySize(System.Int32)
// docid: M:System.Security.Cryptography.AsymmetricAlgorithm.set_KeySize(System.Int32)
    open func set_KeySize(value : Swift.Int32) throws {
        var __thrown : NullableHandle = nil;
        System_Security_Cryptography_AsymmetricAlgorithm_void__set_KeySize_0__1__i32(&__thrown, self.get_handle(), value);
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
            return;
        }
    }
    // [IsSpecialName] System.Security.Cryptography.KeySizes[] get_LegalKeySizes()
// docid: M:System.Security.Cryptography.AsymmetricAlgorithm.get_LegalKeySizes
    open func get_LegalKeySizes() throws -> dotnet.System_Arr<dotnet.System.Security.Cryptography.KeySizes> {
        var __thrown : NullableHandle = nil;
        let __return = System_Security_Cryptography_AsymmetricAlgorithm_KeySizesArray__get_LegalKeySizes_0__0(&__thrown, self.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return dotnet.System_Arr<dotnet.System.Security.Cryptography.KeySizes>(hndl : __return);
        }
    }
    // [IsSpecialName] System.String get_SignatureAlgorithm()
// docid: M:System.Security.Cryptography.AsymmetricAlgorithm.get_SignatureAlgorithm
    open func get_SignatureAlgorithm() throws -> Optional<dotnet.System.String> {
        var __thrown : NullableHandle = nil;
        let __return = System_Security_Cryptography_AsymmetricAlgorithm_String__get_SignatureAlgorithm_0__0(&__thrown, self.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        if let __ret_unwrapped = __return {
            return dotnet.System.String(hndl : __ret_unwrapped);
        } else {
            return nil;
        }
        }
    }
    /**
    When overridden in a derived class, gets the name of the key exchange algorithm. Otherwise, throws an .

    */
    open var KeyExchangeAlgorithm : Optional<dotnet.System.String> {
        get {
            return try! get_KeyExchangeAlgorithm();
        }
    }
    /**
    Gets or sets the size, in bits, of the key modulus used by the asymmetric algorithm.

    */
    open var KeySize : Swift.Int32 {
        get {
            return try! get_KeySize();
        }
        set(v) {
            return try! set_KeySize(value: v);
        }
    }
    /**
    Gets the key sizes that are supported by the asymmetric algorithm.

    */
    open var LegalKeySizes : dotnet.System_Arr<dotnet.System.Security.Cryptography.KeySizes> {
        get {
            return try! get_LegalKeySizes();
        }
    }
    /**
    When implemented in a derived class, gets the name of the signature algorithm. Otherwise, always throws a .

    */
    open var SignatureAlgorithm : Optional<dotnet.System.String> {
        get {
            return try! get_SignatureAlgorithm();
        }
    }
} // AsymmetricAlgorithm


// type: System.Security.Cryptography.CipherMode
    /**
    Specifies the block cipher mode to use for encryption.

    */
public struct CipherMode : SGBridgeGenericValue {
    let v : Swift.Int32;
    public init(val: Swift.Int32) { self.v = val; }
    public func get_value() -> Swift.Int32 { return self.v; }
    public static func get_type_handle() -> TypeHandle {
        return System_Security_Cryptography_CipherMode_get_type_handle();
    }
    public func to_gval() -> GVal { return GVal(self.v); }
    public func dup_gval() -> GVal { return to_gval(); }
    public init(gval: GVal) { self.v = Swift.Int32(gval); }
    // static field: System.Security.Cryptography.CipherMode CBC
    /**
    The Cipher Block Chaining () mode introduces feedback. Before each plain text block is encrypted, it is combined with the cipher text of the previous block by a bitwise exclusive OR operation. This ensures that even if the plain text contains many identical blocks, they will each encrypt to a different cipher text block. The initialization vector is combined with the first plain text block by a bitwise exclusive OR operation before the block is encrypted. If a single bit of the cipher text block is mangled, the corresponding plain text block will also be mangled. In addition, a bit in the subsequent block, in the same position as the original mangled bit, will be mangled.

    */
    public static var CBC : dotnet.System.Security.Cryptography.CipherMode {
        get {
        let __return = dotnet.System.Security.Cryptography.CipherMode(val: System_Security_Cryptography_CipherMode_get_CBC());
            return __return;
        }
    }
    // static field: System.Security.Cryptography.CipherMode ECB
    /**
    The Electronic Codebook () mode encrypts each block individually. Any blocks of plain text that are identical and in the same message, or that are in a different message encrypted with the same key, will be transformed into identical cipher text blocks. Important:  This mode is not recommended because it opens the door for multiple security exploits. If the plain text to be encrypted contains substantial repetition, it is feasible for the cipher text to be broken one block at a time. It is also possible to use block analysis to determine the encryption key. Also, an active adversary can substitute and exchange individual blocks without detection, which allows blocks to be saved and inserted into the stream at other points without detection.

    */
    public static var ECB : dotnet.System.Security.Cryptography.CipherMode {
        get {
        let __return = dotnet.System.Security.Cryptography.CipherMode(val: System_Security_Cryptography_CipherMode_get_ECB());
            return __return;
        }
    }
    // static field: System.Security.Cryptography.CipherMode OFB
    /**
    The Output Feedback () mode processes small increments of plain text into cipher text instead of processing an entire block at a time. This mode is similar to ; the only difference between the two modes is the way that the shift register is filled. If a bit in the cipher text is mangled, the corresponding bit of plain text will be mangled. However, if there are extra or missing bits from the cipher text, the plain text will be mangled from that point on.

    */
    public static var OFB : dotnet.System.Security.Cryptography.CipherMode {
        get {
        let __return = dotnet.System.Security.Cryptography.CipherMode(val: System_Security_Cryptography_CipherMode_get_OFB());
            return __return;
        }
    }
    // static field: System.Security.Cryptography.CipherMode CFB
    /**
    The Cipher Feedback () mode processes small increments of plain text into cipher text, instead of processing an entire block at a time. This mode uses a shift register that is one block in length and is divided into sections. For example, if the block size is 8 bytes, with one byte processed at a time, the shift register is divided into eight sections. If a bit in the cipher text is mangled, one plain text bit is mangled and the shift register is corrupted. This results in the next several plain text increments being mangled until the bad bit is shifted out of the shift register. The default feedback size can vary by algorithm, but is typically either 8 bits or the number of bits of the block size. You can alter the number of feedback bits by using the  property. Algorithms that support CFB use this property to set the feedback.

    */
    public static var CFB : dotnet.System.Security.Cryptography.CipherMode {
        get {
        let __return = dotnet.System.Security.Cryptography.CipherMode(val: System_Security_Cryptography_CipherMode_get_CFB());
            return __return;
        }
    }
    // static field: System.Security.Cryptography.CipherMode CTS
    /**
    The Cipher Text Stealing () mode handles any length of plain text and produces cipher text whose length matches the plain text length. This mode behaves like the  mode for all but the last two blocks of the plain text.

    */
    public static var CTS : dotnet.System.Security.Cryptography.CipherMode {
        get {
        let __return = dotnet.System.Security.Cryptography.CipherMode(val: System_Security_Cryptography_CipherMode_get_CTS());
            return __return;
        }
    }
} // CipherMode


// type: System.Security.Cryptography.CryptoStream
    /**
    Defines a stream that links data streams to cryptographic transformations.

    */
open class CryptoStream
    :
    dotnet.System.IO.Stream
{
    open class override func get_type_handle() -> TypeHandle {
        return System_Security_Cryptography_CryptoStream_get_type_handle();
    }
    public required init(hndl: NonnullHandle) { super.init(hndl: hndl); }
    public required init(gval: GVal) { super.init(gval: gval); }
    // .ctor(System.IO.Stream, System.Security.Cryptography.ICryptoTransform, System.Security.Cryptography.CryptoStreamMode)
// docid: M:System.Security.Cryptography.CryptoStream.#ctor(System.IO.Stream,System.Security.Cryptography.ICryptoTransform,System.Security.Cryptography.CryptoStreamMode)
    /**
    Initializes a new instance of the  class with a target data stream, the transformation to use, and the mode of the stream.

    - Parameter stream: The stream on which to perform the cryptographic transformation.
    - Parameter transform: The cryptographic transformation that is to be performed on the stream.
    - Parameter mode: One of the  values.
    */
    public init(stream : dotnet.System.IO.Stream, transform : dotnet.System.Security.Cryptography.ICryptoTransform, mode : dotnet.System.Security.Cryptography.CryptoStreamMode) throws {
        var __thrown : NullableHandle = nil;
        let h = System_Security_Cryptography_CryptoStream_ctor_0__3__Stream_ICryptoTransform_CryptoStreamMode(&__thrown, stream.get_handle(), transform.get_handle(), mode.get_value());
        if let __ex = __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
            super.init(hndl: h);
        }
    }
    // .ctor(System.IO.Stream, System.Security.Cryptography.ICryptoTransform, System.Security.Cryptography.CryptoStreamMode, bool)
// docid: M:System.Security.Cryptography.CryptoStream.#ctor(System.IO.Stream,System.Security.Cryptography.ICryptoTransform,System.Security.Cryptography.CryptoStreamMode,System.Boolean)
    /**
    Initializes a new instance of the  class.

    - Parameter stream: The stream on which to perform the cryptographic transformation.
    - Parameter transform: The cryptographic transformation that is to be performed on the stream.
    - Parameter mode: The mode of the stream.
    - Parameter leaveOpen: 
         to not close the underlying stream when the  object is disposed; otherwise, .
    */
    public init(stream : dotnet.System.IO.Stream, transform : dotnet.System.Security.Cryptography.ICryptoTransform, mode : dotnet.System.Security.Cryptography.CryptoStreamMode, leaveOpen : Bool) throws {
        var __thrown : NullableHandle = nil;
        let h = System_Security_Cryptography_CryptoStream_ctor_0__4__Stream_ICryptoTransform_CryptoStreamMode_bool(&__thrown, stream.get_handle(), transform.get_handle(), mode.get_value(), Swift.Int32(leaveOpen ? 1 : 0));
        if let __ex = __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
            super.init(hndl: h);
        }
    }
    // System.IAsyncResult BeginRead(System.Byte[], System.Int32, System.Int32, System.AsyncCallback, System.Object)
// docid: M:System.Security.Cryptography.CryptoStream.BeginRead(System.Byte[],System.Int32,System.Int32,System.AsyncCallback,System.Object)
    /**
    Begins an asynchronous read operation. (Consider using  instead.)

    - Parameter buffer: The buffer to read the data into.
    - Parameter offset: The byte offset in  at which to begin writing data read from the stream.
    - Parameter count: The maximum number of bytes to read.
    - Parameter callback: An optional asynchronous callback, to be called when the read is complete.
    - Parameter state: A user-provided object that distinguishes this particular asynchronous read request from other requests.
    - Returns: An  that represents the asynchronous read, which could still be pending.

    */
    open override func BeginRead(buffer : dotnet.System_Arr<Swift.UInt8>, offset : Swift.Int32, count : Swift.Int32, callback : Optional<dotnet.System.AsyncCallback>, state : Optional<dotnet.System.Object>) throws -> dotnet.System.IAsyncResult {
        var __thrown : NullableHandle = nil;
        let __return = System_Security_Cryptography_CryptoStream_IAsyncResult__BeginRead_0__5__u8Array_i32_i32_AsyncCallback_Object(&__thrown, self.get_handle(), buffer.get_handle(), offset, count, callback?.get_handle() ?? nil, state?.get_handle() ?? nil);
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return dotnet.System.IAsyncResult(hndl : __return);
        }
    }
    // delegate closure overload
    open override func BeginRead(buffer : dotnet.System_Arr<Swift.UInt8>, offset : Swift.Int32, count : Swift.Int32, callback : @escaping (dotnet.System.IAsyncResult) throws -> Void, state : Optional<dotnet.System.Object>) throws -> dotnet.System.IAsyncResult {
        let del_callback = try dotnet.System.AsyncCallback(callback);
        return try BeginRead(buffer: buffer, offset: offset, count: count, callback: del_callback, state: state);
    }
    // System.IAsyncResult BeginWrite(System.Byte[], System.Int32, System.Int32, System.AsyncCallback, System.Object)
// docid: M:System.Security.Cryptography.CryptoStream.BeginWrite(System.Byte[],System.Int32,System.Int32,System.AsyncCallback,System.Object)
    /**
    Begins an asynchronous write operation. (Consider using  instead.)

    - Parameter buffer: The buffer to write data from.
    - Parameter offset: The byte offset in  from which to begin writing.
    - Parameter count: The maximum number of bytes to write.
    - Parameter callback: An optional asynchronous callback, to be called when the write is complete.
    - Parameter state: A user-provided object that distinguishes this particular asynchronous write request from other requests.
    - Returns: An  that represents the asynchronous write, which could still be pending.

    */
    open override func BeginWrite(buffer : dotnet.System_Arr<Swift.UInt8>, offset : Swift.Int32, count : Swift.Int32, callback : Optional<dotnet.System.AsyncCallback>, state : Optional<dotnet.System.Object>) throws -> dotnet.System.IAsyncResult {
        var __thrown : NullableHandle = nil;
        let __return = System_Security_Cryptography_CryptoStream_IAsyncResult__BeginWrite_0__5__u8Array_i32_i32_AsyncCallback_Object(&__thrown, self.get_handle(), buffer.get_handle(), offset, count, callback?.get_handle() ?? nil, state?.get_handle() ?? nil);
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return dotnet.System.IAsyncResult(hndl : __return);
        }
    }
    // delegate closure overload
    open override func BeginWrite(buffer : dotnet.System_Arr<Swift.UInt8>, offset : Swift.Int32, count : Swift.Int32, callback : @escaping (dotnet.System.IAsyncResult) throws -> Void, state : Optional<dotnet.System.Object>) throws -> dotnet.System.IAsyncResult {
        let del_callback = try dotnet.System.AsyncCallback(callback);
        return try BeginWrite(buffer: buffer, offset: offset, count: count, callback: del_callback, state: state);
    }
    // void Clear()
// docid: M:System.Security.Cryptography.CryptoStream.Clear
    /**
    Releases all resources used by the .

    */
    open func Clear() throws {
        var __thrown : NullableHandle = nil;
        System_Security_Cryptography_CryptoStream_void__Clear_0__0(&__thrown, self.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
            return;
        }
    }
    // void CopyTo(System.IO.Stream, System.Int32)
// docid: M:System.Security.Cryptography.CryptoStream.CopyTo(System.IO.Stream,System.Int32)
    open override func CopyTo(destination : dotnet.System.IO.Stream, bufferSize : Swift.Int32) throws {
        var __thrown : NullableHandle = nil;
        System_Security_Cryptography_CryptoStream_void__CopyTo_0__2__Stream_i32(&__thrown, self.get_handle(), destination.get_handle(), bufferSize);
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
            return;
        }
    }
    // System.Threading.Tasks.Task CopyToAsync(System.IO.Stream, System.Int32, System.Threading.CancellationToken)
// docid: M:System.Security.Cryptography.CryptoStream.CopyToAsync(System.IO.Stream,System.Int32,System.Threading.CancellationToken)
    open override func CopyToAsync(destination : dotnet.System.IO.Stream, bufferSize : Swift.Int32, cancellationToken : dotnet.System.Threading.CancellationToken) throws -> dotnet.System.Threading.Tasks.Task {
        var __thrown : NullableHandle = nil;
        let __return = System_Security_Cryptography_CryptoStream_Task__CopyToAsync_0__3__Stream_i32_CancellationToken(&__thrown, self.get_handle(), destination.get_handle(), bufferSize, cancellationToken.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return dotnet.System.Threading.Tasks.Task(hndl : __return);
        }
    }
    // System.Threading.Tasks.ValueTask DisposeAsync()
// docid: M:System.Security.Cryptography.CryptoStream.DisposeAsync
    /**
    Asynchronously releases the unmanaged resources used by the .

    - Returns: A task that represents the asynchronous dispose operation.

    */
    open override func DisposeAsync() throws -> dotnet.System.Threading.Tasks.ValueTask {
        var __thrown : NullableHandle = nil;
        let __return = System_Security_Cryptography_CryptoStream_ValueTask__DisposeAsync_0__0(&__thrown, self.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return dotnet.System.Threading.Tasks.ValueTask(hndl : __return);
        }
    }
    // System.Int32 EndRead(System.IAsyncResult)
// docid: M:System.Security.Cryptography.CryptoStream.EndRead(System.IAsyncResult)
    /**
    Waits for the pending asynchronous read to complete. (Consider using  instead.)

    - Parameter asyncResult: The reference to the pending asynchronous request to finish.
    - Returns: The number of bytes read from the stream, between zero (0) and the number of bytes you requested. Streams return zero (0) only at the end of the stream, otherwise, they should block until at least one byte is available.

    */
    open override func EndRead(asyncResult : dotnet.System.IAsyncResult) throws -> Swift.Int32 {
        var __thrown : NullableHandle = nil;
        let __return = System_Security_Cryptography_CryptoStream_i32__EndRead_0__1__IAsyncResult(&__thrown, self.get_handle(), asyncResult.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return __return;
        }
    }
    // void EndWrite(System.IAsyncResult)
// docid: M:System.Security.Cryptography.CryptoStream.EndWrite(System.IAsyncResult)
    /**
    Ends an asynchronous write operation. (Consider using  instead.)

    - Parameter asyncResult: A reference to the outstanding asynchronous I/O request.
    */
    open override func EndWrite(asyncResult : dotnet.System.IAsyncResult) throws {
        var __thrown : NullableHandle = nil;
        System_Security_Cryptography_CryptoStream_void__EndWrite_0__1__IAsyncResult(&__thrown, self.get_handle(), asyncResult.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
            return;
        }
    }
    // void Flush()
// docid: M:System.Security.Cryptography.CryptoStream.Flush
    /**
    Clears all buffers for the current stream and causes any buffered data to be written to the underlying device.

    */
    open override func Flush() throws {
        var __thrown : NullableHandle = nil;
        System_Security_Cryptography_CryptoStream_void__Flush_0__0(&__thrown, self.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
            return;
        }
    }
    // System.Threading.Tasks.Task FlushAsync(System.Threading.CancellationToken)
// docid: M:System.Security.Cryptography.CryptoStream.FlushAsync(System.Threading.CancellationToken)
    /**
    Clears all buffers for the current stream asynchronously, causes any buffered data to be written to the underlying device, and monitors cancellation requests.

    - Parameter cancellationToken: The token to monitor for cancellation requests. The default value is .
    - Returns: A task that represents the asynchronous flush operation.

    */
    open override func FlushAsync(cancellationToken : dotnet.System.Threading.CancellationToken) throws -> dotnet.System.Threading.Tasks.Task {
        var __thrown : NullableHandle = nil;
        let __return = System_Security_Cryptography_CryptoStream_Task__FlushAsync_0__1__CancellationToken(&__thrown, self.get_handle(), cancellationToken.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return dotnet.System.Threading.Tasks.Task(hndl : __return);
        }
    }
    // void FlushFinalBlock()
// docid: M:System.Security.Cryptography.CryptoStream.FlushFinalBlock
    /**
    Updates the underlying data source or repository with the current state of the buffer, then clears the buffer.

    */
    open func FlushFinalBlock() throws {
        var __thrown : NullableHandle = nil;
        System_Security_Cryptography_CryptoStream_void__FlushFinalBlock_0__0(&__thrown, self.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
            return;
        }
    }
    // System.Threading.Tasks.ValueTask FlushFinalBlockAsync(System.Threading.CancellationToken)
// docid: M:System.Security.Cryptography.CryptoStream.FlushFinalBlockAsync(System.Threading.CancellationToken)
    /**
    Asynchronously updates the underlying data source or repository with the current state of the buffer, then clears the buffer.

    - Parameter cancellationToken: The token to monitor for cancellation requests. The default value is .
    - Returns: A task that represents the asynchronous flush operation.

    */
    open func FlushFinalBlockAsync(cancellationToken : dotnet.System.Threading.CancellationToken = System.Threading.CancellationToken.None) throws -> dotnet.System.Threading.Tasks.ValueTask {
        var __thrown : NullableHandle = nil;
        let __return = System_Security_Cryptography_CryptoStream_ValueTask__FlushFinalBlockAsync_0__1__CancellationToken(&__thrown, self.get_handle(), cancellationToken.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return dotnet.System.Threading.Tasks.ValueTask(hndl : __return);
        }
    }
    // System.Int32 Read(System.Byte[], System.Int32, System.Int32)
// docid: M:System.Security.Cryptography.CryptoStream.Read(System.Byte[],System.Int32,System.Int32)
    /**
    Reads a sequence of bytes from the current stream and advances the position within the stream by the number of bytes read.

    - Parameter buffer: An array of bytes. A maximum of  bytes are read from the current stream and stored in .
    - Parameter offset: The byte offset in  at which to begin storing the data read from the current stream.
    - Parameter count: The maximum number of bytes to be read from the current stream.
    - Returns: The total number of bytes read into the buffer. This can be less than the number of bytes requested if that many bytes are not currently available, or zero if the end of the stream has been reached.

    */
    open override func Read(buffer : dotnet.System_Arr<Swift.UInt8>, offset : Swift.Int32, count : Swift.Int32) throws -> Swift.Int32 {
        var __thrown : NullableHandle = nil;
        let __return = System_Security_Cryptography_CryptoStream_i32__Read_0__3__u8Array_i32_i32(&__thrown, self.get_handle(), buffer.get_handle(), offset, count);
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return __return;
        }
    }
    // System.Threading.Tasks.Task<System.Int32> ReadAsync(System.Byte[], System.Int32, System.Int32, System.Threading.CancellationToken)
// docid: M:System.Security.Cryptography.CryptoStream.ReadAsync(System.Byte[],System.Int32,System.Int32,System.Threading.CancellationToken)
    /**
    Reads a sequence of bytes from the current stream asynchronously, advances the position within the stream by the number of bytes read, and monitors cancellation requests.

    - Parameter buffer: The buffer to write the data into.
    - Parameter offset: The byte offset in  at which to begin writing data from the stream.
    - Parameter count: The maximum number of bytes to read.
    - Parameter cancellationToken: The token to monitor for cancellation requests. The default value is .
    - Returns: A task that represents the asynchronous read operation. The value of the task object's  parameter contains the total number of bytes read into the buffer. The result can be less than the number of bytes requested if the number of bytes currently available is less than the requested number, or it can be 0 (zero) if the end of the stream has been reached.

    */
    open override func ReadAsync(buffer : dotnet.System_Arr<Swift.UInt8>, offset : Swift.Int32, count : Swift.Int32, cancellationToken : dotnet.System.Threading.CancellationToken) throws -> dotnet.System.Threading.Tasks.Task_1<Swift.Int32> {
        var __thrown : NullableHandle = nil;
        let __return = System_Security_Cryptography_CryptoStream_System_Threading_Tasks_Task_i32___ReadAsync_0__4__u8Array_i32_i32_CancellationToken(&__thrown, self.get_handle(), buffer.get_handle(), offset, count, cancellationToken.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return dotnet.System.Threading.Tasks.Task_1(hndl : __return);
        }
    }
    // System.Threading.Tasks.ValueTask<System.Int32> ReadAsync(System.Memory<System.Byte>, System.Threading.CancellationToken)
// docid: M:System.Security.Cryptography.CryptoStream.ReadAsync(System.Memory{System.Byte},System.Threading.CancellationToken)
    open override func ReadAsync(buffer : dotnet.System.Memory_1<Swift.UInt8>, cancellationToken : dotnet.System.Threading.CancellationToken = System.Threading.CancellationToken.None) throws -> dotnet.System.Threading.Tasks.ValueTask_1<Swift.Int32> {
        var __thrown : NullableHandle = nil;
        let __return = System_Security_Cryptography_CryptoStream_System_Threading_Tasks_ValueTask_i32___ReadAsync_0__2__System_Memory_u8__CancellationToken(&__thrown, self.get_handle(), buffer.get_handle(), cancellationToken.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return dotnet.System.Threading.Tasks.ValueTask_1(hndl : __return);
        }
    }
    // System.Int32 ReadByte()
// docid: M:System.Security.Cryptography.CryptoStream.ReadByte
    /**
    Reads a byte from the stream and advances the position within the stream by one byte, or returns -1 if at the end of the stream.

    - Returns: The unsigned byte cast to an , or -1 if at the end of the stream.

    */
    open override func ReadByte() throws -> Swift.Int32 {
        var __thrown : NullableHandle = nil;
        let __return = System_Security_Cryptography_CryptoStream_i32__ReadByte_0__0(&__thrown, self.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return __return;
        }
    }
    // System.Int64 Seek(System.Int64, System.IO.SeekOrigin)
// docid: M:System.Security.Cryptography.CryptoStream.Seek(System.Int64,System.IO.SeekOrigin)
    /**
    Sets the position within the current stream.

    - Parameter offset: A byte offset relative to the  parameter.
    - Parameter origin: A  object indicating the reference point used to obtain the new position.
    - Returns: This method is not supported.

    */
    open override func Seek(offset : Swift.Int64, origin : dotnet.System.IO.SeekOrigin) throws -> Swift.Int64 {
        var __thrown : NullableHandle = nil;
        let __return = System_Security_Cryptography_CryptoStream_i64__Seek_0__2__i64_SeekOrigin(&__thrown, self.get_handle(), offset, origin.get_value());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return __return;
        }
    }
    // void SetLength(System.Int64)
// docid: M:System.Security.Cryptography.CryptoStream.SetLength(System.Int64)
    /**
    Sets the length of the current stream.

    - Parameter value: The desired length of the current stream in bytes.
    */
    open override func SetLength(value : Swift.Int64) throws {
        var __thrown : NullableHandle = nil;
        System_Security_Cryptography_CryptoStream_void__SetLength_0__1__i64(&__thrown, self.get_handle(), value);
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
            return;
        }
    }
    // void Write(System.Byte[], System.Int32, System.Int32)
// docid: M:System.Security.Cryptography.CryptoStream.Write(System.Byte[],System.Int32,System.Int32)
    /**
    Writes a sequence of bytes to the current  and advances the current position within the stream by the number of bytes written.

    - Parameter buffer: An array of bytes. This method copies  bytes from  to the current stream.
    - Parameter offset: The byte offset in  at which to begin copying bytes to the current stream.
    - Parameter count: The number of bytes to be written to the current stream.
    */
    open override func Write(buffer : dotnet.System_Arr<Swift.UInt8>, offset : Swift.Int32, count : Swift.Int32) throws {
        var __thrown : NullableHandle = nil;
        System_Security_Cryptography_CryptoStream_void__Write_0__3__u8Array_i32_i32(&__thrown, self.get_handle(), buffer.get_handle(), offset, count);
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
            return;
        }
    }
    // System.Threading.Tasks.Task WriteAsync(System.Byte[], System.Int32, System.Int32, System.Threading.CancellationToken)
// docid: M:System.Security.Cryptography.CryptoStream.WriteAsync(System.Byte[],System.Int32,System.Int32,System.Threading.CancellationToken)
    /**
    Writes a sequence of bytes to the current stream asynchronously, advances the current position within the stream by the number of bytes written, and monitors cancellation requests.

    - Parameter buffer: The buffer to write data from.
    - Parameter offset: The zero-based byte offset in  from which to begin writing bytes to the stream.
    - Parameter count: The maximum number of bytes to write.
    - Parameter cancellationToken: The token to monitor for cancellation requests. The default value is .
    - Returns: A task that represents the asynchronous write operation.

    */
    open override func WriteAsync(buffer : dotnet.System_Arr<Swift.UInt8>, offset : Swift.Int32, count : Swift.Int32, cancellationToken : dotnet.System.Threading.CancellationToken) throws -> dotnet.System.Threading.Tasks.Task {
        var __thrown : NullableHandle = nil;
        let __return = System_Security_Cryptography_CryptoStream_Task__WriteAsync_0__4__u8Array_i32_i32_CancellationToken(&__thrown, self.get_handle(), buffer.get_handle(), offset, count, cancellationToken.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return dotnet.System.Threading.Tasks.Task(hndl : __return);
        }
    }
    // System.Threading.Tasks.ValueTask WriteAsync(System.ReadOnlyMemory<System.Byte>, System.Threading.CancellationToken)
// docid: M:System.Security.Cryptography.CryptoStream.WriteAsync(System.ReadOnlyMemory{System.Byte},System.Threading.CancellationToken)
    open override func WriteAsync(buffer : dotnet.System.ReadOnlyMemory_1<Swift.UInt8>, cancellationToken : dotnet.System.Threading.CancellationToken = System.Threading.CancellationToken.None) throws -> dotnet.System.Threading.Tasks.ValueTask {
        var __thrown : NullableHandle = nil;
        let __return = System_Security_Cryptography_CryptoStream_ValueTask__WriteAsync_0__2__System_ReadOnlyMemory_u8__CancellationToken(&__thrown, self.get_handle(), buffer.get_handle(), cancellationToken.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return dotnet.System.Threading.Tasks.ValueTask(hndl : __return);
        }
    }
    // void WriteByte(System.Byte)
// docid: M:System.Security.Cryptography.CryptoStream.WriteByte(System.Byte)
    /**
    Writes a byte to the current position in the stream and advances the position within the stream by one byte.

    - Parameter value: The byte to write to the stream.
    */
    open override func WriteByte(value : Swift.UInt8) throws {
        var __thrown : NullableHandle = nil;
        System_Security_Cryptography_CryptoStream_void__WriteByte_0__1__u8(&__thrown, self.get_handle(), value);
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
            return;
        }
    }
    // [IsSpecialName] bool get_CanRead()
// docid: M:System.Security.Cryptography.CryptoStream.get_CanRead
    open override func get_CanRead() throws -> Bool {
        var __thrown : NullableHandle = nil;
        let __return = System_Security_Cryptography_CryptoStream_bool__get_CanRead_0__0(&__thrown, self.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return (__return) != 0;
        }
    }
    // [IsSpecialName] bool get_CanSeek()
// docid: M:System.Security.Cryptography.CryptoStream.get_CanSeek
    open override func get_CanSeek() throws -> Bool {
        var __thrown : NullableHandle = nil;
        let __return = System_Security_Cryptography_CryptoStream_bool__get_CanSeek_0__0(&__thrown, self.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return (__return) != 0;
        }
    }
    // [IsSpecialName] bool get_CanWrite()
// docid: M:System.Security.Cryptography.CryptoStream.get_CanWrite
    open override func get_CanWrite() throws -> Bool {
        var __thrown : NullableHandle = nil;
        let __return = System_Security_Cryptography_CryptoStream_bool__get_CanWrite_0__0(&__thrown, self.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return (__return) != 0;
        }
    }
    // [IsSpecialName] bool get_HasFlushedFinalBlock()
// docid: M:System.Security.Cryptography.CryptoStream.get_HasFlushedFinalBlock
    open func get_HasFlushedFinalBlock() throws -> Bool {
        var __thrown : NullableHandle = nil;
        let __return = System_Security_Cryptography_CryptoStream_bool__get_HasFlushedFinalBlock_0__0(&__thrown, self.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return (__return) != 0;
        }
    }
    // [IsSpecialName] System.Int64 get_Length()
// docid: M:System.Security.Cryptography.CryptoStream.get_Length
    open override func get_Length() throws -> Swift.Int64 {
        var __thrown : NullableHandle = nil;
        let __return = System_Security_Cryptography_CryptoStream_i64__get_Length_0__0(&__thrown, self.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return __return;
        }
    }
    // [IsSpecialName] System.Int64 get_Position()
// docid: M:System.Security.Cryptography.CryptoStream.get_Position
    open override func get_Position() throws -> Swift.Int64 {
        var __thrown : NullableHandle = nil;
        let __return = System_Security_Cryptography_CryptoStream_i64__get_Position_0__0(&__thrown, self.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return __return;
        }
    }
    // [IsSpecialName] void set_Position(System.Int64)
// docid: M:System.Security.Cryptography.CryptoStream.set_Position(System.Int64)
    open override func set_Position(value : Swift.Int64) throws {
        var __thrown : NullableHandle = nil;
        System_Security_Cryptography_CryptoStream_void__set_Position_0__1__i64(&__thrown, self.get_handle(), value);
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
            return;
        }
    }
    /**
    Gets a value indicating whether the current  is readable.

    */
    open override var CanRead : Bool {
        get {
            return try! get_CanRead();
        }
    }
    /**
    Gets a value indicating whether you can seek within the current .

    */
    open override var CanSeek : Bool {
        get {
            return try! get_CanSeek();
        }
    }
    /**
    Gets a value indicating whether the current  is writable.

    */
    open override var CanWrite : Bool {
        get {
            return try! get_CanWrite();
        }
    }
    /**
    Gets a value indicating whether the final buffer block has been written to the underlying stream.

    */
    open var HasFlushedFinalBlock : Bool {
        get {
            return try! get_HasFlushedFinalBlock();
        }
    }
    /**
    Gets the length in bytes of the stream.

    */
    open override var Length : Swift.Int64 {
        get {
            return try! get_Length();
        }
    }
    /**
    Gets or sets the position within the current stream.

    */
    open override var Position : Swift.Int64 {
        get {
            return try! get_Position();
        }
        set(v) {
            return try! set_Position(value: v);
        }
    }
} // CryptoStream


// type: System.Security.Cryptography.CryptoStreamMode
    /**
    Specifies the mode of a cryptographic stream.

    */
public struct CryptoStreamMode : SGBridgeGenericValue {
    let v : Swift.Int32;
    public init(val: Swift.Int32) { self.v = val; }
    public func get_value() -> Swift.Int32 { return self.v; }
    public static func get_type_handle() -> TypeHandle {
        return System_Security_Cryptography_CryptoStreamMode_get_type_handle();
    }
    public func to_gval() -> GVal { return GVal(self.v); }
    public func dup_gval() -> GVal { return to_gval(); }
    public init(gval: GVal) { self.v = Swift.Int32(gval); }
    // static field: System.Security.Cryptography.CryptoStreamMode Read
    /**
    Read access to a cryptographic stream.

    */
    public static var Read : dotnet.System.Security.Cryptography.CryptoStreamMode {
        get {
        let __return = dotnet.System.Security.Cryptography.CryptoStreamMode(val: System_Security_Cryptography_CryptoStreamMode_get_Read());
            return __return;
        }
    }
    // static field: System.Security.Cryptography.CryptoStreamMode Write
    /**
    Write access to a cryptographic stream.

    */
    public static var Write : dotnet.System.Security.Cryptography.CryptoStreamMode {
        get {
        let __return = dotnet.System.Security.Cryptography.CryptoStreamMode(val: System_Security_Cryptography_CryptoStreamMode_get_Write());
            return __return;
        }
    }
} // CryptoStreamMode


// type: System.Security.Cryptography.CryptographicOperations
public struct CryptographicOperations {
// TODO COPE (write_all_methods) (span) bool FixedTimeEquals(System.ReadOnlySpan<System.Byte>, System.ReadOnlySpan<System.Byte>)
// TODO COPE (write_all_methods) (span) void ZeroMemory(System.Span<System.Byte>)
} // CryptographicOperations


// type: System.Security.Cryptography.CryptographicUnexpectedOperationException
    /**
    The exception that is thrown when an unexpected operation occurs during a cryptographic operation.

    */
open class CryptographicUnexpectedOperationException
    :
    dotnet.System.Security.Cryptography.CryptographicException
{
    open class override func get_type_handle() -> TypeHandle {
        return System_Security_Cryptography_CryptographicUnexpectedOperationException_get_type_handle();
    }
    public required init(hndl: NonnullHandle) { super.init(hndl: hndl); }
    public required init(gval: GVal) { super.init(gval: gval); }
    // .ctor()
// docid: M:System.Security.Cryptography.CryptographicUnexpectedOperationException.#ctor
    /**
    Initializes a new instance of the  class with default properties.

    */
    public override init() throws {
        var __thrown : NullableHandle = nil;
        let h = System_Security_Cryptography_CryptographicUnexpectedOperationException_ctor_0__0(&__thrown);
        if let __ex = __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
            super.init(hndl: h);
        }
    }
    // .ctor(System.String)
// docid: M:System.Security.Cryptography.CryptographicUnexpectedOperationException.#ctor(System.String)
    /**
    Initializes a new instance of the  class with a specified error message.

    - Parameter message: The error message that explains the reason for the exception.
    */
    public override init(message : Optional<dotnet.System.String>) throws {
        var __thrown : NullableHandle = nil;
        let h = System_Security_Cryptography_CryptographicUnexpectedOperationException_ctor_0__1__String(&__thrown, message?.get_handle() ?? nil);
        if let __ex = __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
            super.init(hndl: h);
        }
    }
    // .ctor(System.String, System.Exception)
// docid: M:System.Security.Cryptography.CryptographicUnexpectedOperationException.#ctor(System.String,System.Exception)
    /**
    Initializes a new instance of the  class with a specified error message and a reference to the inner exception that is the cause of this exception.

    - Parameter message: The error message that explains the reason for the exception.
    - Parameter inner: The exception that is the cause of the current exception. If the  parameter is not , the current exception is raised in a  block that handles the inner exception.
    */
    public override init(message : Optional<dotnet.System.String>, inner : Optional<dotnet.System.Exception>) throws {
        var __thrown : NullableHandle = nil;
        let h = System_Security_Cryptography_CryptographicUnexpectedOperationException_ctor_0__2__String_Exception(&__thrown, message?.get_handle() ?? nil, inner?.get_handle() ?? nil);
        if let __ex = __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
            super.init(hndl: h);
        }
    }
    // .ctor(System.String, System.String)
// docid: M:System.Security.Cryptography.CryptographicUnexpectedOperationException.#ctor(System.String,System.String)
    /**
    Initializes a new instance of the  class with a specified error message in the specified format.

    - Parameter format: The format used to output the error message.
    - Parameter insert: The error message that explains the reason for the exception.
    */
    public override init(format : dotnet.System.String, insert : Optional<dotnet.System.String>) throws {
        var __thrown : NullableHandle = nil;
        let h = System_Security_Cryptography_CryptographicUnexpectedOperationException_ctor_0__2__String_String(&__thrown, format.get_handle(), insert?.get_handle() ?? nil);
        if let __ex = __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
            super.init(hndl: h);
        }
    }
} // CryptographicUnexpectedOperationException


// type: System.Security.Cryptography.HMAC
    /**
    Represents the abstract class from which all implementations of Hash-based Message Authentication Code (HMAC) must derive.

    */
open class HMAC
    :
    dotnet.System.Security.Cryptography.KeyedHashAlgorithm
{
    open class override func get_type_handle() -> TypeHandle {
        return System_Security_Cryptography_HMAC_get_type_handle();
    }
    public required init(hndl: NonnullHandle) { super.init(hndl: hndl); }
    public required init(gval: GVal) { super.init(gval: gval); }
    // System.Security.Cryptography.HMAC Create()
// docid: M:System.Security.Cryptography.HMAC.Create
    /**
    Creates an instance of the default implementation of a Hash-based Message Authentication Code (HMAC).

    - Returns: A new SHA-1 instance, unless the default settings have been changed by using the <cryptoClass> element.

    */
    open class override func Create() throws -> dotnet.System.Security.Cryptography.HMAC {
        var __thrown : NullableHandle = nil;
        let __return = System_Security_Cryptography_HMAC_HMAC__Create_0__0(&__thrown);
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return dotnet.System.Security.Cryptography.HMAC(hndl : __return);
        }
    }
    // System.Security.Cryptography.HMAC Create(System.String)
// docid: M:System.Security.Cryptography.HMAC.Create(System.String)
    /**
    Creates an instance of the specified implementation of a Hash-based Message Authentication Code (HMAC).

    - Parameter algorithmName: The HMAC implementation to use. The following table shows the valid values for the  parameter and the algorithms they map to.  
  
  Parameter value Implements System.Security.Cryptography.HMAC System.Security.Cryptography.KeyedHashAlgorithm HMACMD5 System.Security.Cryptography.HMACMD5 HMACRIPEMD160 System.Security.Cryptography.HMACRIPEMD160 HMACSHA1 System.Security.Cryptography.HMACSHA1 HMACSHA256 System.Security.Cryptography.HMACSHA256 HMACSHA384 System.Security.Cryptography.HMACSHA384 HMACSHA512 System.Security.Cryptography.HMACSHA512 MACTripleDES System.Security.Cryptography.MACTripleDES
    - Returns: A new instance of the specified HMAC implementation.

    */
    open class func Create(algorithmName : dotnet.System.String) throws -> Optional<dotnet.System.Security.Cryptography.HMAC> {
        var __thrown : NullableHandle = nil;
        let __return = System_Security_Cryptography_HMAC_HMAC__Create_0__1__String(&__thrown, algorithmName.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        if let __ret_unwrapped = __return {
            return dotnet.System.Security.Cryptography.HMAC(hndl : __ret_unwrapped);
        } else {
            return nil;
        }
        }
    }
    // void Initialize()
// docid: M:System.Security.Cryptography.HMAC.Initialize
    /**
    Initializes an instance of the default implementation of .

    */
    open override func Initialize() throws {
        var __thrown : NullableHandle = nil;
        System_Security_Cryptography_HMAC_void__Initialize_0__0(&__thrown, self.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
            return;
        }
    }
    // [IsSpecialName] System.String get_HashName()
// docid: M:System.Security.Cryptography.HMAC.get_HashName
    open func get_HashName() throws -> dotnet.System.String {
        var __thrown : NullableHandle = nil;
        let __return = System_Security_Cryptography_HMAC_String__get_HashName_0__0(&__thrown, self.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return dotnet.System.String(hndl : __return);
        }
    }
    // [IsSpecialName] void set_HashName(System.String)
// docid: M:System.Security.Cryptography.HMAC.set_HashName(System.String)
    open func set_HashName(value : dotnet.System.String) throws {
        var __thrown : NullableHandle = nil;
        System_Security_Cryptography_HMAC_void__set_HashName_0__1__String(&__thrown, self.get_handle(), value.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
            return;
        }
    }
    // [IsSpecialName] System.Byte[] get_Key()
// docid: M:System.Security.Cryptography.HMAC.get_Key
    open override func get_Key() throws -> dotnet.System_Arr<Swift.UInt8> {
        var __thrown : NullableHandle = nil;
        let __return = System_Security_Cryptography_HMAC_u8Array__get_Key_0__0(&__thrown, self.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return dotnet.System_Arr<Swift.UInt8>(hndl : __return);
        }
    }
    // [IsSpecialName] void set_Key(System.Byte[])
// docid: M:System.Security.Cryptography.HMAC.set_Key(System.Byte[])
    open override func set_Key(value : dotnet.System_Arr<Swift.UInt8>) throws {
        var __thrown : NullableHandle = nil;
        System_Security_Cryptography_HMAC_void__set_Key_0__1__u8Array(&__thrown, self.get_handle(), value.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
            return;
        }
    }
    /**
    Gets or sets the name of the hash algorithm to use for hashing.

    */
    open var HashName : dotnet.System.String {
        get {
            return try! get_HashName();
        }
        set(v) {
            return try! set_HashName(value: v);
        }
    }
    /**
    Gets or sets the key to use in the HMAC calculation.

    */
    open override var Key : dotnet.System_Arr<Swift.UInt8> {
        get {
            return try! get_Key();
        }
        set(v) {
            return try! set_Key(value: v);
        }
    }
} // HMAC


// type: System.Security.Cryptography.HashAlgorithm
    /**
    Represents the base class from which all implementations of cryptographic hash algorithms must derive.

    */
open class HashAlgorithm
    :
    dotnet.System.Object,
    System_IDisposable,
    System_Security_Cryptography_ICryptoTransform
{
    open class override func get_type_handle() -> TypeHandle {
        return System_Security_Cryptography_HashAlgorithm_get_type_handle();
    }
    public required init(hndl: NonnullHandle) { super.init(hndl: hndl); }
    public required init(gval: GVal) { super.init(gval: gval); }
    // void Clear()
// docid: M:System.Security.Cryptography.HashAlgorithm.Clear
    /**
    Releases all resources used by the  class.

    */
    open func Clear() throws {
        var __thrown : NullableHandle = nil;
        System_Security_Cryptography_HashAlgorithm_void__Clear_0__0(&__thrown, self.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
            return;
        }
    }
    // System.Byte[] ComputeHash(System.Byte[])
// docid: M:System.Security.Cryptography.HashAlgorithm.ComputeHash(System.Byte[])
    /**
    Computes the hash value for the specified byte array.

    - Parameter buffer: The input to compute the hash code for.
    - Returns: The computed hash code.

    */
    open func ComputeHash(buffer : dotnet.System_Arr<Swift.UInt8>) throws -> dotnet.System_Arr<Swift.UInt8> {
        var __thrown : NullableHandle = nil;
        let __return = System_Security_Cryptography_HashAlgorithm_u8Array__ComputeHash_0__1__u8Array(&__thrown, self.get_handle(), buffer.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return dotnet.System_Arr<Swift.UInt8>(hndl : __return);
        }
    }
    // System.Byte[] ComputeHash(System.Byte[], System.Int32, System.Int32)
// docid: M:System.Security.Cryptography.HashAlgorithm.ComputeHash(System.Byte[],System.Int32,System.Int32)
    /**
    Computes the hash value for the specified region of the specified byte array.

    - Parameter buffer: The input to compute the hash code for.
    - Parameter offset: The offset into the byte array from which to begin using data.
    - Parameter count: The number of bytes in the array to use as data.
    - Returns: The computed hash code.

    */
    open func ComputeHash(buffer : dotnet.System_Arr<Swift.UInt8>, offset : Swift.Int32, count : Swift.Int32) throws -> dotnet.System_Arr<Swift.UInt8> {
        var __thrown : NullableHandle = nil;
        let __return = System_Security_Cryptography_HashAlgorithm_u8Array__ComputeHash_0__3__u8Array_i32_i32(&__thrown, self.get_handle(), buffer.get_handle(), offset, count);
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return dotnet.System_Arr<Swift.UInt8>(hndl : __return);
        }
    }
    // System.Byte[] ComputeHash(System.IO.Stream)
// docid: M:System.Security.Cryptography.HashAlgorithm.ComputeHash(System.IO.Stream)
    /**
    Computes the hash value for the specified  object.

    - Parameter inputStream: The input to compute the hash code for.
    - Returns: The computed hash code.

    */
    open func ComputeHash(inputStream : dotnet.System.IO.Stream) throws -> dotnet.System_Arr<Swift.UInt8> {
        var __thrown : NullableHandle = nil;
        let __return = System_Security_Cryptography_HashAlgorithm_u8Array__ComputeHash_0__1__Stream(&__thrown, self.get_handle(), inputStream.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return dotnet.System_Arr<Swift.UInt8>(hndl : __return);
        }
    }
    // System.Threading.Tasks.Task<System.Byte[]> ComputeHashAsync(System.IO.Stream, System.Threading.CancellationToken)
// docid: M:System.Security.Cryptography.HashAlgorithm.ComputeHashAsync(System.IO.Stream,System.Threading.CancellationToken)
    /**
    Asynchronously computes the hash value for the specified  object.

    - Parameter inputStream: The input to compute the hash code for.
    - Parameter cancellationToken: The token to monitor for cancellation requests.
    - Returns: A task that represents the asynchronous compute hash operation and wraps the computed hash code.

    */
    open func ComputeHashAsync(inputStream : dotnet.System.IO.Stream, cancellationToken : dotnet.System.Threading.CancellationToken = System.Threading.CancellationToken.None) throws -> dotnet.System.Threading.Tasks.Task_1<dotnet.System_Arr<Swift.UInt8>> {
        var __thrown : NullableHandle = nil;
        let __return = System_Security_Cryptography_HashAlgorithm_System_Threading_Tasks_Task_u8Array___ComputeHashAsync_0__2__Stream_CancellationToken(&__thrown, self.get_handle(), inputStream.get_handle(), cancellationToken.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return dotnet.System.Threading.Tasks.Task_1(hndl : __return);
        }
    }
    // System.Security.Cryptography.HashAlgorithm Create()
// docid: M:System.Security.Cryptography.HashAlgorithm.Create
    /**
    Creates an instance of the default implementation of a hash algorithm.

    - Returns: A new  instance, unless the default settings have been changed using the .

    */
    open class func Create() throws -> dotnet.System.Security.Cryptography.HashAlgorithm {
        var __thrown : NullableHandle = nil;
        let __return = System_Security_Cryptography_HashAlgorithm_HashAlgorithm__Create_0__0(&__thrown);
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return dotnet.System.Security.Cryptography.HashAlgorithm(hndl : __return);
        }
    }
    // System.Security.Cryptography.HashAlgorithm Create(System.String)
// docid: M:System.Security.Cryptography.HashAlgorithm.Create(System.String)
    /**
    Creates an instance of the specified implementation of a hash algorithm.

    - Parameter hashName: The hash algorithm implementation to use. The following table shows the valid values for the  parameter and the algorithms they map to.  
  
  Parameter value Implements SHA SHA1 System.Security.Cryptography.SHA1 System.Security.Cryptography.HashAlgorithm MD5 System.Security.Cryptography.MD5 SHA256 SHA-256 System.Security.Cryptography.SHA256 SHA384 SHA-384 System.Security.Cryptography.SHA384 SHA512 SHA-512 System.Security.Cryptography.SHA512
    - Returns: A new instance of the specified hash algorithm, or  if  is not a valid hash algorithm.

    */
    open class func Create(hashName : dotnet.System.String) throws -> Optional<dotnet.System.Security.Cryptography.HashAlgorithm> {
        var __thrown : NullableHandle = nil;
        let __return = System_Security_Cryptography_HashAlgorithm_HashAlgorithm__Create_0__1__String(&__thrown, hashName.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        if let __ret_unwrapped = __return {
            return dotnet.System.Security.Cryptography.HashAlgorithm(hndl : __ret_unwrapped);
        } else {
            return nil;
        }
        }
    }
    // void Dispose()
// docid: M:System.Security.Cryptography.HashAlgorithm.Dispose
    /**
    Releases all resources used by the current instance of the  class.

    */
    open /* method final */ func Dispose() throws {
        var __thrown : NullableHandle = nil;
        System_Security_Cryptography_HashAlgorithm_void__Dispose_0__0(&__thrown, self.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
            return;
        }
    }
    // void Initialize()
// docid: M:System.Security.Cryptography.HashAlgorithm.Initialize
    /**
    Resets the hash algorithm to its initial state.

    */
    open func Initialize() throws {
        var __thrown : NullableHandle = nil;
        System_Security_Cryptography_HashAlgorithm_void__Initialize_0__0(&__thrown, self.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
            return;
        }
    }
    // System.Int32 TransformBlock(System.Byte[], System.Int32, System.Int32, System.Byte[], System.Int32)
// docid: M:System.Security.Cryptography.HashAlgorithm.TransformBlock(System.Byte[],System.Int32,System.Int32,System.Byte[],System.Int32)
    /**
    Computes the hash value for the specified region of the input byte array and copies the specified region of the input byte array to the specified region of the output byte array.

    - Parameter inputBuffer: The input to compute the hash code for.
    - Parameter inputOffset: The offset into the input byte array from which to begin using data.
    - Parameter inputCount: The number of bytes in the input byte array to use as data.
    - Parameter outputBuffer: A copy of the part of the input array used to compute the hash code.
    - Parameter outputOffset: The offset into the output byte array from which to begin writing data.
    - Returns: The number of bytes written.

    */
    open /* method final */ func TransformBlock(inputBuffer : dotnet.System_Arr<Swift.UInt8>, inputOffset : Swift.Int32, inputCount : Swift.Int32, outputBuffer : Optional<dotnet.System_Arr<Swift.UInt8>>, outputOffset : Swift.Int32) throws -> Swift.Int32 {
        var __thrown : NullableHandle = nil;
        let __return = System_Security_Cryptography_HashAlgorithm_i32__TransformBlock_0__5__u8Array_i32_i32_u8Array_i32(&__thrown, self.get_handle(), inputBuffer.get_handle(), inputOffset, inputCount, (outputBuffer?.get_handle()), outputOffset);
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return __return;
        }
    }
    // System.Byte[] TransformFinalBlock(System.Byte[], System.Int32, System.Int32)
// docid: M:System.Security.Cryptography.HashAlgorithm.TransformFinalBlock(System.Byte[],System.Int32,System.Int32)
    /**
    Computes the hash value for the specified region of the specified byte array.

    - Parameter inputBuffer: The input to compute the hash code for.
    - Parameter inputOffset: The offset into the byte array from which to begin using data.
    - Parameter inputCount: The number of bytes in the byte array to use as data.
    - Returns: An array that is a copy of the part of the input that is hashed.

    */
    open /* method final */ func TransformFinalBlock(inputBuffer : dotnet.System_Arr<Swift.UInt8>, inputOffset : Swift.Int32, inputCount : Swift.Int32) throws -> dotnet.System_Arr<Swift.UInt8> {
        var __thrown : NullableHandle = nil;
        let __return = System_Security_Cryptography_HashAlgorithm_u8Array__TransformFinalBlock_0__3__u8Array_i32_i32(&__thrown, self.get_handle(), inputBuffer.get_handle(), inputOffset, inputCount);
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return dotnet.System_Arr<Swift.UInt8>(hndl : __return);
        }
    }
// TODO COPE (write_all_methods) (span) bool TryComputeHash(System.ReadOnlySpan<System.Byte>, System.Span<System.Byte>, ref System.Int32)
    // [IsSpecialName] bool get_CanReuseTransform()
// docid: M:System.Security.Cryptography.HashAlgorithm.get_CanReuseTransform
    open func get_CanReuseTransform() throws -> Bool {
        var __thrown : NullableHandle = nil;
        let __return = System_Security_Cryptography_HashAlgorithm_bool__get_CanReuseTransform_0__0(&__thrown, self.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return (__return) != 0;
        }
    }
    // [IsSpecialName] bool get_CanTransformMultipleBlocks()
// docid: M:System.Security.Cryptography.HashAlgorithm.get_CanTransformMultipleBlocks
    open func get_CanTransformMultipleBlocks() throws -> Bool {
        var __thrown : NullableHandle = nil;
        let __return = System_Security_Cryptography_HashAlgorithm_bool__get_CanTransformMultipleBlocks_0__0(&__thrown, self.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return (__return) != 0;
        }
    }
    // [IsSpecialName] System.Byte[] get_Hash()
// docid: M:System.Security.Cryptography.HashAlgorithm.get_Hash
    open func get_Hash() throws -> Optional<dotnet.System_Arr<Swift.UInt8>> {
        var __thrown : NullableHandle = nil;
        let __return = System_Security_Cryptography_HashAlgorithm_u8Array__get_Hash_0__0(&__thrown, self.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        if let __ret_unwrapped = __return {
            return dotnet.System_Arr<Swift.UInt8>(hndl : __ret_unwrapped);
        } else {
            return nil;
        }
        }
    }
    // [IsSpecialName] System.Int32 get_HashSize()
// docid: M:System.Security.Cryptography.HashAlgorithm.get_HashSize
    open func get_HashSize() throws -> Swift.Int32 {
        var __thrown : NullableHandle = nil;
        let __return = System_Security_Cryptography_HashAlgorithm_i32__get_HashSize_0__0(&__thrown, self.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return __return;
        }
    }
    // [IsSpecialName] System.Int32 get_InputBlockSize()
// docid: M:System.Security.Cryptography.HashAlgorithm.get_InputBlockSize
    open func get_InputBlockSize() throws -> Swift.Int32 {
        var __thrown : NullableHandle = nil;
        let __return = System_Security_Cryptography_HashAlgorithm_i32__get_InputBlockSize_0__0(&__thrown, self.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return __return;
        }
    }
    // [IsSpecialName] System.Int32 get_OutputBlockSize()
// docid: M:System.Security.Cryptography.HashAlgorithm.get_OutputBlockSize
    open func get_OutputBlockSize() throws -> Swift.Int32 {
        var __thrown : NullableHandle = nil;
        let __return = System_Security_Cryptography_HashAlgorithm_i32__get_OutputBlockSize_0__0(&__thrown, self.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return __return;
        }
    }
    /**
    Gets a value indicating whether the current transform can be reused.

    */
    open var CanReuseTransform : Bool {
        get {
            return try! get_CanReuseTransform();
        }
    }
    /**
    When overridden in a derived class, gets a value indicating whether multiple blocks can be transformed.

    */
    open var CanTransformMultipleBlocks : Bool {
        get {
            return try! get_CanTransformMultipleBlocks();
        }
    }
    /**
    Gets the value of the computed hash code.

    */
    open var Hash : Optional<dotnet.System_Arr<Swift.UInt8>> {
        get {
            return try! get_Hash();
        }
    }
    /**
    Gets the size, in bits, of the computed hash code.

    */
    open var HashSize : Swift.Int32 {
        get {
            return try! get_HashSize();
        }
    }
    /**
    When overridden in a derived class, gets the input block size.

    */
    open var InputBlockSize : Swift.Int32 {
        get {
            return try! get_InputBlockSize();
        }
    }
    /**
    When overridden in a derived class, gets the output block size.

    */
    open var OutputBlockSize : Swift.Int32 {
        get {
            return try! get_OutputBlockSize();
        }
    }
} // HashAlgorithm


// type: System.Security.Cryptography.HashAlgorithmName
// boxed value type
    /**
    Specifies the name of a cryptographic hash algorithm.

    */
public final class HashAlgorithmName
    :
    dotnet.System.Object
{
    public class override func get_type_handle() -> TypeHandle {
        return System_Security_Cryptography_HashAlgorithmName_get_type_handle();
    }
    public required init(hndl: NonnullHandle) { super.init(hndl: hndl); }
    public required init(gval: GVal) { super.init(gval: gval); }
    /**
    Gets a hash algorithm name that represents "MD5".

    */
    public static var MD5 : dotnet.System.Security.Cryptography.HashAlgorithmName {
        get {
            return try! get_MD5();
        }
    }
    /**
    Gets the underlying string representation of the algorithm name.

    */
    public var Name : Optional<dotnet.System.String> {
        get {
            return try! get_Name();
        }
    }
    /**
    Gets a hash algorithm name that represents "SHA1".

    */
    public static var SHA1 : dotnet.System.Security.Cryptography.HashAlgorithmName {
        get {
            return try! get_SHA1();
        }
    }
    /**
    Gets a hash algorithm name that represents "SHA256".

    */
    public static var SHA256 : dotnet.System.Security.Cryptography.HashAlgorithmName {
        get {
            return try! get_SHA256();
        }
    }
    /**
    Gets a hash algorithm name that represents "SHA384".

    */
    public static var SHA384 : dotnet.System.Security.Cryptography.HashAlgorithmName {
        get {
            return try! get_SHA384();
        }
    }
    /**
    Gets a hash algorithm name that represents "SHA512".

    */
    public static var SHA512 : dotnet.System.Security.Cryptography.HashAlgorithmName {
        get {
            return try! get_SHA512();
        }
    }
    // .ctor(System.String)
// docid: M:System.Security.Cryptography.HashAlgorithmName.#ctor(System.String)
    /**
    Initializes a new instance of the  structure with a custom name.

    - Parameter name: The custom hash algorithm name.
    */
    public init(name : Optional<dotnet.System.String>) throws {
        var __thrown : NullableHandle = nil;
        let h = System_Security_Cryptography_HashAlgorithmName_ctor_0__1__String(&__thrown, name?.get_handle() ?? nil);
        if let __ex = __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
            super.init(hndl: h);
        }
    }
    public override init() {
        let h = System_Security_Cryptography_HashAlgorithmName_implicit_ctor();
            super.init(hndl: h);
    }
    // bool Equals(System.Object)
// docid: M:System.Security.Cryptography.HashAlgorithmName.Equals(System.Object)
    /**
    Returns a value that indicates whether the current instance and a specified object are equal.

    - Parameter obj: The object to compare with the current instance.
    - Returns: 
         if  is a  object and its  property is equal to that of the current instance. The comparison is ordinal and case-sensitive.

    */
    public override func Equals(obj : Optional<dotnet.System.Object>) throws -> Bool {
        var __thrown : NullableHandle = nil;
        let __return = System_Security_Cryptography_HashAlgorithmName_bool__Equals_0__1__Object(&__thrown, self.get_handle(), obj?.get_handle() ?? nil);
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return (__return) != 0;
        }
    }
    // bool Equals(System.Security.Cryptography.HashAlgorithmName)
// docid: M:System.Security.Cryptography.HashAlgorithmName.Equals(System.Security.Cryptography.HashAlgorithmName)
    /**
    Returns a value that indicates whether two  instances are equal.

    - Parameter other: The object to compare with the current instance.
    - Returns: 
         if the  property of  is equal to that of the current instance. The comparison is ordinal and case-sensitive.

    */
    public func Equals(other : dotnet.System.Security.Cryptography.HashAlgorithmName) throws -> Bool {
        var __thrown : NullableHandle = nil;
        let __return = System_Security_Cryptography_HashAlgorithmName_bool__Equals_0__1__HashAlgorithmName(&__thrown, self.get_handle(), other.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return (__return) != 0;
        }
    }
    // System.Security.Cryptography.HashAlgorithmName FromOid(System.String)
// docid: M:System.Security.Cryptography.HashAlgorithmName.FromOid(System.String)
    /**
    Converts the specified OID to a hash algorithm name.

    - Parameter oidValue: The OID of the hash algorithm.
    - Returns: The hash algorithm name identified by the OID.

    */
    public class func FromOid(oidValue : dotnet.System.String) throws -> dotnet.System.Security.Cryptography.HashAlgorithmName {
        var __thrown : NullableHandle = nil;
        let __return = System_Security_Cryptography_HashAlgorithmName_HashAlgorithmName__FromOid_0__1__String(&__thrown, oidValue.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return dotnet.System.Security.Cryptography.HashAlgorithmName(hndl : __return);
        }
    }
    // System.Int32 GetHashCode()
// docid: M:System.Security.Cryptography.HashAlgorithmName.GetHashCode
    /**
    Returns the hash code for the current instance.

    - Returns: The hash code for the current instance, or 0 if no  value was supplied to the  constructor.

    */
    public override func GetHashCode() throws -> Swift.Int32 {
        var __thrown : NullableHandle = nil;
        let __return = System_Security_Cryptography_HashAlgorithmName_i32__GetHashCode_0__0(&__thrown, self.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return __return;
        }
    }
    // [IsSpecialName] bool op_Equality(System.Security.Cryptography.HashAlgorithmName, System.Security.Cryptography.HashAlgorithmName)
// docid: M:System.Security.Cryptography.HashAlgorithmName.op_Equality(System.Security.Cryptography.HashAlgorithmName,System.Security.Cryptography.HashAlgorithmName)
    /**
    Determines whether two specified  objects are equal.

    - Parameter left: The first object to compare.
    - Parameter right: The second object to compare.
    - Returns: 
         if both  and  have the same  value; otherwise, .

    */
    public class func op_Equality(left : dotnet.System.Security.Cryptography.HashAlgorithmName, right : dotnet.System.Security.Cryptography.HashAlgorithmName) throws -> Bool {
        var __thrown : NullableHandle = nil;
        let __return = System_Security_Cryptography_HashAlgorithmName_bool__op_Equality_0__2__HashAlgorithmName_HashAlgorithmName(&__thrown, left.get_handle(), right.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return (__return) != 0;
        }
    }
    // [IsSpecialName] bool op_Inequality(System.Security.Cryptography.HashAlgorithmName, System.Security.Cryptography.HashAlgorithmName)
// docid: M:System.Security.Cryptography.HashAlgorithmName.op_Inequality(System.Security.Cryptography.HashAlgorithmName,System.Security.Cryptography.HashAlgorithmName)
    /**
    Determines whether two specified  objects are not equal.

    - Parameter left: The first object to compare.
    - Parameter right: The second object to compare.
    - Returns: 
         if both  and  do not have the same  value; otherwise, .

    */
    public class func op_Inequality(left : dotnet.System.Security.Cryptography.HashAlgorithmName, right : dotnet.System.Security.Cryptography.HashAlgorithmName) throws -> Bool {
        var __thrown : NullableHandle = nil;
        let __return = System_Security_Cryptography_HashAlgorithmName_bool__op_Inequality_0__2__HashAlgorithmName_HashAlgorithmName(&__thrown, left.get_handle(), right.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return (__return) != 0;
        }
    }
    // System.String ToString()
// docid: M:System.Security.Cryptography.HashAlgorithmName.ToString
    /**
    Returns the string representation of the current  instance.

    - Returns: The string representation of the current  instance.

    */
    public override func ToString() throws -> dotnet.System.String {
        var __thrown : NullableHandle = nil;
        let __return = System_Security_Cryptography_HashAlgorithmName_String__ToString_0__0(&__thrown, self.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return dotnet.System.String(hndl : __return);
        }
    }
    // bool TryFromOid(System.String, ref System.Security.Cryptography.HashAlgorithmName)
// docid: M:System.Security.Cryptography.HashAlgorithmName.TryFromOid(System.String,System.Security.Cryptography.HashAlgorithmName@)
    /**
    Tries to convert the specified OID to a hash algorithm name.

    - Parameter oidValue: The OID of the hash algorithm.
    - Parameter value: When this method returns , the hash algorithm. When this method returns , contains default.
    - Returns: 
         if the OID was successfully mapped to a hash algorithm; otherwise .

    */
    public class func TryFromOid(oidValue : dotnet.System.String, value : inout dotnet.System.Security.Cryptography.HashAlgorithmName) throws -> Bool {
        var __thrown : NullableHandle = nil;
            var _tmp_out_value = value.get_handle();
        let __return = System_Security_Cryptography_HashAlgorithmName_bool__TryFromOid_0__2__String_outHashAlgorithmName(&__thrown, oidValue.get_handle(), &_tmp_out_value);
        let _tmp2_value = dotnet.System.Security.Cryptography.HashAlgorithmName(hndl: _tmp_out_value);
            value = _tmp2_value;
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return (__return) != 0;
        }
    }
    // [IsSpecialName] System.Security.Cryptography.HashAlgorithmName get_MD5()
// docid: M:System.Security.Cryptography.HashAlgorithmName.get_MD5
    public class func get_MD5() throws -> dotnet.System.Security.Cryptography.HashAlgorithmName {
        var __thrown : NullableHandle = nil;
        let __return = System_Security_Cryptography_HashAlgorithmName_HashAlgorithmName__get_MD5_0__0(&__thrown);
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return dotnet.System.Security.Cryptography.HashAlgorithmName(hndl : __return);
        }
    }
    // [IsSpecialName] System.String get_Name()
// docid: M:System.Security.Cryptography.HashAlgorithmName.get_Name
    public func get_Name() throws -> Optional<dotnet.System.String> {
        var __thrown : NullableHandle = nil;
        let __return = System_Security_Cryptography_HashAlgorithmName_String__get_Name_0__0(&__thrown, self.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        if let __ret_unwrapped = __return {
            return dotnet.System.String(hndl : __ret_unwrapped);
        } else {
            return nil;
        }
        }
    }
    // [IsSpecialName] System.Security.Cryptography.HashAlgorithmName get_SHA1()
// docid: M:System.Security.Cryptography.HashAlgorithmName.get_SHA1
    public class func get_SHA1() throws -> dotnet.System.Security.Cryptography.HashAlgorithmName {
        var __thrown : NullableHandle = nil;
        let __return = System_Security_Cryptography_HashAlgorithmName_HashAlgorithmName__get_SHA1_0__0(&__thrown);
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return dotnet.System.Security.Cryptography.HashAlgorithmName(hndl : __return);
        }
    }
    // [IsSpecialName] System.Security.Cryptography.HashAlgorithmName get_SHA256()
// docid: M:System.Security.Cryptography.HashAlgorithmName.get_SHA256
    public class func get_SHA256() throws -> dotnet.System.Security.Cryptography.HashAlgorithmName {
        var __thrown : NullableHandle = nil;
        let __return = System_Security_Cryptography_HashAlgorithmName_HashAlgorithmName__get_SHA256_0__0(&__thrown);
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return dotnet.System.Security.Cryptography.HashAlgorithmName(hndl : __return);
        }
    }
    // [IsSpecialName] System.Security.Cryptography.HashAlgorithmName get_SHA384()
// docid: M:System.Security.Cryptography.HashAlgorithmName.get_SHA384
    public class func get_SHA384() throws -> dotnet.System.Security.Cryptography.HashAlgorithmName {
        var __thrown : NullableHandle = nil;
        let __return = System_Security_Cryptography_HashAlgorithmName_HashAlgorithmName__get_SHA384_0__0(&__thrown);
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return dotnet.System.Security.Cryptography.HashAlgorithmName(hndl : __return);
        }
    }
    // [IsSpecialName] System.Security.Cryptography.HashAlgorithmName get_SHA512()
// docid: M:System.Security.Cryptography.HashAlgorithmName.get_SHA512
    public class func get_SHA512() throws -> dotnet.System.Security.Cryptography.HashAlgorithmName {
        var __thrown : NullableHandle = nil;
        let __return = System_Security_Cryptography_HashAlgorithmName_HashAlgorithmName__get_SHA512_0__0(&__thrown);
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return dotnet.System.Security.Cryptography.HashAlgorithmName(hndl : __return);
        }
    }
} // HashAlgorithmName


// type: System.Security.Cryptography.ICryptoTransform
    /**
    Defines the basic operations of cryptographic transformations.

    */
open class ICryptoTransform
    :
    SGBridgeGenericValue,
    System_Security_Cryptography_ICryptoTransform,
    System_IDisposable
{
    open class func get_type_handle() -> TypeHandle {
        return System_Security_Cryptography_ICryptoTransform_get_type_handle();
    }
    let h : NonnullHandle;
    public func to_gval() -> GVal { return GVal(Swift.Int(bitPattern: self.h)); }
    public func dup_gval() -> GVal { return GVal(Swift.Int(bitPattern: __copy_handle(self.h))); }
    public required init(gval: GVal) { self.h = NonnullHandle(bitPattern: Swift.Int(truncatingIfNeeded: gval))!; }
    public required init(hndl: NonnullHandle) { self.h = hndl; }
    public func get_handle() -> NonnullHandle { return self.h; }

    deinit { __drop_handle(self.h); }

    // System.Int32 TransformBlock(System.Byte[], System.Int32, System.Int32, System.Byte[], System.Int32)
// docid: M:System.Security.Cryptography.ICryptoTransform.TransformBlock(System.Byte[],System.Int32,System.Int32,System.Byte[],System.Int32)
    /**
    Transforms the specified region of the input byte array and copies the resulting transform to the specified region of the output byte array.

    - Parameter inputBuffer: The input for which to compute the transform.
    - Parameter inputOffset: The offset into the input byte array from which to begin using data.
    - Parameter inputCount: The number of bytes in the input byte array to use as data.
    - Parameter outputBuffer: The output to which to write the transform.
    - Parameter outputOffset: The offset into the output byte array from which to begin writing data.
    - Returns: The number of bytes written.

    */
    open func TransformBlock(inputBuffer : dotnet.System_Arr<Swift.UInt8>, inputOffset : Swift.Int32, inputCount : Swift.Int32, outputBuffer : dotnet.System_Arr<Swift.UInt8>, outputOffset : Swift.Int32) throws -> Swift.Int32 {
        var __thrown : NullableHandle = nil;
        let __return = System_Security_Cryptography_ICryptoTransform_i32__TransformBlock_0__5__u8Array_i32_i32_u8Array_i32(&__thrown, self.get_handle(), inputBuffer.get_handle(), inputOffset, inputCount, outputBuffer.get_handle(), outputOffset);
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return __return;
        }
    }
    // System.Byte[] TransformFinalBlock(System.Byte[], System.Int32, System.Int32)
// docid: M:System.Security.Cryptography.ICryptoTransform.TransformFinalBlock(System.Byte[],System.Int32,System.Int32)
    /**
    Transforms the specified region of the specified byte array.

    - Parameter inputBuffer: The input for which to compute the transform.
    - Parameter inputOffset: The offset into the byte array from which to begin using data.
    - Parameter inputCount: The number of bytes in the byte array to use as data.
    - Returns: The computed transform.

    */
    open func TransformFinalBlock(inputBuffer : dotnet.System_Arr<Swift.UInt8>, inputOffset : Swift.Int32, inputCount : Swift.Int32) throws -> dotnet.System_Arr<Swift.UInt8> {
        var __thrown : NullableHandle = nil;
        let __return = System_Security_Cryptography_ICryptoTransform_u8Array__TransformFinalBlock_0__3__u8Array_i32_i32(&__thrown, self.get_handle(), inputBuffer.get_handle(), inputOffset, inputCount);
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return dotnet.System_Arr<Swift.UInt8>(hndl : __return);
        }
    }
    // [IsSpecialName] bool get_CanReuseTransform()
// docid: M:System.Security.Cryptography.ICryptoTransform.get_CanReuseTransform
    open func get_CanReuseTransform() throws -> Bool {
        var __thrown : NullableHandle = nil;
        let __return = System_Security_Cryptography_ICryptoTransform_bool__get_CanReuseTransform_0__0(&__thrown, self.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return (__return) != 0;
        }
    }
    // [IsSpecialName] bool get_CanTransformMultipleBlocks()
// docid: M:System.Security.Cryptography.ICryptoTransform.get_CanTransformMultipleBlocks
    open func get_CanTransformMultipleBlocks() throws -> Bool {
        var __thrown : NullableHandle = nil;
        let __return = System_Security_Cryptography_ICryptoTransform_bool__get_CanTransformMultipleBlocks_0__0(&__thrown, self.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return (__return) != 0;
        }
    }
    // [IsSpecialName] System.Int32 get_InputBlockSize()
// docid: M:System.Security.Cryptography.ICryptoTransform.get_InputBlockSize
    open func get_InputBlockSize() throws -> Swift.Int32 {
        var __thrown : NullableHandle = nil;
        let __return = System_Security_Cryptography_ICryptoTransform_i32__get_InputBlockSize_0__0(&__thrown, self.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return __return;
        }
    }
    // [IsSpecialName] System.Int32 get_OutputBlockSize()
// docid: M:System.Security.Cryptography.ICryptoTransform.get_OutputBlockSize
    open func get_OutputBlockSize() throws -> Swift.Int32 {
        var __thrown : NullableHandle = nil;
        let __return = System_Security_Cryptography_ICryptoTransform_i32__get_OutputBlockSize_0__0(&__thrown, self.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return __return;
        }
    }
} // ICryptoTransform


// type: System.Security.Cryptography.KeySizes
    /**
    Determines the set of valid key sizes for the symmetric cryptographic algorithms.

    */
public final class KeySizes
    :
    dotnet.System.Object
{
    public class override func get_type_handle() -> TypeHandle {
        return System_Security_Cryptography_KeySizes_get_type_handle();
    }
    public required init(hndl: NonnullHandle) { super.init(hndl: hndl); }
    public required init(gval: GVal) { super.init(gval: gval); }
    // .ctor(System.Int32, System.Int32, System.Int32)
// docid: M:System.Security.Cryptography.KeySizes.#ctor(System.Int32,System.Int32,System.Int32)
    /**
    Initializes a new instance of the  class with the specified key values.

    - Parameter minSize: The minimum valid key size.
    - Parameter maxSize: The maximum valid key size.
    - Parameter skipSize: The interval between valid key sizes.
    */
    public init(minSize : Swift.Int32, maxSize : Swift.Int32, skipSize : Swift.Int32) throws {
        var __thrown : NullableHandle = nil;
        let h = System_Security_Cryptography_KeySizes_ctor_0__3__i32_i32_i32(&__thrown, minSize, maxSize, skipSize);
        if let __ex = __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
            super.init(hndl: h);
        }
    }
    // [IsSpecialName] System.Int32 get_MaxSize()
// docid: M:System.Security.Cryptography.KeySizes.get_MaxSize
    public func get_MaxSize() throws -> Swift.Int32 {
        var __thrown : NullableHandle = nil;
        let __return = System_Security_Cryptography_KeySizes_i32__get_MaxSize_0__0(&__thrown, self.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return __return;
        }
    }
    // [IsSpecialName] System.Int32 get_MinSize()
// docid: M:System.Security.Cryptography.KeySizes.get_MinSize
    public func get_MinSize() throws -> Swift.Int32 {
        var __thrown : NullableHandle = nil;
        let __return = System_Security_Cryptography_KeySizes_i32__get_MinSize_0__0(&__thrown, self.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return __return;
        }
    }
    // [IsSpecialName] System.Int32 get_SkipSize()
// docid: M:System.Security.Cryptography.KeySizes.get_SkipSize
    public func get_SkipSize() throws -> Swift.Int32 {
        var __thrown : NullableHandle = nil;
        let __return = System_Security_Cryptography_KeySizes_i32__get_SkipSize_0__0(&__thrown, self.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return __return;
        }
    }
    /**
    Specifies the maximum key size.

    */
    public var MaxSize : Swift.Int32 {
        get {
            return try! get_MaxSize();
        }
    }
    /**
    Specifies the minimum key size.

    */
    public var MinSize : Swift.Int32 {
        get {
            return try! get_MinSize();
        }
    }
    /**
    Specifies the interval between valid key sizes.

    */
    public var SkipSize : Swift.Int32 {
        get {
            return try! get_SkipSize();
        }
    }
} // KeySizes


// type: System.Security.Cryptography.KeyedHashAlgorithm
    /**
    Represents the abstract class from which all implementations of keyed hash algorithms must derive.

    */
open class KeyedHashAlgorithm
    :
    dotnet.System.Security.Cryptography.HashAlgorithm
{
    open class override func get_type_handle() -> TypeHandle {
        return System_Security_Cryptography_KeyedHashAlgorithm_get_type_handle();
    }
    public required init(hndl: NonnullHandle) { super.init(hndl: hndl); }
    public required init(gval: GVal) { super.init(gval: gval); }
    // System.Security.Cryptography.KeyedHashAlgorithm Create()
// docid: M:System.Security.Cryptography.KeyedHashAlgorithm.Create
    /**
    Creates an instance of the default implementation of a keyed hash algorithm.

    - Returns: A new  instance, unless the default settings have been changed.

    */
    open class override func Create() throws -> dotnet.System.Security.Cryptography.KeyedHashAlgorithm {
        var __thrown : NullableHandle = nil;
        let __return = System_Security_Cryptography_KeyedHashAlgorithm_KeyedHashAlgorithm__Create_0__0(&__thrown);
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return dotnet.System.Security.Cryptography.KeyedHashAlgorithm(hndl : __return);
        }
    }
    // System.Security.Cryptography.KeyedHashAlgorithm Create(System.String)
// docid: M:System.Security.Cryptography.KeyedHashAlgorithm.Create(System.String)
    /**
    Creates an instance of the specified implementation of a keyed hash algorithm.

    - Parameter algName: The keyed hash algorithm implementation to use. The following table shows the valid values for the  parameter and the algorithms they map to.  
  
  Parameter value Implements System.Security.Cryptography.HMAC System.Security.Cryptography.KeyedHashAlgorithm HMACMD5 System.Security.Cryptography.HMACMD5 HMACRIPEMD160 System.Security.Cryptography.HMACRIPEMD160 HMACSHA1 System.Security.Cryptography.HMACSHA1 HMACSHA256 System.Security.Cryptography.HMACSHA256 HMACSHA384 System.Security.Cryptography.HMACSHA384 HMACSHA512 System.Security.Cryptography.HMACSHA512 MACTripleDES System.Security.Cryptography.MACTripleDES
    - Returns: A new instance of the specified keyed hash algorithm.

    */
    open class func Create(algName : dotnet.System.String) throws -> Optional<dotnet.System.Security.Cryptography.KeyedHashAlgorithm> {
        var __thrown : NullableHandle = nil;
        let __return = System_Security_Cryptography_KeyedHashAlgorithm_KeyedHashAlgorithm__Create_0__1__String(&__thrown, algName.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        if let __ret_unwrapped = __return {
            return dotnet.System.Security.Cryptography.KeyedHashAlgorithm(hndl : __ret_unwrapped);
        } else {
            return nil;
        }
        }
    }
    // [IsSpecialName] System.Byte[] get_Key()
// docid: M:System.Security.Cryptography.KeyedHashAlgorithm.get_Key
    open func get_Key() throws -> dotnet.System_Arr<Swift.UInt8> {
        var __thrown : NullableHandle = nil;
        let __return = System_Security_Cryptography_KeyedHashAlgorithm_u8Array__get_Key_0__0(&__thrown, self.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return dotnet.System_Arr<Swift.UInt8>(hndl : __return);
        }
    }
    // [IsSpecialName] void set_Key(System.Byte[])
// docid: M:System.Security.Cryptography.KeyedHashAlgorithm.set_Key(System.Byte[])
    open func set_Key(value : dotnet.System_Arr<Swift.UInt8>) throws {
        var __thrown : NullableHandle = nil;
        System_Security_Cryptography_KeyedHashAlgorithm_void__set_Key_0__1__u8Array(&__thrown, self.get_handle(), value.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
            return;
        }
    }
    /**
    Gets or sets the key to use in the hash algorithm.

    */
    open var Key : dotnet.System_Arr<Swift.UInt8> {
        get {
            return try! get_Key();
        }
        set(v) {
            return try! set_Key(value: v);
        }
    }
} // KeyedHashAlgorithm


// type: System.Security.Cryptography.PaddingMode
    /**
    Specifies the type of padding to apply when the message data block is shorter than the full number of bytes needed for a cryptographic operation.

    */
public struct PaddingMode : SGBridgeGenericValue {
    let v : Swift.Int32;
    public init(val: Swift.Int32) { self.v = val; }
    public func get_value() -> Swift.Int32 { return self.v; }
    public static func get_type_handle() -> TypeHandle {
        return System_Security_Cryptography_PaddingMode_get_type_handle();
    }
    public func to_gval() -> GVal { return GVal(self.v); }
    public func dup_gval() -> GVal { return to_gval(); }
    public init(gval: GVal) { self.v = Swift.Int32(gval); }
    // static field: System.Security.Cryptography.PaddingMode None
    /**
    No padding is done.

    */
    public static var None : dotnet.System.Security.Cryptography.PaddingMode {
        get {
        let __return = dotnet.System.Security.Cryptography.PaddingMode(val: System_Security_Cryptography_PaddingMode_get_None());
            return __return;
        }
    }
    // static field: System.Security.Cryptography.PaddingMode PKCS7
    /**
    The PKCS #7 padding string consists of a sequence of bytes, each of which is equal to the total number of padding bytes added.

    */
    public static var PKCS7 : dotnet.System.Security.Cryptography.PaddingMode {
        get {
        let __return = dotnet.System.Security.Cryptography.PaddingMode(val: System_Security_Cryptography_PaddingMode_get_PKCS7());
            return __return;
        }
    }
    // static field: System.Security.Cryptography.PaddingMode Zeros
    /**
    The padding string consists of bytes set to zero.

    */
    public static var Zeros : dotnet.System.Security.Cryptography.PaddingMode {
        get {
        let __return = dotnet.System.Security.Cryptography.PaddingMode(val: System_Security_Cryptography_PaddingMode_get_Zeros());
            return __return;
        }
    }
    // static field: System.Security.Cryptography.PaddingMode ANSIX923
    /**
    The ANSIX923 padding string consists of a sequence of bytes filled with zeros before the length.

    */
    public static var ANSIX923 : dotnet.System.Security.Cryptography.PaddingMode {
        get {
        let __return = dotnet.System.Security.Cryptography.PaddingMode(val: System_Security_Cryptography_PaddingMode_get_ANSIX923());
            return __return;
        }
    }
    // static field: System.Security.Cryptography.PaddingMode ISO10126
    /**
    The ISO10126 padding string consists of random data before the length.

    */
    public static var ISO10126 : dotnet.System.Security.Cryptography.PaddingMode {
        get {
        let __return = dotnet.System.Security.Cryptography.PaddingMode(val: System_Security_Cryptography_PaddingMode_get_ISO10126());
            return __return;
        }
    }
} // PaddingMode


// type: System.Security.Cryptography.PbeEncryptionAlgorithm
    /**
    Specifies encryption algorithms to be used with Password-Based Encryption (PBE).

    */
public struct PbeEncryptionAlgorithm : SGBridgeGenericValue {
    let v : Swift.Int32;
    public init(val: Swift.Int32) { self.v = val; }
    public func get_value() -> Swift.Int32 { return self.v; }
    public static func get_type_handle() -> TypeHandle {
        return System_Security_Cryptography_PbeEncryptionAlgorithm_get_type_handle();
    }
    public func to_gval() -> GVal { return GVal(self.v); }
    public func dup_gval() -> GVal { return to_gval(); }
    public init(gval: GVal) { self.v = Swift.Int32(gval); }
    // static field: System.Security.Cryptography.PbeEncryptionAlgorithm Unknown
    /**
    Indicates that no encryption algorithm has been selected.

    */
    public static var Unknown : dotnet.System.Security.Cryptography.PbeEncryptionAlgorithm {
        get {
        let __return = dotnet.System.Security.Cryptography.PbeEncryptionAlgorithm(val: System_Security_Cryptography_PbeEncryptionAlgorithm_get_Unknown());
            return __return;
        }
    }
    // static field: System.Security.Cryptography.PbeEncryptionAlgorithm Aes128Cbc
    /**
    Indicates the encryption should be performed with the AES-128 algorithm in CBC mode with PKCS#7 padding.

    */
    public static var Aes128Cbc : dotnet.System.Security.Cryptography.PbeEncryptionAlgorithm {
        get {
        let __return = dotnet.System.Security.Cryptography.PbeEncryptionAlgorithm(val: System_Security_Cryptography_PbeEncryptionAlgorithm_get_Aes128Cbc());
            return __return;
        }
    }
    // static field: System.Security.Cryptography.PbeEncryptionAlgorithm Aes192Cbc
    /**
    Indicates the encryption should be performed with the AES-192 algorithm in CBC mode with PKCS#7 padding.

    */
    public static var Aes192Cbc : dotnet.System.Security.Cryptography.PbeEncryptionAlgorithm {
        get {
        let __return = dotnet.System.Security.Cryptography.PbeEncryptionAlgorithm(val: System_Security_Cryptography_PbeEncryptionAlgorithm_get_Aes192Cbc());
            return __return;
        }
    }
    // static field: System.Security.Cryptography.PbeEncryptionAlgorithm Aes256Cbc
    /**
    Indicates that encryption be performed with the AES-256 algorithm in CBC mode with PKCS#7 padding.

    */
    public static var Aes256Cbc : dotnet.System.Security.Cryptography.PbeEncryptionAlgorithm {
        get {
        let __return = dotnet.System.Security.Cryptography.PbeEncryptionAlgorithm(val: System_Security_Cryptography_PbeEncryptionAlgorithm_get_Aes256Cbc());
            return __return;
        }
    }
    // static field: System.Security.Cryptography.PbeEncryptionAlgorithm TripleDes3KeyPkcs12
    /**
    Indicates the encryption should be performed with the TripleDES algorithm in CBC mode with a 192-bit key derived using the Key Derivation Function (KDF) from PKCS#12.

    */
    public static var TripleDes3KeyPkcs12 : dotnet.System.Security.Cryptography.PbeEncryptionAlgorithm {
        get {
        let __return = dotnet.System.Security.Cryptography.PbeEncryptionAlgorithm(val: System_Security_Cryptography_PbeEncryptionAlgorithm_get_TripleDes3KeyPkcs12());
            return __return;
        }
    }
} // PbeEncryptionAlgorithm


// type: System.Security.Cryptography.PbeParameters
    /**
    Represents parameters to be used for Password-Based Encryption (PBE).

    */
public final class PbeParameters
    :
    dotnet.System.Object
{
    public class override func get_type_handle() -> TypeHandle {
        return System_Security_Cryptography_PbeParameters_get_type_handle();
    }
    public required init(hndl: NonnullHandle) { super.init(hndl: hndl); }
    public required init(gval: GVal) { super.init(gval: gval); }
    // .ctor(System.Security.Cryptography.PbeEncryptionAlgorithm, System.Security.Cryptography.HashAlgorithmName, System.Int32)
// docid: M:System.Security.Cryptography.PbeParameters.#ctor(System.Security.Cryptography.PbeEncryptionAlgorithm,System.Security.Cryptography.HashAlgorithmName,System.Int32)
    /**
    Initializes a new instance of the  class.

    - Parameter encryptionAlgorithm: The algorithm to use when encrypting data.
    - Parameter hashAlgorithm: The name of a hash algorithm to use with the Key Derivation Function (KDF) to turn a password into an encryption key.
    - Parameter iterationCount: The iteration count to provide to the Key Derivation Function (KDF) to turn a password into an encryption key.
    */
    public init(encryptionAlgorithm : dotnet.System.Security.Cryptography.PbeEncryptionAlgorithm, hashAlgorithm : dotnet.System.Security.Cryptography.HashAlgorithmName, iterationCount : Swift.Int32) throws {
        var __thrown : NullableHandle = nil;
        let h = System_Security_Cryptography_PbeParameters_ctor_0__3__PbeEncryptionAlgorithm_HashAlgorithmName_i32(&__thrown, encryptionAlgorithm.get_value(), hashAlgorithm.get_handle(), iterationCount);
        if let __ex = __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
            super.init(hndl: h);
        }
    }
    // [IsSpecialName] System.Security.Cryptography.PbeEncryptionAlgorithm get_EncryptionAlgorithm()
// docid: M:System.Security.Cryptography.PbeParameters.get_EncryptionAlgorithm
    public func get_EncryptionAlgorithm() throws -> dotnet.System.Security.Cryptography.PbeEncryptionAlgorithm {
        var __thrown : NullableHandle = nil;
        let __return = System_Security_Cryptography_PbeParameters_PbeEncryptionAlgorithm__get_EncryptionAlgorithm_0__0(&__thrown, self.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return dotnet.System.Security.Cryptography.PbeEncryptionAlgorithm(val: __return);
        }
    }
    // [IsSpecialName] System.Security.Cryptography.HashAlgorithmName get_HashAlgorithm()
// docid: M:System.Security.Cryptography.PbeParameters.get_HashAlgorithm
    public func get_HashAlgorithm() throws -> dotnet.System.Security.Cryptography.HashAlgorithmName {
        var __thrown : NullableHandle = nil;
        let __return = System_Security_Cryptography_PbeParameters_HashAlgorithmName__get_HashAlgorithm_0__0(&__thrown, self.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return dotnet.System.Security.Cryptography.HashAlgorithmName(hndl : __return);
        }
    }
    // [IsSpecialName] System.Int32 get_IterationCount()
// docid: M:System.Security.Cryptography.PbeParameters.get_IterationCount
    public func get_IterationCount() throws -> Swift.Int32 {
        var __thrown : NullableHandle = nil;
        let __return = System_Security_Cryptography_PbeParameters_i32__get_IterationCount_0__0(&__thrown, self.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return __return;
        }
    }
    /**
    Gets the algorithm to use when encrypting data.

    */
    public var EncryptionAlgorithm : dotnet.System.Security.Cryptography.PbeEncryptionAlgorithm {
        get {
            return try! get_EncryptionAlgorithm();
        }
    }
    /**
    Gets the name of the hash algorithm to use with the Key Derivation Function (KDF) to turn a password into an encryption key.

    */
    public var HashAlgorithm : dotnet.System.Security.Cryptography.HashAlgorithmName {
        get {
            return try! get_HashAlgorithm();
        }
    }
    /**
    Gets the iteration count to provide to the Key Derivation Function (KDF) to turn a password into an encryption key.

    */
    public var IterationCount : Swift.Int32 {
        get {
            return try! get_IterationCount();
        }
    }
} // PbeParameters


// type: System.Security.Cryptography.SymmetricAlgorithm
    /**
    Represents the abstract base class from which all implementations of symmetric algorithms must inherit.

    */
open class SymmetricAlgorithm
    :
    dotnet.System.Object,
    System_IDisposable
{
    open class override func get_type_handle() -> TypeHandle {
        return System_Security_Cryptography_SymmetricAlgorithm_get_type_handle();
    }
    public required init(hndl: NonnullHandle) { super.init(hndl: hndl); }
    public required init(gval: GVal) { super.init(gval: gval); }
    // void Clear()
// docid: M:System.Security.Cryptography.SymmetricAlgorithm.Clear
    /**
    Releases all resources used by the  class.

    */
    open func Clear() throws {
        var __thrown : NullableHandle = nil;
        System_Security_Cryptography_SymmetricAlgorithm_void__Clear_0__0(&__thrown, self.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
            return;
        }
    }
    // System.Security.Cryptography.SymmetricAlgorithm Create()
// docid: M:System.Security.Cryptography.SymmetricAlgorithm.Create
    /**
    Creates a default cryptographic object used to perform the symmetric algorithm.

    - Returns: A default cryptographic object used to perform the symmetric algorithm.

    */
    open class func Create() throws -> dotnet.System.Security.Cryptography.SymmetricAlgorithm {
        var __thrown : NullableHandle = nil;
        let __return = System_Security_Cryptography_SymmetricAlgorithm_SymmetricAlgorithm__Create_0__0(&__thrown);
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return dotnet.System.Security.Cryptography.SymmetricAlgorithm(hndl : __return);
        }
    }
    // System.Security.Cryptography.SymmetricAlgorithm Create(System.String)
// docid: M:System.Security.Cryptography.SymmetricAlgorithm.Create(System.String)
    /**
    Creates the specified cryptographic object used to perform the symmetric algorithm.

    - Parameter algName: The name of the specific implementation of the  class to use.
    - Returns: A cryptographic object used to perform the symmetric algorithm.

    */
    open class func Create(algName : dotnet.System.String) throws -> Optional<dotnet.System.Security.Cryptography.SymmetricAlgorithm> {
        var __thrown : NullableHandle = nil;
        let __return = System_Security_Cryptography_SymmetricAlgorithm_SymmetricAlgorithm__Create_0__1__String(&__thrown, algName.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        if let __ret_unwrapped = __return {
            return dotnet.System.Security.Cryptography.SymmetricAlgorithm(hndl : __ret_unwrapped);
        } else {
            return nil;
        }
        }
    }
    // System.Security.Cryptography.ICryptoTransform CreateDecryptor()
// docid: M:System.Security.Cryptography.SymmetricAlgorithm.CreateDecryptor
    /**
    Creates a symmetric decryptor object with the current  property and initialization vector ().

    - Returns: A symmetric decryptor object.

    */
    open func CreateDecryptor() throws -> dotnet.System.Security.Cryptography.ICryptoTransform {
        var __thrown : NullableHandle = nil;
        let __return = System_Security_Cryptography_SymmetricAlgorithm_ICryptoTransform__CreateDecryptor_0__0(&__thrown, self.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return dotnet.System.Security.Cryptography.ICryptoTransform(hndl : __return);
        }
    }
    // System.Security.Cryptography.ICryptoTransform CreateDecryptor(System.Byte[], System.Byte[])
// docid: M:System.Security.Cryptography.SymmetricAlgorithm.CreateDecryptor(System.Byte[],System.Byte[])
    /**
    When overridden in a derived class, creates a symmetric decryptor object with the specified  property and initialization vector ().

    - Parameter rgbKey: The secret key to use for the symmetric algorithm.
    - Parameter rgbIV: The initialization vector to use for the symmetric algorithm.
    - Returns: A symmetric decryptor object.

    */
    open func CreateDecryptor(rgbKey : dotnet.System_Arr<Swift.UInt8>, rgbIV : Optional<dotnet.System_Arr<Swift.UInt8>>) throws -> dotnet.System.Security.Cryptography.ICryptoTransform {
        var __thrown : NullableHandle = nil;
        let __return = System_Security_Cryptography_SymmetricAlgorithm_ICryptoTransform__CreateDecryptor_0__2__u8Array_u8Array(&__thrown, self.get_handle(), rgbKey.get_handle(), (rgbIV?.get_handle()));
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return dotnet.System.Security.Cryptography.ICryptoTransform(hndl : __return);
        }
    }
    // System.Security.Cryptography.ICryptoTransform CreateEncryptor()
// docid: M:System.Security.Cryptography.SymmetricAlgorithm.CreateEncryptor
    /**
    Creates a symmetric encryptor object with the current  property and initialization vector ().

    - Returns: A symmetric encryptor object.

    */
    open func CreateEncryptor() throws -> dotnet.System.Security.Cryptography.ICryptoTransform {
        var __thrown : NullableHandle = nil;
        let __return = System_Security_Cryptography_SymmetricAlgorithm_ICryptoTransform__CreateEncryptor_0__0(&__thrown, self.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return dotnet.System.Security.Cryptography.ICryptoTransform(hndl : __return);
        }
    }
    // System.Security.Cryptography.ICryptoTransform CreateEncryptor(System.Byte[], System.Byte[])
// docid: M:System.Security.Cryptography.SymmetricAlgorithm.CreateEncryptor(System.Byte[],System.Byte[])
    /**
    When overridden in a derived class, creates a symmetric encryptor object with the specified  property and initialization vector ().

    - Parameter rgbKey: The secret key to use for the symmetric algorithm.
    - Parameter rgbIV: The initialization vector to use for the symmetric algorithm.
    - Returns: A symmetric encryptor object.

    */
    open func CreateEncryptor(rgbKey : dotnet.System_Arr<Swift.UInt8>, rgbIV : Optional<dotnet.System_Arr<Swift.UInt8>>) throws -> dotnet.System.Security.Cryptography.ICryptoTransform {
        var __thrown : NullableHandle = nil;
        let __return = System_Security_Cryptography_SymmetricAlgorithm_ICryptoTransform__CreateEncryptor_0__2__u8Array_u8Array(&__thrown, self.get_handle(), rgbKey.get_handle(), (rgbIV?.get_handle()));
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return dotnet.System.Security.Cryptography.ICryptoTransform(hndl : __return);
        }
    }
    // System.Byte[] DecryptCbc(System.Byte[], System.Byte[], System.Security.Cryptography.PaddingMode)
// docid: M:System.Security.Cryptography.SymmetricAlgorithm.DecryptCbc(System.Byte[],System.Byte[],System.Security.Cryptography.PaddingMode)
    open func DecryptCbc(ciphertext : dotnet.System_Arr<Swift.UInt8>, iv : dotnet.System_Arr<Swift.UInt8>, paddingMode : dotnet.System.Security.Cryptography.PaddingMode/* TODO default enum */) throws -> dotnet.System_Arr<Swift.UInt8> {
        var __thrown : NullableHandle = nil;
        let __return = System_Security_Cryptography_SymmetricAlgorithm_u8Array__DecryptCbc_0__3__u8Array_u8Array_PaddingMode(&__thrown, self.get_handle(), ciphertext.get_handle(), iv.get_handle(), paddingMode.get_value());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return dotnet.System_Arr<Swift.UInt8>(hndl : __return);
        }
    }
// TODO COPE (write_all_methods) (span) System.Byte[] DecryptCbc(System.ReadOnlySpan<System.Byte>, System.ReadOnlySpan<System.Byte>, System.Security.Cryptography.PaddingMode)
// TODO COPE (write_all_methods) (span) System.Int32 DecryptCbc(System.ReadOnlySpan<System.Byte>, System.ReadOnlySpan<System.Byte>, System.Span<System.Byte>, System.Security.Cryptography.PaddingMode)
    // System.Byte[] DecryptCfb(System.Byte[], System.Byte[], System.Security.Cryptography.PaddingMode, System.Int32)
// docid: M:System.Security.Cryptography.SymmetricAlgorithm.DecryptCfb(System.Byte[],System.Byte[],System.Security.Cryptography.PaddingMode,System.Int32)
    open func DecryptCfb(ciphertext : dotnet.System_Arr<Swift.UInt8>, iv : dotnet.System_Arr<Swift.UInt8>, paddingMode : dotnet.System.Security.Cryptography.PaddingMode/* TODO default enum */, feedbackSizeInBits : Swift.Int32 = 8) throws -> dotnet.System_Arr<Swift.UInt8> {
        var __thrown : NullableHandle = nil;
        let __return = System_Security_Cryptography_SymmetricAlgorithm_u8Array__DecryptCfb_0__4__u8Array_u8Array_PaddingMode_i32(&__thrown, self.get_handle(), ciphertext.get_handle(), iv.get_handle(), paddingMode.get_value(), feedbackSizeInBits);
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return dotnet.System_Arr<Swift.UInt8>(hndl : __return);
        }
    }
// TODO COPE (write_all_methods) (span) System.Byte[] DecryptCfb(System.ReadOnlySpan<System.Byte>, System.ReadOnlySpan<System.Byte>, System.Security.Cryptography.PaddingMode, System.Int32)
// TODO COPE (write_all_methods) (span) System.Int32 DecryptCfb(System.ReadOnlySpan<System.Byte>, System.ReadOnlySpan<System.Byte>, System.Span<System.Byte>, System.Security.Cryptography.PaddingMode, System.Int32)
    // System.Byte[] DecryptEcb(System.Byte[], System.Security.Cryptography.PaddingMode)
// docid: M:System.Security.Cryptography.SymmetricAlgorithm.DecryptEcb(System.Byte[],System.Security.Cryptography.PaddingMode)
    open func DecryptEcb(ciphertext : dotnet.System_Arr<Swift.UInt8>, paddingMode : dotnet.System.Security.Cryptography.PaddingMode) throws -> dotnet.System_Arr<Swift.UInt8> {
        var __thrown : NullableHandle = nil;
        let __return = System_Security_Cryptography_SymmetricAlgorithm_u8Array__DecryptEcb_0__2__u8Array_PaddingMode(&__thrown, self.get_handle(), ciphertext.get_handle(), paddingMode.get_value());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return dotnet.System_Arr<Swift.UInt8>(hndl : __return);
        }
    }
// TODO COPE (write_all_methods) (span) System.Byte[] DecryptEcb(System.ReadOnlySpan<System.Byte>, System.Security.Cryptography.PaddingMode)
// TODO COPE (write_all_methods) (span) System.Int32 DecryptEcb(System.ReadOnlySpan<System.Byte>, System.Span<System.Byte>, System.Security.Cryptography.PaddingMode)
    // void Dispose()
// docid: M:System.Security.Cryptography.SymmetricAlgorithm.Dispose
    /**
    Releases all resources used by the current instance of the  class.

    */
    open /* method final */ func Dispose() throws {
        var __thrown : NullableHandle = nil;
        System_Security_Cryptography_SymmetricAlgorithm_void__Dispose_0__0(&__thrown, self.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
            return;
        }
    }
    // System.Byte[] EncryptCbc(System.Byte[], System.Byte[], System.Security.Cryptography.PaddingMode)
// docid: M:System.Security.Cryptography.SymmetricAlgorithm.EncryptCbc(System.Byte[],System.Byte[],System.Security.Cryptography.PaddingMode)
    open func EncryptCbc(plaintext : dotnet.System_Arr<Swift.UInt8>, iv : dotnet.System_Arr<Swift.UInt8>, paddingMode : dotnet.System.Security.Cryptography.PaddingMode/* TODO default enum */) throws -> dotnet.System_Arr<Swift.UInt8> {
        var __thrown : NullableHandle = nil;
        let __return = System_Security_Cryptography_SymmetricAlgorithm_u8Array__EncryptCbc_0__3__u8Array_u8Array_PaddingMode(&__thrown, self.get_handle(), plaintext.get_handle(), iv.get_handle(), paddingMode.get_value());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return dotnet.System_Arr<Swift.UInt8>(hndl : __return);
        }
    }
// TODO COPE (write_all_methods) (span) System.Byte[] EncryptCbc(System.ReadOnlySpan<System.Byte>, System.ReadOnlySpan<System.Byte>, System.Security.Cryptography.PaddingMode)
// TODO COPE (write_all_methods) (span) System.Int32 EncryptCbc(System.ReadOnlySpan<System.Byte>, System.ReadOnlySpan<System.Byte>, System.Span<System.Byte>, System.Security.Cryptography.PaddingMode)
    // System.Byte[] EncryptCfb(System.Byte[], System.Byte[], System.Security.Cryptography.PaddingMode, System.Int32)
// docid: M:System.Security.Cryptography.SymmetricAlgorithm.EncryptCfb(System.Byte[],System.Byte[],System.Security.Cryptography.PaddingMode,System.Int32)
    open func EncryptCfb(plaintext : dotnet.System_Arr<Swift.UInt8>, iv : dotnet.System_Arr<Swift.UInt8>, paddingMode : dotnet.System.Security.Cryptography.PaddingMode/* TODO default enum */, feedbackSizeInBits : Swift.Int32 = 8) throws -> dotnet.System_Arr<Swift.UInt8> {
        var __thrown : NullableHandle = nil;
        let __return = System_Security_Cryptography_SymmetricAlgorithm_u8Array__EncryptCfb_0__4__u8Array_u8Array_PaddingMode_i32(&__thrown, self.get_handle(), plaintext.get_handle(), iv.get_handle(), paddingMode.get_value(), feedbackSizeInBits);
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return dotnet.System_Arr<Swift.UInt8>(hndl : __return);
        }
    }
// TODO COPE (write_all_methods) (span) System.Byte[] EncryptCfb(System.ReadOnlySpan<System.Byte>, System.ReadOnlySpan<System.Byte>, System.Security.Cryptography.PaddingMode, System.Int32)
// TODO COPE (write_all_methods) (span) System.Int32 EncryptCfb(System.ReadOnlySpan<System.Byte>, System.ReadOnlySpan<System.Byte>, System.Span<System.Byte>, System.Security.Cryptography.PaddingMode, System.Int32)
    // System.Byte[] EncryptEcb(System.Byte[], System.Security.Cryptography.PaddingMode)
// docid: M:System.Security.Cryptography.SymmetricAlgorithm.EncryptEcb(System.Byte[],System.Security.Cryptography.PaddingMode)
    open func EncryptEcb(plaintext : dotnet.System_Arr<Swift.UInt8>, paddingMode : dotnet.System.Security.Cryptography.PaddingMode) throws -> dotnet.System_Arr<Swift.UInt8> {
        var __thrown : NullableHandle = nil;
        let __return = System_Security_Cryptography_SymmetricAlgorithm_u8Array__EncryptEcb_0__2__u8Array_PaddingMode(&__thrown, self.get_handle(), plaintext.get_handle(), paddingMode.get_value());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return dotnet.System_Arr<Swift.UInt8>(hndl : __return);
        }
    }
// TODO COPE (write_all_methods) (span) System.Byte[] EncryptEcb(System.ReadOnlySpan<System.Byte>, System.Security.Cryptography.PaddingMode)
// TODO COPE (write_all_methods) (span) System.Int32 EncryptEcb(System.ReadOnlySpan<System.Byte>, System.Span<System.Byte>, System.Security.Cryptography.PaddingMode)
    // void GenerateIV()
// docid: M:System.Security.Cryptography.SymmetricAlgorithm.GenerateIV
    /**
    When overridden in a derived class, generates a random initialization vector () to use for the algorithm.

    */
    open func GenerateIV() throws {
        var __thrown : NullableHandle = nil;
        System_Security_Cryptography_SymmetricAlgorithm_void__GenerateIV_0__0(&__thrown, self.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
            return;
        }
    }
    // void GenerateKey()
// docid: M:System.Security.Cryptography.SymmetricAlgorithm.GenerateKey
    /**
    When overridden in a derived class, generates a random key () to use for the algorithm.

    */
    open func GenerateKey() throws {
        var __thrown : NullableHandle = nil;
        System_Security_Cryptography_SymmetricAlgorithm_void__GenerateKey_0__0(&__thrown, self.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
            return;
        }
    }
    // System.Int32 GetCiphertextLengthCbc(System.Int32, System.Security.Cryptography.PaddingMode)
// docid: M:System.Security.Cryptography.SymmetricAlgorithm.GetCiphertextLengthCbc(System.Int32,System.Security.Cryptography.PaddingMode)
    open func GetCiphertextLengthCbc(plaintextLength : Swift.Int32, paddingMode : dotnet.System.Security.Cryptography.PaddingMode/* TODO default enum */) throws -> Swift.Int32 {
        var __thrown : NullableHandle = nil;
        let __return = System_Security_Cryptography_SymmetricAlgorithm_i32__GetCiphertextLengthCbc_0__2__i32_PaddingMode(&__thrown, self.get_handle(), plaintextLength, paddingMode.get_value());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return __return;
        }
    }
    // System.Int32 GetCiphertextLengthCfb(System.Int32, System.Security.Cryptography.PaddingMode, System.Int32)
// docid: M:System.Security.Cryptography.SymmetricAlgorithm.GetCiphertextLengthCfb(System.Int32,System.Security.Cryptography.PaddingMode,System.Int32)
    open func GetCiphertextLengthCfb(plaintextLength : Swift.Int32, paddingMode : dotnet.System.Security.Cryptography.PaddingMode/* TODO default enum */, feedbackSizeInBits : Swift.Int32 = 8) throws -> Swift.Int32 {
        var __thrown : NullableHandle = nil;
        let __return = System_Security_Cryptography_SymmetricAlgorithm_i32__GetCiphertextLengthCfb_0__3__i32_PaddingMode_i32(&__thrown, self.get_handle(), plaintextLength, paddingMode.get_value(), feedbackSizeInBits);
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return __return;
        }
    }
    // System.Int32 GetCiphertextLengthEcb(System.Int32, System.Security.Cryptography.PaddingMode)
// docid: M:System.Security.Cryptography.SymmetricAlgorithm.GetCiphertextLengthEcb(System.Int32,System.Security.Cryptography.PaddingMode)
    open func GetCiphertextLengthEcb(plaintextLength : Swift.Int32, paddingMode : dotnet.System.Security.Cryptography.PaddingMode) throws -> Swift.Int32 {
        var __thrown : NullableHandle = nil;
        let __return = System_Security_Cryptography_SymmetricAlgorithm_i32__GetCiphertextLengthEcb_0__2__i32_PaddingMode(&__thrown, self.get_handle(), plaintextLength, paddingMode.get_value());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return __return;
        }
    }
// TODO COPE (write_all_methods) (span) bool TryDecryptCbc(System.ReadOnlySpan<System.Byte>, System.ReadOnlySpan<System.Byte>, System.Span<System.Byte>, ref System.Int32, System.Security.Cryptography.PaddingMode)
// TODO COPE (write_all_methods) (span) bool TryDecryptCfb(System.ReadOnlySpan<System.Byte>, System.ReadOnlySpan<System.Byte>, System.Span<System.Byte>, ref System.Int32, System.Security.Cryptography.PaddingMode, System.Int32)
// TODO COPE (write_all_methods) (span) bool TryDecryptEcb(System.ReadOnlySpan<System.Byte>, System.Span<System.Byte>, System.Security.Cryptography.PaddingMode, ref System.Int32)
// TODO COPE (write_all_methods) (span) bool TryEncryptCbc(System.ReadOnlySpan<System.Byte>, System.ReadOnlySpan<System.Byte>, System.Span<System.Byte>, ref System.Int32, System.Security.Cryptography.PaddingMode)
// TODO COPE (write_all_methods) (span) bool TryEncryptCfb(System.ReadOnlySpan<System.Byte>, System.ReadOnlySpan<System.Byte>, System.Span<System.Byte>, ref System.Int32, System.Security.Cryptography.PaddingMode, System.Int32)
// TODO COPE (write_all_methods) (span) bool TryEncryptEcb(System.ReadOnlySpan<System.Byte>, System.Span<System.Byte>, System.Security.Cryptography.PaddingMode, ref System.Int32)
    // bool ValidKeySize(System.Int32)
// docid: M:System.Security.Cryptography.SymmetricAlgorithm.ValidKeySize(System.Int32)
    /**
    Determines whether the specified key size is valid for the current algorithm.

    - Parameter bitLength: The length, in bits, to check for a valid key size.
    - Returns: 
         if the specified key size is valid for the current algorithm; otherwise, .

    */
    open func ValidKeySize(bitLength : Swift.Int32) throws -> Bool {
        var __thrown : NullableHandle = nil;
        let __return = System_Security_Cryptography_SymmetricAlgorithm_bool__ValidKeySize_0__1__i32(&__thrown, self.get_handle(), bitLength);
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return (__return) != 0;
        }
    }
    // [IsSpecialName] System.Int32 get_BlockSize()
// docid: M:System.Security.Cryptography.SymmetricAlgorithm.get_BlockSize
    open func get_BlockSize() throws -> Swift.Int32 {
        var __thrown : NullableHandle = nil;
        let __return = System_Security_Cryptography_SymmetricAlgorithm_i32__get_BlockSize_0__0(&__thrown, self.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return __return;
        }
    }
    // [IsSpecialName] void set_BlockSize(System.Int32)
// docid: M:System.Security.Cryptography.SymmetricAlgorithm.set_BlockSize(System.Int32)
    open func set_BlockSize(value : Swift.Int32) throws {
        var __thrown : NullableHandle = nil;
        System_Security_Cryptography_SymmetricAlgorithm_void__set_BlockSize_0__1__i32(&__thrown, self.get_handle(), value);
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
            return;
        }
    }
    // [IsSpecialName] System.Int32 get_FeedbackSize()
// docid: M:System.Security.Cryptography.SymmetricAlgorithm.get_FeedbackSize
    open func get_FeedbackSize() throws -> Swift.Int32 {
        var __thrown : NullableHandle = nil;
        let __return = System_Security_Cryptography_SymmetricAlgorithm_i32__get_FeedbackSize_0__0(&__thrown, self.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return __return;
        }
    }
    // [IsSpecialName] void set_FeedbackSize(System.Int32)
// docid: M:System.Security.Cryptography.SymmetricAlgorithm.set_FeedbackSize(System.Int32)
    open func set_FeedbackSize(value : Swift.Int32) throws {
        var __thrown : NullableHandle = nil;
        System_Security_Cryptography_SymmetricAlgorithm_void__set_FeedbackSize_0__1__i32(&__thrown, self.get_handle(), value);
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
            return;
        }
    }
    // [IsSpecialName] System.Byte[] get_IV()
// docid: M:System.Security.Cryptography.SymmetricAlgorithm.get_IV
    open func get_IV() throws -> dotnet.System_Arr<Swift.UInt8> {
        var __thrown : NullableHandle = nil;
        let __return = System_Security_Cryptography_SymmetricAlgorithm_u8Array__get_IV_0__0(&__thrown, self.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return dotnet.System_Arr<Swift.UInt8>(hndl : __return);
        }
    }
    // [IsSpecialName] void set_IV(System.Byte[])
// docid: M:System.Security.Cryptography.SymmetricAlgorithm.set_IV(System.Byte[])
    open func set_IV(value : dotnet.System_Arr<Swift.UInt8>) throws {
        var __thrown : NullableHandle = nil;
        System_Security_Cryptography_SymmetricAlgorithm_void__set_IV_0__1__u8Array(&__thrown, self.get_handle(), value.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
            return;
        }
    }
    // [IsSpecialName] System.Byte[] get_Key()
// docid: M:System.Security.Cryptography.SymmetricAlgorithm.get_Key
    open func get_Key() throws -> dotnet.System_Arr<Swift.UInt8> {
        var __thrown : NullableHandle = nil;
        let __return = System_Security_Cryptography_SymmetricAlgorithm_u8Array__get_Key_0__0(&__thrown, self.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return dotnet.System_Arr<Swift.UInt8>(hndl : __return);
        }
    }
    // [IsSpecialName] void set_Key(System.Byte[])
// docid: M:System.Security.Cryptography.SymmetricAlgorithm.set_Key(System.Byte[])
    open func set_Key(value : dotnet.System_Arr<Swift.UInt8>) throws {
        var __thrown : NullableHandle = nil;
        System_Security_Cryptography_SymmetricAlgorithm_void__set_Key_0__1__u8Array(&__thrown, self.get_handle(), value.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
            return;
        }
    }
    // [IsSpecialName] System.Int32 get_KeySize()
// docid: M:System.Security.Cryptography.SymmetricAlgorithm.get_KeySize
    open func get_KeySize() throws -> Swift.Int32 {
        var __thrown : NullableHandle = nil;
        let __return = System_Security_Cryptography_SymmetricAlgorithm_i32__get_KeySize_0__0(&__thrown, self.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return __return;
        }
    }
    // [IsSpecialName] void set_KeySize(System.Int32)
// docid: M:System.Security.Cryptography.SymmetricAlgorithm.set_KeySize(System.Int32)
    open func set_KeySize(value : Swift.Int32) throws {
        var __thrown : NullableHandle = nil;
        System_Security_Cryptography_SymmetricAlgorithm_void__set_KeySize_0__1__i32(&__thrown, self.get_handle(), value);
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
            return;
        }
    }
    // [IsSpecialName] System.Security.Cryptography.KeySizes[] get_LegalBlockSizes()
// docid: M:System.Security.Cryptography.SymmetricAlgorithm.get_LegalBlockSizes
    open func get_LegalBlockSizes() throws -> dotnet.System_Arr<dotnet.System.Security.Cryptography.KeySizes> {
        var __thrown : NullableHandle = nil;
        let __return = System_Security_Cryptography_SymmetricAlgorithm_KeySizesArray__get_LegalBlockSizes_0__0(&__thrown, self.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return dotnet.System_Arr<dotnet.System.Security.Cryptography.KeySizes>(hndl : __return);
        }
    }
    // [IsSpecialName] System.Security.Cryptography.KeySizes[] get_LegalKeySizes()
// docid: M:System.Security.Cryptography.SymmetricAlgorithm.get_LegalKeySizes
    open func get_LegalKeySizes() throws -> dotnet.System_Arr<dotnet.System.Security.Cryptography.KeySizes> {
        var __thrown : NullableHandle = nil;
        let __return = System_Security_Cryptography_SymmetricAlgorithm_KeySizesArray__get_LegalKeySizes_0__0(&__thrown, self.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return dotnet.System_Arr<dotnet.System.Security.Cryptography.KeySizes>(hndl : __return);
        }
    }
    // [IsSpecialName] System.Security.Cryptography.CipherMode get_Mode()
// docid: M:System.Security.Cryptography.SymmetricAlgorithm.get_Mode
    open func get_Mode() throws -> dotnet.System.Security.Cryptography.CipherMode {
        var __thrown : NullableHandle = nil;
        let __return = System_Security_Cryptography_SymmetricAlgorithm_CipherMode__get_Mode_0__0(&__thrown, self.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return dotnet.System.Security.Cryptography.CipherMode(val: __return);
        }
    }
    // [IsSpecialName] void set_Mode(System.Security.Cryptography.CipherMode)
// docid: M:System.Security.Cryptography.SymmetricAlgorithm.set_Mode(System.Security.Cryptography.CipherMode)
    open func set_Mode(value : dotnet.System.Security.Cryptography.CipherMode) throws {
        var __thrown : NullableHandle = nil;
        System_Security_Cryptography_SymmetricAlgorithm_void__set_Mode_0__1__CipherMode(&__thrown, self.get_handle(), value.get_value());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
            return;
        }
    }
    // [IsSpecialName] System.Security.Cryptography.PaddingMode get_Padding()
// docid: M:System.Security.Cryptography.SymmetricAlgorithm.get_Padding
    open func get_Padding() throws -> dotnet.System.Security.Cryptography.PaddingMode {
        var __thrown : NullableHandle = nil;
        let __return = System_Security_Cryptography_SymmetricAlgorithm_PaddingMode__get_Padding_0__0(&__thrown, self.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return dotnet.System.Security.Cryptography.PaddingMode(val: __return);
        }
    }
    // [IsSpecialName] void set_Padding(System.Security.Cryptography.PaddingMode)
// docid: M:System.Security.Cryptography.SymmetricAlgorithm.set_Padding(System.Security.Cryptography.PaddingMode)
    open func set_Padding(value : dotnet.System.Security.Cryptography.PaddingMode) throws {
        var __thrown : NullableHandle = nil;
        System_Security_Cryptography_SymmetricAlgorithm_void__set_Padding_0__1__PaddingMode(&__thrown, self.get_handle(), value.get_value());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
            return;
        }
    }
    /**
    Gets or sets the block size, in bits, of the cryptographic operation.

    */
    open var BlockSize : Swift.Int32 {
        get {
            return try! get_BlockSize();
        }
        set(v) {
            return try! set_BlockSize(value: v);
        }
    }
    /**
    Gets or sets the feedback size, in bits, of the cryptographic operation for the Cipher Feedback (CFB) and Output Feedback (OFB) cipher modes.

    */
    open var FeedbackSize : Swift.Int32 {
        get {
            return try! get_FeedbackSize();
        }
        set(v) {
            return try! set_FeedbackSize(value: v);
        }
    }
    /**
    Gets or sets the initialization vector () for the symmetric algorithm.

    */
    open var IV : dotnet.System_Arr<Swift.UInt8> {
        get {
            return try! get_IV();
        }
        set(v) {
            return try! set_IV(value: v);
        }
    }
    /**
    Gets or sets the secret key for the symmetric algorithm.

    */
    open var Key : dotnet.System_Arr<Swift.UInt8> {
        get {
            return try! get_Key();
        }
        set(v) {
            return try! set_Key(value: v);
        }
    }
    /**
    Gets or sets the size, in bits, of the secret key used by the symmetric algorithm.

    */
    open var KeySize : Swift.Int32 {
        get {
            return try! get_KeySize();
        }
        set(v) {
            return try! set_KeySize(value: v);
        }
    }
    /**
    Gets the block sizes, in bits, that are supported by the symmetric algorithm.

    */
    open var LegalBlockSizes : dotnet.System_Arr<dotnet.System.Security.Cryptography.KeySizes> {
        get {
            return try! get_LegalBlockSizes();
        }
    }
    /**
    Gets the key sizes, in bits, that are supported by the symmetric algorithm.

    */
    open var LegalKeySizes : dotnet.System_Arr<dotnet.System.Security.Cryptography.KeySizes> {
        get {
            return try! get_LegalKeySizes();
        }
    }
    /**
    Gets or sets the mode for operation of the symmetric algorithm.

    */
    open var Mode : dotnet.System.Security.Cryptography.CipherMode {
        get {
            return try! get_Mode();
        }
        set(v) {
            return try! set_Mode(value: v);
        }
    }
    /**
    Gets or sets the padding mode used in the symmetric algorithm.

    */
    open var Padding : dotnet.System.Security.Cryptography.PaddingMode {
        get {
            return try! get_Padding();
        }
        set(v) {
            return try! set_Padding(value: v);
        }
    }
} // SymmetricAlgorithm


}



public protocol System_Security_Cryptography_ICryptoTransform
    :
    System_IDisposable
{
}

