// this file is automatically generated
// Copyright 2021 SourceGear

import jumptable_dotnet;

// System
// System.Net
// System.Net.Security
extension System.Net.Security {
// type: System.Net.Security.AuthenticatedStream
    /**
    Provides methods for passing credentials across a stream and requesting or performing authentication for client-server applications.

    */
open class AuthenticatedStream
    :
    dotnet.System.IO.Stream
{
    open class override func get_type_handle() -> TypeHandle {
        return System_Net_Security_AuthenticatedStream_get_type_handle();
    }
    public required init(hndl: NonnullHandle) { super.init(hndl: hndl); }
    public required init(gval: GVal) { super.init(gval: gval); }
    // System.Threading.Tasks.ValueTask DisposeAsync()
// docid: M:System.Net.Security.AuthenticatedStream.DisposeAsync
    /**
    Asynchronously releases the unmanaged and managed resources used by the .

    - Returns: A task that represents the asynchronous dispose operation.

    */
    open override func DisposeAsync() throws -> dotnet.System.Threading.Tasks.ValueTask {
        var __thrown : NullableHandle = nil;
        let __return = System_Net_Security_AuthenticatedStream_ValueTask__DisposeAsync_0__0(&__thrown, self.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return dotnet.System.Threading.Tasks.ValueTask(hndl : __return);
        }
    }
    // [IsSpecialName] bool get_IsAuthenticated()
// docid: M:System.Net.Security.AuthenticatedStream.get_IsAuthenticated
    open func get_IsAuthenticated() throws -> Bool {
        var __thrown : NullableHandle = nil;
        let __return = System_Net_Security_AuthenticatedStream_bool__get_IsAuthenticated_0__0(&__thrown, self.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return (__return) != 0;
        }
    }
    // [IsSpecialName] bool get_IsEncrypted()
// docid: M:System.Net.Security.AuthenticatedStream.get_IsEncrypted
    open func get_IsEncrypted() throws -> Bool {
        var __thrown : NullableHandle = nil;
        let __return = System_Net_Security_AuthenticatedStream_bool__get_IsEncrypted_0__0(&__thrown, self.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return (__return) != 0;
        }
    }
    // [IsSpecialName] bool get_IsMutuallyAuthenticated()
// docid: M:System.Net.Security.AuthenticatedStream.get_IsMutuallyAuthenticated
    open func get_IsMutuallyAuthenticated() throws -> Bool {
        var __thrown : NullableHandle = nil;
        let __return = System_Net_Security_AuthenticatedStream_bool__get_IsMutuallyAuthenticated_0__0(&__thrown, self.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return (__return) != 0;
        }
    }
    // [IsSpecialName] bool get_IsServer()
// docid: M:System.Net.Security.AuthenticatedStream.get_IsServer
    open func get_IsServer() throws -> Bool {
        var __thrown : NullableHandle = nil;
        let __return = System_Net_Security_AuthenticatedStream_bool__get_IsServer_0__0(&__thrown, self.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return (__return) != 0;
        }
    }
    // [IsSpecialName] bool get_IsSigned()
// docid: M:System.Net.Security.AuthenticatedStream.get_IsSigned
    open func get_IsSigned() throws -> Bool {
        var __thrown : NullableHandle = nil;
        let __return = System_Net_Security_AuthenticatedStream_bool__get_IsSigned_0__0(&__thrown, self.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return (__return) != 0;
        }
    }
    // [IsSpecialName] bool get_LeaveInnerStreamOpen()
// docid: M:System.Net.Security.AuthenticatedStream.get_LeaveInnerStreamOpen
    open func get_LeaveInnerStreamOpen() throws -> Bool {
        var __thrown : NullableHandle = nil;
        let __return = System_Net_Security_AuthenticatedStream_bool__get_LeaveInnerStreamOpen_0__0(&__thrown, self.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return (__return) != 0;
        }
    }
    /**
    Gets a  value that indicates whether authentication was successful.

    */
    open var IsAuthenticated : Bool {
        get {
            return try! get_IsAuthenticated();
        }
    }
    /**
    Gets a  value that indicates whether data sent using this  is encrypted.

    */
    open var IsEncrypted : Bool {
        get {
            return try! get_IsEncrypted();
        }
    }
    /**
    Gets a  value that indicates whether both server and client have been authenticated.

    */
    open var IsMutuallyAuthenticated : Bool {
        get {
            return try! get_IsMutuallyAuthenticated();
        }
    }
    /**
    Gets a  value that indicates whether the local side of the connection was authenticated as the server.

    */
    open var IsServer : Bool {
        get {
            return try! get_IsServer();
        }
    }
    /**
    Gets a  value that indicates whether the data sent using this stream is signed.

    */
    open var IsSigned : Bool {
        get {
            return try! get_IsSigned();
        }
    }
    /**
    Gets whether the stream used by this  for sending and receiving data has been left open.

    */
    open var LeaveInnerStreamOpen : Bool {
        get {
            return try! get_LeaveInnerStreamOpen();
        }
    }
} // AuthenticatedStream


// type: System.Net.Security.CipherSuitesPolicy
    /**
    Specifies allowed cipher suites.

    */
public final class CipherSuitesPolicy
    :
    dotnet.System.Object
{
    public class override func get_type_handle() -> TypeHandle {
        return System_Net_Security_CipherSuitesPolicy_get_type_handle();
    }
    public required init(hndl: NonnullHandle) { super.init(hndl: hndl); }
    public required init(gval: GVal) { super.init(gval: gval); }
    // .ctor(System.Collections.Generic.IEnumerable<System.Net.Security.TlsCipherSuite>)
// docid: M:System.Net.Security.CipherSuitesPolicy.#ctor(System.Collections.Generic.IEnumerable{System.Net.Security.TlsCipherSuite})
    /**
    Initializes a new instance of the  class that can be used for client or server authentication.

    - Parameter allowedCipherSuites: The collection of cipher suites allowed in this policy for negotiation.
    */
    public init(allowedCipherSuites : dotnet.System.Collections.Generic.IEnumerable_1<dotnet.System.Net.Security.TlsCipherSuite>) throws {
        var __thrown : NullableHandle = nil;
        let h = System_Net_Security_CipherSuitesPolicy_ctor_0__1__System_Collections_Generic_IEnumerable_System_Net_Security_TlsCipherSuite_(&__thrown, allowedCipherSuites.get_handle());
        if let __ex = __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
            super.init(hndl: h);
        }
    }
    // [IsSpecialName] System.Collections.Generic.IEnumerable<System.Net.Security.TlsCipherSuite> get_AllowedCipherSuites()
// docid: M:System.Net.Security.CipherSuitesPolicy.get_AllowedCipherSuites
    public func get_AllowedCipherSuites() throws -> dotnet.System.Collections.Generic.IEnumerable_1<dotnet.System.Net.Security.TlsCipherSuite> {
        var __thrown : NullableHandle = nil;
        let __return = System_Net_Security_CipherSuitesPolicy_System_Collections_Generic_IEnumerable_System_Net_Security_TlsCipherSuite___get_AllowedCipherSuites_0__0(&__thrown, self.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return dotnet.System.Collections.Generic.IEnumerable_1(hndl : __return);
        }
    }
    /**
    Gets a subset of valid cipher suites passed into  constructor as a collection of cipher suites allowed in this policy for negotiation.

    */
    public var AllowedCipherSuites : dotnet.System.Collections.Generic.IEnumerable_1<dotnet.System.Net.Security.TlsCipherSuite> {
        get {
            return try! get_AllowedCipherSuites();
        }
    }
} // CipherSuitesPolicy


// type: System.Net.Security.EncryptionPolicy
    /**
    The EncryptionPolicy to use.

    */
public struct EncryptionPolicy : SGBridgeGenericValue {
    let v : Swift.Int32;
    public init(val: Swift.Int32) { self.v = val; }
    public func get_value() -> Swift.Int32 { return self.v; }
    public static func get_type_handle() -> TypeHandle {
        return System_Net_Security_EncryptionPolicy_get_type_handle();
    }
    public func to_gval() -> GVal { return GVal(self.v); }
    public func dup_gval() -> GVal { return to_gval(); }
    public init(gval: GVal) { self.v = Swift.Int32(gval); }
    // static field: System.Net.Security.EncryptionPolicy RequireEncryption
    /**
    Require encryption and never allow a NULL cipher.

    */
    public static var RequireEncryption : dotnet.System.Net.Security.EncryptionPolicy {
        get {
        let __return = dotnet.System.Net.Security.EncryptionPolicy(val: System_Net_Security_EncryptionPolicy_get_RequireEncryption());
            return __return;
        }
    }
    // static field: System.Net.Security.EncryptionPolicy AllowNoEncryption
    /**
    Prefer that full encryption be used, but allow a NULL cipher (no encryption) if the server agrees.

    */
    public static var AllowNoEncryption : dotnet.System.Net.Security.EncryptionPolicy {
        get {
        let __return = dotnet.System.Net.Security.EncryptionPolicy(val: System_Net_Security_EncryptionPolicy_get_AllowNoEncryption());
            return __return;
        }
    }
    // static field: System.Net.Security.EncryptionPolicy NoEncryption
    /**
    Allow no encryption and request that a NULL cipher be used if the other endpoint can handle a NULL cipher.

    */
    public static var NoEncryption : dotnet.System.Net.Security.EncryptionPolicy {
        get {
        let __return = dotnet.System.Net.Security.EncryptionPolicy(val: System_Net_Security_EncryptionPolicy_get_NoEncryption());
            return __return;
        }
    }
} // EncryptionPolicy


// type: System.Net.Security.LocalCertificateSelectionCallback
    /**
    Selects the local Secure Sockets Layer (SSL) certificate used for authentication.

    */
public final class LocalCertificateSelectionCallback
    :
    dotnet.System.Delegate
{
    public class override func get_type_handle() -> TypeHandle {
        return System_Net_Security_LocalCertificateSelectionCallback_get_type_handle();
    }
    public required init(hndl: NonnullHandle) { super.init(hndl: hndl); }
    public required init(gval: GVal) { super.init(gval: gval); }
    // System.Security.Cryptography.X509Certificates.X509Certificate Invoke(System.Object, System.String, System.Security.Cryptography.X509Certificates.X509CertificateCollection, System.Security.Cryptography.X509Certificates.X509Certificate, System.String[])
// docid: M:System.Net.Security.LocalCertificateSelectionCallback.Invoke(System.Object,System.String,System.Security.Cryptography.X509Certificates.X509CertificateCollection,System.Security.Cryptography.X509Certificates.X509Certificate,System.String[])
    public func Invoke(sender : dotnet.System.Object, targetHost : dotnet.System.String, localCertificates : dotnet.System.Security.Cryptography.X509Certificates.X509CertificateCollection, remoteCertificate : Optional<dotnet.System.Security.Cryptography.X509Certificates.X509Certificate>, acceptableIssuers : dotnet.System_Arr<dotnet.System.String>) throws -> dotnet.System.Security.Cryptography.X509Certificates.X509Certificate {
        var __thrown : NullableHandle = nil;
        let __return = System_Net_Security_LocalCertificateSelectionCallback_X509Certificate__Invoke_0__5__Object_String_X509CertificateCollection_X509Certificate_StringArray(&__thrown, self.get_handle(), sender.get_handle(), targetHost.get_handle(), localCertificates.get_handle(), remoteCertificate?.get_handle() ?? nil, acceptableIssuers.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return dotnet.System.Security.Cryptography.X509Certificates.X509Certificate(hndl : __return);
        }
    }
    // System.IAsyncResult BeginInvoke(System.Object, System.String, System.Security.Cryptography.X509Certificates.X509CertificateCollection, System.Security.Cryptography.X509Certificates.X509Certificate, System.String[], System.AsyncCallback, System.Object)
// docid: M:System.Net.Security.LocalCertificateSelectionCallback.BeginInvoke(System.Object,System.String,System.Security.Cryptography.X509Certificates.X509CertificateCollection,System.Security.Cryptography.X509Certificates.X509Certificate,System.String[],System.AsyncCallback,System.Object)
    public func BeginInvoke(sender : dotnet.System.Object, targetHost : dotnet.System.String, localCertificates : dotnet.System.Security.Cryptography.X509Certificates.X509CertificateCollection, remoteCertificate : Optional<dotnet.System.Security.Cryptography.X509Certificates.X509Certificate>, acceptableIssuers : dotnet.System_Arr<dotnet.System.String>, callback : Optional<dotnet.System.AsyncCallback>, object : Optional<dotnet.System.Object>) throws -> Optional<dotnet.System.IAsyncResult> {
        var __thrown : NullableHandle = nil;
        let __return = System_Net_Security_LocalCertificateSelectionCallback_IAsyncResult__BeginInvoke_0__7__Object_String_X509CertificateCollection_X509Certificate_StringArray_AsyncCallback_Object(&__thrown, self.get_handle(), sender.get_handle(), targetHost.get_handle(), localCertificates.get_handle(), remoteCertificate?.get_handle() ?? nil, acceptableIssuers.get_handle(), callback?.get_handle() ?? nil, object?.get_handle() ?? nil);
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        if let __ret_unwrapped = __return {
            return dotnet.System.IAsyncResult(hndl : __ret_unwrapped);
        } else {
            return nil;
        }
        }
    }
    // System.Security.Cryptography.X509Certificates.X509Certificate EndInvoke(System.IAsyncResult)
// docid: M:System.Net.Security.LocalCertificateSelectionCallback.EndInvoke(System.IAsyncResult)
    public func EndInvoke(result : Optional<dotnet.System.IAsyncResult>) throws -> dotnet.System.Security.Cryptography.X509Certificates.X509Certificate {
        var __thrown : NullableHandle = nil;
        let __return = System_Net_Security_LocalCertificateSelectionCallback_X509Certificate__EndInvoke_0__1__IAsyncResult(&__thrown, self.get_handle(), result?.get_handle() ?? nil);
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return dotnet.System.Security.Cryptography.X509Certificates.X509Certificate(hndl : __return);
        }
    }
    public init(_ callback : @escaping (dotnet.System.Object, dotnet.System.String, dotnet.System.Security.Cryptography.X509Certificates.X509CertificateCollection, Optional<dotnet.System.Security.Cryptography.X509Certificates.X509Certificate>, dotnet.System_Arr<dotnet.System.String>) throws -> dotnet.System.Security.Cryptography.X509Certificates.X509Certificate) throws
    {
        let __bridge : (UnsafeMutablePointer<NullableHandle>, NonnullHandle, NonnullHandle, NonnullHandle, NullableHandle, NonnullHandle) -> NonnullHandle =
        {
            (thrown : UnsafeMutablePointer<NullableHandle>, sender : NonnullHandle, targetHost : NonnullHandle, localCertificates : NonnullHandle, remoteCertificate : NullableHandle, acceptableIssuers : NonnullHandle) -> NonnullHandle in
            do
            {
                thrown.pointee = nil;
                let ret = try callback(dotnet.System.Object(hndl: sender), dotnet.System.String(hndl: targetHost), dotnet.System.Security.Cryptography.X509Certificates.X509CertificateCollection(hndl: localCertificates), (remoteCertificate != nil) ? (dotnet.System.Security.Cryptography.X509Certificates.X509Certificate(hndl: remoteCertificate!)) : nil, dotnet.System_Arr(hndl: acceptableIssuers));
                return __copy_handle(ret.get_handle());
            }
            catch let e as dotnet.System.Exception
            {
                thrown.pointee = __copy_handle(e.get_handle());
                return NonnullHandle(bitPattern: 8675309)!;
            }
            catch
            {
                let e = try! dotnet.System.Exception(message: "TODO fail inside closure");
                thrown.pointee = __copy_handle(e.get_handle());
                return NonnullHandle(bitPattern: 8675309)!;
            }
        };
        let cbarg = UnsafeRawPointer(Unmanaged.passRetained(__bridge as AnyObject).toOpaque());
        func __cb(cb : UnsafeRawPointer?, thrown : UnsafeMutablePointer<NullableHandle>, sender : NonnullHandle, targetHost : NonnullHandle, localCertificates : NonnullHandle, remoteCertificate : NullableHandle, acceptableIssuers : NonnullHandle) -> NonnullHandle
        {
            let f = Unmanaged<AnyObject>.fromOpaque(cb!).takeUnretainedValue() as! (UnsafeMutablePointer<NullableHandle>, NonnullHandle, NonnullHandle, NonnullHandle, NullableHandle, NonnullHandle) -> NonnullHandle;
            return f(thrown, sender, targetHost, localCertificates, remoteCertificate, acceptableIssuers);
        }
        var __thrown : NullableHandle = nil;
        let h = System_Net_Security_LocalCertificateSelectionCallback_create(
            &__thrown,
            cbarg,
            nil, // TODO deinit
            __cb
            );
            // TODO check thrown
        if let __ex = __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
            super.init(hndl: h);
        }
    }
    // System.Security.Cryptography.X509Certificates.X509Certificate Invoke(System.Object, System.String, System.Security.Cryptography.X509Certificates.X509CertificateCollection, System.Security.Cryptography.X509Certificates.X509Certificate, System.String[])
// docid: M:System.Net.Security.LocalCertificateSelectionCallback.Invoke(System.Object,System.String,System.Security.Cryptography.X509Certificates.X509CertificateCollection,System.Security.Cryptography.X509Certificates.X509Certificate,System.String[])
    public func callAsFunction(sender : dotnet.System.Object, targetHost : dotnet.System.String, localCertificates : dotnet.System.Security.Cryptography.X509Certificates.X509CertificateCollection, remoteCertificate : Optional<dotnet.System.Security.Cryptography.X509Certificates.X509Certificate>, acceptableIssuers : dotnet.System_Arr<dotnet.System.String>) throws -> dotnet.System.Security.Cryptography.X509Certificates.X509Certificate {
        var __thrown : NullableHandle = nil;
        let __return = System_Net_Security_LocalCertificateSelectionCallback_X509Certificate__Invoke_0__5__Object_String_X509CertificateCollection_X509Certificate_StringArray(&__thrown, self.get_handle(), sender.get_handle(), targetHost.get_handle(), localCertificates.get_handle(), remoteCertificate?.get_handle() ?? nil, acceptableIssuers.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return dotnet.System.Security.Cryptography.X509Certificates.X509Certificate(hndl : __return);
        }
    }
} // LocalCertificateSelectionCallback


// type: System.Net.Security.NegotiateStream
    /**
    Provides a stream that uses the Negotiate security protocol to authenticate the client, and optionally the server, in client-server communication.

    */
open class NegotiateStream
    :
    dotnet.System.Net.Security.AuthenticatedStream
{
    open class override func get_type_handle() -> TypeHandle {
        return System_Net_Security_NegotiateStream_get_type_handle();
    }
    public required init(hndl: NonnullHandle) { super.init(hndl: hndl); }
    public required init(gval: GVal) { super.init(gval: gval); }
    // .ctor(System.IO.Stream)
// docid: M:System.Net.Security.NegotiateStream.#ctor(System.IO.Stream)
    /**
    Initializes a new instance of the  class using the specified .

    - Parameter innerStream: A  object used by the  for sending and receiving data.
    */
    public init(innerStream : dotnet.System.IO.Stream) throws {
        var __thrown : NullableHandle = nil;
        let h = System_Net_Security_NegotiateStream_ctor_0__1__Stream(&__thrown, innerStream.get_handle());
        if let __ex = __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
            super.init(hndl: h);
        }
    }
    // .ctor(System.IO.Stream, bool)
// docid: M:System.Net.Security.NegotiateStream.#ctor(System.IO.Stream,System.Boolean)
    /**
    Initializes a new instance of the  class using the specified  and stream closure behavior.

    - Parameter innerStream: A  object used by the  for sending and receiving data.
    - Parameter leaveInnerStreamOpen: 
         to indicate that closing this  has no effect on ;  to indicate that closing this  also closes .
    */
    public init(innerStream : dotnet.System.IO.Stream, leaveInnerStreamOpen : Bool) throws {
        var __thrown : NullableHandle = nil;
        let h = System_Net_Security_NegotiateStream_ctor_0__2__Stream_bool(&__thrown, innerStream.get_handle(), Swift.Int32(leaveInnerStreamOpen ? 1 : 0));
        if let __ex = __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
            super.init(hndl: h);
        }
    }
    // void AuthenticateAsClient()
// docid: M:System.Net.Security.NegotiateStream.AuthenticateAsClient
    /**
    Called by clients to authenticate the client, and optionally the server, in a client-server connection.

    */
    open func AuthenticateAsClient() throws {
        var __thrown : NullableHandle = nil;
        System_Net_Security_NegotiateStream_void__AuthenticateAsClient_0__0(&__thrown, self.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
            return;
        }
    }
    // void AuthenticateAsClient(System.Net.NetworkCredential, System.Security.Authentication.ExtendedProtection.ChannelBinding, System.String)
// docid: M:System.Net.Security.NegotiateStream.AuthenticateAsClient(System.Net.NetworkCredential,System.Security.Authentication.ExtendedProtection.ChannelBinding,System.String)
    /**
    Called by clients to authenticate the client, and optionally the server, in a client-server connection. The authentication process uses the specified client credential and the channel binding.

    - Parameter credential: The  that is used to establish the identity of the client.
    - Parameter binding: The  that is used for extended protection.
    - Parameter targetName: The Service Principal Name (SPN) that uniquely identifies the server to authenticate.
    */
    open func AuthenticateAsClient(credential : dotnet.System.Net.NetworkCredential, binding : Optional<dotnet.System.Security.Authentication.ExtendedProtection.ChannelBinding>, targetName : dotnet.System.String) throws {
        var __thrown : NullableHandle = nil;
        System_Net_Security_NegotiateStream_void__AuthenticateAsClient_0__3__NetworkCredential_ChannelBinding_String(&__thrown, self.get_handle(), credential.get_handle(), binding?.get_handle() ?? nil, targetName.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
            return;
        }
    }
    // void AuthenticateAsClient(System.Net.NetworkCredential, System.Security.Authentication.ExtendedProtection.ChannelBinding, System.String, System.Net.Security.ProtectionLevel, System.Security.Principal.TokenImpersonationLevel)
// docid: M:System.Net.Security.NegotiateStream.AuthenticateAsClient(System.Net.NetworkCredential,System.Security.Authentication.ExtendedProtection.ChannelBinding,System.String,System.Net.Security.ProtectionLevel,System.Security.Principal.TokenImpersonationLevel)
    /**
    Called by clients to authenticate the client, and optionally the server, in a client-server connection. The authentication process uses the specified credential, authentication options, and channel binding.

    - Parameter credential: The  that is used to establish the identity of the client.
    - Parameter binding: The  that is used for extended protection.
    - Parameter targetName: The Service Principal Name (SPN) that uniquely identifies the server to authenticate.
    - Parameter requiredProtectionLevel: One of the  values, indicating the security services for the stream.
    - Parameter allowedImpersonationLevel: One of the  values, indicating how the server can use the client's credentials to access resources.
    */
    open func AuthenticateAsClient(credential : dotnet.System.Net.NetworkCredential, binding : Optional<dotnet.System.Security.Authentication.ExtendedProtection.ChannelBinding>, targetName : dotnet.System.String, requiredProtectionLevel : dotnet.System.Net.Security.ProtectionLevel, allowedImpersonationLevel : dotnet.System.Security.Principal.TokenImpersonationLevel) throws {
        var __thrown : NullableHandle = nil;
        System_Net_Security_NegotiateStream_void__AuthenticateAsClient_0__5__NetworkCredential_ChannelBinding_String_ProtectionLevel_TokenImpersonationLevel(&__thrown, self.get_handle(), credential.get_handle(), binding?.get_handle() ?? nil, targetName.get_handle(), requiredProtectionLevel.get_value(), allowedImpersonationLevel.get_value());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
            return;
        }
    }
    // void AuthenticateAsClient(System.Net.NetworkCredential, System.String)
// docid: M:System.Net.Security.NegotiateStream.AuthenticateAsClient(System.Net.NetworkCredential,System.String)
    /**
    Called by clients to authenticate the client, and optionally the server, in a client-server connection. The authentication process uses the specified client credential.

    - Parameter credential: The  that is used to establish the identity of the client.
    - Parameter targetName: The Service Principal Name (SPN) that uniquely identifies the server to authenticate.
    */
    open func AuthenticateAsClient(credential : dotnet.System.Net.NetworkCredential, targetName : dotnet.System.String) throws {
        var __thrown : NullableHandle = nil;
        System_Net_Security_NegotiateStream_void__AuthenticateAsClient_0__2__NetworkCredential_String(&__thrown, self.get_handle(), credential.get_handle(), targetName.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
            return;
        }
    }
    // void AuthenticateAsClient(System.Net.NetworkCredential, System.String, System.Net.Security.ProtectionLevel, System.Security.Principal.TokenImpersonationLevel)
// docid: M:System.Net.Security.NegotiateStream.AuthenticateAsClient(System.Net.NetworkCredential,System.String,System.Net.Security.ProtectionLevel,System.Security.Principal.TokenImpersonationLevel)
    /**
    Called by clients to authenticate the client, and optionally the server, in a client-server connection. The authentication process uses the specified credentials and authentication options.

    - Parameter credential: The  that is used to establish the identity of the client.
    - Parameter targetName: The Service Principal Name (SPN) that uniquely identifies the server to authenticate.
    - Parameter requiredProtectionLevel: One of the  values, indicating the security services for the stream.
    - Parameter allowedImpersonationLevel: One of the  values, indicating how the server can use the client's credentials to access resources.
    */
    open func AuthenticateAsClient(credential : dotnet.System.Net.NetworkCredential, targetName : dotnet.System.String, requiredProtectionLevel : dotnet.System.Net.Security.ProtectionLevel, allowedImpersonationLevel : dotnet.System.Security.Principal.TokenImpersonationLevel) throws {
        var __thrown : NullableHandle = nil;
        System_Net_Security_NegotiateStream_void__AuthenticateAsClient_0__4__NetworkCredential_String_ProtectionLevel_TokenImpersonationLevel(&__thrown, self.get_handle(), credential.get_handle(), targetName.get_handle(), requiredProtectionLevel.get_value(), allowedImpersonationLevel.get_value());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
            return;
        }
    }
    // System.Threading.Tasks.Task AuthenticateAsClientAsync()
// docid: M:System.Net.Security.NegotiateStream.AuthenticateAsClientAsync
    /**
    Called by clients to authenticate the client, and optionally the server, in a client-server connection as an asynchronous operation.

    - Returns: The task object representing the asynchronous operation.

    */
    open func AuthenticateAsClientAsync() throws -> dotnet.System.Threading.Tasks.Task {
        var __thrown : NullableHandle = nil;
        let __return = System_Net_Security_NegotiateStream_Task__AuthenticateAsClientAsync_0__0(&__thrown, self.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return dotnet.System.Threading.Tasks.Task(hndl : __return);
        }
    }
    // System.Threading.Tasks.Task AuthenticateAsClientAsync(System.Net.NetworkCredential, System.Security.Authentication.ExtendedProtection.ChannelBinding, System.String)
// docid: M:System.Net.Security.NegotiateStream.AuthenticateAsClientAsync(System.Net.NetworkCredential,System.Security.Authentication.ExtendedProtection.ChannelBinding,System.String)
    /**
    Called by clients to authenticate the client, and optionally the server, in a client-server connection as an asynchronous operation. The authentication process uses the specified client credential and the channel binding.

    - Parameter credential: The  that is used to establish the identity of the client.
    - Parameter binding: The  that is used for extended protection.
    - Parameter targetName: The Service Principal Name (SPN) that uniquely identifies the server to authenticate.
    - Returns: The task object representing the asynchronous operation.

    */
    open func AuthenticateAsClientAsync(credential : dotnet.System.Net.NetworkCredential, binding : Optional<dotnet.System.Security.Authentication.ExtendedProtection.ChannelBinding>, targetName : dotnet.System.String) throws -> dotnet.System.Threading.Tasks.Task {
        var __thrown : NullableHandle = nil;
        let __return = System_Net_Security_NegotiateStream_Task__AuthenticateAsClientAsync_0__3__NetworkCredential_ChannelBinding_String(&__thrown, self.get_handle(), credential.get_handle(), binding?.get_handle() ?? nil, targetName.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return dotnet.System.Threading.Tasks.Task(hndl : __return);
        }
    }
    // System.Threading.Tasks.Task AuthenticateAsClientAsync(System.Net.NetworkCredential, System.Security.Authentication.ExtendedProtection.ChannelBinding, System.String, System.Net.Security.ProtectionLevel, System.Security.Principal.TokenImpersonationLevel)
// docid: M:System.Net.Security.NegotiateStream.AuthenticateAsClientAsync(System.Net.NetworkCredential,System.Security.Authentication.ExtendedProtection.ChannelBinding,System.String,System.Net.Security.ProtectionLevel,System.Security.Principal.TokenImpersonationLevel)
    /**
    Called by clients to authenticate the client, and optionally the server, in a client-server connection as an asynchronous operation. The authentication process uses the specified credential, authentication options, and channel binding.

    - Parameter credential: The  that is used to establish the identity of the client.
    - Parameter binding: The  that is used for extended protection.
    - Parameter targetName: The Service Principal Name (SPN) that uniquely identifies the server to authenticate.
    - Parameter requiredProtectionLevel: One of the  values, indicating the security services for the stream.
    - Parameter allowedImpersonationLevel: One of the  values, indicating how the server can use the client's credentials to access resources.
    - Returns: The task object representing the asynchronous operation.

    */
    open func AuthenticateAsClientAsync(credential : dotnet.System.Net.NetworkCredential, binding : Optional<dotnet.System.Security.Authentication.ExtendedProtection.ChannelBinding>, targetName : dotnet.System.String, requiredProtectionLevel : dotnet.System.Net.Security.ProtectionLevel, allowedImpersonationLevel : dotnet.System.Security.Principal.TokenImpersonationLevel) throws -> dotnet.System.Threading.Tasks.Task {
        var __thrown : NullableHandle = nil;
        let __return = System_Net_Security_NegotiateStream_Task__AuthenticateAsClientAsync_0__5__NetworkCredential_ChannelBinding_String_ProtectionLevel_TokenImpersonationLevel(&__thrown, self.get_handle(), credential.get_handle(), binding?.get_handle() ?? nil, targetName.get_handle(), requiredProtectionLevel.get_value(), allowedImpersonationLevel.get_value());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return dotnet.System.Threading.Tasks.Task(hndl : __return);
        }
    }
    // System.Threading.Tasks.Task AuthenticateAsClientAsync(System.Net.NetworkCredential, System.String)
// docid: M:System.Net.Security.NegotiateStream.AuthenticateAsClientAsync(System.Net.NetworkCredential,System.String)
    /**
    Called by clients to authenticate the client, and optionally the server, in a client-server connection as an asynchronous operation. The authentication process uses the specified client credential.

    - Parameter credential: The  that is used to establish the identity of the client.
    - Parameter targetName: The Service Principal Name (SPN) that uniquely identifies the server to authenticate.
    - Returns: The task object representing the asynchronous operation.

    */
    open func AuthenticateAsClientAsync(credential : dotnet.System.Net.NetworkCredential, targetName : dotnet.System.String) throws -> dotnet.System.Threading.Tasks.Task {
        var __thrown : NullableHandle = nil;
        let __return = System_Net_Security_NegotiateStream_Task__AuthenticateAsClientAsync_0__2__NetworkCredential_String(&__thrown, self.get_handle(), credential.get_handle(), targetName.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return dotnet.System.Threading.Tasks.Task(hndl : __return);
        }
    }
    // System.Threading.Tasks.Task AuthenticateAsClientAsync(System.Net.NetworkCredential, System.String, System.Net.Security.ProtectionLevel, System.Security.Principal.TokenImpersonationLevel)
// docid: M:System.Net.Security.NegotiateStream.AuthenticateAsClientAsync(System.Net.NetworkCredential,System.String,System.Net.Security.ProtectionLevel,System.Security.Principal.TokenImpersonationLevel)
    /**
    Called by clients to authenticate the client, and optionally the server, in a client-server connection as an asynchronous operation. The authentication process uses the specified credentials and authentication options.

    - Parameter credential: The  that is used to establish the identity of the client.
    - Parameter targetName: The Service Principal Name (SPN) that uniquely identifies the server to authenticate.
    - Parameter requiredProtectionLevel: One of the  values, indicating the security services for the stream.
    - Parameter allowedImpersonationLevel: One of the  values, indicating how the server can use the client's credentials to access resources.
    - Returns: The task object representing the asynchronous operation.

    */
    open func AuthenticateAsClientAsync(credential : dotnet.System.Net.NetworkCredential, targetName : dotnet.System.String, requiredProtectionLevel : dotnet.System.Net.Security.ProtectionLevel, allowedImpersonationLevel : dotnet.System.Security.Principal.TokenImpersonationLevel) throws -> dotnet.System.Threading.Tasks.Task {
        var __thrown : NullableHandle = nil;
        let __return = System_Net_Security_NegotiateStream_Task__AuthenticateAsClientAsync_0__4__NetworkCredential_String_ProtectionLevel_TokenImpersonationLevel(&__thrown, self.get_handle(), credential.get_handle(), targetName.get_handle(), requiredProtectionLevel.get_value(), allowedImpersonationLevel.get_value());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return dotnet.System.Threading.Tasks.Task(hndl : __return);
        }
    }
    // void AuthenticateAsServer()
// docid: M:System.Net.Security.NegotiateStream.AuthenticateAsServer
    /**
    Called by servers to authenticate the client, and optionally the server, in a client-server connection.

    */
    open func AuthenticateAsServer() throws {
        var __thrown : NullableHandle = nil;
        System_Net_Security_NegotiateStream_void__AuthenticateAsServer_0__0(&__thrown, self.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
            return;
        }
    }
    // void AuthenticateAsServer(System.Net.NetworkCredential, System.Net.Security.ProtectionLevel, System.Security.Principal.TokenImpersonationLevel)
// docid: M:System.Net.Security.NegotiateStream.AuthenticateAsServer(System.Net.NetworkCredential,System.Net.Security.ProtectionLevel,System.Security.Principal.TokenImpersonationLevel)
    /**
    Called by servers to authenticate the client, and optionally the server, in a client-server connection. The authentication process uses the specified server credentials and authentication options.

    - Parameter credential: The  that is used to establish the identity of the server.
    - Parameter requiredProtectionLevel: One of the  values, indicating the security services for the stream.
    - Parameter requiredImpersonationLevel: One of the  values, indicating how the server can use the client's credentials to access resources.
    */
    open func AuthenticateAsServer(credential : dotnet.System.Net.NetworkCredential, requiredProtectionLevel : dotnet.System.Net.Security.ProtectionLevel, requiredImpersonationLevel : dotnet.System.Security.Principal.TokenImpersonationLevel) throws {
        var __thrown : NullableHandle = nil;
        System_Net_Security_NegotiateStream_void__AuthenticateAsServer_0__3__NetworkCredential_ProtectionLevel_TokenImpersonationLevel(&__thrown, self.get_handle(), credential.get_handle(), requiredProtectionLevel.get_value(), requiredImpersonationLevel.get_value());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
            return;
        }
    }
    // void AuthenticateAsServer(System.Net.NetworkCredential, System.Security.Authentication.ExtendedProtection.ExtendedProtectionPolicy, System.Net.Security.ProtectionLevel, System.Security.Principal.TokenImpersonationLevel)
// docid: M:System.Net.Security.NegotiateStream.AuthenticateAsServer(System.Net.NetworkCredential,System.Security.Authentication.ExtendedProtection.ExtendedProtectionPolicy,System.Net.Security.ProtectionLevel,System.Security.Principal.TokenImpersonationLevel)
    /**
    Called by servers to authenticate the client, and optionally the server, in a client-server connection. The authentication process uses the specified server credentials, authentication options, and extended protection policy.

    - Parameter credential: The  that is used to establish the identity of the client.
    - Parameter policy: The  that is used for extended protection.
    - Parameter requiredProtectionLevel: One of the  values, indicating the security services for the stream.
    - Parameter requiredImpersonationLevel: One of the  values, indicating how the server can use the client's credentials to access resources.
    */
    open func AuthenticateAsServer(credential : dotnet.System.Net.NetworkCredential, policy : Optional<dotnet.System.Security.Authentication.ExtendedProtection.ExtendedProtectionPolicy>, requiredProtectionLevel : dotnet.System.Net.Security.ProtectionLevel, requiredImpersonationLevel : dotnet.System.Security.Principal.TokenImpersonationLevel) throws {
        var __thrown : NullableHandle = nil;
        System_Net_Security_NegotiateStream_void__AuthenticateAsServer_0__4__NetworkCredential_ExtendedProtectionPolicy_ProtectionLevel_TokenImpersonationLevel(&__thrown, self.get_handle(), credential.get_handle(), policy?.get_handle() ?? nil, requiredProtectionLevel.get_value(), requiredImpersonationLevel.get_value());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
            return;
        }
    }
    // void AuthenticateAsServer(System.Security.Authentication.ExtendedProtection.ExtendedProtectionPolicy)
// docid: M:System.Net.Security.NegotiateStream.AuthenticateAsServer(System.Security.Authentication.ExtendedProtection.ExtendedProtectionPolicy)
    /**
    Called by servers to authenticate the client, and optionally the server, in a client-server connection. The authentication process uses the specified extended protection policy.

    - Parameter policy: The  that is used for extended protection.
    */
    open func AuthenticateAsServer(policy : Optional<dotnet.System.Security.Authentication.ExtendedProtection.ExtendedProtectionPolicy>) throws {
        var __thrown : NullableHandle = nil;
        System_Net_Security_NegotiateStream_void__AuthenticateAsServer_0__1__ExtendedProtectionPolicy(&__thrown, self.get_handle(), policy?.get_handle() ?? nil);
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
            return;
        }
    }
    // System.Threading.Tasks.Task AuthenticateAsServerAsync()
// docid: M:System.Net.Security.NegotiateStream.AuthenticateAsServerAsync
    /**
    Called by servers to authenticate the client, and optionally the server, in a client-server connection as an asynchronous operation.

    - Returns: The task object representing the asynchronous operation.

    */
    open func AuthenticateAsServerAsync() throws -> dotnet.System.Threading.Tasks.Task {
        var __thrown : NullableHandle = nil;
        let __return = System_Net_Security_NegotiateStream_Task__AuthenticateAsServerAsync_0__0(&__thrown, self.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return dotnet.System.Threading.Tasks.Task(hndl : __return);
        }
    }
    // System.Threading.Tasks.Task AuthenticateAsServerAsync(System.Net.NetworkCredential, System.Net.Security.ProtectionLevel, System.Security.Principal.TokenImpersonationLevel)
// docid: M:System.Net.Security.NegotiateStream.AuthenticateAsServerAsync(System.Net.NetworkCredential,System.Net.Security.ProtectionLevel,System.Security.Principal.TokenImpersonationLevel)
    /**
    Called by servers to authenticate the client, and optionally the server, in a client-server connection as an asynchronous operation. The authentication process uses the specified server credentials and authentication options.

    - Parameter credential: The  that is used to establish the identity of the server.
    - Parameter requiredProtectionLevel: One of the  values, indicating the security services for the stream.
    - Parameter requiredImpersonationLevel: One of the  values, indicating how the server can use the client's credentials to access resources.
    - Returns: The task object representing the asynchronous operation.

    */
    open func AuthenticateAsServerAsync(credential : dotnet.System.Net.NetworkCredential, requiredProtectionLevel : dotnet.System.Net.Security.ProtectionLevel, requiredImpersonationLevel : dotnet.System.Security.Principal.TokenImpersonationLevel) throws -> dotnet.System.Threading.Tasks.Task {
        var __thrown : NullableHandle = nil;
        let __return = System_Net_Security_NegotiateStream_Task__AuthenticateAsServerAsync_0__3__NetworkCredential_ProtectionLevel_TokenImpersonationLevel(&__thrown, self.get_handle(), credential.get_handle(), requiredProtectionLevel.get_value(), requiredImpersonationLevel.get_value());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return dotnet.System.Threading.Tasks.Task(hndl : __return);
        }
    }
    // System.Threading.Tasks.Task AuthenticateAsServerAsync(System.Net.NetworkCredential, System.Security.Authentication.ExtendedProtection.ExtendedProtectionPolicy, System.Net.Security.ProtectionLevel, System.Security.Principal.TokenImpersonationLevel)
// docid: M:System.Net.Security.NegotiateStream.AuthenticateAsServerAsync(System.Net.NetworkCredential,System.Security.Authentication.ExtendedProtection.ExtendedProtectionPolicy,System.Net.Security.ProtectionLevel,System.Security.Principal.TokenImpersonationLevel)
    /**
    Called by servers to authenticate the client, and optionally the server, in a client-server connection as an asynchronous operation. The authentication process uses the specified server credentials, authentication options, and extended protection policy.

    - Parameter credential: The  that is used to establish the identity of the client.
    - Parameter policy: The  that is used for extended protection.
    - Parameter requiredProtectionLevel: One of the  values, indicating the security services for the stream.
    - Parameter requiredImpersonationLevel: One of the  values, indicating how the server can use the client's credentials to access resources.
    - Returns: The task object representing the asynchronous operation.

    */
    open func AuthenticateAsServerAsync(credential : dotnet.System.Net.NetworkCredential, policy : Optional<dotnet.System.Security.Authentication.ExtendedProtection.ExtendedProtectionPolicy>, requiredProtectionLevel : dotnet.System.Net.Security.ProtectionLevel, requiredImpersonationLevel : dotnet.System.Security.Principal.TokenImpersonationLevel) throws -> dotnet.System.Threading.Tasks.Task {
        var __thrown : NullableHandle = nil;
        let __return = System_Net_Security_NegotiateStream_Task__AuthenticateAsServerAsync_0__4__NetworkCredential_ExtendedProtectionPolicy_ProtectionLevel_TokenImpersonationLevel(&__thrown, self.get_handle(), credential.get_handle(), policy?.get_handle() ?? nil, requiredProtectionLevel.get_value(), requiredImpersonationLevel.get_value());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return dotnet.System.Threading.Tasks.Task(hndl : __return);
        }
    }
    // System.Threading.Tasks.Task AuthenticateAsServerAsync(System.Security.Authentication.ExtendedProtection.ExtendedProtectionPolicy)
// docid: M:System.Net.Security.NegotiateStream.AuthenticateAsServerAsync(System.Security.Authentication.ExtendedProtection.ExtendedProtectionPolicy)
    /**
    Called by servers to authenticate the client, and optionally the server, in a client-server connection as an asynchronous operation. The authentication process uses the specified extended protection policy.

    - Parameter policy: The  that is used for extended protection.
    - Returns: The task object representing the asynchronous operation.

    */
    open func AuthenticateAsServerAsync(policy : Optional<dotnet.System.Security.Authentication.ExtendedProtection.ExtendedProtectionPolicy>) throws -> dotnet.System.Threading.Tasks.Task {
        var __thrown : NullableHandle = nil;
        let __return = System_Net_Security_NegotiateStream_Task__AuthenticateAsServerAsync_0__1__ExtendedProtectionPolicy(&__thrown, self.get_handle(), policy?.get_handle() ?? nil);
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return dotnet.System.Threading.Tasks.Task(hndl : __return);
        }
    }
    // System.IAsyncResult BeginAuthenticateAsClient(System.AsyncCallback, System.Object)
// docid: M:System.Net.Security.NegotiateStream.BeginAuthenticateAsClient(System.AsyncCallback,System.Object)
    /**
    Called by clients to begin an asynchronous operation to authenticate the client, and optionally the server, in a client-server connection. This method does not block.

    - Parameter asyncCallback: An  delegate that references the method to invoke when the authentication is complete.
    - Parameter asyncState: A user-defined object containing information about the operation. This object is passed to the  delegate when the operation completes.
    - Returns: An  object indicating the status of the asynchronous operation.

    */
    open func BeginAuthenticateAsClient(asyncCallback : Optional<dotnet.System.AsyncCallback>, asyncState : Optional<dotnet.System.Object>) throws -> dotnet.System.IAsyncResult {
        var __thrown : NullableHandle = nil;
        let __return = System_Net_Security_NegotiateStream_IAsyncResult__BeginAuthenticateAsClient_0__2__AsyncCallback_Object(&__thrown, self.get_handle(), asyncCallback?.get_handle() ?? nil, asyncState?.get_handle() ?? nil);
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return dotnet.System.IAsyncResult(hndl : __return);
        }
    }
    // delegate closure overload
    open func BeginAuthenticateAsClient(asyncCallback : @escaping (dotnet.System.IAsyncResult) throws -> Void, asyncState : Optional<dotnet.System.Object>) throws -> dotnet.System.IAsyncResult {
        let del_asyncCallback = try dotnet.System.AsyncCallback(asyncCallback);
        return try BeginAuthenticateAsClient(asyncCallback: del_asyncCallback, asyncState: asyncState);
    }
    // System.IAsyncResult BeginAuthenticateAsClient(System.Net.NetworkCredential, System.Security.Authentication.ExtendedProtection.ChannelBinding, System.String, System.AsyncCallback, System.Object)
// docid: M:System.Net.Security.NegotiateStream.BeginAuthenticateAsClient(System.Net.NetworkCredential,System.Security.Authentication.ExtendedProtection.ChannelBinding,System.String,System.AsyncCallback,System.Object)
    /**
    Called by clients to begin an asynchronous operation to authenticate the client, and optionally the server, in a client-server connection. The authentication process uses the specified credentials and channel binding. This method does not block.

    - Parameter credential: The  that is used to establish the identity of the client.
    - Parameter binding: The  that is used for extended protection.
    - Parameter targetName: The Service Principal Name (SPN) that uniquely identifies the server to authenticate.
    - Parameter asyncCallback: An  delegate that references the method to invoke when the authentication is complete.
    - Parameter asyncState: A user-defined object containing information about the write operation. This object is passed to the  delegate when the operation completes.
    - Returns: An  object indicating the status of the asynchronous operation.

    */
    open func BeginAuthenticateAsClient(credential : dotnet.System.Net.NetworkCredential, binding : Optional<dotnet.System.Security.Authentication.ExtendedProtection.ChannelBinding>, targetName : dotnet.System.String, asyncCallback : Optional<dotnet.System.AsyncCallback>, asyncState : Optional<dotnet.System.Object>) throws -> dotnet.System.IAsyncResult {
        var __thrown : NullableHandle = nil;
        let __return = System_Net_Security_NegotiateStream_IAsyncResult__BeginAuthenticateAsClient_0__5__NetworkCredential_ChannelBinding_String_AsyncCallback_Object(&__thrown, self.get_handle(), credential.get_handle(), binding?.get_handle() ?? nil, targetName.get_handle(), asyncCallback?.get_handle() ?? nil, asyncState?.get_handle() ?? nil);
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return dotnet.System.IAsyncResult(hndl : __return);
        }
    }
    // delegate closure overload
    open func BeginAuthenticateAsClient(credential : dotnet.System.Net.NetworkCredential, binding : Optional<dotnet.System.Security.Authentication.ExtendedProtection.ChannelBinding>, targetName : dotnet.System.String, asyncCallback : @escaping (dotnet.System.IAsyncResult) throws -> Void, asyncState : Optional<dotnet.System.Object>) throws -> dotnet.System.IAsyncResult {
        let del_asyncCallback = try dotnet.System.AsyncCallback(asyncCallback);
        return try BeginAuthenticateAsClient(credential: credential, binding: binding, targetName: targetName, asyncCallback: del_asyncCallback, asyncState: asyncState);
    }
    // System.IAsyncResult BeginAuthenticateAsClient(System.Net.NetworkCredential, System.Security.Authentication.ExtendedProtection.ChannelBinding, System.String, System.Net.Security.ProtectionLevel, System.Security.Principal.TokenImpersonationLevel, System.AsyncCallback, System.Object)
// docid: M:System.Net.Security.NegotiateStream.BeginAuthenticateAsClient(System.Net.NetworkCredential,System.Security.Authentication.ExtendedProtection.ChannelBinding,System.String,System.Net.Security.ProtectionLevel,System.Security.Principal.TokenImpersonationLevel,System.AsyncCallback,System.Object)
    /**
    Called by clients to begin an asynchronous operation to authenticate the client, and optionally the server, in a client-server connection. The authentication process uses the specified credentials, authentication options, and channel binding. This method does not block.

    - Parameter credential: The  that is used to establish the identity of the client.
    - Parameter binding: The  that is used for extended protection.
    - Parameter targetName: The Service Principal Name (SPN) that uniquely identifies the server to authenticate.
    - Parameter requiredProtectionLevel: One of the  values, indicating the security services for the stream.
    - Parameter allowedImpersonationLevel: One of the  values, indicating how the server can use the client's credentials to access resources.
    - Parameter asyncCallback: An  delegate that references the method to invoke when the authentication is complete.
    - Parameter asyncState: A user-defined object containing information about the write operation. This object is passed to the  delegate when the operation completes.
    - Returns: An  object indicating the status of the asynchronous operation.

    */
    open func BeginAuthenticateAsClient(credential : dotnet.System.Net.NetworkCredential, binding : Optional<dotnet.System.Security.Authentication.ExtendedProtection.ChannelBinding>, targetName : dotnet.System.String, requiredProtectionLevel : dotnet.System.Net.Security.ProtectionLevel, allowedImpersonationLevel : dotnet.System.Security.Principal.TokenImpersonationLevel, asyncCallback : Optional<dotnet.System.AsyncCallback>, asyncState : Optional<dotnet.System.Object>) throws -> dotnet.System.IAsyncResult {
        var __thrown : NullableHandle = nil;
        let __return = System_Net_Security_NegotiateStream_IAsyncResult__BeginAuthenticateAsClient_0__7__NetworkCredential_ChannelBinding_String_ProtectionLevel_TokenImpersonationLevel_AsyncCallback_Object(&__thrown, self.get_handle(), credential.get_handle(), binding?.get_handle() ?? nil, targetName.get_handle(), requiredProtectionLevel.get_value(), allowedImpersonationLevel.get_value(), asyncCallback?.get_handle() ?? nil, asyncState?.get_handle() ?? nil);
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return dotnet.System.IAsyncResult(hndl : __return);
        }
    }
    // delegate closure overload
    open func BeginAuthenticateAsClient(credential : dotnet.System.Net.NetworkCredential, binding : Optional<dotnet.System.Security.Authentication.ExtendedProtection.ChannelBinding>, targetName : dotnet.System.String, requiredProtectionLevel : dotnet.System.Net.Security.ProtectionLevel, allowedImpersonationLevel : dotnet.System.Security.Principal.TokenImpersonationLevel, asyncCallback : @escaping (dotnet.System.IAsyncResult) throws -> Void, asyncState : Optional<dotnet.System.Object>) throws -> dotnet.System.IAsyncResult {
        let del_asyncCallback = try dotnet.System.AsyncCallback(asyncCallback);
        return try BeginAuthenticateAsClient(credential: credential, binding: binding, targetName: targetName, requiredProtectionLevel: requiredProtectionLevel, allowedImpersonationLevel: allowedImpersonationLevel, asyncCallback: del_asyncCallback, asyncState: asyncState);
    }
    // System.IAsyncResult BeginAuthenticateAsClient(System.Net.NetworkCredential, System.String, System.AsyncCallback, System.Object)
// docid: M:System.Net.Security.NegotiateStream.BeginAuthenticateAsClient(System.Net.NetworkCredential,System.String,System.AsyncCallback,System.Object)
    /**
    Called by clients to begin an asynchronous operation to authenticate the client, and optionally the server, in a client-server connection. The authentication process uses the specified credentials. This method does not block.

    - Parameter credential: The  that is used to establish the identity of the client.
    - Parameter targetName: The Service Principal Name (SPN) that uniquely identifies the server to authenticate.
    - Parameter asyncCallback: An  delegate that references the method to invoke when the authentication is complete.
    - Parameter asyncState: A user-defined object containing information about the write operation. This object is passed to the  delegate when the operation completes.
    - Returns: An  object indicating the status of the asynchronous operation.

    */
    open func BeginAuthenticateAsClient(credential : dotnet.System.Net.NetworkCredential, targetName : dotnet.System.String, asyncCallback : Optional<dotnet.System.AsyncCallback>, asyncState : Optional<dotnet.System.Object>) throws -> dotnet.System.IAsyncResult {
        var __thrown : NullableHandle = nil;
        let __return = System_Net_Security_NegotiateStream_IAsyncResult__BeginAuthenticateAsClient_0__4__NetworkCredential_String_AsyncCallback_Object(&__thrown, self.get_handle(), credential.get_handle(), targetName.get_handle(), asyncCallback?.get_handle() ?? nil, asyncState?.get_handle() ?? nil);
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return dotnet.System.IAsyncResult(hndl : __return);
        }
    }
    // delegate closure overload
    open func BeginAuthenticateAsClient(credential : dotnet.System.Net.NetworkCredential, targetName : dotnet.System.String, asyncCallback : @escaping (dotnet.System.IAsyncResult) throws -> Void, asyncState : Optional<dotnet.System.Object>) throws -> dotnet.System.IAsyncResult {
        let del_asyncCallback = try dotnet.System.AsyncCallback(asyncCallback);
        return try BeginAuthenticateAsClient(credential: credential, targetName: targetName, asyncCallback: del_asyncCallback, asyncState: asyncState);
    }
    // System.IAsyncResult BeginAuthenticateAsClient(System.Net.NetworkCredential, System.String, System.Net.Security.ProtectionLevel, System.Security.Principal.TokenImpersonationLevel, System.AsyncCallback, System.Object)
// docid: M:System.Net.Security.NegotiateStream.BeginAuthenticateAsClient(System.Net.NetworkCredential,System.String,System.Net.Security.ProtectionLevel,System.Security.Principal.TokenImpersonationLevel,System.AsyncCallback,System.Object)
    /**
    Called by clients to begin an asynchronous operation to authenticate the client, and optionally the server, in a client-server connection. The authentication process uses the specified credentials and authentication options. This method does not block.

    - Parameter credential: The  that is used to establish the identity of the client.
    - Parameter targetName: The Service Principal Name (SPN) that uniquely identifies the server to authenticate.
    - Parameter requiredProtectionLevel: One of the  values, indicating the security services for the stream.
    - Parameter allowedImpersonationLevel: One of the  values, indicating how the server can use the client's credentials to access resources.
    - Parameter asyncCallback: An  delegate that references the method to invoke when the authentication is complete.
    - Parameter asyncState: A user-defined object containing information about the write operation. This object is passed to the  delegate when the operation completes.
    - Returns: An  object indicating the status of the asynchronous operation.

    */
    open func BeginAuthenticateAsClient(credential : dotnet.System.Net.NetworkCredential, targetName : dotnet.System.String, requiredProtectionLevel : dotnet.System.Net.Security.ProtectionLevel, allowedImpersonationLevel : dotnet.System.Security.Principal.TokenImpersonationLevel, asyncCallback : Optional<dotnet.System.AsyncCallback>, asyncState : Optional<dotnet.System.Object>) throws -> dotnet.System.IAsyncResult {
        var __thrown : NullableHandle = nil;
        let __return = System_Net_Security_NegotiateStream_IAsyncResult__BeginAuthenticateAsClient_0__6__NetworkCredential_String_ProtectionLevel_TokenImpersonationLevel_AsyncCallback_Object(&__thrown, self.get_handle(), credential.get_handle(), targetName.get_handle(), requiredProtectionLevel.get_value(), allowedImpersonationLevel.get_value(), asyncCallback?.get_handle() ?? nil, asyncState?.get_handle() ?? nil);
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return dotnet.System.IAsyncResult(hndl : __return);
        }
    }
    // delegate closure overload
    open func BeginAuthenticateAsClient(credential : dotnet.System.Net.NetworkCredential, targetName : dotnet.System.String, requiredProtectionLevel : dotnet.System.Net.Security.ProtectionLevel, allowedImpersonationLevel : dotnet.System.Security.Principal.TokenImpersonationLevel, asyncCallback : @escaping (dotnet.System.IAsyncResult) throws -> Void, asyncState : Optional<dotnet.System.Object>) throws -> dotnet.System.IAsyncResult {
        let del_asyncCallback = try dotnet.System.AsyncCallback(asyncCallback);
        return try BeginAuthenticateAsClient(credential: credential, targetName: targetName, requiredProtectionLevel: requiredProtectionLevel, allowedImpersonationLevel: allowedImpersonationLevel, asyncCallback: del_asyncCallback, asyncState: asyncState);
    }
    // System.IAsyncResult BeginAuthenticateAsServer(System.AsyncCallback, System.Object)
// docid: M:System.Net.Security.NegotiateStream.BeginAuthenticateAsServer(System.AsyncCallback,System.Object)
    /**
    Called by servers to begin an asynchronous operation to authenticate the client, and optionally the server, in a client-server connection. This method does not block.

    - Parameter asyncCallback: An  delegate that references the method to invoke when the authentication is complete.
    - Parameter asyncState: A user-defined object containing information about the operation. This object is passed to the  delegate when the operation completes.
    - Returns: An  object indicating the status of the asynchronous operation.

    */
    open func BeginAuthenticateAsServer(asyncCallback : Optional<dotnet.System.AsyncCallback>, asyncState : Optional<dotnet.System.Object>) throws -> dotnet.System.IAsyncResult {
        var __thrown : NullableHandle = nil;
        let __return = System_Net_Security_NegotiateStream_IAsyncResult__BeginAuthenticateAsServer_0__2__AsyncCallback_Object(&__thrown, self.get_handle(), asyncCallback?.get_handle() ?? nil, asyncState?.get_handle() ?? nil);
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return dotnet.System.IAsyncResult(hndl : __return);
        }
    }
    // delegate closure overload
    open func BeginAuthenticateAsServer(asyncCallback : @escaping (dotnet.System.IAsyncResult) throws -> Void, asyncState : Optional<dotnet.System.Object>) throws -> dotnet.System.IAsyncResult {
        let del_asyncCallback = try dotnet.System.AsyncCallback(asyncCallback);
        return try BeginAuthenticateAsServer(asyncCallback: del_asyncCallback, asyncState: asyncState);
    }
    // System.IAsyncResult BeginAuthenticateAsServer(System.Net.NetworkCredential, System.Net.Security.ProtectionLevel, System.Security.Principal.TokenImpersonationLevel, System.AsyncCallback, System.Object)
// docid: M:System.Net.Security.NegotiateStream.BeginAuthenticateAsServer(System.Net.NetworkCredential,System.Net.Security.ProtectionLevel,System.Security.Principal.TokenImpersonationLevel,System.AsyncCallback,System.Object)
    /**
    Called by servers to begin an asynchronous operation to authenticate the client, and optionally the server, in a client-server connection. The authentication process uses the specified server credentials and authentication options. This method does not block.

    - Parameter credential: The  that is used to establish the identity of the client.
    - Parameter requiredProtectionLevel: One of the  values, indicating the security services for the stream.
    - Parameter requiredImpersonationLevel: One of the  values, indicating how the server can use the client's credentials to access resources.
    - Parameter asyncCallback: An  delegate that references the method to invoke when the authentication is complete.
    - Parameter asyncState: A user-defined object containing information about the operation. This object is passed to the  delegate when the operation completes.
    - Returns: An  object indicating the status of the asynchronous operation.

    */
    open func BeginAuthenticateAsServer(credential : dotnet.System.Net.NetworkCredential, requiredProtectionLevel : dotnet.System.Net.Security.ProtectionLevel, requiredImpersonationLevel : dotnet.System.Security.Principal.TokenImpersonationLevel, asyncCallback : Optional<dotnet.System.AsyncCallback>, asyncState : Optional<dotnet.System.Object>) throws -> dotnet.System.IAsyncResult {
        var __thrown : NullableHandle = nil;
        let __return = System_Net_Security_NegotiateStream_IAsyncResult__BeginAuthenticateAsServer_0__5__NetworkCredential_ProtectionLevel_TokenImpersonationLevel_AsyncCallback_Object(&__thrown, self.get_handle(), credential.get_handle(), requiredProtectionLevel.get_value(), requiredImpersonationLevel.get_value(), asyncCallback?.get_handle() ?? nil, asyncState?.get_handle() ?? nil);
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return dotnet.System.IAsyncResult(hndl : __return);
        }
    }
    // delegate closure overload
    open func BeginAuthenticateAsServer(credential : dotnet.System.Net.NetworkCredential, requiredProtectionLevel : dotnet.System.Net.Security.ProtectionLevel, requiredImpersonationLevel : dotnet.System.Security.Principal.TokenImpersonationLevel, asyncCallback : @escaping (dotnet.System.IAsyncResult) throws -> Void, asyncState : Optional<dotnet.System.Object>) throws -> dotnet.System.IAsyncResult {
        let del_asyncCallback = try dotnet.System.AsyncCallback(asyncCallback);
        return try BeginAuthenticateAsServer(credential: credential, requiredProtectionLevel: requiredProtectionLevel, requiredImpersonationLevel: requiredImpersonationLevel, asyncCallback: del_asyncCallback, asyncState: asyncState);
    }
    // System.IAsyncResult BeginAuthenticateAsServer(System.Net.NetworkCredential, System.Security.Authentication.ExtendedProtection.ExtendedProtectionPolicy, System.Net.Security.ProtectionLevel, System.Security.Principal.TokenImpersonationLevel, System.AsyncCallback, System.Object)
// docid: M:System.Net.Security.NegotiateStream.BeginAuthenticateAsServer(System.Net.NetworkCredential,System.Security.Authentication.ExtendedProtection.ExtendedProtectionPolicy,System.Net.Security.ProtectionLevel,System.Security.Principal.TokenImpersonationLevel,System.AsyncCallback,System.Object)
    /**
    Called by servers to begin an asynchronous operation to authenticate the client, and optionally the server, in a client-server connection. The authentication process uses the specified server credentials, authentication options, and extended protection policy. This method does not block.

    - Parameter credential: The  that is used to establish the identity of the client.
    - Parameter policy: The  that is used for extended protection.
    - Parameter requiredProtectionLevel: One of the  values, indicating the security services for the stream.
    - Parameter requiredImpersonationLevel: One of the  values, indicating how the server can use the client's credentials to access resources.
    - Parameter asyncCallback: An  delegate that references the method to invoke when the authentication is complete.
    - Parameter asyncState: A user-defined object containing information about the write operation. This object is passed to the  delegate when the operation completes.
    - Returns: An  object indicating the status of the asynchronous operation.

    */
    open func BeginAuthenticateAsServer(credential : dotnet.System.Net.NetworkCredential, policy : Optional<dotnet.System.Security.Authentication.ExtendedProtection.ExtendedProtectionPolicy>, requiredProtectionLevel : dotnet.System.Net.Security.ProtectionLevel, requiredImpersonationLevel : dotnet.System.Security.Principal.TokenImpersonationLevel, asyncCallback : Optional<dotnet.System.AsyncCallback>, asyncState : Optional<dotnet.System.Object>) throws -> dotnet.System.IAsyncResult {
        var __thrown : NullableHandle = nil;
        let __return = System_Net_Security_NegotiateStream_IAsyncResult__BeginAuthenticateAsServer_0__6__NetworkCredential_ExtendedProtectionPolicy_ProtectionLevel_TokenImpersonationLevel_AsyncCallback_Object(&__thrown, self.get_handle(), credential.get_handle(), policy?.get_handle() ?? nil, requiredProtectionLevel.get_value(), requiredImpersonationLevel.get_value(), asyncCallback?.get_handle() ?? nil, asyncState?.get_handle() ?? nil);
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return dotnet.System.IAsyncResult(hndl : __return);
        }
    }
    // delegate closure overload
    open func BeginAuthenticateAsServer(credential : dotnet.System.Net.NetworkCredential, policy : Optional<dotnet.System.Security.Authentication.ExtendedProtection.ExtendedProtectionPolicy>, requiredProtectionLevel : dotnet.System.Net.Security.ProtectionLevel, requiredImpersonationLevel : dotnet.System.Security.Principal.TokenImpersonationLevel, asyncCallback : @escaping (dotnet.System.IAsyncResult) throws -> Void, asyncState : Optional<dotnet.System.Object>) throws -> dotnet.System.IAsyncResult {
        let del_asyncCallback = try dotnet.System.AsyncCallback(asyncCallback);
        return try BeginAuthenticateAsServer(credential: credential, policy: policy, requiredProtectionLevel: requiredProtectionLevel, requiredImpersonationLevel: requiredImpersonationLevel, asyncCallback: del_asyncCallback, asyncState: asyncState);
    }
    // System.IAsyncResult BeginAuthenticateAsServer(System.Security.Authentication.ExtendedProtection.ExtendedProtectionPolicy, System.AsyncCallback, System.Object)
// docid: M:System.Net.Security.NegotiateStream.BeginAuthenticateAsServer(System.Security.Authentication.ExtendedProtection.ExtendedProtectionPolicy,System.AsyncCallback,System.Object)
    /**
    Called by servers to begin an asynchronous operation to authenticate the client, and optionally the server, in a client-server connection. The authentication process uses the specified extended protection policy. This method does not block.

    - Parameter policy: The  that is used for extended protection.
    - Parameter asyncCallback: An  delegate that references the method to invoke when the authentication is complete.
    - Parameter asyncState: A user-defined object containing information about the write operation. This object is passed to the  delegate when the operation completes.
    - Returns: An  object indicating the status of the asynchronous operation.

    */
    open func BeginAuthenticateAsServer(policy : Optional<dotnet.System.Security.Authentication.ExtendedProtection.ExtendedProtectionPolicy>, asyncCallback : Optional<dotnet.System.AsyncCallback>, asyncState : Optional<dotnet.System.Object>) throws -> dotnet.System.IAsyncResult {
        var __thrown : NullableHandle = nil;
        let __return = System_Net_Security_NegotiateStream_IAsyncResult__BeginAuthenticateAsServer_0__3__ExtendedProtectionPolicy_AsyncCallback_Object(&__thrown, self.get_handle(), policy?.get_handle() ?? nil, asyncCallback?.get_handle() ?? nil, asyncState?.get_handle() ?? nil);
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return dotnet.System.IAsyncResult(hndl : __return);
        }
    }
    // delegate closure overload
    open func BeginAuthenticateAsServer(policy : Optional<dotnet.System.Security.Authentication.ExtendedProtection.ExtendedProtectionPolicy>, asyncCallback : @escaping (dotnet.System.IAsyncResult) throws -> Void, asyncState : Optional<dotnet.System.Object>) throws -> dotnet.System.IAsyncResult {
        let del_asyncCallback = try dotnet.System.AsyncCallback(asyncCallback);
        return try BeginAuthenticateAsServer(policy: policy, asyncCallback: del_asyncCallback, asyncState: asyncState);
    }
    // System.IAsyncResult BeginRead(System.Byte[], System.Int32, System.Int32, System.AsyncCallback, System.Object)
// docid: M:System.Net.Security.NegotiateStream.BeginRead(System.Byte[],System.Int32,System.Int32,System.AsyncCallback,System.Object)
    /**
    Begins an asynchronous read operation that reads data from the stream and stores it in the specified array.

    - Parameter buffer: A  array that receives the bytes read from the stream.
    - Parameter offset: The zero-based location in  at which to begin storing the data read from this stream.
    - Parameter count: The maximum number of bytes to read from the stream.
    - Parameter asyncCallback: An  delegate that references the method to invoke when the read operation is complete.
    - Parameter asyncState: A user-defined object containing information about the read operation. This object is passed to the  delegate when the operation completes.
    - Returns: An  object indicating the status of the asynchronous operation.

    */
    open func BeginRead(buffer : dotnet.System_Arr<Swift.UInt8>, offset : Swift.Int32, count : Swift.Int32, asyncCallback : Optional<dotnet.System.AsyncCallback>, asyncState : Optional<dotnet.System.Object>) throws -> dotnet.System.IAsyncResult {
        var __thrown : NullableHandle = nil;
        let __return = System_Net_Security_NegotiateStream_IAsyncResult__BeginRead_0__5__u8Array_i32_i32_AsyncCallback_Object(&__thrown, self.get_handle(), buffer.get_handle(), offset, count, asyncCallback?.get_handle() ?? nil, asyncState?.get_handle() ?? nil);
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return dotnet.System.IAsyncResult(hndl : __return);
        }
    }
    // delegate closure overload
    open func BeginRead(buffer : dotnet.System_Arr<Swift.UInt8>, offset : Swift.Int32, count : Swift.Int32, asyncCallback : @escaping (dotnet.System.IAsyncResult) throws -> Void, asyncState : Optional<dotnet.System.Object>) throws -> dotnet.System.IAsyncResult {
        let del_asyncCallback = try dotnet.System.AsyncCallback(asyncCallback);
        return try BeginRead(buffer: buffer, offset: offset, count: count, asyncCallback: del_asyncCallback, asyncState: asyncState);
    }
    // System.IAsyncResult BeginWrite(System.Byte[], System.Int32, System.Int32, System.AsyncCallback, System.Object)
// docid: M:System.Net.Security.NegotiateStream.BeginWrite(System.Byte[],System.Int32,System.Int32,System.AsyncCallback,System.Object)
    /**
    Begins an asynchronous write operation that writes s from the specified buffer to the stream.

    - Parameter buffer: A  array that supplies the bytes to be written to the stream.
    - Parameter offset: The zero-based location in  at which to begin reading bytes to be written to the stream.
    - Parameter count: An  value that specifies the number of bytes to read from .
    - Parameter asyncCallback: An  delegate that references the method to invoke when the write operation is complete.
    - Parameter asyncState: A user-defined object containing information about the write operation. This object is passed to the  delegate when the operation completes.
    - Returns: An  object indicating the status of the asynchronous operation.

    */
    open func BeginWrite(buffer : dotnet.System_Arr<Swift.UInt8>, offset : Swift.Int32, count : Swift.Int32, asyncCallback : Optional<dotnet.System.AsyncCallback>, asyncState : Optional<dotnet.System.Object>) throws -> dotnet.System.IAsyncResult {
        var __thrown : NullableHandle = nil;
        let __return = System_Net_Security_NegotiateStream_IAsyncResult__BeginWrite_0__5__u8Array_i32_i32_AsyncCallback_Object(&__thrown, self.get_handle(), buffer.get_handle(), offset, count, asyncCallback?.get_handle() ?? nil, asyncState?.get_handle() ?? nil);
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return dotnet.System.IAsyncResult(hndl : __return);
        }
    }
    // delegate closure overload
    open func BeginWrite(buffer : dotnet.System_Arr<Swift.UInt8>, offset : Swift.Int32, count : Swift.Int32, asyncCallback : @escaping (dotnet.System.IAsyncResult) throws -> Void, asyncState : Optional<dotnet.System.Object>) throws -> dotnet.System.IAsyncResult {
        let del_asyncCallback = try dotnet.System.AsyncCallback(asyncCallback);
        return try BeginWrite(buffer: buffer, offset: offset, count: count, asyncCallback: del_asyncCallback, asyncState: asyncState);
    }
    // System.Threading.Tasks.ValueTask DisposeAsync()
// docid: M:System.Net.Security.NegotiateStream.DisposeAsync
    /**
    Asynchronously releases the unmanaged and managed resources used by the .

    - Returns: A task that represents the asynchronous dispose operation.

    */
    open override func DisposeAsync() throws -> dotnet.System.Threading.Tasks.ValueTask {
        var __thrown : NullableHandle = nil;
        let __return = System_Net_Security_NegotiateStream_ValueTask__DisposeAsync_0__0(&__thrown, self.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return dotnet.System.Threading.Tasks.ValueTask(hndl : __return);
        }
    }
    // void EndAuthenticateAsClient(System.IAsyncResult)
// docid: M:System.Net.Security.NegotiateStream.EndAuthenticateAsClient(System.IAsyncResult)
    /**
    Ends a pending asynchronous client authentication operation that was started with a call to .

    - Parameter asyncResult: An  instance returned by a call to .
    */
    open func EndAuthenticateAsClient(asyncResult : dotnet.System.IAsyncResult) throws {
        var __thrown : NullableHandle = nil;
        System_Net_Security_NegotiateStream_void__EndAuthenticateAsClient_0__1__IAsyncResult(&__thrown, self.get_handle(), asyncResult.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
            return;
        }
    }
    // void EndAuthenticateAsServer(System.IAsyncResult)
// docid: M:System.Net.Security.NegotiateStream.EndAuthenticateAsServer(System.IAsyncResult)
    /**
    Ends a pending asynchronous client authentication operation that was started with a call to .

    - Parameter asyncResult: An  instance returned by a call to .
    */
    open func EndAuthenticateAsServer(asyncResult : dotnet.System.IAsyncResult) throws {
        var __thrown : NullableHandle = nil;
        System_Net_Security_NegotiateStream_void__EndAuthenticateAsServer_0__1__IAsyncResult(&__thrown, self.get_handle(), asyncResult.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
            return;
        }
    }
    // System.Int32 EndRead(System.IAsyncResult)
// docid: M:System.Net.Security.NegotiateStream.EndRead(System.IAsyncResult)
    /**
    Ends an asynchronous read operation that was started with a call to .

    - Parameter asyncResult: An  instance returned by a call to 
    - Returns: A  value that specifies the number of bytes read from the underlying stream.

    */
    open override func EndRead(asyncResult : dotnet.System.IAsyncResult) throws -> Swift.Int32 {
        var __thrown : NullableHandle = nil;
        let __return = System_Net_Security_NegotiateStream_i32__EndRead_0__1__IAsyncResult(&__thrown, self.get_handle(), asyncResult.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return __return;
        }
    }
    // void EndWrite(System.IAsyncResult)
// docid: M:System.Net.Security.NegotiateStream.EndWrite(System.IAsyncResult)
    /**
    Ends an asynchronous write operation that was started with a call to .

    - Parameter asyncResult: An  instance returned by a call to 
    */
    open override func EndWrite(asyncResult : dotnet.System.IAsyncResult) throws {
        var __thrown : NullableHandle = nil;
        System_Net_Security_NegotiateStream_void__EndWrite_0__1__IAsyncResult(&__thrown, self.get_handle(), asyncResult.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
            return;
        }
    }
    // void Flush()
// docid: M:System.Net.Security.NegotiateStream.Flush
    /**
    Causes any buffered data to be written to the underlying device.

    */
    open override func Flush() throws {
        var __thrown : NullableHandle = nil;
        System_Net_Security_NegotiateStream_void__Flush_0__0(&__thrown, self.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
            return;
        }
    }
    // System.Threading.Tasks.Task FlushAsync(System.Threading.CancellationToken)
// docid: M:System.Net.Security.NegotiateStream.FlushAsync(System.Threading.CancellationToken)
    /**
    Asynchronously writes any buffered data to the underlying device.

    - Parameter cancellationToken: The token to monitor for cancellation requests.
    - Returns: A task that represents the asynchronous flush operation.

    */
    open override func FlushAsync(cancellationToken : dotnet.System.Threading.CancellationToken) throws -> dotnet.System.Threading.Tasks.Task {
        var __thrown : NullableHandle = nil;
        let __return = System_Net_Security_NegotiateStream_Task__FlushAsync_0__1__CancellationToken(&__thrown, self.get_handle(), cancellationToken.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return dotnet.System.Threading.Tasks.Task(hndl : __return);
        }
    }
    // System.Int32 Read(System.Byte[], System.Int32, System.Int32)
// docid: M:System.Net.Security.NegotiateStream.Read(System.Byte[],System.Int32,System.Int32)
    /**
    Reads data from this stream and stores it in the specified array.

    - Parameter buffer: A  array that receives the bytes read from the stream.
    - Parameter offset: A  containing the zero-based location in  at which to begin storing the data read from this stream.
    - Parameter count: A  containing the maximum number of bytes to read from the stream.
    - Returns: An  value that specifies the number of bytes read from the underlying stream. When there is no more data to be read, returns 0.

    */
    open override func Read(buffer : dotnet.System_Arr<Swift.UInt8>, offset : Swift.Int32, count : Swift.Int32) throws -> Swift.Int32 {
        var __thrown : NullableHandle = nil;
        let __return = System_Net_Security_NegotiateStream_i32__Read_0__3__u8Array_i32_i32(&__thrown, self.get_handle(), buffer.get_handle(), offset, count);
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return __return;
        }
    }
    // System.Threading.Tasks.Task<System.Int32> ReadAsync(System.Byte[], System.Int32, System.Int32, System.Threading.CancellationToken)
// docid: M:System.Net.Security.NegotiateStream.ReadAsync(System.Byte[],System.Int32,System.Int32,System.Threading.CancellationToken)
    /**
    Reads data asynchronously from this stream and stores it in the specified array.

    - Parameter buffer: A  array that receives the bytes read from the stream.
    - Parameter offset: A  containing the zero-based location in  at which to begin storing the data read from this stream.
    - Parameter count: A  containing the maximum number of bytes to read from the stream.
    - Parameter cancellationToken: The token to monitor for cancellation requests.
    - Returns: An  value that specifies the number of bytes read from the underlying stream. When there is no more data to be read, returns 0.

    */
    open override func ReadAsync(buffer : dotnet.System_Arr<Swift.UInt8>, offset : Swift.Int32, count : Swift.Int32, cancellationToken : dotnet.System.Threading.CancellationToken) throws -> dotnet.System.Threading.Tasks.Task_1<Swift.Int32> {
        var __thrown : NullableHandle = nil;
        let __return = System_Net_Security_NegotiateStream_System_Threading_Tasks_Task_i32___ReadAsync_0__4__u8Array_i32_i32_CancellationToken(&__thrown, self.get_handle(), buffer.get_handle(), offset, count, cancellationToken.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return dotnet.System.Threading.Tasks.Task_1(hndl : __return);
        }
    }
    // System.Threading.Tasks.ValueTask<System.Int32> ReadAsync(System.Memory<System.Byte>, System.Threading.CancellationToken)
// docid: M:System.Net.Security.NegotiateStream.ReadAsync(System.Memory{System.Byte},System.Threading.CancellationToken)
    /**
    Reads data asynchronously from the  and stores it in a byte memory range as an asynchronous operation.

    - Parameter buffer: The buffer to write the data to.
    - Parameter cancellationToken: The token to monitor for cancellation requests.
    - Returns: A  that represents the asynchronous read operation. The value of its  property contains the total number of bytes read into .

    */
    open override func ReadAsync(buffer : dotnet.System.Memory_1<Swift.UInt8>, cancellationToken : dotnet.System.Threading.CancellationToken = System.Threading.CancellationToken.None) throws -> dotnet.System.Threading.Tasks.ValueTask_1<Swift.Int32> {
        var __thrown : NullableHandle = nil;
        let __return = System_Net_Security_NegotiateStream_System_Threading_Tasks_ValueTask_i32___ReadAsync_0__2__System_Memory_u8__CancellationToken(&__thrown, self.get_handle(), buffer.get_handle(), cancellationToken.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return dotnet.System.Threading.Tasks.ValueTask_1(hndl : __return);
        }
    }
    // System.Int64 Seek(System.Int64, System.IO.SeekOrigin)
// docid: M:System.Net.Security.NegotiateStream.Seek(System.Int64,System.IO.SeekOrigin)
    /**
    Throws .

    - Parameter offset: This value is ignored.
    - Parameter origin: This value is ignored.
    - Returns: Always throws a .

    */
    open override func Seek(offset : Swift.Int64, origin : dotnet.System.IO.SeekOrigin) throws -> Swift.Int64 {
        var __thrown : NullableHandle = nil;
        let __return = System_Net_Security_NegotiateStream_i64__Seek_0__2__i64_SeekOrigin(&__thrown, self.get_handle(), offset, origin.get_value());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return __return;
        }
    }
    // void SetLength(System.Int64)
// docid: M:System.Net.Security.NegotiateStream.SetLength(System.Int64)
    /**
    Sets the length of the underlying stream.

    - Parameter value: An  value that specifies the length of the stream.
    */
    open override func SetLength(value : Swift.Int64) throws {
        var __thrown : NullableHandle = nil;
        System_Net_Security_NegotiateStream_void__SetLength_0__1__i64(&__thrown, self.get_handle(), value);
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
            return;
        }
    }
    // void Write(System.Byte[], System.Int32, System.Int32)
// docid: M:System.Net.Security.NegotiateStream.Write(System.Byte[],System.Int32,System.Int32)
    /**
    Write the specified number of s to the underlying stream using the specified buffer and offset.

    - Parameter buffer: A  array that supplies the bytes written to the stream.
    - Parameter offset: An  containing the zero-based location in  at which to begin reading bytes to be written to the stream.
    - Parameter count: A  containing the number of bytes to read from .
    */
    open override func Write(buffer : dotnet.System_Arr<Swift.UInt8>, offset : Swift.Int32, count : Swift.Int32) throws {
        var __thrown : NullableHandle = nil;
        System_Net_Security_NegotiateStream_void__Write_0__3__u8Array_i32_i32(&__thrown, self.get_handle(), buffer.get_handle(), offset, count);
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
            return;
        }
    }
    // System.Threading.Tasks.Task WriteAsync(System.Byte[], System.Int32, System.Int32, System.Threading.CancellationToken)
// docid: M:System.Net.Security.NegotiateStream.WriteAsync(System.Byte[],System.Int32,System.Int32,System.Threading.CancellationToken)
    /**
    Write asynchronously the specified number of s to the underlying stream.

    - Parameter buffer: A  array that supplies the bytes written to the stream.
    - Parameter offset: An  containing the zero-based location in  at which to begin reading bytes to be written to the stream.
    - Parameter count: A  containing the number of bytes to read from .
    - Parameter cancellationToken: 
    */
    open override func WriteAsync(buffer : dotnet.System_Arr<Swift.UInt8>, offset : Swift.Int32, count : Swift.Int32, cancellationToken : dotnet.System.Threading.CancellationToken) throws -> dotnet.System.Threading.Tasks.Task {
        var __thrown : NullableHandle = nil;
        let __return = System_Net_Security_NegotiateStream_Task__WriteAsync_0__4__u8Array_i32_i32_CancellationToken(&__thrown, self.get_handle(), buffer.get_handle(), offset, count, cancellationToken.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return dotnet.System.Threading.Tasks.Task(hndl : __return);
        }
    }
    // System.Threading.Tasks.ValueTask WriteAsync(System.ReadOnlyMemory<System.Byte>, System.Threading.CancellationToken)
// docid: M:System.Net.Security.NegotiateStream.WriteAsync(System.ReadOnlyMemory{System.Byte},System.Threading.CancellationToken)
    /**
    Write asynchronously the specified number of s to the underlying stream.

    - Parameter buffer: A region of memory that contains the data to write to the .
    - Parameter cancellationToken: The token to monitor for cancellation requests.
    */
    open override func WriteAsync(buffer : dotnet.System.ReadOnlyMemory_1<Swift.UInt8>, cancellationToken : dotnet.System.Threading.CancellationToken = System.Threading.CancellationToken.None) throws -> dotnet.System.Threading.Tasks.ValueTask {
        var __thrown : NullableHandle = nil;
        let __return = System_Net_Security_NegotiateStream_ValueTask__WriteAsync_0__2__System_ReadOnlyMemory_u8__CancellationToken(&__thrown, self.get_handle(), buffer.get_handle(), cancellationToken.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return dotnet.System.Threading.Tasks.ValueTask(hndl : __return);
        }
    }
    // [IsSpecialName] bool get_CanRead()
// docid: M:System.Net.Security.NegotiateStream.get_CanRead
    open override func get_CanRead() throws -> Bool {
        var __thrown : NullableHandle = nil;
        let __return = System_Net_Security_NegotiateStream_bool__get_CanRead_0__0(&__thrown, self.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return (__return) != 0;
        }
    }
    // [IsSpecialName] bool get_CanSeek()
// docid: M:System.Net.Security.NegotiateStream.get_CanSeek
    open override func get_CanSeek() throws -> Bool {
        var __thrown : NullableHandle = nil;
        let __return = System_Net_Security_NegotiateStream_bool__get_CanSeek_0__0(&__thrown, self.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return (__return) != 0;
        }
    }
    // [IsSpecialName] bool get_CanTimeout()
// docid: M:System.Net.Security.NegotiateStream.get_CanTimeout
    open override func get_CanTimeout() throws -> Bool {
        var __thrown : NullableHandle = nil;
        let __return = System_Net_Security_NegotiateStream_bool__get_CanTimeout_0__0(&__thrown, self.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return (__return) != 0;
        }
    }
    // [IsSpecialName] bool get_CanWrite()
// docid: M:System.Net.Security.NegotiateStream.get_CanWrite
    open override func get_CanWrite() throws -> Bool {
        var __thrown : NullableHandle = nil;
        let __return = System_Net_Security_NegotiateStream_bool__get_CanWrite_0__0(&__thrown, self.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return (__return) != 0;
        }
    }
    // [IsSpecialName] System.Security.Principal.TokenImpersonationLevel get_ImpersonationLevel()
// docid: M:System.Net.Security.NegotiateStream.get_ImpersonationLevel
    open func get_ImpersonationLevel() throws -> dotnet.System.Security.Principal.TokenImpersonationLevel {
        var __thrown : NullableHandle = nil;
        let __return = System_Net_Security_NegotiateStream_TokenImpersonationLevel__get_ImpersonationLevel_0__0(&__thrown, self.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return dotnet.System.Security.Principal.TokenImpersonationLevel(val: __return);
        }
    }
    // [IsSpecialName] bool get_IsAuthenticated()
// docid: M:System.Net.Security.NegotiateStream.get_IsAuthenticated
    open override func get_IsAuthenticated() throws -> Bool {
        var __thrown : NullableHandle = nil;
        let __return = System_Net_Security_NegotiateStream_bool__get_IsAuthenticated_0__0(&__thrown, self.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return (__return) != 0;
        }
    }
    // [IsSpecialName] bool get_IsEncrypted()
// docid: M:System.Net.Security.NegotiateStream.get_IsEncrypted
    open override func get_IsEncrypted() throws -> Bool {
        var __thrown : NullableHandle = nil;
        let __return = System_Net_Security_NegotiateStream_bool__get_IsEncrypted_0__0(&__thrown, self.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return (__return) != 0;
        }
    }
    // [IsSpecialName] bool get_IsMutuallyAuthenticated()
// docid: M:System.Net.Security.NegotiateStream.get_IsMutuallyAuthenticated
    open override func get_IsMutuallyAuthenticated() throws -> Bool {
        var __thrown : NullableHandle = nil;
        let __return = System_Net_Security_NegotiateStream_bool__get_IsMutuallyAuthenticated_0__0(&__thrown, self.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return (__return) != 0;
        }
    }
    // [IsSpecialName] bool get_IsServer()
// docid: M:System.Net.Security.NegotiateStream.get_IsServer
    open override func get_IsServer() throws -> Bool {
        var __thrown : NullableHandle = nil;
        let __return = System_Net_Security_NegotiateStream_bool__get_IsServer_0__0(&__thrown, self.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return (__return) != 0;
        }
    }
    // [IsSpecialName] bool get_IsSigned()
// docid: M:System.Net.Security.NegotiateStream.get_IsSigned
    open override func get_IsSigned() throws -> Bool {
        var __thrown : NullableHandle = nil;
        let __return = System_Net_Security_NegotiateStream_bool__get_IsSigned_0__0(&__thrown, self.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return (__return) != 0;
        }
    }
    // [IsSpecialName] System.Int64 get_Length()
// docid: M:System.Net.Security.NegotiateStream.get_Length
    open override func get_Length() throws -> Swift.Int64 {
        var __thrown : NullableHandle = nil;
        let __return = System_Net_Security_NegotiateStream_i64__get_Length_0__0(&__thrown, self.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return __return;
        }
    }
    // [IsSpecialName] System.Int64 get_Position()
// docid: M:System.Net.Security.NegotiateStream.get_Position
    open override func get_Position() throws -> Swift.Int64 {
        var __thrown : NullableHandle = nil;
        let __return = System_Net_Security_NegotiateStream_i64__get_Position_0__0(&__thrown, self.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return __return;
        }
    }
    // [IsSpecialName] void set_Position(System.Int64)
// docid: M:System.Net.Security.NegotiateStream.set_Position(System.Int64)
    open override func set_Position(value : Swift.Int64) throws {
        var __thrown : NullableHandle = nil;
        System_Net_Security_NegotiateStream_void__set_Position_0__1__i64(&__thrown, self.get_handle(), value);
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
            return;
        }
    }
    // [IsSpecialName] System.Int32 get_ReadTimeout()
// docid: M:System.Net.Security.NegotiateStream.get_ReadTimeout
    open override func get_ReadTimeout() throws -> Swift.Int32 {
        var __thrown : NullableHandle = nil;
        let __return = System_Net_Security_NegotiateStream_i32__get_ReadTimeout_0__0(&__thrown, self.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return __return;
        }
    }
    // [IsSpecialName] void set_ReadTimeout(System.Int32)
// docid: M:System.Net.Security.NegotiateStream.set_ReadTimeout(System.Int32)
    open override func set_ReadTimeout(value : Swift.Int32) throws {
        var __thrown : NullableHandle = nil;
        System_Net_Security_NegotiateStream_void__set_ReadTimeout_0__1__i32(&__thrown, self.get_handle(), value);
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
            return;
        }
    }
    // [IsSpecialName] System.Security.Principal.IIdentity get_RemoteIdentity()
// docid: M:System.Net.Security.NegotiateStream.get_RemoteIdentity
    open func get_RemoteIdentity() throws -> dotnet.System.Security.Principal.IIdentity {
        var __thrown : NullableHandle = nil;
        let __return = System_Net_Security_NegotiateStream_IIdentity__get_RemoteIdentity_0__0(&__thrown, self.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return dotnet.System.Security.Principal.IIdentity(hndl : __return);
        }
    }
    // [IsSpecialName] System.Int32 get_WriteTimeout()
// docid: M:System.Net.Security.NegotiateStream.get_WriteTimeout
    open override func get_WriteTimeout() throws -> Swift.Int32 {
        var __thrown : NullableHandle = nil;
        let __return = System_Net_Security_NegotiateStream_i32__get_WriteTimeout_0__0(&__thrown, self.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return __return;
        }
    }
    // [IsSpecialName] void set_WriteTimeout(System.Int32)
// docid: M:System.Net.Security.NegotiateStream.set_WriteTimeout(System.Int32)
    open override func set_WriteTimeout(value : Swift.Int32) throws {
        var __thrown : NullableHandle = nil;
        System_Net_Security_NegotiateStream_void__set_WriteTimeout_0__1__i32(&__thrown, self.get_handle(), value);
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
            return;
        }
    }
    /**
    Gets a  value that indicates whether the underlying stream is readable.

    */
    open override var CanRead : Bool {
        get {
            return try! get_CanRead();
        }
    }
    /**
    Gets a  value that indicates whether the underlying stream is seekable.

    */
    open override var CanSeek : Bool {
        get {
            return try! get_CanSeek();
        }
    }
    /**
    Gets a  value that indicates whether the underlying stream supports time-outs.

    */
    open override var CanTimeout : Bool {
        get {
            return try! get_CanTimeout();
        }
    }
    /**
    Gets a  value that indicates whether the underlying stream is writable.

    */
    open override var CanWrite : Bool {
        get {
            return try! get_CanWrite();
        }
    }
    /**
    Gets a value that indicates how the server can use the client's credentials.

    */
    open var ImpersonationLevel : dotnet.System.Security.Principal.TokenImpersonationLevel {
        get {
            return try! get_ImpersonationLevel();
        }
    }
    /**
    Gets a  value that indicates whether authentication was successful.

    */
    open override var IsAuthenticated : Bool {
        get {
            return try! get_IsAuthenticated();
        }
    }
    /**
    Gets a  value that indicates whether this  uses data encryption.

    */
    open override var IsEncrypted : Bool {
        get {
            return try! get_IsEncrypted();
        }
    }
    /**
    Gets a  value that indicates whether both the server and the client have been authenticated.

    */
    open override var IsMutuallyAuthenticated : Bool {
        get {
            return try! get_IsMutuallyAuthenticated();
        }
    }
    /**
    Gets a  value that indicates whether the local side of the connection used by this  was authenticated as the server.

    */
    open override var IsServer : Bool {
        get {
            return try! get_IsServer();
        }
    }
    /**
    Gets a  value that indicates whether the data sent using this stream is signed.

    */
    open override var IsSigned : Bool {
        get {
            return try! get_IsSigned();
        }
    }
    /**
    Gets the length of the underlying stream.

    */
    open override var Length : Swift.Int64 {
        get {
            return try! get_Length();
        }
    }
    /**
    Gets or sets the current position in the underlying stream.

    */
    open override var Position : Swift.Int64 {
        get {
            return try! get_Position();
        }
        set(v) {
            return try! set_Position(value: v);
        }
    }
    /**
    Gets or sets the amount of time a read operation blocks waiting for data.

    */
    open override var ReadTimeout : Swift.Int32 {
        get {
            return try! get_ReadTimeout();
        }
        set(v) {
            return try! set_ReadTimeout(value: v);
        }
    }
    /**
    Gets information about the identity of the remote party sharing this authenticated stream.

    */
    open var RemoteIdentity : dotnet.System.Security.Principal.IIdentity {
        get {
            return try! get_RemoteIdentity();
        }
    }
    /**
    Gets or sets the amount of time a write operation blocks waiting for data.

    */
    open override var WriteTimeout : Swift.Int32 {
        get {
            return try! get_WriteTimeout();
        }
        set(v) {
            return try! set_WriteTimeout(value: v);
        }
    }
} // NegotiateStream


// type: System.Net.Security.ProtectionLevel
    /**
    Indicates the security services requested for an authenticated stream.

    */
public struct ProtectionLevel : SGBridgeGenericValue {
    let v : Swift.Int32;
    public init(val: Swift.Int32) { self.v = val; }
    public func get_value() -> Swift.Int32 { return self.v; }
    public static func get_type_handle() -> TypeHandle {
        return System_Net_Security_ProtectionLevel_get_type_handle();
    }
    public func to_gval() -> GVal { return GVal(self.v); }
    public func dup_gval() -> GVal { return to_gval(); }
    public init(gval: GVal) { self.v = Swift.Int32(gval); }
    // static field: System.Net.Security.ProtectionLevel None
    /**
    Authentication only.

    */
    public static var None : dotnet.System.Net.Security.ProtectionLevel {
        get {
        let __return = dotnet.System.Net.Security.ProtectionLevel(val: System_Net_Security_ProtectionLevel_get_None());
            return __return;
        }
    }
    // static field: System.Net.Security.ProtectionLevel Sign
    /**
    Sign data to help ensure the integrity of transmitted data.

    */
    public static var Sign : dotnet.System.Net.Security.ProtectionLevel {
        get {
        let __return = dotnet.System.Net.Security.ProtectionLevel(val: System_Net_Security_ProtectionLevel_get_Sign());
            return __return;
        }
    }
    // static field: System.Net.Security.ProtectionLevel EncryptAndSign
    /**
    Encrypt and sign data to help ensure the confidentiality and integrity of transmitted data.

    */
    public static var EncryptAndSign : dotnet.System.Net.Security.ProtectionLevel {
        get {
        let __return = dotnet.System.Net.Security.ProtectionLevel(val: System_Net_Security_ProtectionLevel_get_EncryptAndSign());
            return __return;
        }
    }
} // ProtectionLevel


// type: System.Net.Security.RemoteCertificateValidationCallback
    /**
    Verifies the remote Secure Sockets Layer (SSL) certificate used for authentication.

    */
public final class RemoteCertificateValidationCallback
    :
    dotnet.System.Delegate
{
    public class override func get_type_handle() -> TypeHandle {
        return System_Net_Security_RemoteCertificateValidationCallback_get_type_handle();
    }
    public required init(hndl: NonnullHandle) { super.init(hndl: hndl); }
    public required init(gval: GVal) { super.init(gval: gval); }
    // bool Invoke(System.Object, System.Security.Cryptography.X509Certificates.X509Certificate, System.Security.Cryptography.X509Certificates.X509Chain, System.Net.Security.SslPolicyErrors)
// docid: M:System.Net.Security.RemoteCertificateValidationCallback.Invoke(System.Object,System.Security.Cryptography.X509Certificates.X509Certificate,System.Security.Cryptography.X509Certificates.X509Chain,System.Net.Security.SslPolicyErrors)
    public func Invoke(sender : dotnet.System.Object, certificate : Optional<dotnet.System.Security.Cryptography.X509Certificates.X509Certificate>, chain : Optional<dotnet.System.Security.Cryptography.X509Certificates.X509Chain>, sslPolicyErrors : dotnet.System.Net.Security.SslPolicyErrors) throws -> Bool {
        var __thrown : NullableHandle = nil;
        let __return = System_Net_Security_RemoteCertificateValidationCallback_bool__Invoke_0__4__Object_X509Certificate_X509Chain_SslPolicyErrors(&__thrown, self.get_handle(), sender.get_handle(), certificate?.get_handle() ?? nil, chain?.get_handle() ?? nil, sslPolicyErrors.get_value());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return (__return) != 0;
        }
    }
    // System.IAsyncResult BeginInvoke(System.Object, System.Security.Cryptography.X509Certificates.X509Certificate, System.Security.Cryptography.X509Certificates.X509Chain, System.Net.Security.SslPolicyErrors, System.AsyncCallback, System.Object)
// docid: M:System.Net.Security.RemoteCertificateValidationCallback.BeginInvoke(System.Object,System.Security.Cryptography.X509Certificates.X509Certificate,System.Security.Cryptography.X509Certificates.X509Chain,System.Net.Security.SslPolicyErrors,System.AsyncCallback,System.Object)
    public func BeginInvoke(sender : dotnet.System.Object, certificate : Optional<dotnet.System.Security.Cryptography.X509Certificates.X509Certificate>, chain : Optional<dotnet.System.Security.Cryptography.X509Certificates.X509Chain>, sslPolicyErrors : dotnet.System.Net.Security.SslPolicyErrors, callback : Optional<dotnet.System.AsyncCallback>, object : Optional<dotnet.System.Object>) throws -> Optional<dotnet.System.IAsyncResult> {
        var __thrown : NullableHandle = nil;
        let __return = System_Net_Security_RemoteCertificateValidationCallback_IAsyncResult__BeginInvoke_0__6__Object_X509Certificate_X509Chain_SslPolicyErrors_AsyncCallback_Object(&__thrown, self.get_handle(), sender.get_handle(), certificate?.get_handle() ?? nil, chain?.get_handle() ?? nil, sslPolicyErrors.get_value(), callback?.get_handle() ?? nil, object?.get_handle() ?? nil);
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        if let __ret_unwrapped = __return {
            return dotnet.System.IAsyncResult(hndl : __ret_unwrapped);
        } else {
            return nil;
        }
        }
    }
    // bool EndInvoke(System.IAsyncResult)
// docid: M:System.Net.Security.RemoteCertificateValidationCallback.EndInvoke(System.IAsyncResult)
    public func EndInvoke(result : Optional<dotnet.System.IAsyncResult>) throws -> Bool {
        var __thrown : NullableHandle = nil;
        let __return = System_Net_Security_RemoteCertificateValidationCallback_bool__EndInvoke_0__1__IAsyncResult(&__thrown, self.get_handle(), result?.get_handle() ?? nil);
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return (__return) != 0;
        }
    }
    public init(_ callback : @escaping (dotnet.System.Object, Optional<dotnet.System.Security.Cryptography.X509Certificates.X509Certificate>, Optional<dotnet.System.Security.Cryptography.X509Certificates.X509Chain>, dotnet.System.Net.Security.SslPolicyErrors) throws -> Bool) throws
    {
        let __bridge : (UnsafeMutablePointer<NullableHandle>, NonnullHandle, NullableHandle, NullableHandle, Swift.Int32) -> Swift.Int32 =
        {
            (thrown : UnsafeMutablePointer<NullableHandle>, sender : NonnullHandle, certificate : NullableHandle, chain : NullableHandle, sslPolicyErrors : Swift.Int32) -> Swift.Int32 in
            do
            {
                thrown.pointee = nil;
                let ret = try callback(dotnet.System.Object(hndl: sender), (certificate != nil) ? (dotnet.System.Security.Cryptography.X509Certificates.X509Certificate(hndl: certificate!)) : nil, (chain != nil) ? (dotnet.System.Security.Cryptography.X509Certificates.X509Chain(hndl: chain!)) : nil, dotnet.System.Net.Security.SslPolicyErrors(val: sslPolicyErrors));
                return ret ? 1 : 0;
            }
            catch let e as dotnet.System.Exception
            {
                thrown.pointee = __copy_handle(e.get_handle());
                return 0;
            }
            catch
            {
                let e = try! dotnet.System.Exception(message: "TODO fail inside closure");
                thrown.pointee = __copy_handle(e.get_handle());
                return 0;
            }
        };
        let cbarg = UnsafeRawPointer(Unmanaged.passRetained(__bridge as AnyObject).toOpaque());
        func __cb(cb : UnsafeRawPointer?, thrown : UnsafeMutablePointer<NullableHandle>, sender : NonnullHandle, certificate : NullableHandle, chain : NullableHandle, sslPolicyErrors : Swift.Int32) -> Swift.Int32
        {
            let f = Unmanaged<AnyObject>.fromOpaque(cb!).takeUnretainedValue() as! (UnsafeMutablePointer<NullableHandle>, NonnullHandle, NullableHandle, NullableHandle, Swift.Int32) -> Swift.Int32;
            return f(thrown, sender, certificate, chain, sslPolicyErrors);
        }
        var __thrown : NullableHandle = nil;
        let h = System_Net_Security_RemoteCertificateValidationCallback_create(
            &__thrown,
            cbarg,
            nil, // TODO deinit
            __cb
            );
            // TODO check thrown
        if let __ex = __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
            super.init(hndl: h);
        }
    }
    // bool Invoke(System.Object, System.Security.Cryptography.X509Certificates.X509Certificate, System.Security.Cryptography.X509Certificates.X509Chain, System.Net.Security.SslPolicyErrors)
// docid: M:System.Net.Security.RemoteCertificateValidationCallback.Invoke(System.Object,System.Security.Cryptography.X509Certificates.X509Certificate,System.Security.Cryptography.X509Certificates.X509Chain,System.Net.Security.SslPolicyErrors)
    public func callAsFunction(sender : dotnet.System.Object, certificate : Optional<dotnet.System.Security.Cryptography.X509Certificates.X509Certificate>, chain : Optional<dotnet.System.Security.Cryptography.X509Certificates.X509Chain>, sslPolicyErrors : dotnet.System.Net.Security.SslPolicyErrors) throws -> Bool {
        var __thrown : NullableHandle = nil;
        let __return = System_Net_Security_RemoteCertificateValidationCallback_bool__Invoke_0__4__Object_X509Certificate_X509Chain_SslPolicyErrors(&__thrown, self.get_handle(), sender.get_handle(), certificate?.get_handle() ?? nil, chain?.get_handle() ?? nil, sslPolicyErrors.get_value());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return (__return) != 0;
        }
    }
} // RemoteCertificateValidationCallback


// type: System.Net.Security.ServerCertificateSelectionCallback
    /**
    Selects the server Secure Sockets Layer (SSL) certificate.

    */
public final class ServerCertificateSelectionCallback
    :
    dotnet.System.Delegate
{
    public class override func get_type_handle() -> TypeHandle {
        return System_Net_Security_ServerCertificateSelectionCallback_get_type_handle();
    }
    public required init(hndl: NonnullHandle) { super.init(hndl: hndl); }
    public required init(gval: GVal) { super.init(gval: gval); }
    // System.Security.Cryptography.X509Certificates.X509Certificate Invoke(System.Object, System.String)
// docid: M:System.Net.Security.ServerCertificateSelectionCallback.Invoke(System.Object,System.String)
    public func Invoke(sender : dotnet.System.Object, hostName : Optional<dotnet.System.String>) throws -> dotnet.System.Security.Cryptography.X509Certificates.X509Certificate {
        var __thrown : NullableHandle = nil;
        let __return = System_Net_Security_ServerCertificateSelectionCallback_X509Certificate__Invoke_0__2__Object_String(&__thrown, self.get_handle(), sender.get_handle(), hostName?.get_handle() ?? nil);
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return dotnet.System.Security.Cryptography.X509Certificates.X509Certificate(hndl : __return);
        }
    }
    // System.IAsyncResult BeginInvoke(System.Object, System.String, System.AsyncCallback, System.Object)
// docid: M:System.Net.Security.ServerCertificateSelectionCallback.BeginInvoke(System.Object,System.String,System.AsyncCallback,System.Object)
    public func BeginInvoke(sender : dotnet.System.Object, hostName : Optional<dotnet.System.String>, callback : Optional<dotnet.System.AsyncCallback>, object : Optional<dotnet.System.Object>) throws -> Optional<dotnet.System.IAsyncResult> {
        var __thrown : NullableHandle = nil;
        let __return = System_Net_Security_ServerCertificateSelectionCallback_IAsyncResult__BeginInvoke_0__4__Object_String_AsyncCallback_Object(&__thrown, self.get_handle(), sender.get_handle(), hostName?.get_handle() ?? nil, callback?.get_handle() ?? nil, object?.get_handle() ?? nil);
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        if let __ret_unwrapped = __return {
            return dotnet.System.IAsyncResult(hndl : __ret_unwrapped);
        } else {
            return nil;
        }
        }
    }
    // System.Security.Cryptography.X509Certificates.X509Certificate EndInvoke(System.IAsyncResult)
// docid: M:System.Net.Security.ServerCertificateSelectionCallback.EndInvoke(System.IAsyncResult)
    public func EndInvoke(result : Optional<dotnet.System.IAsyncResult>) throws -> dotnet.System.Security.Cryptography.X509Certificates.X509Certificate {
        var __thrown : NullableHandle = nil;
        let __return = System_Net_Security_ServerCertificateSelectionCallback_X509Certificate__EndInvoke_0__1__IAsyncResult(&__thrown, self.get_handle(), result?.get_handle() ?? nil);
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return dotnet.System.Security.Cryptography.X509Certificates.X509Certificate(hndl : __return);
        }
    }
    public init(_ callback : @escaping (dotnet.System.Object, Optional<dotnet.System.String>) throws -> dotnet.System.Security.Cryptography.X509Certificates.X509Certificate) throws
    {
        let __bridge : (UnsafeMutablePointer<NullableHandle>, NonnullHandle, NullableHandle) -> NonnullHandle =
        {
            (thrown : UnsafeMutablePointer<NullableHandle>, sender : NonnullHandle, hostName : NullableHandle) -> NonnullHandle in
            do
            {
                thrown.pointee = nil;
                let ret = try callback(dotnet.System.Object(hndl: sender), (hostName != nil) ? (dotnet.System.String(hndl: hostName!)) : nil);
                return __copy_handle(ret.get_handle());
            }
            catch let e as dotnet.System.Exception
            {
                thrown.pointee = __copy_handle(e.get_handle());
                return NonnullHandle(bitPattern: 8675309)!;
            }
            catch
            {
                let e = try! dotnet.System.Exception(message: "TODO fail inside closure");
                thrown.pointee = __copy_handle(e.get_handle());
                return NonnullHandle(bitPattern: 8675309)!;
            }
        };
        let cbarg = UnsafeRawPointer(Unmanaged.passRetained(__bridge as AnyObject).toOpaque());
        func __cb(cb : UnsafeRawPointer?, thrown : UnsafeMutablePointer<NullableHandle>, sender : NonnullHandle, hostName : NullableHandle) -> NonnullHandle
        {
            let f = Unmanaged<AnyObject>.fromOpaque(cb!).takeUnretainedValue() as! (UnsafeMutablePointer<NullableHandle>, NonnullHandle, NullableHandle) -> NonnullHandle;
            return f(thrown, sender, hostName);
        }
        var __thrown : NullableHandle = nil;
        let h = System_Net_Security_ServerCertificateSelectionCallback_create(
            &__thrown,
            cbarg,
            nil, // TODO deinit
            __cb
            );
            // TODO check thrown
        if let __ex = __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
            super.init(hndl: h);
        }
    }
    // System.Security.Cryptography.X509Certificates.X509Certificate Invoke(System.Object, System.String)
// docid: M:System.Net.Security.ServerCertificateSelectionCallback.Invoke(System.Object,System.String)
    public func callAsFunction(sender : dotnet.System.Object, hostName : Optional<dotnet.System.String>) throws -> dotnet.System.Security.Cryptography.X509Certificates.X509Certificate {
        var __thrown : NullableHandle = nil;
        let __return = System_Net_Security_ServerCertificateSelectionCallback_X509Certificate__Invoke_0__2__Object_String(&__thrown, self.get_handle(), sender.get_handle(), hostName?.get_handle() ?? nil);
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return dotnet.System.Security.Cryptography.X509Certificates.X509Certificate(hndl : __return);
        }
    }
} // ServerCertificateSelectionCallback


// type: System.Net.Security.ServerOptionsSelectionCallback
    /**
    Represents the asynchronous callback method that will select session properties based on the name requested by the client.

    */
public final class ServerOptionsSelectionCallback
    :
    dotnet.System.Delegate
{
    public class override func get_type_handle() -> TypeHandle {
        return System_Net_Security_ServerOptionsSelectionCallback_get_type_handle();
    }
    public required init(hndl: NonnullHandle) { super.init(hndl: hndl); }
    public required init(gval: GVal) { super.init(gval: gval); }
    // System.Threading.Tasks.ValueTask<System.Net.Security.SslServerAuthenticationOptions> Invoke(System.Net.Security.SslStream, System.Net.Security.SslClientHelloInfo, System.Object, System.Threading.CancellationToken)
// docid: M:System.Net.Security.ServerOptionsSelectionCallback.Invoke(System.Net.Security.SslStream,System.Net.Security.SslClientHelloInfo,System.Object,System.Threading.CancellationToken)
    public func Invoke(stream : dotnet.System.Net.Security.SslStream, clientHelloInfo : dotnet.System.Net.Security.SslClientHelloInfo, state : Optional<dotnet.System.Object>, cancellationToken : dotnet.System.Threading.CancellationToken) throws -> dotnet.System.Threading.Tasks.ValueTask_1<dotnet.System.Net.Security.SslServerAuthenticationOptions> {
        var __thrown : NullableHandle = nil;
        let __return = System_Net_Security_ServerOptionsSelectionCallback_System_Threading_Tasks_ValueTask_System_Net_Security_SslServerAuthenticationOptions___Invoke_0__4__SslStream_SslClientHelloInfo_Object_CancellationToken(&__thrown, self.get_handle(), stream.get_handle(), clientHelloInfo.get_handle(), state?.get_handle() ?? nil, cancellationToken.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return dotnet.System.Threading.Tasks.ValueTask_1(hndl : __return);
        }
    }
    // System.IAsyncResult BeginInvoke(System.Net.Security.SslStream, System.Net.Security.SslClientHelloInfo, System.Object, System.Threading.CancellationToken, System.AsyncCallback, System.Object)
// docid: M:System.Net.Security.ServerOptionsSelectionCallback.BeginInvoke(System.Net.Security.SslStream,System.Net.Security.SslClientHelloInfo,System.Object,System.Threading.CancellationToken,System.AsyncCallback,System.Object)
    public func BeginInvoke(stream : dotnet.System.Net.Security.SslStream, clientHelloInfo : dotnet.System.Net.Security.SslClientHelloInfo, state : Optional<dotnet.System.Object>, cancellationToken : dotnet.System.Threading.CancellationToken, callback : Optional<dotnet.System.AsyncCallback>, object : Optional<dotnet.System.Object>) throws -> Optional<dotnet.System.IAsyncResult> {
        var __thrown : NullableHandle = nil;
        let __return = System_Net_Security_ServerOptionsSelectionCallback_IAsyncResult__BeginInvoke_0__6__SslStream_SslClientHelloInfo_Object_CancellationToken_AsyncCallback_Object(&__thrown, self.get_handle(), stream.get_handle(), clientHelloInfo.get_handle(), state?.get_handle() ?? nil, cancellationToken.get_handle(), callback?.get_handle() ?? nil, object?.get_handle() ?? nil);
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        if let __ret_unwrapped = __return {
            return dotnet.System.IAsyncResult(hndl : __ret_unwrapped);
        } else {
            return nil;
        }
        }
    }
    // System.Threading.Tasks.ValueTask<System.Net.Security.SslServerAuthenticationOptions> EndInvoke(System.IAsyncResult)
// docid: M:System.Net.Security.ServerOptionsSelectionCallback.EndInvoke(System.IAsyncResult)
    public func EndInvoke(result : Optional<dotnet.System.IAsyncResult>) throws -> dotnet.System.Threading.Tasks.ValueTask_1<dotnet.System.Net.Security.SslServerAuthenticationOptions> {
        var __thrown : NullableHandle = nil;
        let __return = System_Net_Security_ServerOptionsSelectionCallback_System_Threading_Tasks_ValueTask_System_Net_Security_SslServerAuthenticationOptions___EndInvoke_0__1__IAsyncResult(&__thrown, self.get_handle(), result?.get_handle() ?? nil);
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return dotnet.System.Threading.Tasks.ValueTask_1(hndl : __return);
        }
    }
    public init(_ callback : @escaping (dotnet.System.Net.Security.SslStream, dotnet.System.Net.Security.SslClientHelloInfo, Optional<dotnet.System.Object>, dotnet.System.Threading.CancellationToken) throws -> dotnet.System.Threading.Tasks.ValueTask_1<dotnet.System.Net.Security.SslServerAuthenticationOptions>) throws
    {
        let __bridge : (UnsafeMutablePointer<NullableHandle>, NonnullHandle, NonnullHandle, NullableHandle, NonnullHandle) -> NonnullHandle =
        {
            (thrown : UnsafeMutablePointer<NullableHandle>, stream : NonnullHandle, clientHelloInfo : NonnullHandle, state : NullableHandle, cancellationToken : NonnullHandle) -> NonnullHandle in
            do
            {
                thrown.pointee = nil;
                let ret = try callback(dotnet.System.Net.Security.SslStream(hndl: stream), dotnet.System.Net.Security.SslClientHelloInfo(hndl: clientHelloInfo), (state != nil) ? (dotnet.System.Object(hndl: state!)) : nil, dotnet.System.Threading.CancellationToken(hndl: cancellationToken));
                return __copy_handle(ret.get_handle());
            }
            catch let e as dotnet.System.Exception
            {
                thrown.pointee = __copy_handle(e.get_handle());
                return NonnullHandle(bitPattern: 8675309)!;
            }
            catch
            {
                let e = try! dotnet.System.Exception(message: "TODO fail inside closure");
                thrown.pointee = __copy_handle(e.get_handle());
                return NonnullHandle(bitPattern: 8675309)!;
            }
        };
        let cbarg = UnsafeRawPointer(Unmanaged.passRetained(__bridge as AnyObject).toOpaque());
        func __cb(cb : UnsafeRawPointer?, thrown : UnsafeMutablePointer<NullableHandle>, stream : NonnullHandle, clientHelloInfo : NonnullHandle, state : NullableHandle, cancellationToken : NonnullHandle) -> NonnullHandle
        {
            let f = Unmanaged<AnyObject>.fromOpaque(cb!).takeUnretainedValue() as! (UnsafeMutablePointer<NullableHandle>, NonnullHandle, NonnullHandle, NullableHandle, NonnullHandle) -> NonnullHandle;
            return f(thrown, stream, clientHelloInfo, state, cancellationToken);
        }
        var __thrown : NullableHandle = nil;
        let h = System_Net_Security_ServerOptionsSelectionCallback_create(
            &__thrown,
            cbarg,
            nil, // TODO deinit
            __cb
            );
            // TODO check thrown
        if let __ex = __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
            super.init(hndl: h);
        }
    }
    // System.Threading.Tasks.ValueTask<System.Net.Security.SslServerAuthenticationOptions> Invoke(System.Net.Security.SslStream, System.Net.Security.SslClientHelloInfo, System.Object, System.Threading.CancellationToken)
// docid: M:System.Net.Security.ServerOptionsSelectionCallback.Invoke(System.Net.Security.SslStream,System.Net.Security.SslClientHelloInfo,System.Object,System.Threading.CancellationToken)
    public func callAsFunction(stream : dotnet.System.Net.Security.SslStream, clientHelloInfo : dotnet.System.Net.Security.SslClientHelloInfo, state : Optional<dotnet.System.Object>, cancellationToken : dotnet.System.Threading.CancellationToken) throws -> dotnet.System.Threading.Tasks.ValueTask_1<dotnet.System.Net.Security.SslServerAuthenticationOptions> {
        var __thrown : NullableHandle = nil;
        let __return = System_Net_Security_ServerOptionsSelectionCallback_System_Threading_Tasks_ValueTask_System_Net_Security_SslServerAuthenticationOptions___Invoke_0__4__SslStream_SslClientHelloInfo_Object_CancellationToken(&__thrown, self.get_handle(), stream.get_handle(), clientHelloInfo.get_handle(), state?.get_handle() ?? nil, cancellationToken.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return dotnet.System.Threading.Tasks.ValueTask_1(hndl : __return);
        }
    }
} // ServerOptionsSelectionCallback


// type: System.Net.Security.SslApplicationProtocol
// boxed value type
    /**
    Represents a value of TLS Application protocol.

    */
public final class SslApplicationProtocol
    :
    dotnet.System.Object
{
    public class override func get_type_handle() -> TypeHandle {
        return System_Net_Security_SslApplicationProtocol_get_type_handle();
    }
    public required init(hndl: NonnullHandle) { super.init(hndl: hndl); }
    public required init(gval: GVal) { super.init(gval: gval); }
    // static field: System.Net.Security.SslApplicationProtocol Http11
    /**
    Gets a  representing HTTP/1.1 TLS application protocol.

    */
    public class var Http11 : dotnet.System.Net.Security.SslApplicationProtocol {
        get {
        let __return = dotnet.System.Net.Security.SslApplicationProtocol(hndl: System_Net_Security_SslApplicationProtocol_get_Http11());
            return __return;
        }
    }
    // static field: System.Net.Security.SslApplicationProtocol Http2
    /**
    Gets a  representing HTTP/2 TLS application protocol.

    */
    public class var Http2 : dotnet.System.Net.Security.SslApplicationProtocol {
        get {
        let __return = dotnet.System.Net.Security.SslApplicationProtocol(hndl: System_Net_Security_SslApplicationProtocol_get_Http2());
            return __return;
        }
    }
    // static field: System.Net.Security.SslApplicationProtocol Http3
    public class var Http3 : dotnet.System.Net.Security.SslApplicationProtocol {
        get {
        let __return = dotnet.System.Net.Security.SslApplicationProtocol(hndl: System_Net_Security_SslApplicationProtocol_get_Http3());
            return __return;
        }
    }
    /**
    Gets a current TLS application protocol represented by this .

    */
    public var Protocol_ : dotnet.System.ReadOnlyMemory_1<Swift.UInt8> {
        get {
            return try! get_Protocol();
        }
    }
    // .ctor(System.Byte[])
// docid: M:System.Net.Security.SslApplicationProtocol.#ctor(System.Byte[])
    /**
    Initializes a new instance of the .

    - Parameter protocol: TLS Application protocol.
    */
    public init(protocol_ : dotnet.System_Arr<Swift.UInt8>) throws {
        var __thrown : NullableHandle = nil;
        let h = System_Net_Security_SslApplicationProtocol_ctor_0__1__u8Array(&__thrown, protocol_.get_handle());
        if let __ex = __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
            super.init(hndl: h);
        }
    }
    // .ctor(System.String)
// docid: M:System.Net.Security.SslApplicationProtocol.#ctor(System.String)
    /**
    Initializes a new instance of the .

    - Parameter protocol: TLS Application protocol.
    */
    public init(protocol_ : dotnet.System.String) throws {
        var __thrown : NullableHandle = nil;
        let h = System_Net_Security_SslApplicationProtocol_ctor_0__1__String(&__thrown, protocol_.get_handle());
        if let __ex = __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
            super.init(hndl: h);
        }
    }
    public override init() {
        let h = System_Net_Security_SslApplicationProtocol_implicit_ctor();
            super.init(hndl: h);
    }
    // bool Equals(System.Net.Security.SslApplicationProtocol)
// docid: M:System.Net.Security.SslApplicationProtocol.Equals(System.Net.Security.SslApplicationProtocol)
    /**
    Compares a  to the specified  instance.

    - Parameter other: The  instance to test for equality.
    - Returns: 
         if the  instance provided has matching data; otherwise, .

    */
    public func Equals(other : dotnet.System.Net.Security.SslApplicationProtocol) throws -> Bool {
        var __thrown : NullableHandle = nil;
        let __return = System_Net_Security_SslApplicationProtocol_bool__Equals_0__1__SslApplicationProtocol(&__thrown, self.get_handle(), other.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return (__return) != 0;
        }
    }
    // bool Equals(System.Object)
// docid: M:System.Net.Security.SslApplicationProtocol.Equals(System.Object)
    /**
    Compares the  to the specified object.

    - Parameter obj: The object to test for equality.
    - Returns: 
         if  is a  instance, and the  instances have matching data; otherwise, .

    */
    public override func Equals(obj : Optional<dotnet.System.Object>) throws -> Bool {
        var __thrown : NullableHandle = nil;
        let __return = System_Net_Security_SslApplicationProtocol_bool__Equals_0__1__Object(&__thrown, self.get_handle(), obj?.get_handle() ?? nil);
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return (__return) != 0;
        }
    }
    // System.Int32 GetHashCode()
// docid: M:System.Net.Security.SslApplicationProtocol.GetHashCode
    /**
    Returns the hash code for the  instance.

    - Returns: A 32-bit signed integer hash code used to compare instances of this type.

    */
    public override func GetHashCode() throws -> Swift.Int32 {
        var __thrown : NullableHandle = nil;
        let __return = System_Net_Security_SslApplicationProtocol_i32__GetHashCode_0__0(&__thrown, self.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return __return;
        }
    }
    // [IsSpecialName] bool op_Equality(System.Net.Security.SslApplicationProtocol, System.Net.Security.SslApplicationProtocol)
// docid: M:System.Net.Security.SslApplicationProtocol.op_Equality(System.Net.Security.SslApplicationProtocol,System.Net.Security.SslApplicationProtocol)
    /**
    The equality operator for comparing two  objects.

    - Parameter left: The left  to an equality operator.
    - Parameter right: The right  to an equality operator.
    - Returns: 
         if the specified  and  parameters are equal; otherwise, .

    */
    public class func op_Equality(left : dotnet.System.Net.Security.SslApplicationProtocol, right : dotnet.System.Net.Security.SslApplicationProtocol) throws -> Bool {
        var __thrown : NullableHandle = nil;
        let __return = System_Net_Security_SslApplicationProtocol_bool__op_Equality_0__2__SslApplicationProtocol_SslApplicationProtocol(&__thrown, left.get_handle(), right.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return (__return) != 0;
        }
    }
    // [IsSpecialName] bool op_Inequality(System.Net.Security.SslApplicationProtocol, System.Net.Security.SslApplicationProtocol)
// docid: M:System.Net.Security.SslApplicationProtocol.op_Inequality(System.Net.Security.SslApplicationProtocol,System.Net.Security.SslApplicationProtocol)
    /**
    The inequality operator for comparing two  objects.

    - Parameter left: The left  to an inequality operator.
    - Parameter right: The right   to an inequality operator.
    - Returns: 
         if the specified  and  parameters are inequal; otherwise, .

    */
    public class func op_Inequality(left : dotnet.System.Net.Security.SslApplicationProtocol, right : dotnet.System.Net.Security.SslApplicationProtocol) throws -> Bool {
        var __thrown : NullableHandle = nil;
        let __return = System_Net_Security_SslApplicationProtocol_bool__op_Inequality_0__2__SslApplicationProtocol_SslApplicationProtocol(&__thrown, left.get_handle(), right.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return (__return) != 0;
        }
    }
    // System.String ToString()
// docid: M:System.Net.Security.SslApplicationProtocol.ToString
    /**
    Overrides the  method.

    - Returns: Returns a string representation of this  object.

    */
    public override func ToString() throws -> dotnet.System.String {
        var __thrown : NullableHandle = nil;
        let __return = System_Net_Security_SslApplicationProtocol_String__ToString_0__0(&__thrown, self.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return dotnet.System.String(hndl : __return);
        }
    }
    // [IsSpecialName] System.ReadOnlyMemory<System.Byte> get_Protocol()
// docid: M:System.Net.Security.SslApplicationProtocol.get_Protocol
    public func get_Protocol() throws -> dotnet.System.ReadOnlyMemory_1<Swift.UInt8> {
        var __thrown : NullableHandle = nil;
        let __return = System_Net_Security_SslApplicationProtocol_System_ReadOnlyMemory_u8___get_Protocol_0__0(&__thrown, self.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return dotnet.System.ReadOnlyMemory_1(hndl : __return);
        }
    }
} // SslApplicationProtocol


// type: System.Net.Security.SslCertificateTrust
public final class SslCertificateTrust
    :
    dotnet.System.Object
{
    public class override func get_type_handle() -> TypeHandle {
        return System_Net_Security_SslCertificateTrust_get_type_handle();
    }
    public required init(hndl: NonnullHandle) { super.init(hndl: hndl); }
    public required init(gval: GVal) { super.init(gval: gval); }
    // System.Net.Security.SslCertificateTrust CreateForX509Store(System.Security.Cryptography.X509Certificates.X509Store, bool)
// docid: M:System.Net.Security.SslCertificateTrust.CreateForX509Store(System.Security.Cryptography.X509Certificates.X509Store,System.Boolean)
    public class func CreateForX509Store(store : dotnet.System.Security.Cryptography.X509Certificates.X509Store, sendTrustInHandshake : Bool = false) throws -> dotnet.System.Net.Security.SslCertificateTrust {
        var __thrown : NullableHandle = nil;
        let __return = System_Net_Security_SslCertificateTrust_SslCertificateTrust__CreateForX509Store_0__2__X509Store_bool(&__thrown, store.get_handle(), Swift.Int32(sendTrustInHandshake ? 1 : 0));
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return dotnet.System.Net.Security.SslCertificateTrust(hndl : __return);
        }
    }
    // System.Net.Security.SslCertificateTrust CreateForX509Collection(System.Security.Cryptography.X509Certificates.X509Certificate2Collection, bool)
// docid: M:System.Net.Security.SslCertificateTrust.CreateForX509Collection(System.Security.Cryptography.X509Certificates.X509Certificate2Collection,System.Boolean)
    public class func CreateForX509Collection(trustList : dotnet.System.Security.Cryptography.X509Certificates.X509Certificate2Collection, sendTrustInHandshake : Bool = false) throws -> dotnet.System.Net.Security.SslCertificateTrust {
        var __thrown : NullableHandle = nil;
        let __return = System_Net_Security_SslCertificateTrust_SslCertificateTrust__CreateForX509Collection_0__2__X509Certificate2Collection_bool(&__thrown, trustList.get_handle(), Swift.Int32(sendTrustInHandshake ? 1 : 0));
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return dotnet.System.Net.Security.SslCertificateTrust(hndl : __return);
        }
    }
} // SslCertificateTrust


// type: System.Net.Security.SslClientAuthenticationOptions
    /**
    Represents a client authentication property bag for the .

    */
open class SslClientAuthenticationOptions
    :
    dotnet.System.Object
{
    open class override func get_type_handle() -> TypeHandle {
        return System_Net_Security_SslClientAuthenticationOptions_get_type_handle();
    }
    public required init(hndl: NonnullHandle) { super.init(hndl: hndl); }
    public required init(gval: GVal) { super.init(gval: gval); }
    // .ctor()
// docid: M:System.Net.Security.SslClientAuthenticationOptions.#ctor
    /**
    Initializes a new instance of the  class.

    */
    public override init() throws {
        var __thrown : NullableHandle = nil;
        let h = System_Net_Security_SslClientAuthenticationOptions_ctor_0__0(&__thrown);
        if let __ex = __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
            super.init(hndl: h);
        }
    }
    // [IsSpecialName] bool get_AllowRenegotiation()
// docid: M:System.Net.Security.SslClientAuthenticationOptions.get_AllowRenegotiation
    open func get_AllowRenegotiation() throws -> Bool {
        var __thrown : NullableHandle = nil;
        let __return = System_Net_Security_SslClientAuthenticationOptions_bool__get_AllowRenegotiation_0__0(&__thrown, self.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return (__return) != 0;
        }
    }
    // [IsSpecialName] void set_AllowRenegotiation(bool)
// docid: M:System.Net.Security.SslClientAuthenticationOptions.set_AllowRenegotiation(System.Boolean)
    open func set_AllowRenegotiation(value : Bool) throws {
        var __thrown : NullableHandle = nil;
        System_Net_Security_SslClientAuthenticationOptions_void__set_AllowRenegotiation_0__1__bool(&__thrown, self.get_handle(), Swift.Int32(value ? 1 : 0));
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
            return;
        }
    }
    // [IsSpecialName] System.Collections.Generic.List<System.Net.Security.SslApplicationProtocol> get_ApplicationProtocols()
// docid: M:System.Net.Security.SslClientAuthenticationOptions.get_ApplicationProtocols
    open func get_ApplicationProtocols() throws -> Optional<dotnet.System.Collections.Generic.List_1<dotnet.System.Net.Security.SslApplicationProtocol>> {
        var __thrown : NullableHandle = nil;
        let __return = System_Net_Security_SslClientAuthenticationOptions_System_Collections_Generic_List_System_Net_Security_SslApplicationProtocol___get_ApplicationProtocols_0__0(&__thrown, self.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        if let __ret_unwrapped = __return {
            return dotnet.System.Collections.Generic.List_1(hndl : __ret_unwrapped);
        } else {
            return nil;
        }
        }
    }
    // [IsSpecialName] void set_ApplicationProtocols(System.Collections.Generic.List<System.Net.Security.SslApplicationProtocol>)
// docid: M:System.Net.Security.SslClientAuthenticationOptions.set_ApplicationProtocols(System.Collections.Generic.List{System.Net.Security.SslApplicationProtocol})
    open func set_ApplicationProtocols(value : Optional<dotnet.System.Collections.Generic.List_1<dotnet.System.Net.Security.SslApplicationProtocol>>) throws {
        var __thrown : NullableHandle = nil;
        System_Net_Security_SslClientAuthenticationOptions_void__set_ApplicationProtocols_0__1__System_Collections_Generic_List_System_Net_Security_SslApplicationProtocol_(&__thrown, self.get_handle(), (value?.get_handle()));
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
            return;
        }
    }
    // [IsSpecialName] System.Security.Cryptography.X509Certificates.X509RevocationMode get_CertificateRevocationCheckMode()
// docid: M:System.Net.Security.SslClientAuthenticationOptions.get_CertificateRevocationCheckMode
    open func get_CertificateRevocationCheckMode() throws -> dotnet.System.Security.Cryptography.X509Certificates.X509RevocationMode {
        var __thrown : NullableHandle = nil;
        let __return = System_Net_Security_SslClientAuthenticationOptions_X509RevocationMode__get_CertificateRevocationCheckMode_0__0(&__thrown, self.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return dotnet.System.Security.Cryptography.X509Certificates.X509RevocationMode(val: __return);
        }
    }
    // [IsSpecialName] void set_CertificateRevocationCheckMode(System.Security.Cryptography.X509Certificates.X509RevocationMode)
// docid: M:System.Net.Security.SslClientAuthenticationOptions.set_CertificateRevocationCheckMode(System.Security.Cryptography.X509Certificates.X509RevocationMode)
    open func set_CertificateRevocationCheckMode(value : dotnet.System.Security.Cryptography.X509Certificates.X509RevocationMode) throws {
        var __thrown : NullableHandle = nil;
        System_Net_Security_SslClientAuthenticationOptions_void__set_CertificateRevocationCheckMode_0__1__X509RevocationMode(&__thrown, self.get_handle(), value.get_value());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
            return;
        }
    }
    // [IsSpecialName] System.Net.Security.CipherSuitesPolicy get_CipherSuitesPolicy()
// docid: M:System.Net.Security.SslClientAuthenticationOptions.get_CipherSuitesPolicy
    open func get_CipherSuitesPolicy() throws -> Optional<dotnet.System.Net.Security.CipherSuitesPolicy> {
        var __thrown : NullableHandle = nil;
        let __return = System_Net_Security_SslClientAuthenticationOptions_CipherSuitesPolicy__get_CipherSuitesPolicy_0__0(&__thrown, self.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        if let __ret_unwrapped = __return {
            return dotnet.System.Net.Security.CipherSuitesPolicy(hndl : __ret_unwrapped);
        } else {
            return nil;
        }
        }
    }
    // [IsSpecialName] void set_CipherSuitesPolicy(System.Net.Security.CipherSuitesPolicy)
// docid: M:System.Net.Security.SslClientAuthenticationOptions.set_CipherSuitesPolicy(System.Net.Security.CipherSuitesPolicy)
    open func set_CipherSuitesPolicy(value : Optional<dotnet.System.Net.Security.CipherSuitesPolicy>) throws {
        var __thrown : NullableHandle = nil;
        System_Net_Security_SslClientAuthenticationOptions_void__set_CipherSuitesPolicy_0__1__CipherSuitesPolicy(&__thrown, self.get_handle(), value?.get_handle() ?? nil);
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
            return;
        }
    }
    // [IsSpecialName] System.Security.Cryptography.X509Certificates.X509CertificateCollection get_ClientCertificates()
// docid: M:System.Net.Security.SslClientAuthenticationOptions.get_ClientCertificates
    open func get_ClientCertificates() throws -> Optional<dotnet.System.Security.Cryptography.X509Certificates.X509CertificateCollection> {
        var __thrown : NullableHandle = nil;
        let __return = System_Net_Security_SslClientAuthenticationOptions_X509CertificateCollection__get_ClientCertificates_0__0(&__thrown, self.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        if let __ret_unwrapped = __return {
            return dotnet.System.Security.Cryptography.X509Certificates.X509CertificateCollection(hndl : __ret_unwrapped);
        } else {
            return nil;
        }
        }
    }
    // [IsSpecialName] void set_ClientCertificates(System.Security.Cryptography.X509Certificates.X509CertificateCollection)
// docid: M:System.Net.Security.SslClientAuthenticationOptions.set_ClientCertificates(System.Security.Cryptography.X509Certificates.X509CertificateCollection)
    open func set_ClientCertificates(value : Optional<dotnet.System.Security.Cryptography.X509Certificates.X509CertificateCollection>) throws {
        var __thrown : NullableHandle = nil;
        System_Net_Security_SslClientAuthenticationOptions_void__set_ClientCertificates_0__1__X509CertificateCollection(&__thrown, self.get_handle(), value?.get_handle() ?? nil);
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
            return;
        }
    }
    // [IsSpecialName] System.Security.Authentication.SslProtocols get_EnabledSslProtocols()
// docid: M:System.Net.Security.SslClientAuthenticationOptions.get_EnabledSslProtocols
    open func get_EnabledSslProtocols() throws -> dotnet.System.Security.Authentication.SslProtocols {
        var __thrown : NullableHandle = nil;
        let __return = System_Net_Security_SslClientAuthenticationOptions_SslProtocols__get_EnabledSslProtocols_0__0(&__thrown, self.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return dotnet.System.Security.Authentication.SslProtocols(val: __return);
        }
    }
    // [IsSpecialName] void set_EnabledSslProtocols(System.Security.Authentication.SslProtocols)
// docid: M:System.Net.Security.SslClientAuthenticationOptions.set_EnabledSslProtocols(System.Security.Authentication.SslProtocols)
    open func set_EnabledSslProtocols(value : dotnet.System.Security.Authentication.SslProtocols) throws {
        var __thrown : NullableHandle = nil;
        System_Net_Security_SslClientAuthenticationOptions_void__set_EnabledSslProtocols_0__1__SslProtocols(&__thrown, self.get_handle(), value.get_value());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
            return;
        }
    }
    // [IsSpecialName] System.Net.Security.EncryptionPolicy get_EncryptionPolicy()
// docid: M:System.Net.Security.SslClientAuthenticationOptions.get_EncryptionPolicy
    open func get_EncryptionPolicy() throws -> dotnet.System.Net.Security.EncryptionPolicy {
        var __thrown : NullableHandle = nil;
        let __return = System_Net_Security_SslClientAuthenticationOptions_EncryptionPolicy__get_EncryptionPolicy_0__0(&__thrown, self.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return dotnet.System.Net.Security.EncryptionPolicy(val: __return);
        }
    }
    // [IsSpecialName] void set_EncryptionPolicy(System.Net.Security.EncryptionPolicy)
// docid: M:System.Net.Security.SslClientAuthenticationOptions.set_EncryptionPolicy(System.Net.Security.EncryptionPolicy)
    open func set_EncryptionPolicy(value : dotnet.System.Net.Security.EncryptionPolicy) throws {
        var __thrown : NullableHandle = nil;
        System_Net_Security_SslClientAuthenticationOptions_void__set_EncryptionPolicy_0__1__EncryptionPolicy(&__thrown, self.get_handle(), value.get_value());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
            return;
        }
    }
    // [IsSpecialName] System.Net.Security.LocalCertificateSelectionCallback get_LocalCertificateSelectionCallback()
// docid: M:System.Net.Security.SslClientAuthenticationOptions.get_LocalCertificateSelectionCallback
    open func get_LocalCertificateSelectionCallback() throws -> Optional<dotnet.System.Net.Security.LocalCertificateSelectionCallback> {
        var __thrown : NullableHandle = nil;
        let __return = System_Net_Security_SslClientAuthenticationOptions_LocalCertificateSelectionCallback__get_LocalCertificateSelectionCallback_0__0(&__thrown, self.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        if let __ret_unwrapped = __return {
            return dotnet.System.Net.Security.LocalCertificateSelectionCallback(hndl : __ret_unwrapped);
        } else {
            return nil;
        }
        }
    }
    // [IsSpecialName] void set_LocalCertificateSelectionCallback(System.Net.Security.LocalCertificateSelectionCallback)
// docid: M:System.Net.Security.SslClientAuthenticationOptions.set_LocalCertificateSelectionCallback(System.Net.Security.LocalCertificateSelectionCallback)
    open func set_LocalCertificateSelectionCallback(value : Optional<dotnet.System.Net.Security.LocalCertificateSelectionCallback>) throws {
        var __thrown : NullableHandle = nil;
        System_Net_Security_SslClientAuthenticationOptions_void__set_LocalCertificateSelectionCallback_0__1__LocalCertificateSelectionCallback(&__thrown, self.get_handle(), value?.get_handle() ?? nil);
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
            return;
        }
    }
    // delegate closure overload
    open func set_LocalCertificateSelectionCallback(value : @escaping (dotnet.System.Object, dotnet.System.String, dotnet.System.Security.Cryptography.X509Certificates.X509CertificateCollection, Optional<dotnet.System.Security.Cryptography.X509Certificates.X509Certificate>, dotnet.System_Arr<dotnet.System.String>) throws -> dotnet.System.Security.Cryptography.X509Certificates.X509Certificate) throws {
        let del_value = try dotnet.System.Net.Security.LocalCertificateSelectionCallback(value);
        return try set_LocalCertificateSelectionCallback(value: del_value);
    }
    // [IsSpecialName] System.Net.Security.RemoteCertificateValidationCallback get_RemoteCertificateValidationCallback()
// docid: M:System.Net.Security.SslClientAuthenticationOptions.get_RemoteCertificateValidationCallback
    open func get_RemoteCertificateValidationCallback() throws -> Optional<dotnet.System.Net.Security.RemoteCertificateValidationCallback> {
        var __thrown : NullableHandle = nil;
        let __return = System_Net_Security_SslClientAuthenticationOptions_RemoteCertificateValidationCallback__get_RemoteCertificateValidationCallback_0__0(&__thrown, self.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        if let __ret_unwrapped = __return {
            return dotnet.System.Net.Security.RemoteCertificateValidationCallback(hndl : __ret_unwrapped);
        } else {
            return nil;
        }
        }
    }
    // [IsSpecialName] void set_RemoteCertificateValidationCallback(System.Net.Security.RemoteCertificateValidationCallback)
// docid: M:System.Net.Security.SslClientAuthenticationOptions.set_RemoteCertificateValidationCallback(System.Net.Security.RemoteCertificateValidationCallback)
    open func set_RemoteCertificateValidationCallback(value : Optional<dotnet.System.Net.Security.RemoteCertificateValidationCallback>) throws {
        var __thrown : NullableHandle = nil;
        System_Net_Security_SslClientAuthenticationOptions_void__set_RemoteCertificateValidationCallback_0__1__RemoteCertificateValidationCallback(&__thrown, self.get_handle(), value?.get_handle() ?? nil);
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
            return;
        }
    }
    // delegate closure overload
    open func set_RemoteCertificateValidationCallback(value : @escaping (dotnet.System.Object, Optional<dotnet.System.Security.Cryptography.X509Certificates.X509Certificate>, Optional<dotnet.System.Security.Cryptography.X509Certificates.X509Chain>, dotnet.System.Net.Security.SslPolicyErrors) throws -> Bool) throws {
        let del_value = try dotnet.System.Net.Security.RemoteCertificateValidationCallback(value);
        return try set_RemoteCertificateValidationCallback(value: del_value);
    }
    // [IsSpecialName] System.String get_TargetHost()
// docid: M:System.Net.Security.SslClientAuthenticationOptions.get_TargetHost
    open func get_TargetHost() throws -> Optional<dotnet.System.String> {
        var __thrown : NullableHandle = nil;
        let __return = System_Net_Security_SslClientAuthenticationOptions_String__get_TargetHost_0__0(&__thrown, self.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        if let __ret_unwrapped = __return {
            return dotnet.System.String(hndl : __ret_unwrapped);
        } else {
            return nil;
        }
        }
    }
    // [IsSpecialName] void set_TargetHost(System.String)
// docid: M:System.Net.Security.SslClientAuthenticationOptions.set_TargetHost(System.String)
    open func set_TargetHost(value : Optional<dotnet.System.String>) throws {
        var __thrown : NullableHandle = nil;
        System_Net_Security_SslClientAuthenticationOptions_void__set_TargetHost_0__1__String(&__thrown, self.get_handle(), value?.get_handle() ?? nil);
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
            return;
        }
    }
    /**
    Gets or sets a value that indicates whether the  should allow SSL renegotiation.

    */
    open var AllowRenegotiation : Bool {
        get {
            return try! get_AllowRenegotiation();
        }
        set(v) {
            return try! set_AllowRenegotiation(value: v);
        }
    }
    /**
    Gets or sets a list of ALPN protocols.

    */
    open var ApplicationProtocols : Optional<dotnet.System.Collections.Generic.List_1<dotnet.System.Net.Security.SslApplicationProtocol>> {
        get {
            return try! get_ApplicationProtocols();
        }
        set(v) {
            return try! set_ApplicationProtocols(value: v!);
        }
    }
    /**
    Gets or sets the certificate revocation mode for certificate validation.

    */
    open var CertificateRevocationCheckMode : dotnet.System.Security.Cryptography.X509Certificates.X509RevocationMode {
        get {
            return try! get_CertificateRevocationCheckMode();
        }
        set(v) {
            return try! set_CertificateRevocationCheckMode(value: v);
        }
    }
    /**
    Specifies the cipher suites allowed for TLS. When set to , the operating system default is used. Use extreme caution when changing this setting.

    */
    open var CipherSuitesPolicy : Optional<dotnet.System.Net.Security.CipherSuitesPolicy> {
        get {
            return try! get_CipherSuitesPolicy();
        }
        set(v) {
            return try! set_CipherSuitesPolicy(value: v!);
        }
    }
    /**
    A collection of certificates to be considered for the client's authentication to the server.

    */
    open var ClientCertificates : Optional<dotnet.System.Security.Cryptography.X509Certificates.X509CertificateCollection> {
        get {
            return try! get_ClientCertificates();
        }
        set(v) {
            return try! set_ClientCertificates(value: v!);
        }
    }
    /**
    Gets or sets the value that represents the protocol versions offered by the client to the server during authentication.

    */
    open var EnabledSslProtocols : dotnet.System.Security.Authentication.SslProtocols {
        get {
            return try! get_EnabledSslProtocols();
        }
        set(v) {
            return try! set_EnabledSslProtocols(value: v);
        }
    }
    /**
    Gets or sets the encryption policy.

    */
    open var EncryptionPolicy : dotnet.System.Net.Security.EncryptionPolicy {
        get {
            return try! get_EncryptionPolicy();
        }
        set(v) {
            return try! set_EncryptionPolicy(value: v);
        }
    }
    /**
    Gets or sets a  delegate that's responsible for selecting the client authentication certificate used for authentication.

    */
    open var LocalCertificateSelectionCallback : Optional<dotnet.System.Net.Security.LocalCertificateSelectionCallback> {
        get {
            return try! get_LocalCertificateSelectionCallback();
        }
        set(v) {
            return try! set_LocalCertificateSelectionCallback(value: v!);
        }
    }
    /**
    Gets or sets a  delegate that's responsible for validating the certificate supplied by the remote party.

    */
    open var RemoteCertificateValidationCallback : Optional<dotnet.System.Net.Security.RemoteCertificateValidationCallback> {
        get {
            return try! get_RemoteCertificateValidationCallback();
        }
        set(v) {
            return try! set_RemoteCertificateValidationCallback(value: v!);
        }
    }
    /**
    Gets or sets the name of the server the client is trying to connect to. That name is used for server certificate validation. It can be a DNS name or an IP address.

    */
    open var TargetHost : Optional<dotnet.System.String> {
        get {
            return try! get_TargetHost();
        }
        set(v) {
            return try! set_TargetHost(value: v!);
        }
    }
} // SslClientAuthenticationOptions


// type: System.Net.Security.SslClientHelloInfo
// boxed value type
    /**
    This struct contains information from received TLS Client Hello frame.

    */
public final class SslClientHelloInfo
    :
    dotnet.System.Object
{
    public class override func get_type_handle() -> TypeHandle {
        return System_Net_Security_SslClientHelloInfo_get_type_handle();
    }
    public required init(hndl: NonnullHandle) { super.init(hndl: hndl); }
    public required init(gval: GVal) { super.init(gval: gval); }
    /**
    Gets the host server specified by the client.

    */
    public var ServerName : dotnet.System.String {
        get {
            return try! get_ServerName();
        }
    }
    /**
    Gets the TLS/SSL protocols offered by client.

    */
    public var SslProtocols : dotnet.System.Security.Authentication.SslProtocols {
        get {
            return try! get_SslProtocols();
        }
    }
    public override init() {
        let h = System_Net_Security_SslClientHelloInfo_implicit_ctor();
            super.init(hndl: h);
    }
    // [IsSpecialName] System.String get_ServerName()
// docid: M:System.Net.Security.SslClientHelloInfo.get_ServerName
    public func get_ServerName() throws -> dotnet.System.String {
        var __thrown : NullableHandle = nil;
        let __return = System_Net_Security_SslClientHelloInfo_String__get_ServerName_0__0(&__thrown, self.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return dotnet.System.String(hndl : __return);
        }
    }
    // [IsSpecialName] System.Security.Authentication.SslProtocols get_SslProtocols()
// docid: M:System.Net.Security.SslClientHelloInfo.get_SslProtocols
    public func get_SslProtocols() throws -> dotnet.System.Security.Authentication.SslProtocols {
        var __thrown : NullableHandle = nil;
        let __return = System_Net_Security_SslClientHelloInfo_SslProtocols__get_SslProtocols_0__0(&__thrown, self.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return dotnet.System.Security.Authentication.SslProtocols(val: __return);
        }
    }
} // SslClientHelloInfo


// type: System.Net.Security.SslServerAuthenticationOptions
    /**
    This struct represents a server authentication property bag for the .

    */
open class SslServerAuthenticationOptions
    :
    dotnet.System.Object
{
    open class override func get_type_handle() -> TypeHandle {
        return System_Net_Security_SslServerAuthenticationOptions_get_type_handle();
    }
    public required init(hndl: NonnullHandle) { super.init(hndl: hndl); }
    public required init(gval: GVal) { super.init(gval: gval); }
    // .ctor()
// docid: M:System.Net.Security.SslServerAuthenticationOptions.#ctor
    /**
    Initializes a new instance of the  class.

    */
    public override init() throws {
        var __thrown : NullableHandle = nil;
        let h = System_Net_Security_SslServerAuthenticationOptions_ctor_0__0(&__thrown);
        if let __ex = __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
            super.init(hndl: h);
        }
    }
    // [IsSpecialName] bool get_AllowRenegotiation()
// docid: M:System.Net.Security.SslServerAuthenticationOptions.get_AllowRenegotiation
    open func get_AllowRenegotiation() throws -> Bool {
        var __thrown : NullableHandle = nil;
        let __return = System_Net_Security_SslServerAuthenticationOptions_bool__get_AllowRenegotiation_0__0(&__thrown, self.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return (__return) != 0;
        }
    }
    // [IsSpecialName] void set_AllowRenegotiation(bool)
// docid: M:System.Net.Security.SslServerAuthenticationOptions.set_AllowRenegotiation(System.Boolean)
    open func set_AllowRenegotiation(value : Bool) throws {
        var __thrown : NullableHandle = nil;
        System_Net_Security_SslServerAuthenticationOptions_void__set_AllowRenegotiation_0__1__bool(&__thrown, self.get_handle(), Swift.Int32(value ? 1 : 0));
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
            return;
        }
    }
    // [IsSpecialName] System.Collections.Generic.List<System.Net.Security.SslApplicationProtocol> get_ApplicationProtocols()
// docid: M:System.Net.Security.SslServerAuthenticationOptions.get_ApplicationProtocols
    open func get_ApplicationProtocols() throws -> Optional<dotnet.System.Collections.Generic.List_1<dotnet.System.Net.Security.SslApplicationProtocol>> {
        var __thrown : NullableHandle = nil;
        let __return = System_Net_Security_SslServerAuthenticationOptions_System_Collections_Generic_List_System_Net_Security_SslApplicationProtocol___get_ApplicationProtocols_0__0(&__thrown, self.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        if let __ret_unwrapped = __return {
            return dotnet.System.Collections.Generic.List_1(hndl : __ret_unwrapped);
        } else {
            return nil;
        }
        }
    }
    // [IsSpecialName] void set_ApplicationProtocols(System.Collections.Generic.List<System.Net.Security.SslApplicationProtocol>)
// docid: M:System.Net.Security.SslServerAuthenticationOptions.set_ApplicationProtocols(System.Collections.Generic.List{System.Net.Security.SslApplicationProtocol})
    open func set_ApplicationProtocols(value : Optional<dotnet.System.Collections.Generic.List_1<dotnet.System.Net.Security.SslApplicationProtocol>>) throws {
        var __thrown : NullableHandle = nil;
        System_Net_Security_SslServerAuthenticationOptions_void__set_ApplicationProtocols_0__1__System_Collections_Generic_List_System_Net_Security_SslApplicationProtocol_(&__thrown, self.get_handle(), (value?.get_handle()));
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
            return;
        }
    }
    // [IsSpecialName] System.Security.Cryptography.X509Certificates.X509RevocationMode get_CertificateRevocationCheckMode()
// docid: M:System.Net.Security.SslServerAuthenticationOptions.get_CertificateRevocationCheckMode
    open func get_CertificateRevocationCheckMode() throws -> dotnet.System.Security.Cryptography.X509Certificates.X509RevocationMode {
        var __thrown : NullableHandle = nil;
        let __return = System_Net_Security_SslServerAuthenticationOptions_X509RevocationMode__get_CertificateRevocationCheckMode_0__0(&__thrown, self.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return dotnet.System.Security.Cryptography.X509Certificates.X509RevocationMode(val: __return);
        }
    }
    // [IsSpecialName] void set_CertificateRevocationCheckMode(System.Security.Cryptography.X509Certificates.X509RevocationMode)
// docid: M:System.Net.Security.SslServerAuthenticationOptions.set_CertificateRevocationCheckMode(System.Security.Cryptography.X509Certificates.X509RevocationMode)
    open func set_CertificateRevocationCheckMode(value : dotnet.System.Security.Cryptography.X509Certificates.X509RevocationMode) throws {
        var __thrown : NullableHandle = nil;
        System_Net_Security_SslServerAuthenticationOptions_void__set_CertificateRevocationCheckMode_0__1__X509RevocationMode(&__thrown, self.get_handle(), value.get_value());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
            return;
        }
    }
    // [IsSpecialName] System.Net.Security.CipherSuitesPolicy get_CipherSuitesPolicy()
// docid: M:System.Net.Security.SslServerAuthenticationOptions.get_CipherSuitesPolicy
    open func get_CipherSuitesPolicy() throws -> Optional<dotnet.System.Net.Security.CipherSuitesPolicy> {
        var __thrown : NullableHandle = nil;
        let __return = System_Net_Security_SslServerAuthenticationOptions_CipherSuitesPolicy__get_CipherSuitesPolicy_0__0(&__thrown, self.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        if let __ret_unwrapped = __return {
            return dotnet.System.Net.Security.CipherSuitesPolicy(hndl : __ret_unwrapped);
        } else {
            return nil;
        }
        }
    }
    // [IsSpecialName] void set_CipherSuitesPolicy(System.Net.Security.CipherSuitesPolicy)
// docid: M:System.Net.Security.SslServerAuthenticationOptions.set_CipherSuitesPolicy(System.Net.Security.CipherSuitesPolicy)
    open func set_CipherSuitesPolicy(value : Optional<dotnet.System.Net.Security.CipherSuitesPolicy>) throws {
        var __thrown : NullableHandle = nil;
        System_Net_Security_SslServerAuthenticationOptions_void__set_CipherSuitesPolicy_0__1__CipherSuitesPolicy(&__thrown, self.get_handle(), value?.get_handle() ?? nil);
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
            return;
        }
    }
    // [IsSpecialName] bool get_ClientCertificateRequired()
// docid: M:System.Net.Security.SslServerAuthenticationOptions.get_ClientCertificateRequired
    open func get_ClientCertificateRequired() throws -> Bool {
        var __thrown : NullableHandle = nil;
        let __return = System_Net_Security_SslServerAuthenticationOptions_bool__get_ClientCertificateRequired_0__0(&__thrown, self.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return (__return) != 0;
        }
    }
    // [IsSpecialName] void set_ClientCertificateRequired(bool)
// docid: M:System.Net.Security.SslServerAuthenticationOptions.set_ClientCertificateRequired(System.Boolean)
    open func set_ClientCertificateRequired(value : Bool) throws {
        var __thrown : NullableHandle = nil;
        System_Net_Security_SslServerAuthenticationOptions_void__set_ClientCertificateRequired_0__1__bool(&__thrown, self.get_handle(), Swift.Int32(value ? 1 : 0));
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
            return;
        }
    }
    // [IsSpecialName] System.Security.Authentication.SslProtocols get_EnabledSslProtocols()
// docid: M:System.Net.Security.SslServerAuthenticationOptions.get_EnabledSslProtocols
    open func get_EnabledSslProtocols() throws -> dotnet.System.Security.Authentication.SslProtocols {
        var __thrown : NullableHandle = nil;
        let __return = System_Net_Security_SslServerAuthenticationOptions_SslProtocols__get_EnabledSslProtocols_0__0(&__thrown, self.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return dotnet.System.Security.Authentication.SslProtocols(val: __return);
        }
    }
    // [IsSpecialName] void set_EnabledSslProtocols(System.Security.Authentication.SslProtocols)
// docid: M:System.Net.Security.SslServerAuthenticationOptions.set_EnabledSslProtocols(System.Security.Authentication.SslProtocols)
    open func set_EnabledSslProtocols(value : dotnet.System.Security.Authentication.SslProtocols) throws {
        var __thrown : NullableHandle = nil;
        System_Net_Security_SslServerAuthenticationOptions_void__set_EnabledSslProtocols_0__1__SslProtocols(&__thrown, self.get_handle(), value.get_value());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
            return;
        }
    }
    // [IsSpecialName] System.Net.Security.EncryptionPolicy get_EncryptionPolicy()
// docid: M:System.Net.Security.SslServerAuthenticationOptions.get_EncryptionPolicy
    open func get_EncryptionPolicy() throws -> dotnet.System.Net.Security.EncryptionPolicy {
        var __thrown : NullableHandle = nil;
        let __return = System_Net_Security_SslServerAuthenticationOptions_EncryptionPolicy__get_EncryptionPolicy_0__0(&__thrown, self.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return dotnet.System.Net.Security.EncryptionPolicy(val: __return);
        }
    }
    // [IsSpecialName] void set_EncryptionPolicy(System.Net.Security.EncryptionPolicy)
// docid: M:System.Net.Security.SslServerAuthenticationOptions.set_EncryptionPolicy(System.Net.Security.EncryptionPolicy)
    open func set_EncryptionPolicy(value : dotnet.System.Net.Security.EncryptionPolicy) throws {
        var __thrown : NullableHandle = nil;
        System_Net_Security_SslServerAuthenticationOptions_void__set_EncryptionPolicy_0__1__EncryptionPolicy(&__thrown, self.get_handle(), value.get_value());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
            return;
        }
    }
    // [IsSpecialName] System.Net.Security.RemoteCertificateValidationCallback get_RemoteCertificateValidationCallback()
// docid: M:System.Net.Security.SslServerAuthenticationOptions.get_RemoteCertificateValidationCallback
    open func get_RemoteCertificateValidationCallback() throws -> Optional<dotnet.System.Net.Security.RemoteCertificateValidationCallback> {
        var __thrown : NullableHandle = nil;
        let __return = System_Net_Security_SslServerAuthenticationOptions_RemoteCertificateValidationCallback__get_RemoteCertificateValidationCallback_0__0(&__thrown, self.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        if let __ret_unwrapped = __return {
            return dotnet.System.Net.Security.RemoteCertificateValidationCallback(hndl : __ret_unwrapped);
        } else {
            return nil;
        }
        }
    }
    // [IsSpecialName] void set_RemoteCertificateValidationCallback(System.Net.Security.RemoteCertificateValidationCallback)
// docid: M:System.Net.Security.SslServerAuthenticationOptions.set_RemoteCertificateValidationCallback(System.Net.Security.RemoteCertificateValidationCallback)
    open func set_RemoteCertificateValidationCallback(value : Optional<dotnet.System.Net.Security.RemoteCertificateValidationCallback>) throws {
        var __thrown : NullableHandle = nil;
        System_Net_Security_SslServerAuthenticationOptions_void__set_RemoteCertificateValidationCallback_0__1__RemoteCertificateValidationCallback(&__thrown, self.get_handle(), value?.get_handle() ?? nil);
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
            return;
        }
    }
    // delegate closure overload
    open func set_RemoteCertificateValidationCallback(value : @escaping (dotnet.System.Object, Optional<dotnet.System.Security.Cryptography.X509Certificates.X509Certificate>, Optional<dotnet.System.Security.Cryptography.X509Certificates.X509Chain>, dotnet.System.Net.Security.SslPolicyErrors) throws -> Bool) throws {
        let del_value = try dotnet.System.Net.Security.RemoteCertificateValidationCallback(value);
        return try set_RemoteCertificateValidationCallback(value: del_value);
    }
    // [IsSpecialName] System.Security.Cryptography.X509Certificates.X509Certificate get_ServerCertificate()
// docid: M:System.Net.Security.SslServerAuthenticationOptions.get_ServerCertificate
    open func get_ServerCertificate() throws -> Optional<dotnet.System.Security.Cryptography.X509Certificates.X509Certificate> {
        var __thrown : NullableHandle = nil;
        let __return = System_Net_Security_SslServerAuthenticationOptions_X509Certificate__get_ServerCertificate_0__0(&__thrown, self.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        if let __ret_unwrapped = __return {
            return dotnet.System.Security.Cryptography.X509Certificates.X509Certificate(hndl : __ret_unwrapped);
        } else {
            return nil;
        }
        }
    }
    // [IsSpecialName] void set_ServerCertificate(System.Security.Cryptography.X509Certificates.X509Certificate)
// docid: M:System.Net.Security.SslServerAuthenticationOptions.set_ServerCertificate(System.Security.Cryptography.X509Certificates.X509Certificate)
    open func set_ServerCertificate(value : Optional<dotnet.System.Security.Cryptography.X509Certificates.X509Certificate>) throws {
        var __thrown : NullableHandle = nil;
        System_Net_Security_SslServerAuthenticationOptions_void__set_ServerCertificate_0__1__X509Certificate(&__thrown, self.get_handle(), value?.get_handle() ?? nil);
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
            return;
        }
    }
    // [IsSpecialName] System.Net.Security.SslStreamCertificateContext get_ServerCertificateContext()
// docid: M:System.Net.Security.SslServerAuthenticationOptions.get_ServerCertificateContext
    open func get_ServerCertificateContext() throws -> Optional<dotnet.System.Net.Security.SslStreamCertificateContext> {
        var __thrown : NullableHandle = nil;
        let __return = System_Net_Security_SslServerAuthenticationOptions_SslStreamCertificateContext__get_ServerCertificateContext_0__0(&__thrown, self.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        if let __ret_unwrapped = __return {
            return dotnet.System.Net.Security.SslStreamCertificateContext(hndl : __ret_unwrapped);
        } else {
            return nil;
        }
        }
    }
    // [IsSpecialName] void set_ServerCertificateContext(System.Net.Security.SslStreamCertificateContext)
// docid: M:System.Net.Security.SslServerAuthenticationOptions.set_ServerCertificateContext(System.Net.Security.SslStreamCertificateContext)
    open func set_ServerCertificateContext(value : Optional<dotnet.System.Net.Security.SslStreamCertificateContext>) throws {
        var __thrown : NullableHandle = nil;
        System_Net_Security_SslServerAuthenticationOptions_void__set_ServerCertificateContext_0__1__SslStreamCertificateContext(&__thrown, self.get_handle(), value?.get_handle() ?? nil);
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
            return;
        }
    }
    // [IsSpecialName] System.Net.Security.ServerCertificateSelectionCallback get_ServerCertificateSelectionCallback()
// docid: M:System.Net.Security.SslServerAuthenticationOptions.get_ServerCertificateSelectionCallback
    open func get_ServerCertificateSelectionCallback() throws -> Optional<dotnet.System.Net.Security.ServerCertificateSelectionCallback> {
        var __thrown : NullableHandle = nil;
        let __return = System_Net_Security_SslServerAuthenticationOptions_ServerCertificateSelectionCallback__get_ServerCertificateSelectionCallback_0__0(&__thrown, self.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        if let __ret_unwrapped = __return {
            return dotnet.System.Net.Security.ServerCertificateSelectionCallback(hndl : __ret_unwrapped);
        } else {
            return nil;
        }
        }
    }
    // [IsSpecialName] void set_ServerCertificateSelectionCallback(System.Net.Security.ServerCertificateSelectionCallback)
// docid: M:System.Net.Security.SslServerAuthenticationOptions.set_ServerCertificateSelectionCallback(System.Net.Security.ServerCertificateSelectionCallback)
    open func set_ServerCertificateSelectionCallback(value : Optional<dotnet.System.Net.Security.ServerCertificateSelectionCallback>) throws {
        var __thrown : NullableHandle = nil;
        System_Net_Security_SslServerAuthenticationOptions_void__set_ServerCertificateSelectionCallback_0__1__ServerCertificateSelectionCallback(&__thrown, self.get_handle(), value?.get_handle() ?? nil);
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
            return;
        }
    }
    // delegate closure overload
    open func set_ServerCertificateSelectionCallback(value : @escaping (dotnet.System.Object, Optional<dotnet.System.String>) throws -> dotnet.System.Security.Cryptography.X509Certificates.X509Certificate) throws {
        let del_value = try dotnet.System.Net.Security.ServerCertificateSelectionCallback(value);
        return try set_ServerCertificateSelectionCallback(value: del_value);
    }
    /**
    Gets or sets a value that indicates whether the  should allow SSL renegotiation.

    */
    open var AllowRenegotiation : Bool {
        get {
            return try! get_AllowRenegotiation();
        }
        set(v) {
            return try! set_AllowRenegotiation(value: v);
        }
    }
    /**
    Gets or sets a list of ALPN protocols.

    */
    open var ApplicationProtocols : Optional<dotnet.System.Collections.Generic.List_1<dotnet.System.Net.Security.SslApplicationProtocol>> {
        get {
            return try! get_ApplicationProtocols();
        }
        set(v) {
            return try! set_ApplicationProtocols(value: v!);
        }
    }
    /**
    Gets or sets the certificate revocation mode for certificate validation.

    */
    open var CertificateRevocationCheckMode : dotnet.System.Security.Cryptography.X509Certificates.X509RevocationMode {
        get {
            return try! get_CertificateRevocationCheckMode();
        }
        set(v) {
            return try! set_CertificateRevocationCheckMode(value: v);
        }
    }
    /**
    Specifies the cipher suites allowed for TLS. When set to , the operating system default is used. Use extreme caution when changing this setting.

    */
    open var CipherSuitesPolicy : Optional<dotnet.System.Net.Security.CipherSuitesPolicy> {
        get {
            return try! get_CipherSuitesPolicy();
        }
        set(v) {
            return try! set_CipherSuitesPolicy(value: v!);
        }
    }
    /**
    Gets or sets a value that specifies whether the client is asked for a certificate for authentication. Note that this is only a request -- if no certificate is provided, the server still accepts the connection request.

    */
    open var ClientCertificateRequired : Bool {
        get {
            return try! get_ClientCertificateRequired();
        }
        set(v) {
            return try! set_ClientCertificateRequired(value: v);
        }
    }
    /**
    Gets or sets a value that represents protocol versions used by the server to match the client protocol version during authentication.

    */
    open var EnabledSslProtocols : dotnet.System.Security.Authentication.SslProtocols {
        get {
            return try! get_EnabledSslProtocols();
        }
        set(v) {
            return try! set_EnabledSslProtocols(value: v);
        }
    }
    /**
    Gets or sets the .

    */
    open var EncryptionPolicy : dotnet.System.Net.Security.EncryptionPolicy {
        get {
            return try! get_EncryptionPolicy();
        }
        set(v) {
            return try! set_EncryptionPolicy(value: v);
        }
    }
    /**
    Gets or sets a  delegate responsible for custom validating the certificate supplied by the remote party.

    */
    open var RemoteCertificateValidationCallback : Optional<dotnet.System.Net.Security.RemoteCertificateValidationCallback> {
        get {
            return try! get_RemoteCertificateValidationCallback();
        }
        set(v) {
            return try! set_RemoteCertificateValidationCallback(value: v!);
        }
    }
    /**
    Gets or sets the server certificate.

    */
    open var ServerCertificate : Optional<dotnet.System.Security.Cryptography.X509Certificates.X509Certificate> {
        get {
            return try! get_ServerCertificate();
        }
        set(v) {
            return try! set_ServerCertificate(value: v!);
        }
    }
    /**
    Gets or sets the server certificate context.

    */
    open var ServerCertificateContext : Optional<dotnet.System.Net.Security.SslStreamCertificateContext> {
        get {
            return try! get_ServerCertificateContext();
        }
        set(v) {
            return try! set_ServerCertificateContext(value: v!);
        }
    }
    /**
    Gets or sets the  delegate responsible for the server certificate selection.

    */
    open var ServerCertificateSelectionCallback : Optional<dotnet.System.Net.Security.ServerCertificateSelectionCallback> {
        get {
            return try! get_ServerCertificateSelectionCallback();
        }
        set(v) {
            return try! set_ServerCertificateSelectionCallback(value: v!);
        }
    }
} // SslServerAuthenticationOptions


// type: System.Net.Security.SslStream
    /**
    Provides a stream used for client-server communication that uses the Secure Socket Layer (SSL) security protocol to authenticate the server and optionally the client.

    */
open class SslStream
    :
    dotnet.System.Net.Security.AuthenticatedStream
{
    open class override func get_type_handle() -> TypeHandle {
        return System_Net_Security_SslStream_get_type_handle();
    }
    public required init(hndl: NonnullHandle) { super.init(hndl: hndl); }
    public required init(gval: GVal) { super.init(gval: gval); }
    // .ctor(System.IO.Stream)
// docid: M:System.Net.Security.SslStream.#ctor(System.IO.Stream)
    /**
    Initializes a new instance of the  class using the specified .

    - Parameter innerStream: A  object used by the  for sending and receiving data.
    */
    public init(innerStream : dotnet.System.IO.Stream) throws {
        var __thrown : NullableHandle = nil;
        let h = System_Net_Security_SslStream_ctor_0__1__Stream(&__thrown, innerStream.get_handle());
        if let __ex = __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
            super.init(hndl: h);
        }
    }
    // .ctor(System.IO.Stream, bool)
// docid: M:System.Net.Security.SslStream.#ctor(System.IO.Stream,System.Boolean)
    /**
    Initializes a new instance of the  class using the specified  and stream closure behavior.

    - Parameter innerStream: A  object used by the  for sending and receiving data.
    - Parameter leaveInnerStreamOpen: A Boolean value that indicates the closure behavior of the  object used by the  for sending and receiving data. This parameter indicates if the inner stream is left open.
    */
    public init(innerStream : dotnet.System.IO.Stream, leaveInnerStreamOpen : Bool) throws {
        var __thrown : NullableHandle = nil;
        let h = System_Net_Security_SslStream_ctor_0__2__Stream_bool(&__thrown, innerStream.get_handle(), Swift.Int32(leaveInnerStreamOpen ? 1 : 0));
        if let __ex = __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
            super.init(hndl: h);
        }
    }
    // .ctor(System.IO.Stream, bool, System.Net.Security.RemoteCertificateValidationCallback)
// docid: M:System.Net.Security.SslStream.#ctor(System.IO.Stream,System.Boolean,System.Net.Security.RemoteCertificateValidationCallback)
    /**
    Initializes a new instance of the  class using the specified , stream closure behavior and certificate validation delegate.

    - Parameter innerStream: A  object used by the  for sending and receiving data.
    - Parameter leaveInnerStreamOpen: A Boolean value that indicates the closure behavior of the  object used by the  for sending and receiving data. This parameter indicates if the inner stream is left open.
    - Parameter userCertificateValidationCallback: A  delegate responsible for validating the certificate supplied by the remote party.
    */
    public init(innerStream : dotnet.System.IO.Stream, leaveInnerStreamOpen : Bool, userCertificateValidationCallback : Optional<dotnet.System.Net.Security.RemoteCertificateValidationCallback>) throws {
        var __thrown : NullableHandle = nil;
        let h = System_Net_Security_SslStream_ctor_0__3__Stream_bool_RemoteCertificateValidationCallback(&__thrown, innerStream.get_handle(), Swift.Int32(leaveInnerStreamOpen ? 1 : 0), userCertificateValidationCallback?.get_handle() ?? nil);
        if let __ex = __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
            super.init(hndl: h);
        }
    }
    // .ctor(System.IO.Stream, bool, System.Net.Security.RemoteCertificateValidationCallback, System.Net.Security.LocalCertificateSelectionCallback)
// docid: M:System.Net.Security.SslStream.#ctor(System.IO.Stream,System.Boolean,System.Net.Security.RemoteCertificateValidationCallback,System.Net.Security.LocalCertificateSelectionCallback)
    /**
    Initializes a new instance of the  class using the specified , stream closure behavior, certificate validation delegate and certificate selection delegate.

    - Parameter innerStream: A  object used by the  for sending and receiving data.
    - Parameter leaveInnerStreamOpen: A Boolean value that indicates the closure behavior of the  object used by the  for sending and receiving data. This parameter indicates if the inner stream is left open.
    - Parameter userCertificateValidationCallback: A  delegate responsible for validating the certificate supplied by the remote party.
    - Parameter userCertificateSelectionCallback: A  delegate responsible for selecting the certificate used for authentication.
    */
    public init(innerStream : dotnet.System.IO.Stream, leaveInnerStreamOpen : Bool, userCertificateValidationCallback : Optional<dotnet.System.Net.Security.RemoteCertificateValidationCallback>, userCertificateSelectionCallback : Optional<dotnet.System.Net.Security.LocalCertificateSelectionCallback>) throws {
        var __thrown : NullableHandle = nil;
        let h = System_Net_Security_SslStream_ctor_0__4__Stream_bool_RemoteCertificateValidationCallback_LocalCertificateSelectionCallback(&__thrown, innerStream.get_handle(), Swift.Int32(leaveInnerStreamOpen ? 1 : 0), userCertificateValidationCallback?.get_handle() ?? nil, userCertificateSelectionCallback?.get_handle() ?? nil);
        if let __ex = __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
            super.init(hndl: h);
        }
    }
    // .ctor(System.IO.Stream, bool, System.Net.Security.RemoteCertificateValidationCallback, System.Net.Security.LocalCertificateSelectionCallback, System.Net.Security.EncryptionPolicy)
// docid: M:System.Net.Security.SslStream.#ctor(System.IO.Stream,System.Boolean,System.Net.Security.RemoteCertificateValidationCallback,System.Net.Security.LocalCertificateSelectionCallback,System.Net.Security.EncryptionPolicy)
    /**
    Initializes a new instance of the  class using the specified 

    - Parameter innerStream: A  object used by the  for sending and receiving data.
    - Parameter leaveInnerStreamOpen: A Boolean value that indicates the closure behavior of the  object used by the  for sending and receiving data. This parameter indicates if the inner stream is left open.
    - Parameter userCertificateValidationCallback: A  delegate responsible for validating the certificate supplied by the remote party.
    - Parameter userCertificateSelectionCallback: A  delegate responsible for selecting the certificate used for authentication.
    - Parameter encryptionPolicy: The  to use.
    */
    public init(innerStream : dotnet.System.IO.Stream, leaveInnerStreamOpen : Bool, userCertificateValidationCallback : Optional<dotnet.System.Net.Security.RemoteCertificateValidationCallback>, userCertificateSelectionCallback : Optional<dotnet.System.Net.Security.LocalCertificateSelectionCallback>, encryptionPolicy : dotnet.System.Net.Security.EncryptionPolicy) throws {
        var __thrown : NullableHandle = nil;
        let h = System_Net_Security_SslStream_ctor_0__5__Stream_bool_RemoteCertificateValidationCallback_LocalCertificateSelectionCallback_EncryptionPolicy(&__thrown, innerStream.get_handle(), Swift.Int32(leaveInnerStreamOpen ? 1 : 0), userCertificateValidationCallback?.get_handle() ?? nil, userCertificateSelectionCallback?.get_handle() ?? nil, encryptionPolicy.get_value());
        if let __ex = __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
            super.init(hndl: h);
        }
    }
    // void AuthenticateAsClient(System.Net.Security.SslClientAuthenticationOptions)
// docid: M:System.Net.Security.SslStream.AuthenticateAsClient(System.Net.Security.SslClientAuthenticationOptions)
    /**
    Called by clients to authenticate the server and optionally the client in a client-server connection.

    - Parameter sslClientAuthenticationOptions: The property bag for the SSL connection.
    */
    open func AuthenticateAsClient(sslClientAuthenticationOptions : dotnet.System.Net.Security.SslClientAuthenticationOptions) throws {
        var __thrown : NullableHandle = nil;
        System_Net_Security_SslStream_void__AuthenticateAsClient_0__1__SslClientAuthenticationOptions(&__thrown, self.get_handle(), sslClientAuthenticationOptions.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
            return;
        }
    }
    // void AuthenticateAsClient(System.String)
// docid: M:System.Net.Security.SslStream.AuthenticateAsClient(System.String)
    /**
    Called by clients to authenticate the server and optionally the client in a client-server connection.

    - Parameter targetHost: The name of the server that shares this .
    */
    open func AuthenticateAsClient(targetHost : dotnet.System.String) throws {
        var __thrown : NullableHandle = nil;
        System_Net_Security_SslStream_void__AuthenticateAsClient_0__1__String(&__thrown, self.get_handle(), targetHost.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
            return;
        }
    }
    // void AuthenticateAsClient(System.String, System.Security.Cryptography.X509Certificates.X509CertificateCollection, bool)
// docid: M:System.Net.Security.SslStream.AuthenticateAsClient(System.String,System.Security.Cryptography.X509Certificates.X509CertificateCollection,System.Boolean)
    /**
    Called by clients to authenticate the server and optionally the client in a client-server connection. The authentication process uses the specified certificate collection, and the system default SSL protocol.

    - Parameter targetHost: The name of the server that will share this .
    - Parameter clientCertificates: The  that contains client certificates.
    - Parameter checkCertificateRevocation: A  value that specifies whether the certificate revocation list is checked during authentication.
    */
    open func AuthenticateAsClient(targetHost : dotnet.System.String, clientCertificates : Optional<dotnet.System.Security.Cryptography.X509Certificates.X509CertificateCollection>, checkCertificateRevocation : Bool) throws {
        var __thrown : NullableHandle = nil;
        System_Net_Security_SslStream_void__AuthenticateAsClient_0__3__String_X509CertificateCollection_bool(&__thrown, self.get_handle(), targetHost.get_handle(), clientCertificates?.get_handle() ?? nil, Swift.Int32(checkCertificateRevocation ? 1 : 0));
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
            return;
        }
    }
    // void AuthenticateAsClient(System.String, System.Security.Cryptography.X509Certificates.X509CertificateCollection, System.Security.Authentication.SslProtocols, bool)
// docid: M:System.Net.Security.SslStream.AuthenticateAsClient(System.String,System.Security.Cryptography.X509Certificates.X509CertificateCollection,System.Security.Authentication.SslProtocols,System.Boolean)
    /**
    Called by clients to authenticate the server and optionally the client in a client-server connection. The authentication process uses the specified certificate collection and SSL protocol.

    - Parameter targetHost: The name of the server that will share this .
    - Parameter clientCertificates: The  that contains client certificates.
    - Parameter enabledSslProtocols: The  value that represents protocols used for authentication.
    - Parameter checkCertificateRevocation: A  value that specifies whether the certificate revocation list is checked during authentication.
    */
    open func AuthenticateAsClient(targetHost : dotnet.System.String, clientCertificates : Optional<dotnet.System.Security.Cryptography.X509Certificates.X509CertificateCollection>, enabledSslProtocols : dotnet.System.Security.Authentication.SslProtocols, checkCertificateRevocation : Bool) throws {
        var __thrown : NullableHandle = nil;
        System_Net_Security_SslStream_void__AuthenticateAsClient_0__4__String_X509CertificateCollection_SslProtocols_bool(&__thrown, self.get_handle(), targetHost.get_handle(), clientCertificates?.get_handle() ?? nil, enabledSslProtocols.get_value(), Swift.Int32(checkCertificateRevocation ? 1 : 0));
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
            return;
        }
    }
    // System.Threading.Tasks.Task AuthenticateAsClientAsync(System.Net.Security.SslClientAuthenticationOptions, System.Threading.CancellationToken)
// docid: M:System.Net.Security.SslStream.AuthenticateAsClientAsync(System.Net.Security.SslClientAuthenticationOptions,System.Threading.CancellationToken)
    /**
    Called by clients to authenticate the server and optionally the client in a client-server connection as an asynchronous operation. The authentication process uses information specified in the  property bag.

    - Parameter sslClientAuthenticationOptions: The property bag for the SSL connection.
    - Parameter cancellationToken: The token to monitor for cancellation requests.
    - Returns: The task object representing the asynchronous operation.

    */
    open func AuthenticateAsClientAsync(sslClientAuthenticationOptions : dotnet.System.Net.Security.SslClientAuthenticationOptions, cancellationToken : dotnet.System.Threading.CancellationToken = System.Threading.CancellationToken.None) throws -> dotnet.System.Threading.Tasks.Task {
        var __thrown : NullableHandle = nil;
        let __return = System_Net_Security_SslStream_Task__AuthenticateAsClientAsync_0__2__SslClientAuthenticationOptions_CancellationToken(&__thrown, self.get_handle(), sslClientAuthenticationOptions.get_handle(), cancellationToken.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return dotnet.System.Threading.Tasks.Task(hndl : __return);
        }
    }
    // System.Threading.Tasks.Task AuthenticateAsClientAsync(System.String)
// docid: M:System.Net.Security.SslStream.AuthenticateAsClientAsync(System.String)
    /**
    Called by clients to authenticate the server and optionally the client in a client-server connection as an asynchronous operation.

    - Parameter targetHost: The name of the server that shares this .
    - Returns: The task object representing the asynchronous operation.

    */
    open func AuthenticateAsClientAsync(targetHost : dotnet.System.String) throws -> dotnet.System.Threading.Tasks.Task {
        var __thrown : NullableHandle = nil;
        let __return = System_Net_Security_SslStream_Task__AuthenticateAsClientAsync_0__1__String(&__thrown, self.get_handle(), targetHost.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return dotnet.System.Threading.Tasks.Task(hndl : __return);
        }
    }
    // System.Threading.Tasks.Task AuthenticateAsClientAsync(System.String, System.Security.Cryptography.X509Certificates.X509CertificateCollection, bool)
// docid: M:System.Net.Security.SslStream.AuthenticateAsClientAsync(System.String,System.Security.Cryptography.X509Certificates.X509CertificateCollection,System.Boolean)
    /**
    Called by clients to authenticate the server and optionally the client in a client-server connection as an asynchronous operation. The authentication process uses the specified certificate collection and the system default SSL protocol.

    - Parameter targetHost: The name of the server that will share this .
    - Parameter clientCertificates: The  that contains client certificates.
    - Parameter checkCertificateRevocation: A  value that specifies whether the certificate revocation list is checked during authentication.
    - Returns: The task object representing the asynchronous operation.

    */
    open func AuthenticateAsClientAsync(targetHost : dotnet.System.String, clientCertificates : Optional<dotnet.System.Security.Cryptography.X509Certificates.X509CertificateCollection>, checkCertificateRevocation : Bool) throws -> dotnet.System.Threading.Tasks.Task {
        var __thrown : NullableHandle = nil;
        let __return = System_Net_Security_SslStream_Task__AuthenticateAsClientAsync_0__3__String_X509CertificateCollection_bool(&__thrown, self.get_handle(), targetHost.get_handle(), clientCertificates?.get_handle() ?? nil, Swift.Int32(checkCertificateRevocation ? 1 : 0));
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return dotnet.System.Threading.Tasks.Task(hndl : __return);
        }
    }
    // System.Threading.Tasks.Task AuthenticateAsClientAsync(System.String, System.Security.Cryptography.X509Certificates.X509CertificateCollection, System.Security.Authentication.SslProtocols, bool)
// docid: M:System.Net.Security.SslStream.AuthenticateAsClientAsync(System.String,System.Security.Cryptography.X509Certificates.X509CertificateCollection,System.Security.Authentication.SslProtocols,System.Boolean)
    /**
    Called by clients to authenticate the server and optionally the client in a client-server connection as an asynchronous operation. The authentication process uses the specified certificate collection and SSL protocol.

    - Parameter targetHost: The name of the server that will share this .
    - Parameter clientCertificates: The  that contains client certificates.
    - Parameter enabledSslProtocols: The  value that represents protocols used for authentication.
    - Parameter checkCertificateRevocation: A  value that specifies whether the certificate revocation list is checked during authentication.
    - Returns: The task object representing the asynchronous operation.

    */
    open func AuthenticateAsClientAsync(targetHost : dotnet.System.String, clientCertificates : Optional<dotnet.System.Security.Cryptography.X509Certificates.X509CertificateCollection>, enabledSslProtocols : dotnet.System.Security.Authentication.SslProtocols, checkCertificateRevocation : Bool) throws -> dotnet.System.Threading.Tasks.Task {
        var __thrown : NullableHandle = nil;
        let __return = System_Net_Security_SslStream_Task__AuthenticateAsClientAsync_0__4__String_X509CertificateCollection_SslProtocols_bool(&__thrown, self.get_handle(), targetHost.get_handle(), clientCertificates?.get_handle() ?? nil, enabledSslProtocols.get_value(), Swift.Int32(checkCertificateRevocation ? 1 : 0));
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return dotnet.System.Threading.Tasks.Task(hndl : __return);
        }
    }
    // void AuthenticateAsServer(System.Net.Security.SslServerAuthenticationOptions)
// docid: M:System.Net.Security.SslStream.AuthenticateAsServer(System.Net.Security.SslServerAuthenticationOptions)
    /**
    Called by servers to authenticate the server and optionally the client in a client-server connection using the specified certificate.

    - Parameter sslServerAuthenticationOptions: The property bag for the SSL connection.
    */
    open func AuthenticateAsServer(sslServerAuthenticationOptions : dotnet.System.Net.Security.SslServerAuthenticationOptions) throws {
        var __thrown : NullableHandle = nil;
        System_Net_Security_SslStream_void__AuthenticateAsServer_0__1__SslServerAuthenticationOptions(&__thrown, self.get_handle(), sslServerAuthenticationOptions.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
            return;
        }
    }
    // void AuthenticateAsServer(System.Security.Cryptography.X509Certificates.X509Certificate)
// docid: M:System.Net.Security.SslStream.AuthenticateAsServer(System.Security.Cryptography.X509Certificates.X509Certificate)
    /**
    Called by servers to authenticate the server and optionally the client in a client-server connection using the specified certificate.

    - Parameter serverCertificate: The certificate used to authenticate the server.
    */
    open func AuthenticateAsServer(serverCertificate : dotnet.System.Security.Cryptography.X509Certificates.X509Certificate) throws {
        var __thrown : NullableHandle = nil;
        System_Net_Security_SslStream_void__AuthenticateAsServer_0__1__X509Certificate(&__thrown, self.get_handle(), serverCertificate.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
            return;
        }
    }
    // void AuthenticateAsServer(System.Security.Cryptography.X509Certificates.X509Certificate, bool, bool)
// docid: M:System.Net.Security.SslStream.AuthenticateAsServer(System.Security.Cryptography.X509Certificates.X509Certificate,System.Boolean,System.Boolean)
    /**
    Called by servers to authenticate the server and optionally the client in a client-server connection using the specified certificates and requirements, and using the system default security protocol.

    - Parameter serverCertificate: The X509Certificate used to authenticate the server.
    - Parameter clientCertificateRequired: A  value that specifies whether the client is asked for a certificate for authentication. Note that this is only a request -- if no certificate is provided, the server still accepts the connection request.
    - Parameter checkCertificateRevocation: A  value that specifies whether the certificate revocation list is checked during authentication.
    */
    open func AuthenticateAsServer(serverCertificate : dotnet.System.Security.Cryptography.X509Certificates.X509Certificate, clientCertificateRequired : Bool, checkCertificateRevocation : Bool) throws {
        var __thrown : NullableHandle = nil;
        System_Net_Security_SslStream_void__AuthenticateAsServer_0__3__X509Certificate_bool_bool(&__thrown, self.get_handle(), serverCertificate.get_handle(), Swift.Int32(clientCertificateRequired ? 1 : 0), Swift.Int32(checkCertificateRevocation ? 1 : 0));
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
            return;
        }
    }
    // void AuthenticateAsServer(System.Security.Cryptography.X509Certificates.X509Certificate, bool, System.Security.Authentication.SslProtocols, bool)
// docid: M:System.Net.Security.SslStream.AuthenticateAsServer(System.Security.Cryptography.X509Certificates.X509Certificate,System.Boolean,System.Security.Authentication.SslProtocols,System.Boolean)
    /**
    Called by servers to authenticate the server and optionally the client in a client-server connection using the specified certificates, requirements and security protocol.

    - Parameter serverCertificate: The X509Certificate used to authenticate the server.
    - Parameter clientCertificateRequired: A  value that specifies whether the client is asked for a certificate for authentication. Note that this is only a request -- if no certificate is provided, the server still accepts the connection request.
    - Parameter enabledSslProtocols: The  value that represents protocols used for authentication.
    - Parameter checkCertificateRevocation: A  value that specifies whether the certificate revocation list is checked during authentication.
    */
    open func AuthenticateAsServer(serverCertificate : dotnet.System.Security.Cryptography.X509Certificates.X509Certificate, clientCertificateRequired : Bool, enabledSslProtocols : dotnet.System.Security.Authentication.SslProtocols, checkCertificateRevocation : Bool) throws {
        var __thrown : NullableHandle = nil;
        System_Net_Security_SslStream_void__AuthenticateAsServer_0__4__X509Certificate_bool_SslProtocols_bool(&__thrown, self.get_handle(), serverCertificate.get_handle(), Swift.Int32(clientCertificateRequired ? 1 : 0), enabledSslProtocols.get_value(), Swift.Int32(checkCertificateRevocation ? 1 : 0));
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
            return;
        }
    }
    // System.Threading.Tasks.Task AuthenticateAsServerAsync(System.Net.Security.SslServerAuthenticationOptions, System.Threading.CancellationToken)
// docid: M:System.Net.Security.SslStream.AuthenticateAsServerAsync(System.Net.Security.SslServerAuthenticationOptions,System.Threading.CancellationToken)
    /**
    Called by servers to authenticate the server and optionally the client in a client-server connection as an asynchronous operation. The authentication process uses information specified in the  property bag.

    - Parameter sslServerAuthenticationOptions: The property bag for the SSL connection.
    - Parameter cancellationToken: The token to monitor for cancellation requests.
    - Returns: The task object representing the asynchronous operation.

    */
    open func AuthenticateAsServerAsync(sslServerAuthenticationOptions : dotnet.System.Net.Security.SslServerAuthenticationOptions, cancellationToken : dotnet.System.Threading.CancellationToken = System.Threading.CancellationToken.None) throws -> dotnet.System.Threading.Tasks.Task {
        var __thrown : NullableHandle = nil;
        let __return = System_Net_Security_SslStream_Task__AuthenticateAsServerAsync_0__2__SslServerAuthenticationOptions_CancellationToken(&__thrown, self.get_handle(), sslServerAuthenticationOptions.get_handle(), cancellationToken.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return dotnet.System.Threading.Tasks.Task(hndl : __return);
        }
    }
    // System.Threading.Tasks.Task AuthenticateAsServerAsync(System.Security.Cryptography.X509Certificates.X509Certificate)
// docid: M:System.Net.Security.SslStream.AuthenticateAsServerAsync(System.Security.Cryptography.X509Certificates.X509Certificate)
    /**
    Called by servers to authenticate the server and optionally the client in a client-server connection using the specified certificate as an asynchronous operation.

    - Parameter serverCertificate: The certificate used to authenticate the server.
    - Returns: The task object representing the asynchronous operation.

    */
    open func AuthenticateAsServerAsync(serverCertificate : dotnet.System.Security.Cryptography.X509Certificates.X509Certificate) throws -> dotnet.System.Threading.Tasks.Task {
        var __thrown : NullableHandle = nil;
        let __return = System_Net_Security_SslStream_Task__AuthenticateAsServerAsync_0__1__X509Certificate(&__thrown, self.get_handle(), serverCertificate.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return dotnet.System.Threading.Tasks.Task(hndl : __return);
        }
    }
    // System.Threading.Tasks.Task AuthenticateAsServerAsync(System.Security.Cryptography.X509Certificates.X509Certificate, bool, bool)
// docid: M:System.Net.Security.SslStream.AuthenticateAsServerAsync(System.Security.Cryptography.X509Certificates.X509Certificate,System.Boolean,System.Boolean)
    /**
    Called by servers to authenticate the server and optionally the client in a client-server connection using the specified certificates, requirements and security protocol as an asynchronous operation.

    - Parameter serverCertificate: The X509Certificate used to authenticate the server.
    - Parameter clientCertificateRequired: A  value that specifies whether the client is asked for a certificate for authentication. Note that this is only a request -- if no certificate is provided, the server still accepts the connection request.
    - Parameter checkCertificateRevocation: A  value that specifies whether the certificate revocation list is checked during authentication.
    - Returns: The task object representing the asynchronous operation.

    */
    open func AuthenticateAsServerAsync(serverCertificate : dotnet.System.Security.Cryptography.X509Certificates.X509Certificate, clientCertificateRequired : Bool, checkCertificateRevocation : Bool) throws -> dotnet.System.Threading.Tasks.Task {
        var __thrown : NullableHandle = nil;
        let __return = System_Net_Security_SslStream_Task__AuthenticateAsServerAsync_0__3__X509Certificate_bool_bool(&__thrown, self.get_handle(), serverCertificate.get_handle(), Swift.Int32(clientCertificateRequired ? 1 : 0), Swift.Int32(checkCertificateRevocation ? 1 : 0));
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return dotnet.System.Threading.Tasks.Task(hndl : __return);
        }
    }
    // System.Threading.Tasks.Task AuthenticateAsServerAsync(System.Security.Cryptography.X509Certificates.X509Certificate, bool, System.Security.Authentication.SslProtocols, bool)
// docid: M:System.Net.Security.SslStream.AuthenticateAsServerAsync(System.Security.Cryptography.X509Certificates.X509Certificate,System.Boolean,System.Security.Authentication.SslProtocols,System.Boolean)
    /**
    Called by servers to authenticate the server and optionally the client in a client-server connection using the specified certificates, requirements and security protocol as an asynchronous operation.

    - Parameter serverCertificate: The X509Certificate used to authenticate the server.
    - Parameter clientCertificateRequired: A  value that specifies whether the client is asked for a certificate for authentication. Note that this is only a request -- if no certificate is provided, the server still accepts the connection request.
    - Parameter enabledSslProtocols: The  value that represents protocols used for authentication.
    - Parameter checkCertificateRevocation: A  value that specifies whether the certificate revocation list is checked during authentication.
    - Returns: The task object representing the asynchronous operation.

    */
    open func AuthenticateAsServerAsync(serverCertificate : dotnet.System.Security.Cryptography.X509Certificates.X509Certificate, clientCertificateRequired : Bool, enabledSslProtocols : dotnet.System.Security.Authentication.SslProtocols, checkCertificateRevocation : Bool) throws -> dotnet.System.Threading.Tasks.Task {
        var __thrown : NullableHandle = nil;
        let __return = System_Net_Security_SslStream_Task__AuthenticateAsServerAsync_0__4__X509Certificate_bool_SslProtocols_bool(&__thrown, self.get_handle(), serverCertificate.get_handle(), Swift.Int32(clientCertificateRequired ? 1 : 0), enabledSslProtocols.get_value(), Swift.Int32(checkCertificateRevocation ? 1 : 0));
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return dotnet.System.Threading.Tasks.Task(hndl : __return);
        }
    }
    // System.Threading.Tasks.Task AuthenticateAsServerAsync(System.Net.Security.ServerOptionsSelectionCallback, System.Object, System.Threading.CancellationToken)
// docid: M:System.Net.Security.SslStream.AuthenticateAsServerAsync(System.Net.Security.ServerOptionsSelectionCallback,System.Object,System.Threading.CancellationToken)
    /**
    Called by servers to authenticate the server and optionally the client in a client-server connection as an asynchronous operation. The authentication process uses information returned by .

    - Parameter optionsCallback: The callback delegate.
    - Parameter state: The state object to pass to  when the callback is invoked.
    - Parameter cancellationToken: The token to monitor for cancellation requests.
    - Returns: The task object representing the asynchronous operation.

    */
    open func AuthenticateAsServerAsync(optionsCallback : dotnet.System.Net.Security.ServerOptionsSelectionCallback, state : Optional<dotnet.System.Object>, cancellationToken : dotnet.System.Threading.CancellationToken = System.Threading.CancellationToken.None) throws -> dotnet.System.Threading.Tasks.Task {
        var __thrown : NullableHandle = nil;
        let __return = System_Net_Security_SslStream_Task__AuthenticateAsServerAsync_0__3__ServerOptionsSelectionCallback_Object_CancellationToken(&__thrown, self.get_handle(), optionsCallback.get_handle(), state?.get_handle() ?? nil, cancellationToken.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return dotnet.System.Threading.Tasks.Task(hndl : __return);
        }
    }
    // delegate closure overload
    open func AuthenticateAsServerAsync(optionsCallback : @escaping (dotnet.System.Net.Security.SslStream, dotnet.System.Net.Security.SslClientHelloInfo, Optional<dotnet.System.Object>, dotnet.System.Threading.CancellationToken) throws -> dotnet.System.Threading.Tasks.ValueTask_1<dotnet.System.Net.Security.SslServerAuthenticationOptions>, state : Optional<dotnet.System.Object>, cancellationToken : dotnet.System.Threading.CancellationToken) throws -> dotnet.System.Threading.Tasks.Task {
        let del_optionsCallback = try dotnet.System.Net.Security.ServerOptionsSelectionCallback(optionsCallback);
        return try AuthenticateAsServerAsync(optionsCallback: del_optionsCallback, state: state, cancellationToken: cancellationToken);
    }
    // System.IAsyncResult BeginAuthenticateAsClient(System.String, System.AsyncCallback, System.Object)
// docid: M:System.Net.Security.SslStream.BeginAuthenticateAsClient(System.String,System.AsyncCallback,System.Object)
    /**
    Called by clients to begin an asynchronous operation to authenticate the server and optionally the client.

    - Parameter targetHost: The name of the server that shares this .
    - Parameter asyncCallback: An  delegate that references the method to invoke when the authentication is complete.
    - Parameter asyncState: A user-defined object that contains information about the operation. This object is passed to the  delegate when the operation completes.
    - Returns: An  object that indicates the status of the asynchronous operation.

    */
    open func BeginAuthenticateAsClient(targetHost : dotnet.System.String, asyncCallback : Optional<dotnet.System.AsyncCallback>, asyncState : Optional<dotnet.System.Object>) throws -> dotnet.System.IAsyncResult {
        var __thrown : NullableHandle = nil;
        let __return = System_Net_Security_SslStream_IAsyncResult__BeginAuthenticateAsClient_0__3__String_AsyncCallback_Object(&__thrown, self.get_handle(), targetHost.get_handle(), asyncCallback?.get_handle() ?? nil, asyncState?.get_handle() ?? nil);
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return dotnet.System.IAsyncResult(hndl : __return);
        }
    }
    // delegate closure overload
    open func BeginAuthenticateAsClient(targetHost : dotnet.System.String, asyncCallback : @escaping (dotnet.System.IAsyncResult) throws -> Void, asyncState : Optional<dotnet.System.Object>) throws -> dotnet.System.IAsyncResult {
        let del_asyncCallback = try dotnet.System.AsyncCallback(asyncCallback);
        return try BeginAuthenticateAsClient(targetHost: targetHost, asyncCallback: del_asyncCallback, asyncState: asyncState);
    }
    // System.IAsyncResult BeginAuthenticateAsClient(System.String, System.Security.Cryptography.X509Certificates.X509CertificateCollection, bool, System.AsyncCallback, System.Object)
// docid: M:System.Net.Security.SslStream.BeginAuthenticateAsClient(System.String,System.Security.Cryptography.X509Certificates.X509CertificateCollection,System.Boolean,System.AsyncCallback,System.Object)
    /**
    Called by clients to begin an asynchronous operation to authenticate the server and optionally the client using the specified certificates and the system default security protocol.

    - Parameter targetHost: The name of the server that shares this .
    - Parameter clientCertificates: The  containing client certificates.
    - Parameter checkCertificateRevocation: A  value that specifies whether the certificate revocation list is checked during authentication.
    - Parameter asyncCallback: An  delegate that references the method to invoke when the authentication is complete.
    - Parameter asyncState: A user-defined object that contains information about the operation. This object is passed to the  delegate when the operation completes.
    - Returns: An  object that indicates the status of the asynchronous operation.

    */
    open func BeginAuthenticateAsClient(targetHost : dotnet.System.String, clientCertificates : Optional<dotnet.System.Security.Cryptography.X509Certificates.X509CertificateCollection>, checkCertificateRevocation : Bool, asyncCallback : Optional<dotnet.System.AsyncCallback>, asyncState : Optional<dotnet.System.Object>) throws -> dotnet.System.IAsyncResult {
        var __thrown : NullableHandle = nil;
        let __return = System_Net_Security_SslStream_IAsyncResult__BeginAuthenticateAsClient_0__5__String_X509CertificateCollection_bool_AsyncCallback_Object(&__thrown, self.get_handle(), targetHost.get_handle(), clientCertificates?.get_handle() ?? nil, Swift.Int32(checkCertificateRevocation ? 1 : 0), asyncCallback?.get_handle() ?? nil, asyncState?.get_handle() ?? nil);
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return dotnet.System.IAsyncResult(hndl : __return);
        }
    }
    // delegate closure overload
    open func BeginAuthenticateAsClient(targetHost : dotnet.System.String, clientCertificates : Optional<dotnet.System.Security.Cryptography.X509Certificates.X509CertificateCollection>, checkCertificateRevocation : Bool, asyncCallback : @escaping (dotnet.System.IAsyncResult) throws -> Void, asyncState : Optional<dotnet.System.Object>) throws -> dotnet.System.IAsyncResult {
        let del_asyncCallback = try dotnet.System.AsyncCallback(asyncCallback);
        return try BeginAuthenticateAsClient(targetHost: targetHost, clientCertificates: clientCertificates, checkCertificateRevocation: checkCertificateRevocation, asyncCallback: del_asyncCallback, asyncState: asyncState);
    }
    // System.IAsyncResult BeginAuthenticateAsClient(System.String, System.Security.Cryptography.X509Certificates.X509CertificateCollection, System.Security.Authentication.SslProtocols, bool, System.AsyncCallback, System.Object)
// docid: M:System.Net.Security.SslStream.BeginAuthenticateAsClient(System.String,System.Security.Cryptography.X509Certificates.X509CertificateCollection,System.Security.Authentication.SslProtocols,System.Boolean,System.AsyncCallback,System.Object)
    /**
    Called by clients to begin an asynchronous operation to authenticate the server and optionally the client using the specified certificates and security protocol.

    - Parameter targetHost: The name of the server that shares this .
    - Parameter clientCertificates: The  containing client certificates.
    - Parameter enabledSslProtocols: The  value that represents protocols used for authentication.
    - Parameter checkCertificateRevocation: A  value that specifies whether the certificate revocation list is checked during authentication.
    - Parameter asyncCallback: An  delegate that references the method to invoke when the authentication is complete.
    - Parameter asyncState: A user-defined object that contains information about the operation. This object is passed to the  delegate when the operation completes.
    - Returns: An  object that indicates the status of the asynchronous operation.

    */
    open func BeginAuthenticateAsClient(targetHost : dotnet.System.String, clientCertificates : Optional<dotnet.System.Security.Cryptography.X509Certificates.X509CertificateCollection>, enabledSslProtocols : dotnet.System.Security.Authentication.SslProtocols, checkCertificateRevocation : Bool, asyncCallback : Optional<dotnet.System.AsyncCallback>, asyncState : Optional<dotnet.System.Object>) throws -> dotnet.System.IAsyncResult {
        var __thrown : NullableHandle = nil;
        let __return = System_Net_Security_SslStream_IAsyncResult__BeginAuthenticateAsClient_0__6__String_X509CertificateCollection_SslProtocols_bool_AsyncCallback_Object(&__thrown, self.get_handle(), targetHost.get_handle(), clientCertificates?.get_handle() ?? nil, enabledSslProtocols.get_value(), Swift.Int32(checkCertificateRevocation ? 1 : 0), asyncCallback?.get_handle() ?? nil, asyncState?.get_handle() ?? nil);
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return dotnet.System.IAsyncResult(hndl : __return);
        }
    }
    // delegate closure overload
    open func BeginAuthenticateAsClient(targetHost : dotnet.System.String, clientCertificates : Optional<dotnet.System.Security.Cryptography.X509Certificates.X509CertificateCollection>, enabledSslProtocols : dotnet.System.Security.Authentication.SslProtocols, checkCertificateRevocation : Bool, asyncCallback : @escaping (dotnet.System.IAsyncResult) throws -> Void, asyncState : Optional<dotnet.System.Object>) throws -> dotnet.System.IAsyncResult {
        let del_asyncCallback = try dotnet.System.AsyncCallback(asyncCallback);
        return try BeginAuthenticateAsClient(targetHost: targetHost, clientCertificates: clientCertificates, enabledSslProtocols: enabledSslProtocols, checkCertificateRevocation: checkCertificateRevocation, asyncCallback: del_asyncCallback, asyncState: asyncState);
    }
    // System.IAsyncResult BeginAuthenticateAsServer(System.Security.Cryptography.X509Certificates.X509Certificate, System.AsyncCallback, System.Object)
// docid: M:System.Net.Security.SslStream.BeginAuthenticateAsServer(System.Security.Cryptography.X509Certificates.X509Certificate,System.AsyncCallback,System.Object)
    /**
    Called by servers to begin an asynchronous operation to authenticate the client and optionally the server in a client-server connection.

    - Parameter serverCertificate: The X509Certificate used to authenticate the server.
    - Parameter asyncCallback: An  delegate that references the method to invoke when the authentication is complete.
    - Parameter asyncState: A user-defined object that contains information about the operation. This object is passed to the  delegate when the operation completes.
    - Returns: An  object indicating the status of the asynchronous operation.

    */
    open func BeginAuthenticateAsServer(serverCertificate : dotnet.System.Security.Cryptography.X509Certificates.X509Certificate, asyncCallback : Optional<dotnet.System.AsyncCallback>, asyncState : Optional<dotnet.System.Object>) throws -> dotnet.System.IAsyncResult {
        var __thrown : NullableHandle = nil;
        let __return = System_Net_Security_SslStream_IAsyncResult__BeginAuthenticateAsServer_0__3__X509Certificate_AsyncCallback_Object(&__thrown, self.get_handle(), serverCertificate.get_handle(), asyncCallback?.get_handle() ?? nil, asyncState?.get_handle() ?? nil);
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return dotnet.System.IAsyncResult(hndl : __return);
        }
    }
    // delegate closure overload
    open func BeginAuthenticateAsServer(serverCertificate : dotnet.System.Security.Cryptography.X509Certificates.X509Certificate, asyncCallback : @escaping (dotnet.System.IAsyncResult) throws -> Void, asyncState : Optional<dotnet.System.Object>) throws -> dotnet.System.IAsyncResult {
        let del_asyncCallback = try dotnet.System.AsyncCallback(asyncCallback);
        return try BeginAuthenticateAsServer(serverCertificate: serverCertificate, asyncCallback: del_asyncCallback, asyncState: asyncState);
    }
    // System.IAsyncResult BeginAuthenticateAsServer(System.Security.Cryptography.X509Certificates.X509Certificate, bool, bool, System.AsyncCallback, System.Object)
// docid: M:System.Net.Security.SslStream.BeginAuthenticateAsServer(System.Security.Cryptography.X509Certificates.X509Certificate,System.Boolean,System.Boolean,System.AsyncCallback,System.Object)
    /**
    Called by servers to begin an asynchronous operation to authenticate the server and optionally the client using the specified certificates and requirements, and the system default security protocol.

    - Parameter serverCertificate: The X509Certificate used to authenticate the server.
    - Parameter clientCertificateRequired: A  value that specifies whether the client is asked for a certificate for authentication. Note that this is only a request -- if no certificate is provided, the server still accepts the connection request.
    - Parameter checkCertificateRevocation: A  value that specifies whether the certificate revocation list is checked during authentication.
    - Parameter asyncCallback: An  delegate that references the method to invoke when the authentication is complete.
    - Parameter asyncState: A user-defined object that contains information about the operation. This object is passed to the  delegate when the operation completes.
    - Returns: An  object that indicates the status of the asynchronous operation.

    */
    open func BeginAuthenticateAsServer(serverCertificate : dotnet.System.Security.Cryptography.X509Certificates.X509Certificate, clientCertificateRequired : Bool, checkCertificateRevocation : Bool, asyncCallback : Optional<dotnet.System.AsyncCallback>, asyncState : Optional<dotnet.System.Object>) throws -> dotnet.System.IAsyncResult {
        var __thrown : NullableHandle = nil;
        let __return = System_Net_Security_SslStream_IAsyncResult__BeginAuthenticateAsServer_0__5__X509Certificate_bool_bool_AsyncCallback_Object(&__thrown, self.get_handle(), serverCertificate.get_handle(), Swift.Int32(clientCertificateRequired ? 1 : 0), Swift.Int32(checkCertificateRevocation ? 1 : 0), asyncCallback?.get_handle() ?? nil, asyncState?.get_handle() ?? nil);
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return dotnet.System.IAsyncResult(hndl : __return);
        }
    }
    // delegate closure overload
    open func BeginAuthenticateAsServer(serverCertificate : dotnet.System.Security.Cryptography.X509Certificates.X509Certificate, clientCertificateRequired : Bool, checkCertificateRevocation : Bool, asyncCallback : @escaping (dotnet.System.IAsyncResult) throws -> Void, asyncState : Optional<dotnet.System.Object>) throws -> dotnet.System.IAsyncResult {
        let del_asyncCallback = try dotnet.System.AsyncCallback(asyncCallback);
        return try BeginAuthenticateAsServer(serverCertificate: serverCertificate, clientCertificateRequired: clientCertificateRequired, checkCertificateRevocation: checkCertificateRevocation, asyncCallback: del_asyncCallback, asyncState: asyncState);
    }
    // System.IAsyncResult BeginAuthenticateAsServer(System.Security.Cryptography.X509Certificates.X509Certificate, bool, System.Security.Authentication.SslProtocols, bool, System.AsyncCallback, System.Object)
// docid: M:System.Net.Security.SslStream.BeginAuthenticateAsServer(System.Security.Cryptography.X509Certificates.X509Certificate,System.Boolean,System.Security.Authentication.SslProtocols,System.Boolean,System.AsyncCallback,System.Object)
    /**
    Called by servers to begin an asynchronous operation to authenticate the server and optionally the client using the specified certificates, requirements and security protocol.

    - Parameter serverCertificate: The X509Certificate used to authenticate the server.
    - Parameter clientCertificateRequired: A  value that specifies whether the client is asked for a certificate for authentication. Note that this is only a request -- if no certificate is provided, the server still accepts the connection request.
    - Parameter enabledSslProtocols: The  value that represents protocols used for authentication.
    - Parameter checkCertificateRevocation: A  value that specifies whether the certificate revocation list is checked during authentication.
    - Parameter asyncCallback: An  delegate that references the method to invoke when the authentication is complete.
    - Parameter asyncState: A user-defined object that contains information about the operation. This object is passed to the  delegate when the operation completes.
    - Returns: An  object that indicates the status of the asynchronous operation.

    */
    open func BeginAuthenticateAsServer(serverCertificate : dotnet.System.Security.Cryptography.X509Certificates.X509Certificate, clientCertificateRequired : Bool, enabledSslProtocols : dotnet.System.Security.Authentication.SslProtocols, checkCertificateRevocation : Bool, asyncCallback : Optional<dotnet.System.AsyncCallback>, asyncState : Optional<dotnet.System.Object>) throws -> dotnet.System.IAsyncResult {
        var __thrown : NullableHandle = nil;
        let __return = System_Net_Security_SslStream_IAsyncResult__BeginAuthenticateAsServer_0__6__X509Certificate_bool_SslProtocols_bool_AsyncCallback_Object(&__thrown, self.get_handle(), serverCertificate.get_handle(), Swift.Int32(clientCertificateRequired ? 1 : 0), enabledSslProtocols.get_value(), Swift.Int32(checkCertificateRevocation ? 1 : 0), asyncCallback?.get_handle() ?? nil, asyncState?.get_handle() ?? nil);
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return dotnet.System.IAsyncResult(hndl : __return);
        }
    }
    // delegate closure overload
    open func BeginAuthenticateAsServer(serverCertificate : dotnet.System.Security.Cryptography.X509Certificates.X509Certificate, clientCertificateRequired : Bool, enabledSslProtocols : dotnet.System.Security.Authentication.SslProtocols, checkCertificateRevocation : Bool, asyncCallback : @escaping (dotnet.System.IAsyncResult) throws -> Void, asyncState : Optional<dotnet.System.Object>) throws -> dotnet.System.IAsyncResult {
        let del_asyncCallback = try dotnet.System.AsyncCallback(asyncCallback);
        return try BeginAuthenticateAsServer(serverCertificate: serverCertificate, clientCertificateRequired: clientCertificateRequired, enabledSslProtocols: enabledSslProtocols, checkCertificateRevocation: checkCertificateRevocation, asyncCallback: del_asyncCallback, asyncState: asyncState);
    }
    // System.IAsyncResult BeginRead(System.Byte[], System.Int32, System.Int32, System.AsyncCallback, System.Object)
// docid: M:System.Net.Security.SslStream.BeginRead(System.Byte[],System.Int32,System.Int32,System.AsyncCallback,System.Object)
    /**
    Begins an asynchronous read operation that reads data from the stream and stores it in the specified array.

    - Parameter buffer: A  array that receives the bytes read from the stream.
    - Parameter offset: The zero-based location in  at which to begin storing the data read from this stream.
    - Parameter count: The maximum number of bytes to read from the stream.
    - Parameter asyncCallback: An  delegate that references the method to invoke when the read operation is complete.
    - Parameter asyncState: A user-defined object that contains information about the read operation. This object is passed to the  delegate when the operation completes.
    - Returns: An  object that indicates the status of the asynchronous operation.

    */
    open func BeginRead(buffer : dotnet.System_Arr<Swift.UInt8>, offset : Swift.Int32, count : Swift.Int32, asyncCallback : Optional<dotnet.System.AsyncCallback>, asyncState : Optional<dotnet.System.Object>) throws -> dotnet.System.IAsyncResult {
        var __thrown : NullableHandle = nil;
        let __return = System_Net_Security_SslStream_IAsyncResult__BeginRead_0__5__u8Array_i32_i32_AsyncCallback_Object(&__thrown, self.get_handle(), buffer.get_handle(), offset, count, asyncCallback?.get_handle() ?? nil, asyncState?.get_handle() ?? nil);
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return dotnet.System.IAsyncResult(hndl : __return);
        }
    }
    // delegate closure overload
    open func BeginRead(buffer : dotnet.System_Arr<Swift.UInt8>, offset : Swift.Int32, count : Swift.Int32, asyncCallback : @escaping (dotnet.System.IAsyncResult) throws -> Void, asyncState : Optional<dotnet.System.Object>) throws -> dotnet.System.IAsyncResult {
        let del_asyncCallback = try dotnet.System.AsyncCallback(asyncCallback);
        return try BeginRead(buffer: buffer, offset: offset, count: count, asyncCallback: del_asyncCallback, asyncState: asyncState);
    }
    // System.IAsyncResult BeginWrite(System.Byte[], System.Int32, System.Int32, System.AsyncCallback, System.Object)
// docid: M:System.Net.Security.SslStream.BeginWrite(System.Byte[],System.Int32,System.Int32,System.AsyncCallback,System.Object)
    /**
    Begins an asynchronous write operation that writes s from the specified buffer to the stream.

    - Parameter buffer: A  array that supplies the bytes to be written to the stream.
    - Parameter offset: The zero-based location in  at which to begin reading bytes to be written to the stream.
    - Parameter count: An  value that specifies the number of bytes to read from .
    - Parameter asyncCallback: An  delegate that references the method to invoke when the write operation is complete.
    - Parameter asyncState: A user-defined object that contains information about the write operation. This object is passed to the  delegate when the operation completes.
    - Returns: An  object indicating the status of the asynchronous operation.

    */
    open func BeginWrite(buffer : dotnet.System_Arr<Swift.UInt8>, offset : Swift.Int32, count : Swift.Int32, asyncCallback : Optional<dotnet.System.AsyncCallback>, asyncState : Optional<dotnet.System.Object>) throws -> dotnet.System.IAsyncResult {
        var __thrown : NullableHandle = nil;
        let __return = System_Net_Security_SslStream_IAsyncResult__BeginWrite_0__5__u8Array_i32_i32_AsyncCallback_Object(&__thrown, self.get_handle(), buffer.get_handle(), offset, count, asyncCallback?.get_handle() ?? nil, asyncState?.get_handle() ?? nil);
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return dotnet.System.IAsyncResult(hndl : __return);
        }
    }
    // delegate closure overload
    open func BeginWrite(buffer : dotnet.System_Arr<Swift.UInt8>, offset : Swift.Int32, count : Swift.Int32, asyncCallback : @escaping (dotnet.System.IAsyncResult) throws -> Void, asyncState : Optional<dotnet.System.Object>) throws -> dotnet.System.IAsyncResult {
        let del_asyncCallback = try dotnet.System.AsyncCallback(asyncCallback);
        return try BeginWrite(buffer: buffer, offset: offset, count: count, asyncCallback: del_asyncCallback, asyncState: asyncState);
    }
    // System.Threading.Tasks.ValueTask DisposeAsync()
// docid: M:System.Net.Security.SslStream.DisposeAsync
    /**
    Asynchronously releases the unmanaged and managed resources used by the .

    - Returns: A task that represents the asynchronous dispose operation.

    */
    open override func DisposeAsync() throws -> dotnet.System.Threading.Tasks.ValueTask {
        var __thrown : NullableHandle = nil;
        let __return = System_Net_Security_SslStream_ValueTask__DisposeAsync_0__0(&__thrown, self.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return dotnet.System.Threading.Tasks.ValueTask(hndl : __return);
        }
    }
    // void EndAuthenticateAsClient(System.IAsyncResult)
// docid: M:System.Net.Security.SslStream.EndAuthenticateAsClient(System.IAsyncResult)
    /**
    Ends a pending asynchronous server authentication operation started with a previous call to .

    - Parameter asyncResult: An  instance returned by a call to .
    */
    open func EndAuthenticateAsClient(asyncResult : dotnet.System.IAsyncResult) throws {
        var __thrown : NullableHandle = nil;
        System_Net_Security_SslStream_void__EndAuthenticateAsClient_0__1__IAsyncResult(&__thrown, self.get_handle(), asyncResult.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
            return;
        }
    }
    // void EndAuthenticateAsServer(System.IAsyncResult)
// docid: M:System.Net.Security.SslStream.EndAuthenticateAsServer(System.IAsyncResult)
    /**
    Ends a pending asynchronous client authentication operation started with a previous call to .

    - Parameter asyncResult: An  instance returned by a call to .
    */
    open func EndAuthenticateAsServer(asyncResult : dotnet.System.IAsyncResult) throws {
        var __thrown : NullableHandle = nil;
        System_Net_Security_SslStream_void__EndAuthenticateAsServer_0__1__IAsyncResult(&__thrown, self.get_handle(), asyncResult.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
            return;
        }
    }
    // System.Int32 EndRead(System.IAsyncResult)
// docid: M:System.Net.Security.SslStream.EndRead(System.IAsyncResult)
    /**
    Ends an asynchronous read operation started with a previous call to .

    - Parameter asyncResult: An  instance returned by a call to 
    - Returns: A  value that specifies the number of bytes read from the underlying stream.

    */
    open override func EndRead(asyncResult : dotnet.System.IAsyncResult) throws -> Swift.Int32 {
        var __thrown : NullableHandle = nil;
        let __return = System_Net_Security_SslStream_i32__EndRead_0__1__IAsyncResult(&__thrown, self.get_handle(), asyncResult.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return __return;
        }
    }
    // void EndWrite(System.IAsyncResult)
// docid: M:System.Net.Security.SslStream.EndWrite(System.IAsyncResult)
    /**
    Ends an asynchronous write operation started with a previous call to .

    - Parameter asyncResult: An  instance returned by a call to 
    */
    open override func EndWrite(asyncResult : dotnet.System.IAsyncResult) throws {
        var __thrown : NullableHandle = nil;
        System_Net_Security_SslStream_void__EndWrite_0__1__IAsyncResult(&__thrown, self.get_handle(), asyncResult.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
            return;
        }
    }
    // void Flush()
// docid: M:System.Net.Security.SslStream.Flush
    /**
    Causes any buffered data to be written to the underlying device.

    */
    open override func Flush() throws {
        var __thrown : NullableHandle = nil;
        System_Net_Security_SslStream_void__Flush_0__0(&__thrown, self.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
            return;
        }
    }
    // System.Threading.Tasks.Task FlushAsync(System.Threading.CancellationToken)
// docid: M:System.Net.Security.SslStream.FlushAsync(System.Threading.CancellationToken)
    /**
    Asynchronously writes any buffered data to the underlying device.

    - Parameter cancellationToken: The token to monitor for cancellation requests.
    - Returns: A task that represents the asynchronous flush operation.

    */
    open override func FlushAsync(cancellationToken : dotnet.System.Threading.CancellationToken) throws -> dotnet.System.Threading.Tasks.Task {
        var __thrown : NullableHandle = nil;
        let __return = System_Net_Security_SslStream_Task__FlushAsync_0__1__CancellationToken(&__thrown, self.get_handle(), cancellationToken.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return dotnet.System.Threading.Tasks.Task(hndl : __return);
        }
    }
    // System.Threading.Tasks.Task NegotiateClientCertificateAsync(System.Threading.CancellationToken)
// docid: M:System.Net.Security.SslStream.NegotiateClientCertificateAsync(System.Threading.CancellationToken)
    open func NegotiateClientCertificateAsync(cancellationToken : dotnet.System.Threading.CancellationToken = System.Threading.CancellationToken.None) throws -> dotnet.System.Threading.Tasks.Task {
        var __thrown : NullableHandle = nil;
        let __return = System_Net_Security_SslStream_Task__NegotiateClientCertificateAsync_0__1__CancellationToken(&__thrown, self.get_handle(), cancellationToken.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return dotnet.System.Threading.Tasks.Task(hndl : __return);
        }
    }
    // System.Int32 Read(System.Byte[], System.Int32, System.Int32)
// docid: M:System.Net.Security.SslStream.Read(System.Byte[],System.Int32,System.Int32)
    /**
    Reads data from this stream and stores it in the specified array.

    - Parameter buffer: A  array that receives the bytes read from this stream.
    - Parameter offset: A  that contains the zero-based location in  at which to begin storing the data read from this stream.
    - Parameter count: A  that contains the maximum number of bytes to read from this stream.
    - Returns: A  value that specifies the number of bytes read. When there is no more data to be read, returns 0.

    */
    open override func Read(buffer : dotnet.System_Arr<Swift.UInt8>, offset : Swift.Int32, count : Swift.Int32) throws -> Swift.Int32 {
        var __thrown : NullableHandle = nil;
        let __return = System_Net_Security_SslStream_i32__Read_0__3__u8Array_i32_i32(&__thrown, self.get_handle(), buffer.get_handle(), offset, count);
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return __return;
        }
    }
    // System.Threading.Tasks.Task<System.Int32> ReadAsync(System.Byte[], System.Int32, System.Int32, System.Threading.CancellationToken)
// docid: M:System.Net.Security.SslStream.ReadAsync(System.Byte[],System.Int32,System.Int32,System.Threading.CancellationToken)
    /**
    Asynchronously reads data from this stream and stores it in the specified range of a byte array.

    - Parameter buffer: The buffer that receives the bytes read from this stream.
    - Parameter offset: The zero-based location in  at which to begin storing the data read from this stream.
    - Parameter count: The maximum number of bytes to read from this stream.
    - Parameter cancellationToken: The token to monitor for cancellation requests.
    - Returns: A task that represents the asynchronous read operation. The value of its  property contains the total number of bytes read into . When there is no more data to be read, returns 0.

    */
    open override func ReadAsync(buffer : dotnet.System_Arr<Swift.UInt8>, offset : Swift.Int32, count : Swift.Int32, cancellationToken : dotnet.System.Threading.CancellationToken) throws -> dotnet.System.Threading.Tasks.Task_1<Swift.Int32> {
        var __thrown : NullableHandle = nil;
        let __return = System_Net_Security_SslStream_System_Threading_Tasks_Task_i32___ReadAsync_0__4__u8Array_i32_i32_CancellationToken(&__thrown, self.get_handle(), buffer.get_handle(), offset, count, cancellationToken.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return dotnet.System.Threading.Tasks.Task_1(hndl : __return);
        }
    }
    // System.Threading.Tasks.ValueTask<System.Int32> ReadAsync(System.Memory<System.Byte>, System.Threading.CancellationToken)
// docid: M:System.Net.Security.SslStream.ReadAsync(System.Memory{System.Byte},System.Threading.CancellationToken)
    /**
    Asynchronously reads data from this stream and stores it in the specified memory range.

    - Parameter buffer: The buffer that receives the bytes read from this stream.
    - Parameter cancellationToken: The token to monitor for cancellation requests.
    - Returns: A task that represents the asynchronous read operation. The value of its  property contains the total number of bytes read into . When there is no more data to be read, returns 0.

    */
    open override func ReadAsync(buffer : dotnet.System.Memory_1<Swift.UInt8>, cancellationToken : dotnet.System.Threading.CancellationToken = System.Threading.CancellationToken.None) throws -> dotnet.System.Threading.Tasks.ValueTask_1<Swift.Int32> {
        var __thrown : NullableHandle = nil;
        let __return = System_Net_Security_SslStream_System_Threading_Tasks_ValueTask_i32___ReadAsync_0__2__System_Memory_u8__CancellationToken(&__thrown, self.get_handle(), buffer.get_handle(), cancellationToken.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return dotnet.System.Threading.Tasks.ValueTask_1(hndl : __return);
        }
    }
    // System.Int32 ReadByte()
// docid: M:System.Net.Security.SslStream.ReadByte
    /**
    Reads a byte from the  and advances the position within the stream by one byte, or returns -1 if at the end of the stream.

    - Returns: The unsigned byte cast to an , or -1 if at the end of the stream.

    */
    open override func ReadByte() throws -> Swift.Int32 {
        var __thrown : NullableHandle = nil;
        let __return = System_Net_Security_SslStream_i32__ReadByte_0__0(&__thrown, self.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return __return;
        }
    }
    // System.Int64 Seek(System.Int64, System.IO.SeekOrigin)
// docid: M:System.Net.Security.SslStream.Seek(System.Int64,System.IO.SeekOrigin)
    /**
    Throws a .

    - Parameter offset: This value is ignored.
    - Parameter origin: This value is ignored.
    - Returns: Always throws a .

    */
    open override func Seek(offset : Swift.Int64, origin : dotnet.System.IO.SeekOrigin) throws -> Swift.Int64 {
        var __thrown : NullableHandle = nil;
        let __return = System_Net_Security_SslStream_i64__Seek_0__2__i64_SeekOrigin(&__thrown, self.get_handle(), offset, origin.get_value());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return __return;
        }
    }
    // void SetLength(System.Int64)
// docid: M:System.Net.Security.SslStream.SetLength(System.Int64)
    /**
    Sets the length of the underlying stream.

    - Parameter value: An  value that specifies the length of the stream.
    */
    open override func SetLength(value : Swift.Int64) throws {
        var __thrown : NullableHandle = nil;
        System_Net_Security_SslStream_void__SetLength_0__1__i64(&__thrown, self.get_handle(), value);
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
            return;
        }
    }
    // System.Threading.Tasks.Task ShutdownAsync()
// docid: M:System.Net.Security.SslStream.ShutdownAsync
    /**
    Shuts down this SslStream.

    - Returns: The task object representing the asynchronous operation.

    */
    open func ShutdownAsync() throws -> dotnet.System.Threading.Tasks.Task {
        var __thrown : NullableHandle = nil;
        let __return = System_Net_Security_SslStream_Task__ShutdownAsync_0__0(&__thrown, self.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return dotnet.System.Threading.Tasks.Task(hndl : __return);
        }
    }
    // void Write(System.Byte[])
// docid: M:System.Net.Security.SslStream.Write(System.Byte[])
    /**
    Writes the specified data to this stream.

    - Parameter buffer: A  array that supplies the bytes written to the stream.
    */
    open func Write(buffer : dotnet.System_Arr<Swift.UInt8>) throws {
        var __thrown : NullableHandle = nil;
        System_Net_Security_SslStream_void__Write_0__1__u8Array(&__thrown, self.get_handle(), buffer.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
            return;
        }
    }
    // void Write(System.Byte[], System.Int32, System.Int32)
// docid: M:System.Net.Security.SslStream.Write(System.Byte[],System.Int32,System.Int32)
    /**
    Write the specified number of s to the underlying stream using the specified buffer and offset.

    - Parameter buffer: A  array that supplies the bytes written to the stream.
    - Parameter offset: A  that contains the zero-based location in  at which to begin reading bytes to be written to the stream.
    - Parameter count: A  that contains the number of bytes to read from .
    */
    open override func Write(buffer : dotnet.System_Arr<Swift.UInt8>, offset : Swift.Int32, count : Swift.Int32) throws {
        var __thrown : NullableHandle = nil;
        System_Net_Security_SslStream_void__Write_0__3__u8Array_i32_i32(&__thrown, self.get_handle(), buffer.get_handle(), offset, count);
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
            return;
        }
    }
    // System.Threading.Tasks.Task WriteAsync(System.Byte[], System.Int32, System.Int32, System.Threading.CancellationToken)
// docid: M:System.Net.Security.SslStream.WriteAsync(System.Byte[],System.Int32,System.Int32,System.Threading.CancellationToken)
    /**
    Asynchronously writes data to the underlying stream from the specified range of a byte array.

    - Parameter buffer: The data to write to the underlying stream.
    - Parameter offset: The location in  from which to start writing data.
    - Parameter count: The number of bytes to write to the underlying stream.
    - Parameter cancellationToken: The token to monitor for cancellation requests.
    - Returns: A task that represents the asynchronous write operation.

    */
    open override func WriteAsync(buffer : dotnet.System_Arr<Swift.UInt8>, offset : Swift.Int32, count : Swift.Int32, cancellationToken : dotnet.System.Threading.CancellationToken) throws -> dotnet.System.Threading.Tasks.Task {
        var __thrown : NullableHandle = nil;
        let __return = System_Net_Security_SslStream_Task__WriteAsync_0__4__u8Array_i32_i32_CancellationToken(&__thrown, self.get_handle(), buffer.get_handle(), offset, count, cancellationToken.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return dotnet.System.Threading.Tasks.Task(hndl : __return);
        }
    }
    // System.Threading.Tasks.ValueTask WriteAsync(System.ReadOnlyMemory<System.Byte>, System.Threading.CancellationToken)
// docid: M:System.Net.Security.SslStream.WriteAsync(System.ReadOnlyMemory{System.Byte},System.Threading.CancellationToken)
    /**
    Asynchronously writes data to the underlying stream from a read-only byte memory range.

    - Parameter buffer: The data to write to the underlying stream.
    - Parameter cancellationToken: The token to monitor for cancellation requests.
    - Returns: A task that represents the asynchronous write operation.

    */
    open override func WriteAsync(buffer : dotnet.System.ReadOnlyMemory_1<Swift.UInt8>, cancellationToken : dotnet.System.Threading.CancellationToken = System.Threading.CancellationToken.None) throws -> dotnet.System.Threading.Tasks.ValueTask {
        var __thrown : NullableHandle = nil;
        let __return = System_Net_Security_SslStream_ValueTask__WriteAsync_0__2__System_ReadOnlyMemory_u8__CancellationToken(&__thrown, self.get_handle(), buffer.get_handle(), cancellationToken.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return dotnet.System.Threading.Tasks.ValueTask(hndl : __return);
        }
    }
    // [IsSpecialName] bool get_CanRead()
// docid: M:System.Net.Security.SslStream.get_CanRead
    open override func get_CanRead() throws -> Bool {
        var __thrown : NullableHandle = nil;
        let __return = System_Net_Security_SslStream_bool__get_CanRead_0__0(&__thrown, self.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return (__return) != 0;
        }
    }
    // [IsSpecialName] bool get_CanSeek()
// docid: M:System.Net.Security.SslStream.get_CanSeek
    open override func get_CanSeek() throws -> Bool {
        var __thrown : NullableHandle = nil;
        let __return = System_Net_Security_SslStream_bool__get_CanSeek_0__0(&__thrown, self.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return (__return) != 0;
        }
    }
    // [IsSpecialName] bool get_CanTimeout()
// docid: M:System.Net.Security.SslStream.get_CanTimeout
    open override func get_CanTimeout() throws -> Bool {
        var __thrown : NullableHandle = nil;
        let __return = System_Net_Security_SslStream_bool__get_CanTimeout_0__0(&__thrown, self.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return (__return) != 0;
        }
    }
    // [IsSpecialName] bool get_CanWrite()
// docid: M:System.Net.Security.SslStream.get_CanWrite
    open override func get_CanWrite() throws -> Bool {
        var __thrown : NullableHandle = nil;
        let __return = System_Net_Security_SslStream_bool__get_CanWrite_0__0(&__thrown, self.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return (__return) != 0;
        }
    }
    // [IsSpecialName] bool get_CheckCertRevocationStatus()
// docid: M:System.Net.Security.SslStream.get_CheckCertRevocationStatus
    open func get_CheckCertRevocationStatus() throws -> Bool {
        var __thrown : NullableHandle = nil;
        let __return = System_Net_Security_SslStream_bool__get_CheckCertRevocationStatus_0__0(&__thrown, self.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return (__return) != 0;
        }
    }
    // [IsSpecialName] System.Security.Authentication.CipherAlgorithmType get_CipherAlgorithm()
// docid: M:System.Net.Security.SslStream.get_CipherAlgorithm
    open func get_CipherAlgorithm() throws -> dotnet.System.Security.Authentication.CipherAlgorithmType {
        var __thrown : NullableHandle = nil;
        let __return = System_Net_Security_SslStream_CipherAlgorithmType__get_CipherAlgorithm_0__0(&__thrown, self.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return dotnet.System.Security.Authentication.CipherAlgorithmType(val: __return);
        }
    }
    // [IsSpecialName] System.Int32 get_CipherStrength()
// docid: M:System.Net.Security.SslStream.get_CipherStrength
    open func get_CipherStrength() throws -> Swift.Int32 {
        var __thrown : NullableHandle = nil;
        let __return = System_Net_Security_SslStream_i32__get_CipherStrength_0__0(&__thrown, self.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return __return;
        }
    }
    // [IsSpecialName] System.Security.Authentication.HashAlgorithmType get_HashAlgorithm()
// docid: M:System.Net.Security.SslStream.get_HashAlgorithm
    open func get_HashAlgorithm() throws -> dotnet.System.Security.Authentication.HashAlgorithmType {
        var __thrown : NullableHandle = nil;
        let __return = System_Net_Security_SslStream_HashAlgorithmType__get_HashAlgorithm_0__0(&__thrown, self.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return dotnet.System.Security.Authentication.HashAlgorithmType(val: __return);
        }
    }
    // [IsSpecialName] System.Int32 get_HashStrength()
// docid: M:System.Net.Security.SslStream.get_HashStrength
    open func get_HashStrength() throws -> Swift.Int32 {
        var __thrown : NullableHandle = nil;
        let __return = System_Net_Security_SslStream_i32__get_HashStrength_0__0(&__thrown, self.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return __return;
        }
    }
    // [IsSpecialName] bool get_IsAuthenticated()
// docid: M:System.Net.Security.SslStream.get_IsAuthenticated
    open override func get_IsAuthenticated() throws -> Bool {
        var __thrown : NullableHandle = nil;
        let __return = System_Net_Security_SslStream_bool__get_IsAuthenticated_0__0(&__thrown, self.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return (__return) != 0;
        }
    }
    // [IsSpecialName] bool get_IsEncrypted()
// docid: M:System.Net.Security.SslStream.get_IsEncrypted
    open override func get_IsEncrypted() throws -> Bool {
        var __thrown : NullableHandle = nil;
        let __return = System_Net_Security_SslStream_bool__get_IsEncrypted_0__0(&__thrown, self.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return (__return) != 0;
        }
    }
    // [IsSpecialName] bool get_IsMutuallyAuthenticated()
// docid: M:System.Net.Security.SslStream.get_IsMutuallyAuthenticated
    open override func get_IsMutuallyAuthenticated() throws -> Bool {
        var __thrown : NullableHandle = nil;
        let __return = System_Net_Security_SslStream_bool__get_IsMutuallyAuthenticated_0__0(&__thrown, self.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return (__return) != 0;
        }
    }
    // [IsSpecialName] bool get_IsServer()
// docid: M:System.Net.Security.SslStream.get_IsServer
    open override func get_IsServer() throws -> Bool {
        var __thrown : NullableHandle = nil;
        let __return = System_Net_Security_SslStream_bool__get_IsServer_0__0(&__thrown, self.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return (__return) != 0;
        }
    }
    // [IsSpecialName] bool get_IsSigned()
// docid: M:System.Net.Security.SslStream.get_IsSigned
    open override func get_IsSigned() throws -> Bool {
        var __thrown : NullableHandle = nil;
        let __return = System_Net_Security_SslStream_bool__get_IsSigned_0__0(&__thrown, self.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return (__return) != 0;
        }
    }
    // [IsSpecialName] System.Security.Authentication.ExchangeAlgorithmType get_KeyExchangeAlgorithm()
// docid: M:System.Net.Security.SslStream.get_KeyExchangeAlgorithm
    open func get_KeyExchangeAlgorithm() throws -> dotnet.System.Security.Authentication.ExchangeAlgorithmType {
        var __thrown : NullableHandle = nil;
        let __return = System_Net_Security_SslStream_ExchangeAlgorithmType__get_KeyExchangeAlgorithm_0__0(&__thrown, self.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return dotnet.System.Security.Authentication.ExchangeAlgorithmType(val: __return);
        }
    }
    // [IsSpecialName] System.Int32 get_KeyExchangeStrength()
// docid: M:System.Net.Security.SslStream.get_KeyExchangeStrength
    open func get_KeyExchangeStrength() throws -> Swift.Int32 {
        var __thrown : NullableHandle = nil;
        let __return = System_Net_Security_SslStream_i32__get_KeyExchangeStrength_0__0(&__thrown, self.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return __return;
        }
    }
    // [IsSpecialName] System.Int64 get_Length()
// docid: M:System.Net.Security.SslStream.get_Length
    open override func get_Length() throws -> Swift.Int64 {
        var __thrown : NullableHandle = nil;
        let __return = System_Net_Security_SslStream_i64__get_Length_0__0(&__thrown, self.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return __return;
        }
    }
    // [IsSpecialName] System.Security.Cryptography.X509Certificates.X509Certificate get_LocalCertificate()
// docid: M:System.Net.Security.SslStream.get_LocalCertificate
    open func get_LocalCertificate() throws -> Optional<dotnet.System.Security.Cryptography.X509Certificates.X509Certificate> {
        var __thrown : NullableHandle = nil;
        let __return = System_Net_Security_SslStream_X509Certificate__get_LocalCertificate_0__0(&__thrown, self.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        if let __ret_unwrapped = __return {
            return dotnet.System.Security.Cryptography.X509Certificates.X509Certificate(hndl : __ret_unwrapped);
        } else {
            return nil;
        }
        }
    }
    // [IsSpecialName] System.Net.Security.SslApplicationProtocol get_NegotiatedApplicationProtocol()
// docid: M:System.Net.Security.SslStream.get_NegotiatedApplicationProtocol
    open func get_NegotiatedApplicationProtocol() throws -> dotnet.System.Net.Security.SslApplicationProtocol {
        var __thrown : NullableHandle = nil;
        let __return = System_Net_Security_SslStream_SslApplicationProtocol__get_NegotiatedApplicationProtocol_0__0(&__thrown, self.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return dotnet.System.Net.Security.SslApplicationProtocol(hndl : __return);
        }
    }
    // [IsSpecialName] System.Net.Security.TlsCipherSuite get_NegotiatedCipherSuite()
// docid: M:System.Net.Security.SslStream.get_NegotiatedCipherSuite
    open func get_NegotiatedCipherSuite() throws -> dotnet.System.Net.Security.TlsCipherSuite {
        var __thrown : NullableHandle = nil;
        let __return = System_Net_Security_SslStream_TlsCipherSuite__get_NegotiatedCipherSuite_0__0(&__thrown, self.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return dotnet.System.Net.Security.TlsCipherSuite(val: __return);
        }
    }
    // [IsSpecialName] System.Int64 get_Position()
// docid: M:System.Net.Security.SslStream.get_Position
    open override func get_Position() throws -> Swift.Int64 {
        var __thrown : NullableHandle = nil;
        let __return = System_Net_Security_SslStream_i64__get_Position_0__0(&__thrown, self.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return __return;
        }
    }
    // [IsSpecialName] void set_Position(System.Int64)
// docid: M:System.Net.Security.SslStream.set_Position(System.Int64)
    open override func set_Position(value : Swift.Int64) throws {
        var __thrown : NullableHandle = nil;
        System_Net_Security_SslStream_void__set_Position_0__1__i64(&__thrown, self.get_handle(), value);
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
            return;
        }
    }
    // [IsSpecialName] System.Int32 get_ReadTimeout()
// docid: M:System.Net.Security.SslStream.get_ReadTimeout
    open override func get_ReadTimeout() throws -> Swift.Int32 {
        var __thrown : NullableHandle = nil;
        let __return = System_Net_Security_SslStream_i32__get_ReadTimeout_0__0(&__thrown, self.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return __return;
        }
    }
    // [IsSpecialName] void set_ReadTimeout(System.Int32)
// docid: M:System.Net.Security.SslStream.set_ReadTimeout(System.Int32)
    open override func set_ReadTimeout(value : Swift.Int32) throws {
        var __thrown : NullableHandle = nil;
        System_Net_Security_SslStream_void__set_ReadTimeout_0__1__i32(&__thrown, self.get_handle(), value);
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
            return;
        }
    }
    // [IsSpecialName] System.Security.Cryptography.X509Certificates.X509Certificate get_RemoteCertificate()
// docid: M:System.Net.Security.SslStream.get_RemoteCertificate
    open func get_RemoteCertificate() throws -> Optional<dotnet.System.Security.Cryptography.X509Certificates.X509Certificate> {
        var __thrown : NullableHandle = nil;
        let __return = System_Net_Security_SslStream_X509Certificate__get_RemoteCertificate_0__0(&__thrown, self.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        if let __ret_unwrapped = __return {
            return dotnet.System.Security.Cryptography.X509Certificates.X509Certificate(hndl : __ret_unwrapped);
        } else {
            return nil;
        }
        }
    }
    // [IsSpecialName] System.Security.Authentication.SslProtocols get_SslProtocol()
// docid: M:System.Net.Security.SslStream.get_SslProtocol
    open func get_SslProtocol() throws -> dotnet.System.Security.Authentication.SslProtocols {
        var __thrown : NullableHandle = nil;
        let __return = System_Net_Security_SslStream_SslProtocols__get_SslProtocol_0__0(&__thrown, self.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return dotnet.System.Security.Authentication.SslProtocols(val: __return);
        }
    }
    // [IsSpecialName] System.String get_TargetHostName()
// docid: M:System.Net.Security.SslStream.get_TargetHostName
    open func get_TargetHostName() throws -> dotnet.System.String {
        var __thrown : NullableHandle = nil;
        let __return = System_Net_Security_SslStream_String__get_TargetHostName_0__0(&__thrown, self.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return dotnet.System.String(hndl : __return);
        }
    }
    // [IsSpecialName] System.Net.TransportContext get_TransportContext()
// docid: M:System.Net.Security.SslStream.get_TransportContext
    open func get_TransportContext() throws -> dotnet.System.Net.TransportContext {
        var __thrown : NullableHandle = nil;
        let __return = System_Net_Security_SslStream_TransportContext__get_TransportContext_0__0(&__thrown, self.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return dotnet.System.Net.TransportContext(hndl : __return);
        }
    }
    // [IsSpecialName] System.Int32 get_WriteTimeout()
// docid: M:System.Net.Security.SslStream.get_WriteTimeout
    open override func get_WriteTimeout() throws -> Swift.Int32 {
        var __thrown : NullableHandle = nil;
        let __return = System_Net_Security_SslStream_i32__get_WriteTimeout_0__0(&__thrown, self.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return __return;
        }
    }
    // [IsSpecialName] void set_WriteTimeout(System.Int32)
// docid: M:System.Net.Security.SslStream.set_WriteTimeout(System.Int32)
    open override func set_WriteTimeout(value : Swift.Int32) throws {
        var __thrown : NullableHandle = nil;
        System_Net_Security_SslStream_void__set_WriteTimeout_0__1__i32(&__thrown, self.get_handle(), value);
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
            return;
        }
    }
    /**
    Gets a  value that indicates whether the underlying stream is readable.

    */
    open override var CanRead : Bool {
        get {
            return try! get_CanRead();
        }
    }
    /**
    Gets a  value that indicates whether the underlying stream is seekable.

    */
    open override var CanSeek : Bool {
        get {
            return try! get_CanSeek();
        }
    }
    /**
    Gets a  value that indicates whether the underlying stream supports time-outs.

    */
    open override var CanTimeout : Bool {
        get {
            return try! get_CanTimeout();
        }
    }
    /**
    Gets a  value that indicates whether the underlying stream is writable.

    */
    open override var CanWrite : Bool {
        get {
            return try! get_CanWrite();
        }
    }
    /**
    Gets a  value that indicates whether the certificate revocation list is checked during the certificate validation process.

    */
    open var CheckCertRevocationStatus : Bool {
        get {
            return try! get_CheckCertRevocationStatus();
        }
    }
    /**
    Gets a value that identifies the bulk encryption algorithm used by this .

    */
    open var CipherAlgorithm : dotnet.System.Security.Authentication.CipherAlgorithmType {
        get {
            return try! get_CipherAlgorithm();
        }
    }
    /**
    Gets a value that identifies the strength of the cipher algorithm used by this .

    */
    open var CipherStrength : Swift.Int32 {
        get {
            return try! get_CipherStrength();
        }
    }
    /**
    Gets the algorithm used for generating message authentication codes (MACs).

    */
    open var HashAlgorithm : dotnet.System.Security.Authentication.HashAlgorithmType {
        get {
            return try! get_HashAlgorithm();
        }
    }
    /**
    Gets a value that identifies the strength of the hash algorithm used by this instance.

    */
    open var HashStrength : Swift.Int32 {
        get {
            return try! get_HashStrength();
        }
    }
    /**
    Gets a  value that indicates whether authentication was successful.

    */
    open override var IsAuthenticated : Bool {
        get {
            return try! get_IsAuthenticated();
        }
    }
    /**
    Gets a  value that indicates whether this  uses data encryption.

    */
    open override var IsEncrypted : Bool {
        get {
            return try! get_IsEncrypted();
        }
    }
    /**
    Gets a  value that indicates whether both server and client have been authenticated.

    */
    open override var IsMutuallyAuthenticated : Bool {
        get {
            return try! get_IsMutuallyAuthenticated();
        }
    }
    /**
    Gets a  value that indicates whether the local side of the connection used by this  was authenticated as the server.

    */
    open override var IsServer : Bool {
        get {
            return try! get_IsServer();
        }
    }
    /**
    Gets a  value that indicates whether the data sent using this stream is signed.

    */
    open override var IsSigned : Bool {
        get {
            return try! get_IsSigned();
        }
    }
    /**
    Gets the key exchange algorithm used by this .

    */
    open var KeyExchangeAlgorithm : dotnet.System.Security.Authentication.ExchangeAlgorithmType {
        get {
            return try! get_KeyExchangeAlgorithm();
        }
    }
    /**
    Gets a value that identifies the strength of the key exchange algorithm used by this instance.

    */
    open var KeyExchangeStrength : Swift.Int32 {
        get {
            return try! get_KeyExchangeStrength();
        }
    }
    /**
    Gets the length of the underlying stream.

    */
    open override var Length : Swift.Int64 {
        get {
            return try! get_Length();
        }
    }
    /**
    Gets the certificate used to authenticate the local endpoint.

    */
    open var LocalCertificate : Optional<dotnet.System.Security.Cryptography.X509Certificates.X509Certificate> {
        get {
            return try! get_LocalCertificate();
        }
    }
    /**
    The negotiated application protocol in TLS handshake.

    */
    open var NegotiatedApplicationProtocol : dotnet.System.Net.Security.SslApplicationProtocol {
        get {
            return try! get_NegotiatedApplicationProtocol();
        }
    }
    /**
    Gets the cipher suite which was negotiated for this connection.

    */
    open var NegotiatedCipherSuite : dotnet.System.Net.Security.TlsCipherSuite {
        get {
            return try! get_NegotiatedCipherSuite();
        }
    }
    /**
    Gets or sets the current position in the underlying stream.

    */
    open override var Position : Swift.Int64 {
        get {
            return try! get_Position();
        }
        set(v) {
            return try! set_Position(value: v);
        }
    }
    /**
    Gets or sets the amount of time, expressed in milliseconds, a read operation blocks waiting for data.

    */
    open override var ReadTimeout : Swift.Int32 {
        get {
            return try! get_ReadTimeout();
        }
        set(v) {
            return try! set_ReadTimeout(value: v);
        }
    }
    /**
    Gets the certificate used to authenticate the remote endpoint.

    */
    open var RemoteCertificate : Optional<dotnet.System.Security.Cryptography.X509Certificates.X509Certificate> {
        get {
            return try! get_RemoteCertificate();
        }
    }
    /**
    Gets a value that indicates the security protocol used to authenticate this connection.

    */
    open var SslProtocol : dotnet.System.Security.Authentication.SslProtocols {
        get {
            return try! get_SslProtocol();
        }
    }
    /**
    Gets the name of the server the client is trying to connect to. That name is used for server certificate validation. It can be a DNS name or an IP address.

    */
    open var TargetHostName : dotnet.System.String {
        get {
            return try! get_TargetHostName();
        }
    }
    /**
    Gets the  used for authentication using extended protection.

    */
    open var TransportContext : dotnet.System.Net.TransportContext {
        get {
            return try! get_TransportContext();
        }
    }
    /**
    Gets or sets the amount of time a write operation blocks waiting for data.

    */
    open override var WriteTimeout : Swift.Int32 {
        get {
            return try! get_WriteTimeout();
        }
        set(v) {
            return try! set_WriteTimeout(value: v);
        }
    }
} // SslStream


// type: System.Net.Security.SslStreamCertificateContext
    /**
    Represents a set of certificates used for building a certificate chain.

    */
public final class SslStreamCertificateContext
    :
    dotnet.System.Object
{
    public class override func get_type_handle() -> TypeHandle {
        return System_Net_Security_SslStreamCertificateContext_get_type_handle();
    }
    public required init(hndl: NonnullHandle) { super.init(hndl: hndl); }
    public required init(gval: GVal) { super.init(gval: gval); }
    // System.Net.Security.SslStreamCertificateContext Create(System.Security.Cryptography.X509Certificates.X509Certificate2, System.Security.Cryptography.X509Certificates.X509Certificate2Collection, bool)
// docid: M:System.Net.Security.SslStreamCertificateContext.Create(System.Security.Cryptography.X509Certificates.X509Certificate2,System.Security.Cryptography.X509Certificates.X509Certificate2Collection,System.Boolean)
    /**
    Attempts to build the certificate chain from the provided certificates.

    - Parameter target: The server certificate.
    - Parameter additionalCertificates: Supplementary certificates used to build the certificate chain.
    - Parameter offline: 
         to indicate that the missing certificates can be downloaded from the network;  to indicate that only available X509Certificate stores should be searched for missing certificates.
    - Returns: The certificate context with the newly created certificate chain.

    */
    public class func Create(target : dotnet.System.Security.Cryptography.X509Certificates.X509Certificate2, additionalCertificates : Optional<dotnet.System.Security.Cryptography.X509Certificates.X509Certificate2Collection>, offline : Bool) throws -> dotnet.System.Net.Security.SslStreamCertificateContext {
        var __thrown : NullableHandle = nil;
        let __return = System_Net_Security_SslStreamCertificateContext_SslStreamCertificateContext__Create_0__3__X509Certificate2_X509Certificate2Collection_bool(&__thrown, target.get_handle(), additionalCertificates?.get_handle() ?? nil, Swift.Int32(offline ? 1 : 0));
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return dotnet.System.Net.Security.SslStreamCertificateContext(hndl : __return);
        }
    }
    // System.Net.Security.SslStreamCertificateContext Create(System.Security.Cryptography.X509Certificates.X509Certificate2, System.Security.Cryptography.X509Certificates.X509Certificate2Collection, bool, System.Net.Security.SslCertificateTrust)
// docid: M:System.Net.Security.SslStreamCertificateContext.Create(System.Security.Cryptography.X509Certificates.X509Certificate2,System.Security.Cryptography.X509Certificates.X509Certificate2Collection,System.Boolean,System.Net.Security.SslCertificateTrust)
    public class func Create(target : dotnet.System.Security.Cryptography.X509Certificates.X509Certificate2, additionalCertificates : Optional<dotnet.System.Security.Cryptography.X509Certificates.X509Certificate2Collection>, offline : Bool = false, trust : Optional<dotnet.System.Net.Security.SslCertificateTrust> = nil) throws -> dotnet.System.Net.Security.SslStreamCertificateContext {
        var __thrown : NullableHandle = nil;
        let __return = System_Net_Security_SslStreamCertificateContext_SslStreamCertificateContext__Create_0__4__X509Certificate2_X509Certificate2Collection_bool_SslCertificateTrust(&__thrown, target.get_handle(), additionalCertificates?.get_handle() ?? nil, Swift.Int32(offline ? 1 : 0), trust?.get_handle() ?? nil);
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return dotnet.System.Net.Security.SslStreamCertificateContext(hndl : __return);
        }
    }
} // SslStreamCertificateContext


// type: System.Net.Security.TlsCipherSuite
    /**
    Represents cipher suite values for the TLS (formerly SSL) protocol.

    */
public struct TlsCipherSuite : SGBridgeGenericValue {
    let v : Swift.UInt16;
    public init(val: Swift.UInt16) { self.v = val; }
    public func get_value() -> Swift.UInt16 { return self.v; }
    public static func get_type_handle() -> TypeHandle {
        return System_Net_Security_TlsCipherSuite_get_type_handle();
    }
    public func to_gval() -> GVal { return GVal(self.v); }
    public func dup_gval() -> GVal { return to_gval(); }
    public init(gval: GVal) { self.v = Swift.UInt16(gval); }
    // static field: System.Net.Security.TlsCipherSuite TLS_NULL_WITH_NULL_NULL
    /**
    Represents the TLS_NULL_WITH_NULL_NULL cipher suite.

    */
    public static var TLS_NULL_WITH_NULL_NULL : dotnet.System.Net.Security.TlsCipherSuite {
        get {
        let __return = dotnet.System.Net.Security.TlsCipherSuite(val: System_Net_Security_TlsCipherSuite_get_TLS_NULL_WITH_NULL_NULL());
            return __return;
        }
    }
    // static field: System.Net.Security.TlsCipherSuite TLS_RSA_WITH_NULL_MD5
    /**
    Represents the TLS_RSA_WITH_NULL_MD5 cipher suite.

    */
    public static var TLS_RSA_WITH_NULL_MD5 : dotnet.System.Net.Security.TlsCipherSuite {
        get {
        let __return = dotnet.System.Net.Security.TlsCipherSuite(val: System_Net_Security_TlsCipherSuite_get_TLS_RSA_WITH_NULL_MD5());
            return __return;
        }
    }
    // static field: System.Net.Security.TlsCipherSuite TLS_RSA_WITH_NULL_SHA
    /**
    Represents the TLS_RSA_WITH_NULL_SHA cipher suite.

    */
    public static var TLS_RSA_WITH_NULL_SHA : dotnet.System.Net.Security.TlsCipherSuite {
        get {
        let __return = dotnet.System.Net.Security.TlsCipherSuite(val: System_Net_Security_TlsCipherSuite_get_TLS_RSA_WITH_NULL_SHA());
            return __return;
        }
    }
    // static field: System.Net.Security.TlsCipherSuite TLS_RSA_EXPORT_WITH_RC4_40_MD5
    /**
    Represents the TLS_RSA_EXPORT_WITH_RC4_40_MD5 cipher suite.

    */
    public static var TLS_RSA_EXPORT_WITH_RC4_40_MD5 : dotnet.System.Net.Security.TlsCipherSuite {
        get {
        let __return = dotnet.System.Net.Security.TlsCipherSuite(val: System_Net_Security_TlsCipherSuite_get_TLS_RSA_EXPORT_WITH_RC4_40_MD5());
            return __return;
        }
    }
    // static field: System.Net.Security.TlsCipherSuite TLS_RSA_WITH_RC4_128_MD5
    /**
    Represents the TLS_RSA_WITH_RC4_128_MD5 cipher suite.

    */
    public static var TLS_RSA_WITH_RC4_128_MD5 : dotnet.System.Net.Security.TlsCipherSuite {
        get {
        let __return = dotnet.System.Net.Security.TlsCipherSuite(val: System_Net_Security_TlsCipherSuite_get_TLS_RSA_WITH_RC4_128_MD5());
            return __return;
        }
    }
    // static field: System.Net.Security.TlsCipherSuite TLS_RSA_WITH_RC4_128_SHA
    /**
    Represents the TLS_RSA_WITH_RC4_128_SHA cipher suite.

    */
    public static var TLS_RSA_WITH_RC4_128_SHA : dotnet.System.Net.Security.TlsCipherSuite {
        get {
        let __return = dotnet.System.Net.Security.TlsCipherSuite(val: System_Net_Security_TlsCipherSuite_get_TLS_RSA_WITH_RC4_128_SHA());
            return __return;
        }
    }
    // static field: System.Net.Security.TlsCipherSuite TLS_RSA_EXPORT_WITH_RC2_CBC_40_MD5
    /**
    Represents the TLS_RSA_EXPORT_WITH_RC2_CBC_40_MD5 cipher suite.

    */
    public static var TLS_RSA_EXPORT_WITH_RC2_CBC_40_MD5 : dotnet.System.Net.Security.TlsCipherSuite {
        get {
        let __return = dotnet.System.Net.Security.TlsCipherSuite(val: System_Net_Security_TlsCipherSuite_get_TLS_RSA_EXPORT_WITH_RC2_CBC_40_MD5());
            return __return;
        }
    }
    // static field: System.Net.Security.TlsCipherSuite TLS_RSA_WITH_IDEA_CBC_SHA
    /**
    Represents the TLS_RSA_WITH_IDEA_CBC_SHA cipher suite.

    */
    public static var TLS_RSA_WITH_IDEA_CBC_SHA : dotnet.System.Net.Security.TlsCipherSuite {
        get {
        let __return = dotnet.System.Net.Security.TlsCipherSuite(val: System_Net_Security_TlsCipherSuite_get_TLS_RSA_WITH_IDEA_CBC_SHA());
            return __return;
        }
    }
    // static field: System.Net.Security.TlsCipherSuite TLS_RSA_EXPORT_WITH_DES40_CBC_SHA
    /**
    Represents the TLS_RSA_EXPORT_WITH_DES40_CBC_SHA cipher suite.

    */
    public static var TLS_RSA_EXPORT_WITH_DES40_CBC_SHA : dotnet.System.Net.Security.TlsCipherSuite {
        get {
        let __return = dotnet.System.Net.Security.TlsCipherSuite(val: System_Net_Security_TlsCipherSuite_get_TLS_RSA_EXPORT_WITH_DES40_CBC_SHA());
            return __return;
        }
    }
    // static field: System.Net.Security.TlsCipherSuite TLS_RSA_WITH_DES_CBC_SHA
    /**
    Represents the TLS_RSA_WITH_DES_CBC_SHA cipher suite.

    */
    public static var TLS_RSA_WITH_DES_CBC_SHA : dotnet.System.Net.Security.TlsCipherSuite {
        get {
        let __return = dotnet.System.Net.Security.TlsCipherSuite(val: System_Net_Security_TlsCipherSuite_get_TLS_RSA_WITH_DES_CBC_SHA());
            return __return;
        }
    }
    // static field: System.Net.Security.TlsCipherSuite TLS_RSA_WITH_3DES_EDE_CBC_SHA
    /**
    Represents the TLS_RSA_WITH_3DES_EDE_CBC_SHA cipher suite.

    */
    public static var TLS_RSA_WITH_3DES_EDE_CBC_SHA : dotnet.System.Net.Security.TlsCipherSuite {
        get {
        let __return = dotnet.System.Net.Security.TlsCipherSuite(val: System_Net_Security_TlsCipherSuite_get_TLS_RSA_WITH_3DES_EDE_CBC_SHA());
            return __return;
        }
    }
    // static field: System.Net.Security.TlsCipherSuite TLS_DH_DSS_EXPORT_WITH_DES40_CBC_SHA
    /**
    Represents the TLS_DH_DSS_EXPORT_WITH_DES40_CBC_SHA cipher suite.

    */
    public static var TLS_DH_DSS_EXPORT_WITH_DES40_CBC_SHA : dotnet.System.Net.Security.TlsCipherSuite {
        get {
        let __return = dotnet.System.Net.Security.TlsCipherSuite(val: System_Net_Security_TlsCipherSuite_get_TLS_DH_DSS_EXPORT_WITH_DES40_CBC_SHA());
            return __return;
        }
    }
    // static field: System.Net.Security.TlsCipherSuite TLS_DH_DSS_WITH_DES_CBC_SHA
    /**
    Represents the TLS_DH_DSS_WITH_DES_CBC_SHA cipher suite.

    */
    public static var TLS_DH_DSS_WITH_DES_CBC_SHA : dotnet.System.Net.Security.TlsCipherSuite {
        get {
        let __return = dotnet.System.Net.Security.TlsCipherSuite(val: System_Net_Security_TlsCipherSuite_get_TLS_DH_DSS_WITH_DES_CBC_SHA());
            return __return;
        }
    }
    // static field: System.Net.Security.TlsCipherSuite TLS_DH_DSS_WITH_3DES_EDE_CBC_SHA
    /**
    Represents the TLS_DH_DSS_WITH_3DES_EDE_CBC_SHA cipher suite.

    */
    public static var TLS_DH_DSS_WITH_3DES_EDE_CBC_SHA : dotnet.System.Net.Security.TlsCipherSuite {
        get {
        let __return = dotnet.System.Net.Security.TlsCipherSuite(val: System_Net_Security_TlsCipherSuite_get_TLS_DH_DSS_WITH_3DES_EDE_CBC_SHA());
            return __return;
        }
    }
    // static field: System.Net.Security.TlsCipherSuite TLS_DH_RSA_EXPORT_WITH_DES40_CBC_SHA
    /**
    Represents the TLS_DH_RSA_EXPORT_WITH_DES40_CBC_SHA cipher suite.

    */
    public static var TLS_DH_RSA_EXPORT_WITH_DES40_CBC_SHA : dotnet.System.Net.Security.TlsCipherSuite {
        get {
        let __return = dotnet.System.Net.Security.TlsCipherSuite(val: System_Net_Security_TlsCipherSuite_get_TLS_DH_RSA_EXPORT_WITH_DES40_CBC_SHA());
            return __return;
        }
    }
    // static field: System.Net.Security.TlsCipherSuite TLS_DH_RSA_WITH_DES_CBC_SHA
    /**
    Represents the TLS_DH_RSA_WITH_DES_CBC_SHA cipher suite.

    */
    public static var TLS_DH_RSA_WITH_DES_CBC_SHA : dotnet.System.Net.Security.TlsCipherSuite {
        get {
        let __return = dotnet.System.Net.Security.TlsCipherSuite(val: System_Net_Security_TlsCipherSuite_get_TLS_DH_RSA_WITH_DES_CBC_SHA());
            return __return;
        }
    }
    // static field: System.Net.Security.TlsCipherSuite TLS_DH_RSA_WITH_3DES_EDE_CBC_SHA
    /**
    Represents the TLS_DH_RSA_WITH_3DES_EDE_CBC_SHA cipher suite.

    */
    public static var TLS_DH_RSA_WITH_3DES_EDE_CBC_SHA : dotnet.System.Net.Security.TlsCipherSuite {
        get {
        let __return = dotnet.System.Net.Security.TlsCipherSuite(val: System_Net_Security_TlsCipherSuite_get_TLS_DH_RSA_WITH_3DES_EDE_CBC_SHA());
            return __return;
        }
    }
    // static field: System.Net.Security.TlsCipherSuite TLS_DHE_DSS_EXPORT_WITH_DES40_CBC_SHA
    /**
    Represents the TLS_DHE_DSS_EXPORT_WITH_DES40_CBC_SHA cipher suite.

    */
    public static var TLS_DHE_DSS_EXPORT_WITH_DES40_CBC_SHA : dotnet.System.Net.Security.TlsCipherSuite {
        get {
        let __return = dotnet.System.Net.Security.TlsCipherSuite(val: System_Net_Security_TlsCipherSuite_get_TLS_DHE_DSS_EXPORT_WITH_DES40_CBC_SHA());
            return __return;
        }
    }
    // static field: System.Net.Security.TlsCipherSuite TLS_DHE_DSS_WITH_DES_CBC_SHA
    /**
    Represents the TLS_DHE_DSS_WITH_DES_CBC_SHA cipher suite.

    */
    public static var TLS_DHE_DSS_WITH_DES_CBC_SHA : dotnet.System.Net.Security.TlsCipherSuite {
        get {
        let __return = dotnet.System.Net.Security.TlsCipherSuite(val: System_Net_Security_TlsCipherSuite_get_TLS_DHE_DSS_WITH_DES_CBC_SHA());
            return __return;
        }
    }
    // static field: System.Net.Security.TlsCipherSuite TLS_DHE_DSS_WITH_3DES_EDE_CBC_SHA
    /**
    Represents the TLS_DHE_DSS_WITH_3DES_EDE_CBC_SHA cipher suite.

    */
    public static var TLS_DHE_DSS_WITH_3DES_EDE_CBC_SHA : dotnet.System.Net.Security.TlsCipherSuite {
        get {
        let __return = dotnet.System.Net.Security.TlsCipherSuite(val: System_Net_Security_TlsCipherSuite_get_TLS_DHE_DSS_WITH_3DES_EDE_CBC_SHA());
            return __return;
        }
    }
    // static field: System.Net.Security.TlsCipherSuite TLS_DHE_RSA_EXPORT_WITH_DES40_CBC_SHA
    /**
    Represents the TLS_DHE_RSA_EXPORT_WITH_DES40_CBC_SHA cipher suite.

    */
    public static var TLS_DHE_RSA_EXPORT_WITH_DES40_CBC_SHA : dotnet.System.Net.Security.TlsCipherSuite {
        get {
        let __return = dotnet.System.Net.Security.TlsCipherSuite(val: System_Net_Security_TlsCipherSuite_get_TLS_DHE_RSA_EXPORT_WITH_DES40_CBC_SHA());
            return __return;
        }
    }
    // static field: System.Net.Security.TlsCipherSuite TLS_DHE_RSA_WITH_DES_CBC_SHA
    /**
    Represents the TLS_DHE_RSA_WITH_DES_CBC_SHA cipher suite.

    */
    public static var TLS_DHE_RSA_WITH_DES_CBC_SHA : dotnet.System.Net.Security.TlsCipherSuite {
        get {
        let __return = dotnet.System.Net.Security.TlsCipherSuite(val: System_Net_Security_TlsCipherSuite_get_TLS_DHE_RSA_WITH_DES_CBC_SHA());
            return __return;
        }
    }
    // static field: System.Net.Security.TlsCipherSuite TLS_DHE_RSA_WITH_3DES_EDE_CBC_SHA
    /**
    Represents the TLS_DHE_RSA_WITH_3DES_EDE_CBC_SHA cipher suite.

    */
    public static var TLS_DHE_RSA_WITH_3DES_EDE_CBC_SHA : dotnet.System.Net.Security.TlsCipherSuite {
        get {
        let __return = dotnet.System.Net.Security.TlsCipherSuite(val: System_Net_Security_TlsCipherSuite_get_TLS_DHE_RSA_WITH_3DES_EDE_CBC_SHA());
            return __return;
        }
    }
    // static field: System.Net.Security.TlsCipherSuite TLS_DH_anon_EXPORT_WITH_RC4_40_MD5
    /**
    Represents the TLS_DH_anon_EXPORT_WITH_RC4_40_MD5 cipher suite.

    */
    public static var TLS_DH_anon_EXPORT_WITH_RC4_40_MD5 : dotnet.System.Net.Security.TlsCipherSuite {
        get {
        let __return = dotnet.System.Net.Security.TlsCipherSuite(val: System_Net_Security_TlsCipherSuite_get_TLS_DH_anon_EXPORT_WITH_RC4_40_MD5());
            return __return;
        }
    }
    // static field: System.Net.Security.TlsCipherSuite TLS_DH_anon_WITH_RC4_128_MD5
    /**
    Represents the TLS_DH_anon_WITH_RC4_128_MD5 cipher suite.

    */
    public static var TLS_DH_anon_WITH_RC4_128_MD5 : dotnet.System.Net.Security.TlsCipherSuite {
        get {
        let __return = dotnet.System.Net.Security.TlsCipherSuite(val: System_Net_Security_TlsCipherSuite_get_TLS_DH_anon_WITH_RC4_128_MD5());
            return __return;
        }
    }
    // static field: System.Net.Security.TlsCipherSuite TLS_DH_anon_EXPORT_WITH_DES40_CBC_SHA
    /**
    Represents the TLS_DH_anon_EXPORT_WITH_DES40_CBC_SHA cipher suite.

    */
    public static var TLS_DH_anon_EXPORT_WITH_DES40_CBC_SHA : dotnet.System.Net.Security.TlsCipherSuite {
        get {
        let __return = dotnet.System.Net.Security.TlsCipherSuite(val: System_Net_Security_TlsCipherSuite_get_TLS_DH_anon_EXPORT_WITH_DES40_CBC_SHA());
            return __return;
        }
    }
    // static field: System.Net.Security.TlsCipherSuite TLS_DH_anon_WITH_DES_CBC_SHA
    /**
    Represents the TLS_DH_anon_WITH_DES_CBC_SHA cipher suite.

    */
    public static var TLS_DH_anon_WITH_DES_CBC_SHA : dotnet.System.Net.Security.TlsCipherSuite {
        get {
        let __return = dotnet.System.Net.Security.TlsCipherSuite(val: System_Net_Security_TlsCipherSuite_get_TLS_DH_anon_WITH_DES_CBC_SHA());
            return __return;
        }
    }
    // static field: System.Net.Security.TlsCipherSuite TLS_DH_anon_WITH_3DES_EDE_CBC_SHA
    /**
    Represents the TLS_DH_anon_WITH_3DES_EDE_CBC_SHA cipher suite.

    */
    public static var TLS_DH_anon_WITH_3DES_EDE_CBC_SHA : dotnet.System.Net.Security.TlsCipherSuite {
        get {
        let __return = dotnet.System.Net.Security.TlsCipherSuite(val: System_Net_Security_TlsCipherSuite_get_TLS_DH_anon_WITH_3DES_EDE_CBC_SHA());
            return __return;
        }
    }
    // static field: System.Net.Security.TlsCipherSuite TLS_KRB5_WITH_DES_CBC_SHA
    /**
    Represents the TLS_KRB5_WITH_DES_CBC_SHA cipher suite.

    */
    public static var TLS_KRB5_WITH_DES_CBC_SHA : dotnet.System.Net.Security.TlsCipherSuite {
        get {
        let __return = dotnet.System.Net.Security.TlsCipherSuite(val: System_Net_Security_TlsCipherSuite_get_TLS_KRB5_WITH_DES_CBC_SHA());
            return __return;
        }
    }
    // static field: System.Net.Security.TlsCipherSuite TLS_KRB5_WITH_3DES_EDE_CBC_SHA
    /**
    Represents the TLS_KRB5_WITH_3DES_EDE_CBC_SHA cipher suite.

    */
    public static var TLS_KRB5_WITH_3DES_EDE_CBC_SHA : dotnet.System.Net.Security.TlsCipherSuite {
        get {
        let __return = dotnet.System.Net.Security.TlsCipherSuite(val: System_Net_Security_TlsCipherSuite_get_TLS_KRB5_WITH_3DES_EDE_CBC_SHA());
            return __return;
        }
    }
    // static field: System.Net.Security.TlsCipherSuite TLS_KRB5_WITH_RC4_128_SHA
    /**
    Represents the TLS_KRB5_WITH_RC4_128_SHA cipher suite.

    */
    public static var TLS_KRB5_WITH_RC4_128_SHA : dotnet.System.Net.Security.TlsCipherSuite {
        get {
        let __return = dotnet.System.Net.Security.TlsCipherSuite(val: System_Net_Security_TlsCipherSuite_get_TLS_KRB5_WITH_RC4_128_SHA());
            return __return;
        }
    }
    // static field: System.Net.Security.TlsCipherSuite TLS_KRB5_WITH_IDEA_CBC_SHA
    /**
    Represents the TLS_KRB5_WITH_IDEA_CBC_SHA cipher suite.

    */
    public static var TLS_KRB5_WITH_IDEA_CBC_SHA : dotnet.System.Net.Security.TlsCipherSuite {
        get {
        let __return = dotnet.System.Net.Security.TlsCipherSuite(val: System_Net_Security_TlsCipherSuite_get_TLS_KRB5_WITH_IDEA_CBC_SHA());
            return __return;
        }
    }
    // static field: System.Net.Security.TlsCipherSuite TLS_KRB5_WITH_DES_CBC_MD5
    /**
    Represents the TLS_KRB5_WITH_DES_CBC_MD5 cipher suite.

    */
    public static var TLS_KRB5_WITH_DES_CBC_MD5 : dotnet.System.Net.Security.TlsCipherSuite {
        get {
        let __return = dotnet.System.Net.Security.TlsCipherSuite(val: System_Net_Security_TlsCipherSuite_get_TLS_KRB5_WITH_DES_CBC_MD5());
            return __return;
        }
    }
    // static field: System.Net.Security.TlsCipherSuite TLS_KRB5_WITH_3DES_EDE_CBC_MD5
    /**
    Represents the TLS_KRB5_WITH_3DES_EDE_CBC_MD5 cipher suite.

    */
    public static var TLS_KRB5_WITH_3DES_EDE_CBC_MD5 : dotnet.System.Net.Security.TlsCipherSuite {
        get {
        let __return = dotnet.System.Net.Security.TlsCipherSuite(val: System_Net_Security_TlsCipherSuite_get_TLS_KRB5_WITH_3DES_EDE_CBC_MD5());
            return __return;
        }
    }
    // static field: System.Net.Security.TlsCipherSuite TLS_KRB5_WITH_RC4_128_MD5
    /**
    Represents the TLS_KRB5_WITH_RC4_128_MD5 cipher suite.

    */
    public static var TLS_KRB5_WITH_RC4_128_MD5 : dotnet.System.Net.Security.TlsCipherSuite {
        get {
        let __return = dotnet.System.Net.Security.TlsCipherSuite(val: System_Net_Security_TlsCipherSuite_get_TLS_KRB5_WITH_RC4_128_MD5());
            return __return;
        }
    }
    // static field: System.Net.Security.TlsCipherSuite TLS_KRB5_WITH_IDEA_CBC_MD5
    /**
    Represents the TLS_KRB5_WITH_IDEA_CBC_MD5 cipher suite.

    */
    public static var TLS_KRB5_WITH_IDEA_CBC_MD5 : dotnet.System.Net.Security.TlsCipherSuite {
        get {
        let __return = dotnet.System.Net.Security.TlsCipherSuite(val: System_Net_Security_TlsCipherSuite_get_TLS_KRB5_WITH_IDEA_CBC_MD5());
            return __return;
        }
    }
    // static field: System.Net.Security.TlsCipherSuite TLS_KRB5_EXPORT_WITH_DES_CBC_40_SHA
    /**
    Represents the TLS_KRB5_EXPORT_WITH_DES_CBC_40_SHA cipher suite.

    */
    public static var TLS_KRB5_EXPORT_WITH_DES_CBC_40_SHA : dotnet.System.Net.Security.TlsCipherSuite {
        get {
        let __return = dotnet.System.Net.Security.TlsCipherSuite(val: System_Net_Security_TlsCipherSuite_get_TLS_KRB5_EXPORT_WITH_DES_CBC_40_SHA());
            return __return;
        }
    }
    // static field: System.Net.Security.TlsCipherSuite TLS_KRB5_EXPORT_WITH_RC2_CBC_40_SHA
    /**
    Represents the TLS_KRB5_EXPORT_WITH_RC2_CBC_40_SHA cipher suite.

    */
    public static var TLS_KRB5_EXPORT_WITH_RC2_CBC_40_SHA : dotnet.System.Net.Security.TlsCipherSuite {
        get {
        let __return = dotnet.System.Net.Security.TlsCipherSuite(val: System_Net_Security_TlsCipherSuite_get_TLS_KRB5_EXPORT_WITH_RC2_CBC_40_SHA());
            return __return;
        }
    }
    // static field: System.Net.Security.TlsCipherSuite TLS_KRB5_EXPORT_WITH_RC4_40_SHA
    /**
    Represents the TLS_KRB5_EXPORT_WITH_RC4_40_SHA cipher suite.

    */
    public static var TLS_KRB5_EXPORT_WITH_RC4_40_SHA : dotnet.System.Net.Security.TlsCipherSuite {
        get {
        let __return = dotnet.System.Net.Security.TlsCipherSuite(val: System_Net_Security_TlsCipherSuite_get_TLS_KRB5_EXPORT_WITH_RC4_40_SHA());
            return __return;
        }
    }
    // static field: System.Net.Security.TlsCipherSuite TLS_KRB5_EXPORT_WITH_DES_CBC_40_MD5
    /**
    Represents the TLS_KRB5_EXPORT_WITH_DES_CBC_40_MD5 cipher suite.

    */
    public static var TLS_KRB5_EXPORT_WITH_DES_CBC_40_MD5 : dotnet.System.Net.Security.TlsCipherSuite {
        get {
        let __return = dotnet.System.Net.Security.TlsCipherSuite(val: System_Net_Security_TlsCipherSuite_get_TLS_KRB5_EXPORT_WITH_DES_CBC_40_MD5());
            return __return;
        }
    }
    // static field: System.Net.Security.TlsCipherSuite TLS_KRB5_EXPORT_WITH_RC2_CBC_40_MD5
    /**
    Represents the TLS_KRB5_EXPORT_WITH_RC2_CBC_40_MD5 cipher suite.

    */
    public static var TLS_KRB5_EXPORT_WITH_RC2_CBC_40_MD5 : dotnet.System.Net.Security.TlsCipherSuite {
        get {
        let __return = dotnet.System.Net.Security.TlsCipherSuite(val: System_Net_Security_TlsCipherSuite_get_TLS_KRB5_EXPORT_WITH_RC2_CBC_40_MD5());
            return __return;
        }
    }
    // static field: System.Net.Security.TlsCipherSuite TLS_KRB5_EXPORT_WITH_RC4_40_MD5
    /**
    Represents the TLS_KRB5_EXPORT_WITH_RC4_40_MD5 cipher suite.

    */
    public static var TLS_KRB5_EXPORT_WITH_RC4_40_MD5 : dotnet.System.Net.Security.TlsCipherSuite {
        get {
        let __return = dotnet.System.Net.Security.TlsCipherSuite(val: System_Net_Security_TlsCipherSuite_get_TLS_KRB5_EXPORT_WITH_RC4_40_MD5());
            return __return;
        }
    }
    // static field: System.Net.Security.TlsCipherSuite TLS_PSK_WITH_NULL_SHA
    /**
    Represents the TLS_PSK_WITH_NULL_SHA cipher suite.

    */
    public static var TLS_PSK_WITH_NULL_SHA : dotnet.System.Net.Security.TlsCipherSuite {
        get {
        let __return = dotnet.System.Net.Security.TlsCipherSuite(val: System_Net_Security_TlsCipherSuite_get_TLS_PSK_WITH_NULL_SHA());
            return __return;
        }
    }
    // static field: System.Net.Security.TlsCipherSuite TLS_DHE_PSK_WITH_NULL_SHA
    /**
    Represents the TLS_DHE_PSK_WITH_NULL_SHA cipher suite.

    */
    public static var TLS_DHE_PSK_WITH_NULL_SHA : dotnet.System.Net.Security.TlsCipherSuite {
        get {
        let __return = dotnet.System.Net.Security.TlsCipherSuite(val: System_Net_Security_TlsCipherSuite_get_TLS_DHE_PSK_WITH_NULL_SHA());
            return __return;
        }
    }
    // static field: System.Net.Security.TlsCipherSuite TLS_RSA_PSK_WITH_NULL_SHA
    /**
    Represents the TLS_RSA_PSK_WITH_NULL_SHA cipher suite.

    */
    public static var TLS_RSA_PSK_WITH_NULL_SHA : dotnet.System.Net.Security.TlsCipherSuite {
        get {
        let __return = dotnet.System.Net.Security.TlsCipherSuite(val: System_Net_Security_TlsCipherSuite_get_TLS_RSA_PSK_WITH_NULL_SHA());
            return __return;
        }
    }
    // static field: System.Net.Security.TlsCipherSuite TLS_RSA_WITH_AES_128_CBC_SHA
    /**
    Represents the TLS_RSA_WITH_AES_128_CBC_SHA cipher suite.

    */
    public static var TLS_RSA_WITH_AES_128_CBC_SHA : dotnet.System.Net.Security.TlsCipherSuite {
        get {
        let __return = dotnet.System.Net.Security.TlsCipherSuite(val: System_Net_Security_TlsCipherSuite_get_TLS_RSA_WITH_AES_128_CBC_SHA());
            return __return;
        }
    }
    // static field: System.Net.Security.TlsCipherSuite TLS_DH_DSS_WITH_AES_128_CBC_SHA
    /**
    Represents the TLS_DH_DSS_WITH_AES_128_CBC_SHA cipher suite.

    */
    public static var TLS_DH_DSS_WITH_AES_128_CBC_SHA : dotnet.System.Net.Security.TlsCipherSuite {
        get {
        let __return = dotnet.System.Net.Security.TlsCipherSuite(val: System_Net_Security_TlsCipherSuite_get_TLS_DH_DSS_WITH_AES_128_CBC_SHA());
            return __return;
        }
    }
    // static field: System.Net.Security.TlsCipherSuite TLS_DH_RSA_WITH_AES_128_CBC_SHA
    /**
    Represents the TLS_DH_RSA_WITH_AES_128_CBC_SHA cipher suite.

    */
    public static var TLS_DH_RSA_WITH_AES_128_CBC_SHA : dotnet.System.Net.Security.TlsCipherSuite {
        get {
        let __return = dotnet.System.Net.Security.TlsCipherSuite(val: System_Net_Security_TlsCipherSuite_get_TLS_DH_RSA_WITH_AES_128_CBC_SHA());
            return __return;
        }
    }
    // static field: System.Net.Security.TlsCipherSuite TLS_DHE_DSS_WITH_AES_128_CBC_SHA
    /**
    Represents the TLS_DHE_DSS_WITH_AES_128_CBC_SHA cipher suite.

    */
    public static var TLS_DHE_DSS_WITH_AES_128_CBC_SHA : dotnet.System.Net.Security.TlsCipherSuite {
        get {
        let __return = dotnet.System.Net.Security.TlsCipherSuite(val: System_Net_Security_TlsCipherSuite_get_TLS_DHE_DSS_WITH_AES_128_CBC_SHA());
            return __return;
        }
    }
    // static field: System.Net.Security.TlsCipherSuite TLS_DHE_RSA_WITH_AES_128_CBC_SHA
    /**
    Represents the TLS_DHE_RSA_WITH_AES_128_CBC_SHA cipher suite.

    */
    public static var TLS_DHE_RSA_WITH_AES_128_CBC_SHA : dotnet.System.Net.Security.TlsCipherSuite {
        get {
        let __return = dotnet.System.Net.Security.TlsCipherSuite(val: System_Net_Security_TlsCipherSuite_get_TLS_DHE_RSA_WITH_AES_128_CBC_SHA());
            return __return;
        }
    }
    // static field: System.Net.Security.TlsCipherSuite TLS_DH_anon_WITH_AES_128_CBC_SHA
    /**
    Represents the TLS_DH_anon_WITH_AES_128_CBC_SHA cipher suite.

    */
    public static var TLS_DH_anon_WITH_AES_128_CBC_SHA : dotnet.System.Net.Security.TlsCipherSuite {
        get {
        let __return = dotnet.System.Net.Security.TlsCipherSuite(val: System_Net_Security_TlsCipherSuite_get_TLS_DH_anon_WITH_AES_128_CBC_SHA());
            return __return;
        }
    }
    // static field: System.Net.Security.TlsCipherSuite TLS_RSA_WITH_AES_256_CBC_SHA
    /**
    Represents the TLS_RSA_WITH_AES_256_CBC_SHA cipher suite.

    */
    public static var TLS_RSA_WITH_AES_256_CBC_SHA : dotnet.System.Net.Security.TlsCipherSuite {
        get {
        let __return = dotnet.System.Net.Security.TlsCipherSuite(val: System_Net_Security_TlsCipherSuite_get_TLS_RSA_WITH_AES_256_CBC_SHA());
            return __return;
        }
    }
    // static field: System.Net.Security.TlsCipherSuite TLS_DH_DSS_WITH_AES_256_CBC_SHA
    /**
    Represents the TLS_DH_DSS_WITH_AES_256_CBC_SHA cipher suite.

    */
    public static var TLS_DH_DSS_WITH_AES_256_CBC_SHA : dotnet.System.Net.Security.TlsCipherSuite {
        get {
        let __return = dotnet.System.Net.Security.TlsCipherSuite(val: System_Net_Security_TlsCipherSuite_get_TLS_DH_DSS_WITH_AES_256_CBC_SHA());
            return __return;
        }
    }
    // static field: System.Net.Security.TlsCipherSuite TLS_DH_RSA_WITH_AES_256_CBC_SHA
    /**
    Represents the TLS_DH_RSA_WITH_AES_256_CBC_SHA cipher suite.

    */
    public static var TLS_DH_RSA_WITH_AES_256_CBC_SHA : dotnet.System.Net.Security.TlsCipherSuite {
        get {
        let __return = dotnet.System.Net.Security.TlsCipherSuite(val: System_Net_Security_TlsCipherSuite_get_TLS_DH_RSA_WITH_AES_256_CBC_SHA());
            return __return;
        }
    }
    // static field: System.Net.Security.TlsCipherSuite TLS_DHE_DSS_WITH_AES_256_CBC_SHA
    /**
    Represents the TLS_DHE_DSS_WITH_AES_256_CBC_SHA cipher suite.

    */
    public static var TLS_DHE_DSS_WITH_AES_256_CBC_SHA : dotnet.System.Net.Security.TlsCipherSuite {
        get {
        let __return = dotnet.System.Net.Security.TlsCipherSuite(val: System_Net_Security_TlsCipherSuite_get_TLS_DHE_DSS_WITH_AES_256_CBC_SHA());
            return __return;
        }
    }
    // static field: System.Net.Security.TlsCipherSuite TLS_DHE_RSA_WITH_AES_256_CBC_SHA
    /**
    Represents the TLS_DHE_RSA_WITH_AES_256_CBC_SHA cipher suite.

    */
    public static var TLS_DHE_RSA_WITH_AES_256_CBC_SHA : dotnet.System.Net.Security.TlsCipherSuite {
        get {
        let __return = dotnet.System.Net.Security.TlsCipherSuite(val: System_Net_Security_TlsCipherSuite_get_TLS_DHE_RSA_WITH_AES_256_CBC_SHA());
            return __return;
        }
    }
    // static field: System.Net.Security.TlsCipherSuite TLS_DH_anon_WITH_AES_256_CBC_SHA
    /**
    Represents the TLS_DH_anon_WITH_AES_256_CBC_SHA cipher suite.

    */
    public static var TLS_DH_anon_WITH_AES_256_CBC_SHA : dotnet.System.Net.Security.TlsCipherSuite {
        get {
        let __return = dotnet.System.Net.Security.TlsCipherSuite(val: System_Net_Security_TlsCipherSuite_get_TLS_DH_anon_WITH_AES_256_CBC_SHA());
            return __return;
        }
    }
    // static field: System.Net.Security.TlsCipherSuite TLS_RSA_WITH_NULL_SHA256
    /**
    Represents the TLS_RSA_WITH_NULL_SHA256 cipher suite.

    */
    public static var TLS_RSA_WITH_NULL_SHA256 : dotnet.System.Net.Security.TlsCipherSuite {
        get {
        let __return = dotnet.System.Net.Security.TlsCipherSuite(val: System_Net_Security_TlsCipherSuite_get_TLS_RSA_WITH_NULL_SHA256());
            return __return;
        }
    }
    // static field: System.Net.Security.TlsCipherSuite TLS_RSA_WITH_AES_128_CBC_SHA256
    /**
    Represents the TLS_RSA_WITH_AES_128_CBC_SHA256 cipher suite.

    */
    public static var TLS_RSA_WITH_AES_128_CBC_SHA256 : dotnet.System.Net.Security.TlsCipherSuite {
        get {
        let __return = dotnet.System.Net.Security.TlsCipherSuite(val: System_Net_Security_TlsCipherSuite_get_TLS_RSA_WITH_AES_128_CBC_SHA256());
            return __return;
        }
    }
    // static field: System.Net.Security.TlsCipherSuite TLS_RSA_WITH_AES_256_CBC_SHA256
    /**
    Represents the TLS_RSA_WITH_AES_256_CBC_SHA256 cipher suite.

    */
    public static var TLS_RSA_WITH_AES_256_CBC_SHA256 : dotnet.System.Net.Security.TlsCipherSuite {
        get {
        let __return = dotnet.System.Net.Security.TlsCipherSuite(val: System_Net_Security_TlsCipherSuite_get_TLS_RSA_WITH_AES_256_CBC_SHA256());
            return __return;
        }
    }
    // static field: System.Net.Security.TlsCipherSuite TLS_DH_DSS_WITH_AES_128_CBC_SHA256
    /**
    Represents the TLS_DH_DSS_WITH_AES_128_CBC_SHA256 cipher suite.

    */
    public static var TLS_DH_DSS_WITH_AES_128_CBC_SHA256 : dotnet.System.Net.Security.TlsCipherSuite {
        get {
        let __return = dotnet.System.Net.Security.TlsCipherSuite(val: System_Net_Security_TlsCipherSuite_get_TLS_DH_DSS_WITH_AES_128_CBC_SHA256());
            return __return;
        }
    }
    // static field: System.Net.Security.TlsCipherSuite TLS_DH_RSA_WITH_AES_128_CBC_SHA256
    /**
    Represents the TLS_DH_RSA_WITH_AES_128_CBC_SHA256 cipher suite.

    */
    public static var TLS_DH_RSA_WITH_AES_128_CBC_SHA256 : dotnet.System.Net.Security.TlsCipherSuite {
        get {
        let __return = dotnet.System.Net.Security.TlsCipherSuite(val: System_Net_Security_TlsCipherSuite_get_TLS_DH_RSA_WITH_AES_128_CBC_SHA256());
            return __return;
        }
    }
    // static field: System.Net.Security.TlsCipherSuite TLS_DHE_DSS_WITH_AES_128_CBC_SHA256
    /**
    Represents the TLS_DHE_DSS_WITH_AES_128_CBC_SHA256 cipher suite.

    */
    public static var TLS_DHE_DSS_WITH_AES_128_CBC_SHA256 : dotnet.System.Net.Security.TlsCipherSuite {
        get {
        let __return = dotnet.System.Net.Security.TlsCipherSuite(val: System_Net_Security_TlsCipherSuite_get_TLS_DHE_DSS_WITH_AES_128_CBC_SHA256());
            return __return;
        }
    }
    // static field: System.Net.Security.TlsCipherSuite TLS_RSA_WITH_CAMELLIA_128_CBC_SHA
    /**
    Represents the TLS_RSA_WITH_CAMELLIA_128_CBC_SHA cipher suite.

    */
    public static var TLS_RSA_WITH_CAMELLIA_128_CBC_SHA : dotnet.System.Net.Security.TlsCipherSuite {
        get {
        let __return = dotnet.System.Net.Security.TlsCipherSuite(val: System_Net_Security_TlsCipherSuite_get_TLS_RSA_WITH_CAMELLIA_128_CBC_SHA());
            return __return;
        }
    }
    // static field: System.Net.Security.TlsCipherSuite TLS_DH_DSS_WITH_CAMELLIA_128_CBC_SHA
    /**
    Represents the TLS_DH_DSS_WITH_CAMELLIA_128_CBC_SHA cipher suite.

    */
    public static var TLS_DH_DSS_WITH_CAMELLIA_128_CBC_SHA : dotnet.System.Net.Security.TlsCipherSuite {
        get {
        let __return = dotnet.System.Net.Security.TlsCipherSuite(val: System_Net_Security_TlsCipherSuite_get_TLS_DH_DSS_WITH_CAMELLIA_128_CBC_SHA());
            return __return;
        }
    }
    // static field: System.Net.Security.TlsCipherSuite TLS_DH_RSA_WITH_CAMELLIA_128_CBC_SHA
    /**
    Represents the TLS_DH_RSA_WITH_CAMELLIA_128_CBC_SHA cipher suite.

    */
    public static var TLS_DH_RSA_WITH_CAMELLIA_128_CBC_SHA : dotnet.System.Net.Security.TlsCipherSuite {
        get {
        let __return = dotnet.System.Net.Security.TlsCipherSuite(val: System_Net_Security_TlsCipherSuite_get_TLS_DH_RSA_WITH_CAMELLIA_128_CBC_SHA());
            return __return;
        }
    }
    // static field: System.Net.Security.TlsCipherSuite TLS_DHE_DSS_WITH_CAMELLIA_128_CBC_SHA
    /**
    Represents the TLS_DHE_DSS_WITH_CAMELLIA_128_CBC_SHA cipher suite.

    */
    public static var TLS_DHE_DSS_WITH_CAMELLIA_128_CBC_SHA : dotnet.System.Net.Security.TlsCipherSuite {
        get {
        let __return = dotnet.System.Net.Security.TlsCipherSuite(val: System_Net_Security_TlsCipherSuite_get_TLS_DHE_DSS_WITH_CAMELLIA_128_CBC_SHA());
            return __return;
        }
    }
    // static field: System.Net.Security.TlsCipherSuite TLS_DHE_RSA_WITH_CAMELLIA_128_CBC_SHA
    /**
    Represents the TLS_DHE_RSA_WITH_CAMELLIA_128_CBC_SHA cipher suite.

    */
    public static var TLS_DHE_RSA_WITH_CAMELLIA_128_CBC_SHA : dotnet.System.Net.Security.TlsCipherSuite {
        get {
        let __return = dotnet.System.Net.Security.TlsCipherSuite(val: System_Net_Security_TlsCipherSuite_get_TLS_DHE_RSA_WITH_CAMELLIA_128_CBC_SHA());
            return __return;
        }
    }
    // static field: System.Net.Security.TlsCipherSuite TLS_DH_anon_WITH_CAMELLIA_128_CBC_SHA
    /**
    Represents the TLS_DH_anon_WITH_CAMELLIA_128_CBC_SHA cipher suite.

    */
    public static var TLS_DH_anon_WITH_CAMELLIA_128_CBC_SHA : dotnet.System.Net.Security.TlsCipherSuite {
        get {
        let __return = dotnet.System.Net.Security.TlsCipherSuite(val: System_Net_Security_TlsCipherSuite_get_TLS_DH_anon_WITH_CAMELLIA_128_CBC_SHA());
            return __return;
        }
    }
    // static field: System.Net.Security.TlsCipherSuite TLS_DHE_RSA_WITH_AES_128_CBC_SHA256
    /**
    Represents the TLS_DHE_RSA_WITH_AES_128_CBC_SHA256 cipher suite.

    */
    public static var TLS_DHE_RSA_WITH_AES_128_CBC_SHA256 : dotnet.System.Net.Security.TlsCipherSuite {
        get {
        let __return = dotnet.System.Net.Security.TlsCipherSuite(val: System_Net_Security_TlsCipherSuite_get_TLS_DHE_RSA_WITH_AES_128_CBC_SHA256());
            return __return;
        }
    }
    // static field: System.Net.Security.TlsCipherSuite TLS_DH_DSS_WITH_AES_256_CBC_SHA256
    /**
    Represents the TLS_DH_DSS_WITH_AES_256_CBC_SHA256 cipher suite.

    */
    public static var TLS_DH_DSS_WITH_AES_256_CBC_SHA256 : dotnet.System.Net.Security.TlsCipherSuite {
        get {
        let __return = dotnet.System.Net.Security.TlsCipherSuite(val: System_Net_Security_TlsCipherSuite_get_TLS_DH_DSS_WITH_AES_256_CBC_SHA256());
            return __return;
        }
    }
    // static field: System.Net.Security.TlsCipherSuite TLS_DH_RSA_WITH_AES_256_CBC_SHA256
    /**
    Represents the TLS_DH_RSA_WITH_AES_256_CBC_SHA256 cipher suite.

    */
    public static var TLS_DH_RSA_WITH_AES_256_CBC_SHA256 : dotnet.System.Net.Security.TlsCipherSuite {
        get {
        let __return = dotnet.System.Net.Security.TlsCipherSuite(val: System_Net_Security_TlsCipherSuite_get_TLS_DH_RSA_WITH_AES_256_CBC_SHA256());
            return __return;
        }
    }
    // static field: System.Net.Security.TlsCipherSuite TLS_DHE_DSS_WITH_AES_256_CBC_SHA256
    /**
    Represents the TLS_DHE_DSS_WITH_AES_256_CBC_SHA256 cipher suite.

    */
    public static var TLS_DHE_DSS_WITH_AES_256_CBC_SHA256 : dotnet.System.Net.Security.TlsCipherSuite {
        get {
        let __return = dotnet.System.Net.Security.TlsCipherSuite(val: System_Net_Security_TlsCipherSuite_get_TLS_DHE_DSS_WITH_AES_256_CBC_SHA256());
            return __return;
        }
    }
    // static field: System.Net.Security.TlsCipherSuite TLS_DHE_RSA_WITH_AES_256_CBC_SHA256
    /**
    Represents the TLS_DHE_RSA_WITH_AES_256_CBC_SHA256 cipher suite.

    */
    public static var TLS_DHE_RSA_WITH_AES_256_CBC_SHA256 : dotnet.System.Net.Security.TlsCipherSuite {
        get {
        let __return = dotnet.System.Net.Security.TlsCipherSuite(val: System_Net_Security_TlsCipherSuite_get_TLS_DHE_RSA_WITH_AES_256_CBC_SHA256());
            return __return;
        }
    }
    // static field: System.Net.Security.TlsCipherSuite TLS_DH_anon_WITH_AES_128_CBC_SHA256
    /**
    Represents the TLS_DH_anon_WITH_AES_128_CBC_SHA256 cipher suite.

    */
    public static var TLS_DH_anon_WITH_AES_128_CBC_SHA256 : dotnet.System.Net.Security.TlsCipherSuite {
        get {
        let __return = dotnet.System.Net.Security.TlsCipherSuite(val: System_Net_Security_TlsCipherSuite_get_TLS_DH_anon_WITH_AES_128_CBC_SHA256());
            return __return;
        }
    }
    // static field: System.Net.Security.TlsCipherSuite TLS_DH_anon_WITH_AES_256_CBC_SHA256
    /**
    Represents the TLS_DH_anon_WITH_AES_256_CBC_SHA256 cipher suite.

    */
    public static var TLS_DH_anon_WITH_AES_256_CBC_SHA256 : dotnet.System.Net.Security.TlsCipherSuite {
        get {
        let __return = dotnet.System.Net.Security.TlsCipherSuite(val: System_Net_Security_TlsCipherSuite_get_TLS_DH_anon_WITH_AES_256_CBC_SHA256());
            return __return;
        }
    }
    // static field: System.Net.Security.TlsCipherSuite TLS_RSA_WITH_CAMELLIA_256_CBC_SHA
    /**
    Represents the TLS_RSA_WITH_CAMELLIA_256_CBC_SHA cipher suite.

    */
    public static var TLS_RSA_WITH_CAMELLIA_256_CBC_SHA : dotnet.System.Net.Security.TlsCipherSuite {
        get {
        let __return = dotnet.System.Net.Security.TlsCipherSuite(val: System_Net_Security_TlsCipherSuite_get_TLS_RSA_WITH_CAMELLIA_256_CBC_SHA());
            return __return;
        }
    }
    // static field: System.Net.Security.TlsCipherSuite TLS_DH_DSS_WITH_CAMELLIA_256_CBC_SHA
    /**
    Represents the TLS_DH_DSS_WITH_CAMELLIA_256_CBC_SHA cipher suite.

    */
    public static var TLS_DH_DSS_WITH_CAMELLIA_256_CBC_SHA : dotnet.System.Net.Security.TlsCipherSuite {
        get {
        let __return = dotnet.System.Net.Security.TlsCipherSuite(val: System_Net_Security_TlsCipherSuite_get_TLS_DH_DSS_WITH_CAMELLIA_256_CBC_SHA());
            return __return;
        }
    }
    // static field: System.Net.Security.TlsCipherSuite TLS_DH_RSA_WITH_CAMELLIA_256_CBC_SHA
    /**
    Represents the TLS_DH_RSA_WITH_CAMELLIA_256_CBC_SHA cipher suite.

    */
    public static var TLS_DH_RSA_WITH_CAMELLIA_256_CBC_SHA : dotnet.System.Net.Security.TlsCipherSuite {
        get {
        let __return = dotnet.System.Net.Security.TlsCipherSuite(val: System_Net_Security_TlsCipherSuite_get_TLS_DH_RSA_WITH_CAMELLIA_256_CBC_SHA());
            return __return;
        }
    }
    // static field: System.Net.Security.TlsCipherSuite TLS_DHE_DSS_WITH_CAMELLIA_256_CBC_SHA
    /**
    Represents the TLS_DHE_DSS_WITH_CAMELLIA_256_CBC_SHA cipher suite.

    */
    public static var TLS_DHE_DSS_WITH_CAMELLIA_256_CBC_SHA : dotnet.System.Net.Security.TlsCipherSuite {
        get {
        let __return = dotnet.System.Net.Security.TlsCipherSuite(val: System_Net_Security_TlsCipherSuite_get_TLS_DHE_DSS_WITH_CAMELLIA_256_CBC_SHA());
            return __return;
        }
    }
    // static field: System.Net.Security.TlsCipherSuite TLS_DHE_RSA_WITH_CAMELLIA_256_CBC_SHA
    /**
    Represents the TLS_DHE_RSA_WITH_CAMELLIA_256_CBC_SHA cipher suite.

    */
    public static var TLS_DHE_RSA_WITH_CAMELLIA_256_CBC_SHA : dotnet.System.Net.Security.TlsCipherSuite {
        get {
        let __return = dotnet.System.Net.Security.TlsCipherSuite(val: System_Net_Security_TlsCipherSuite_get_TLS_DHE_RSA_WITH_CAMELLIA_256_CBC_SHA());
            return __return;
        }
    }
    // static field: System.Net.Security.TlsCipherSuite TLS_DH_anon_WITH_CAMELLIA_256_CBC_SHA
    /**
    Represents the TLS_DH_anon_WITH_CAMELLIA_256_CBC_SHA cipher suite.

    */
    public static var TLS_DH_anon_WITH_CAMELLIA_256_CBC_SHA : dotnet.System.Net.Security.TlsCipherSuite {
        get {
        let __return = dotnet.System.Net.Security.TlsCipherSuite(val: System_Net_Security_TlsCipherSuite_get_TLS_DH_anon_WITH_CAMELLIA_256_CBC_SHA());
            return __return;
        }
    }
    // static field: System.Net.Security.TlsCipherSuite TLS_PSK_WITH_RC4_128_SHA
    /**
    Represents the TLS_PSK_WITH_RC4_128_SHA cipher suite.

    */
    public static var TLS_PSK_WITH_RC4_128_SHA : dotnet.System.Net.Security.TlsCipherSuite {
        get {
        let __return = dotnet.System.Net.Security.TlsCipherSuite(val: System_Net_Security_TlsCipherSuite_get_TLS_PSK_WITH_RC4_128_SHA());
            return __return;
        }
    }
    // static field: System.Net.Security.TlsCipherSuite TLS_PSK_WITH_3DES_EDE_CBC_SHA
    /**
    Represents the TLS_PSK_WITH_3DES_EDE_CBC_SHA cipher suite.

    */
    public static var TLS_PSK_WITH_3DES_EDE_CBC_SHA : dotnet.System.Net.Security.TlsCipherSuite {
        get {
        let __return = dotnet.System.Net.Security.TlsCipherSuite(val: System_Net_Security_TlsCipherSuite_get_TLS_PSK_WITH_3DES_EDE_CBC_SHA());
            return __return;
        }
    }
    // static field: System.Net.Security.TlsCipherSuite TLS_PSK_WITH_AES_128_CBC_SHA
    /**
    Represents the TLS_PSK_WITH_AES_128_CBC_SHA cipher suite.

    */
    public static var TLS_PSK_WITH_AES_128_CBC_SHA : dotnet.System.Net.Security.TlsCipherSuite {
        get {
        let __return = dotnet.System.Net.Security.TlsCipherSuite(val: System_Net_Security_TlsCipherSuite_get_TLS_PSK_WITH_AES_128_CBC_SHA());
            return __return;
        }
    }
    // static field: System.Net.Security.TlsCipherSuite TLS_PSK_WITH_AES_256_CBC_SHA
    /**
    Represents the TLS_PSK_WITH_AES_256_CBC_SHA cipher suite.

    */
    public static var TLS_PSK_WITH_AES_256_CBC_SHA : dotnet.System.Net.Security.TlsCipherSuite {
        get {
        let __return = dotnet.System.Net.Security.TlsCipherSuite(val: System_Net_Security_TlsCipherSuite_get_TLS_PSK_WITH_AES_256_CBC_SHA());
            return __return;
        }
    }
    // static field: System.Net.Security.TlsCipherSuite TLS_DHE_PSK_WITH_RC4_128_SHA
    /**
    Represents the TLS_DHE_PSK_WITH_RC4_128_SHA cipher suite.

    */
    public static var TLS_DHE_PSK_WITH_RC4_128_SHA : dotnet.System.Net.Security.TlsCipherSuite {
        get {
        let __return = dotnet.System.Net.Security.TlsCipherSuite(val: System_Net_Security_TlsCipherSuite_get_TLS_DHE_PSK_WITH_RC4_128_SHA());
            return __return;
        }
    }
    // static field: System.Net.Security.TlsCipherSuite TLS_DHE_PSK_WITH_3DES_EDE_CBC_SHA
    /**
    Represents the TLS_DHE_PSK_WITH_3DES_EDE_CBC_SHA cipher suite.

    */
    public static var TLS_DHE_PSK_WITH_3DES_EDE_CBC_SHA : dotnet.System.Net.Security.TlsCipherSuite {
        get {
        let __return = dotnet.System.Net.Security.TlsCipherSuite(val: System_Net_Security_TlsCipherSuite_get_TLS_DHE_PSK_WITH_3DES_EDE_CBC_SHA());
            return __return;
        }
    }
    // static field: System.Net.Security.TlsCipherSuite TLS_DHE_PSK_WITH_AES_128_CBC_SHA
    /**
    Represents the TLS_DHE_PSK_WITH_AES_128_CBC_SHA cipher suite.

    */
    public static var TLS_DHE_PSK_WITH_AES_128_CBC_SHA : dotnet.System.Net.Security.TlsCipherSuite {
        get {
        let __return = dotnet.System.Net.Security.TlsCipherSuite(val: System_Net_Security_TlsCipherSuite_get_TLS_DHE_PSK_WITH_AES_128_CBC_SHA());
            return __return;
        }
    }
    // static field: System.Net.Security.TlsCipherSuite TLS_DHE_PSK_WITH_AES_256_CBC_SHA
    /**
    Represents the TLS_DHE_PSK_WITH_AES_256_CBC_SHA cipher suite.

    */
    public static var TLS_DHE_PSK_WITH_AES_256_CBC_SHA : dotnet.System.Net.Security.TlsCipherSuite {
        get {
        let __return = dotnet.System.Net.Security.TlsCipherSuite(val: System_Net_Security_TlsCipherSuite_get_TLS_DHE_PSK_WITH_AES_256_CBC_SHA());
            return __return;
        }
    }
    // static field: System.Net.Security.TlsCipherSuite TLS_RSA_PSK_WITH_RC4_128_SHA
    /**
    Represents the TLS_RSA_PSK_WITH_RC4_128_SHA cipher suite.

    */
    public static var TLS_RSA_PSK_WITH_RC4_128_SHA : dotnet.System.Net.Security.TlsCipherSuite {
        get {
        let __return = dotnet.System.Net.Security.TlsCipherSuite(val: System_Net_Security_TlsCipherSuite_get_TLS_RSA_PSK_WITH_RC4_128_SHA());
            return __return;
        }
    }
    // static field: System.Net.Security.TlsCipherSuite TLS_RSA_PSK_WITH_3DES_EDE_CBC_SHA
    /**
    Represents the TLS_RSA_PSK_WITH_3DES_EDE_CBC_SHA cipher suite.

    */
    public static var TLS_RSA_PSK_WITH_3DES_EDE_CBC_SHA : dotnet.System.Net.Security.TlsCipherSuite {
        get {
        let __return = dotnet.System.Net.Security.TlsCipherSuite(val: System_Net_Security_TlsCipherSuite_get_TLS_RSA_PSK_WITH_3DES_EDE_CBC_SHA());
            return __return;
        }
    }
    // static field: System.Net.Security.TlsCipherSuite TLS_RSA_PSK_WITH_AES_128_CBC_SHA
    /**
    Represents the TLS_RSA_PSK_WITH_AES_128_CBC_SHA cipher suite.

    */
    public static var TLS_RSA_PSK_WITH_AES_128_CBC_SHA : dotnet.System.Net.Security.TlsCipherSuite {
        get {
        let __return = dotnet.System.Net.Security.TlsCipherSuite(val: System_Net_Security_TlsCipherSuite_get_TLS_RSA_PSK_WITH_AES_128_CBC_SHA());
            return __return;
        }
    }
    // static field: System.Net.Security.TlsCipherSuite TLS_RSA_PSK_WITH_AES_256_CBC_SHA
    /**
    Represents the TLS_RSA_PSK_WITH_AES_256_CBC_SHA cipher suite.

    */
    public static var TLS_RSA_PSK_WITH_AES_256_CBC_SHA : dotnet.System.Net.Security.TlsCipherSuite {
        get {
        let __return = dotnet.System.Net.Security.TlsCipherSuite(val: System_Net_Security_TlsCipherSuite_get_TLS_RSA_PSK_WITH_AES_256_CBC_SHA());
            return __return;
        }
    }
    // static field: System.Net.Security.TlsCipherSuite TLS_RSA_WITH_SEED_CBC_SHA
    /**
    Represents the TLS_RSA_WITH_SEED_CBC_SHA cipher suite.

    */
    public static var TLS_RSA_WITH_SEED_CBC_SHA : dotnet.System.Net.Security.TlsCipherSuite {
        get {
        let __return = dotnet.System.Net.Security.TlsCipherSuite(val: System_Net_Security_TlsCipherSuite_get_TLS_RSA_WITH_SEED_CBC_SHA());
            return __return;
        }
    }
    // static field: System.Net.Security.TlsCipherSuite TLS_DH_DSS_WITH_SEED_CBC_SHA
    /**
    Represents the TLS_DH_DSS_WITH_SEED_CBC_SHA cipher suite.

    */
    public static var TLS_DH_DSS_WITH_SEED_CBC_SHA : dotnet.System.Net.Security.TlsCipherSuite {
        get {
        let __return = dotnet.System.Net.Security.TlsCipherSuite(val: System_Net_Security_TlsCipherSuite_get_TLS_DH_DSS_WITH_SEED_CBC_SHA());
            return __return;
        }
    }
    // static field: System.Net.Security.TlsCipherSuite TLS_DH_RSA_WITH_SEED_CBC_SHA
    /**
    Represents the TLS_DH_RSA_WITH_SEED_CBC_SHA cipher suite.

    */
    public static var TLS_DH_RSA_WITH_SEED_CBC_SHA : dotnet.System.Net.Security.TlsCipherSuite {
        get {
        let __return = dotnet.System.Net.Security.TlsCipherSuite(val: System_Net_Security_TlsCipherSuite_get_TLS_DH_RSA_WITH_SEED_CBC_SHA());
            return __return;
        }
    }
    // static field: System.Net.Security.TlsCipherSuite TLS_DHE_DSS_WITH_SEED_CBC_SHA
    /**
    Represents the TLS_DHE_DSS_WITH_SEED_CBC_SHA cipher suite.

    */
    public static var TLS_DHE_DSS_WITH_SEED_CBC_SHA : dotnet.System.Net.Security.TlsCipherSuite {
        get {
        let __return = dotnet.System.Net.Security.TlsCipherSuite(val: System_Net_Security_TlsCipherSuite_get_TLS_DHE_DSS_WITH_SEED_CBC_SHA());
            return __return;
        }
    }
    // static field: System.Net.Security.TlsCipherSuite TLS_DHE_RSA_WITH_SEED_CBC_SHA
    /**
    Represents the TLS_DHE_RSA_WITH_SEED_CBC_SHA cipher suite.

    */
    public static var TLS_DHE_RSA_WITH_SEED_CBC_SHA : dotnet.System.Net.Security.TlsCipherSuite {
        get {
        let __return = dotnet.System.Net.Security.TlsCipherSuite(val: System_Net_Security_TlsCipherSuite_get_TLS_DHE_RSA_WITH_SEED_CBC_SHA());
            return __return;
        }
    }
    // static field: System.Net.Security.TlsCipherSuite TLS_DH_anon_WITH_SEED_CBC_SHA
    /**
    Represents the TLS_DH_anon_WITH_SEED_CBC_SHA cipher suite.

    */
    public static var TLS_DH_anon_WITH_SEED_CBC_SHA : dotnet.System.Net.Security.TlsCipherSuite {
        get {
        let __return = dotnet.System.Net.Security.TlsCipherSuite(val: System_Net_Security_TlsCipherSuite_get_TLS_DH_anon_WITH_SEED_CBC_SHA());
            return __return;
        }
    }
    // static field: System.Net.Security.TlsCipherSuite TLS_RSA_WITH_AES_128_GCM_SHA256
    /**
    Represents the TLS_RSA_WITH_AES_128_GCM_SHA256 cipher suite.

    */
    public static var TLS_RSA_WITH_AES_128_GCM_SHA256 : dotnet.System.Net.Security.TlsCipherSuite {
        get {
        let __return = dotnet.System.Net.Security.TlsCipherSuite(val: System_Net_Security_TlsCipherSuite_get_TLS_RSA_WITH_AES_128_GCM_SHA256());
            return __return;
        }
    }
    // static field: System.Net.Security.TlsCipherSuite TLS_RSA_WITH_AES_256_GCM_SHA384
    /**
    Represents the TLS_RSA_WITH_AES_256_GCM_SHA384 cipher suite.

    */
    public static var TLS_RSA_WITH_AES_256_GCM_SHA384 : dotnet.System.Net.Security.TlsCipherSuite {
        get {
        let __return = dotnet.System.Net.Security.TlsCipherSuite(val: System_Net_Security_TlsCipherSuite_get_TLS_RSA_WITH_AES_256_GCM_SHA384());
            return __return;
        }
    }
    // static field: System.Net.Security.TlsCipherSuite TLS_DHE_RSA_WITH_AES_128_GCM_SHA256
    /**
    Represents the TLS_DHE_RSA_WITH_AES_128_GCM_SHA256 cipher suite.

    */
    public static var TLS_DHE_RSA_WITH_AES_128_GCM_SHA256 : dotnet.System.Net.Security.TlsCipherSuite {
        get {
        let __return = dotnet.System.Net.Security.TlsCipherSuite(val: System_Net_Security_TlsCipherSuite_get_TLS_DHE_RSA_WITH_AES_128_GCM_SHA256());
            return __return;
        }
    }
    // static field: System.Net.Security.TlsCipherSuite TLS_DHE_RSA_WITH_AES_256_GCM_SHA384
    /**
    Represents the TLS_DHE_RSA_WITH_AES_256_GCM_SHA384 cipher suite.

    */
    public static var TLS_DHE_RSA_WITH_AES_256_GCM_SHA384 : dotnet.System.Net.Security.TlsCipherSuite {
        get {
        let __return = dotnet.System.Net.Security.TlsCipherSuite(val: System_Net_Security_TlsCipherSuite_get_TLS_DHE_RSA_WITH_AES_256_GCM_SHA384());
            return __return;
        }
    }
    // static field: System.Net.Security.TlsCipherSuite TLS_DH_RSA_WITH_AES_128_GCM_SHA256
    /**
    Represents the TLS_DH_RSA_WITH_AES_128_GCM_SHA256 cipher suite.

    */
    public static var TLS_DH_RSA_WITH_AES_128_GCM_SHA256 : dotnet.System.Net.Security.TlsCipherSuite {
        get {
        let __return = dotnet.System.Net.Security.TlsCipherSuite(val: System_Net_Security_TlsCipherSuite_get_TLS_DH_RSA_WITH_AES_128_GCM_SHA256());
            return __return;
        }
    }
    // static field: System.Net.Security.TlsCipherSuite TLS_DH_RSA_WITH_AES_256_GCM_SHA384
    /**
    Represents the TLS_DH_RSA_WITH_AES_256_GCM_SHA384 cipher suite.

    */
    public static var TLS_DH_RSA_WITH_AES_256_GCM_SHA384 : dotnet.System.Net.Security.TlsCipherSuite {
        get {
        let __return = dotnet.System.Net.Security.TlsCipherSuite(val: System_Net_Security_TlsCipherSuite_get_TLS_DH_RSA_WITH_AES_256_GCM_SHA384());
            return __return;
        }
    }
    // static field: System.Net.Security.TlsCipherSuite TLS_DHE_DSS_WITH_AES_128_GCM_SHA256
    /**
    Represents the TLS_DHE_DSS_WITH_AES_128_GCM_SHA256 cipher suite.

    */
    public static var TLS_DHE_DSS_WITH_AES_128_GCM_SHA256 : dotnet.System.Net.Security.TlsCipherSuite {
        get {
        let __return = dotnet.System.Net.Security.TlsCipherSuite(val: System_Net_Security_TlsCipherSuite_get_TLS_DHE_DSS_WITH_AES_128_GCM_SHA256());
            return __return;
        }
    }
    // static field: System.Net.Security.TlsCipherSuite TLS_DHE_DSS_WITH_AES_256_GCM_SHA384
    /**
    Represents the TLS_DHE_DSS_WITH_AES_256_GCM_SHA384 cipher suite.

    */
    public static var TLS_DHE_DSS_WITH_AES_256_GCM_SHA384 : dotnet.System.Net.Security.TlsCipherSuite {
        get {
        let __return = dotnet.System.Net.Security.TlsCipherSuite(val: System_Net_Security_TlsCipherSuite_get_TLS_DHE_DSS_WITH_AES_256_GCM_SHA384());
            return __return;
        }
    }
    // static field: System.Net.Security.TlsCipherSuite TLS_DH_DSS_WITH_AES_128_GCM_SHA256
    /**
    Represents the TLS_DH_DSS_WITH_AES_128_GCM_SHA256 cipher suite.

    */
    public static var TLS_DH_DSS_WITH_AES_128_GCM_SHA256 : dotnet.System.Net.Security.TlsCipherSuite {
        get {
        let __return = dotnet.System.Net.Security.TlsCipherSuite(val: System_Net_Security_TlsCipherSuite_get_TLS_DH_DSS_WITH_AES_128_GCM_SHA256());
            return __return;
        }
    }
    // static field: System.Net.Security.TlsCipherSuite TLS_DH_DSS_WITH_AES_256_GCM_SHA384
    /**
    Represents the TLS_DH_DSS_WITH_AES_256_GCM_SHA384 cipher suite.

    */
    public static var TLS_DH_DSS_WITH_AES_256_GCM_SHA384 : dotnet.System.Net.Security.TlsCipherSuite {
        get {
        let __return = dotnet.System.Net.Security.TlsCipherSuite(val: System_Net_Security_TlsCipherSuite_get_TLS_DH_DSS_WITH_AES_256_GCM_SHA384());
            return __return;
        }
    }
    // static field: System.Net.Security.TlsCipherSuite TLS_DH_anon_WITH_AES_128_GCM_SHA256
    /**
    Represents the TLS_DH_anon_WITH_AES_128_GCM_SHA256 cipher suite.

    */
    public static var TLS_DH_anon_WITH_AES_128_GCM_SHA256 : dotnet.System.Net.Security.TlsCipherSuite {
        get {
        let __return = dotnet.System.Net.Security.TlsCipherSuite(val: System_Net_Security_TlsCipherSuite_get_TLS_DH_anon_WITH_AES_128_GCM_SHA256());
            return __return;
        }
    }
    // static field: System.Net.Security.TlsCipherSuite TLS_DH_anon_WITH_AES_256_GCM_SHA384
    /**
    Represents the TLS_DH_anon_WITH_AES_256_GCM_SHA384 cipher suite.

    */
    public static var TLS_DH_anon_WITH_AES_256_GCM_SHA384 : dotnet.System.Net.Security.TlsCipherSuite {
        get {
        let __return = dotnet.System.Net.Security.TlsCipherSuite(val: System_Net_Security_TlsCipherSuite_get_TLS_DH_anon_WITH_AES_256_GCM_SHA384());
            return __return;
        }
    }
    // static field: System.Net.Security.TlsCipherSuite TLS_PSK_WITH_AES_128_GCM_SHA256
    /**
    Represents the TLS_PSK_WITH_AES_128_GCM_SHA256 cipher suite.

    */
    public static var TLS_PSK_WITH_AES_128_GCM_SHA256 : dotnet.System.Net.Security.TlsCipherSuite {
        get {
        let __return = dotnet.System.Net.Security.TlsCipherSuite(val: System_Net_Security_TlsCipherSuite_get_TLS_PSK_WITH_AES_128_GCM_SHA256());
            return __return;
        }
    }
    // static field: System.Net.Security.TlsCipherSuite TLS_PSK_WITH_AES_256_GCM_SHA384
    /**
    Represents the TLS_PSK_WITH_AES_256_GCM_SHA384 cipher suite.

    */
    public static var TLS_PSK_WITH_AES_256_GCM_SHA384 : dotnet.System.Net.Security.TlsCipherSuite {
        get {
        let __return = dotnet.System.Net.Security.TlsCipherSuite(val: System_Net_Security_TlsCipherSuite_get_TLS_PSK_WITH_AES_256_GCM_SHA384());
            return __return;
        }
    }
    // static field: System.Net.Security.TlsCipherSuite TLS_DHE_PSK_WITH_AES_128_GCM_SHA256
    /**
    Represents the TLS_DHE_PSK_WITH_AES_128_GCM_SHA256 cipher suite.

    */
    public static var TLS_DHE_PSK_WITH_AES_128_GCM_SHA256 : dotnet.System.Net.Security.TlsCipherSuite {
        get {
        let __return = dotnet.System.Net.Security.TlsCipherSuite(val: System_Net_Security_TlsCipherSuite_get_TLS_DHE_PSK_WITH_AES_128_GCM_SHA256());
            return __return;
        }
    }
    // static field: System.Net.Security.TlsCipherSuite TLS_DHE_PSK_WITH_AES_256_GCM_SHA384
    /**
    Represents the TLS_DHE_PSK_WITH_AES_256_GCM_SHA384 cipher suite.

    */
    public static var TLS_DHE_PSK_WITH_AES_256_GCM_SHA384 : dotnet.System.Net.Security.TlsCipherSuite {
        get {
        let __return = dotnet.System.Net.Security.TlsCipherSuite(val: System_Net_Security_TlsCipherSuite_get_TLS_DHE_PSK_WITH_AES_256_GCM_SHA384());
            return __return;
        }
    }
    // static field: System.Net.Security.TlsCipherSuite TLS_RSA_PSK_WITH_AES_128_GCM_SHA256
    /**
    Represents the TLS_RSA_PSK_WITH_AES_128_GCM_SHA256 cipher suite.

    */
    public static var TLS_RSA_PSK_WITH_AES_128_GCM_SHA256 : dotnet.System.Net.Security.TlsCipherSuite {
        get {
        let __return = dotnet.System.Net.Security.TlsCipherSuite(val: System_Net_Security_TlsCipherSuite_get_TLS_RSA_PSK_WITH_AES_128_GCM_SHA256());
            return __return;
        }
    }
    // static field: System.Net.Security.TlsCipherSuite TLS_RSA_PSK_WITH_AES_256_GCM_SHA384
    /**
    Represents the TLS_RSA_PSK_WITH_AES_256_GCM_SHA384 cipher suite.

    */
    public static var TLS_RSA_PSK_WITH_AES_256_GCM_SHA384 : dotnet.System.Net.Security.TlsCipherSuite {
        get {
        let __return = dotnet.System.Net.Security.TlsCipherSuite(val: System_Net_Security_TlsCipherSuite_get_TLS_RSA_PSK_WITH_AES_256_GCM_SHA384());
            return __return;
        }
    }
    // static field: System.Net.Security.TlsCipherSuite TLS_PSK_WITH_AES_128_CBC_SHA256
    /**
    Represents the TLS_PSK_WITH_AES_128_CBC_SHA256 cipher suite.

    */
    public static var TLS_PSK_WITH_AES_128_CBC_SHA256 : dotnet.System.Net.Security.TlsCipherSuite {
        get {
        let __return = dotnet.System.Net.Security.TlsCipherSuite(val: System_Net_Security_TlsCipherSuite_get_TLS_PSK_WITH_AES_128_CBC_SHA256());
            return __return;
        }
    }
    // static field: System.Net.Security.TlsCipherSuite TLS_PSK_WITH_AES_256_CBC_SHA384
    /**
    Represents the TLS_PSK_WITH_AES_256_CBC_SHA384 cipher suite.

    */
    public static var TLS_PSK_WITH_AES_256_CBC_SHA384 : dotnet.System.Net.Security.TlsCipherSuite {
        get {
        let __return = dotnet.System.Net.Security.TlsCipherSuite(val: System_Net_Security_TlsCipherSuite_get_TLS_PSK_WITH_AES_256_CBC_SHA384());
            return __return;
        }
    }
    // static field: System.Net.Security.TlsCipherSuite TLS_PSK_WITH_NULL_SHA256
    /**
    Represents the TLS_PSK_WITH_NULL_SHA256 cipher suite.

    */
    public static var TLS_PSK_WITH_NULL_SHA256 : dotnet.System.Net.Security.TlsCipherSuite {
        get {
        let __return = dotnet.System.Net.Security.TlsCipherSuite(val: System_Net_Security_TlsCipherSuite_get_TLS_PSK_WITH_NULL_SHA256());
            return __return;
        }
    }
    // static field: System.Net.Security.TlsCipherSuite TLS_PSK_WITH_NULL_SHA384
    /**
    Represents the TLS_PSK_WITH_NULL_SHA384 cipher suite.

    */
    public static var TLS_PSK_WITH_NULL_SHA384 : dotnet.System.Net.Security.TlsCipherSuite {
        get {
        let __return = dotnet.System.Net.Security.TlsCipherSuite(val: System_Net_Security_TlsCipherSuite_get_TLS_PSK_WITH_NULL_SHA384());
            return __return;
        }
    }
    // static field: System.Net.Security.TlsCipherSuite TLS_DHE_PSK_WITH_AES_128_CBC_SHA256
    /**
    Represents the TLS_DHE_PSK_WITH_AES_128_CBC_SHA256 cipher suite.

    */
    public static var TLS_DHE_PSK_WITH_AES_128_CBC_SHA256 : dotnet.System.Net.Security.TlsCipherSuite {
        get {
        let __return = dotnet.System.Net.Security.TlsCipherSuite(val: System_Net_Security_TlsCipherSuite_get_TLS_DHE_PSK_WITH_AES_128_CBC_SHA256());
            return __return;
        }
    }
    // static field: System.Net.Security.TlsCipherSuite TLS_DHE_PSK_WITH_AES_256_CBC_SHA384
    /**
    Represents the TLS_DHE_PSK_WITH_AES_256_CBC_SHA384 cipher suite.

    */
    public static var TLS_DHE_PSK_WITH_AES_256_CBC_SHA384 : dotnet.System.Net.Security.TlsCipherSuite {
        get {
        let __return = dotnet.System.Net.Security.TlsCipherSuite(val: System_Net_Security_TlsCipherSuite_get_TLS_DHE_PSK_WITH_AES_256_CBC_SHA384());
            return __return;
        }
    }
    // static field: System.Net.Security.TlsCipherSuite TLS_DHE_PSK_WITH_NULL_SHA256
    /**
    Represents the TLS_DHE_PSK_WITH_NULL_SHA256 cipher suite.

    */
    public static var TLS_DHE_PSK_WITH_NULL_SHA256 : dotnet.System.Net.Security.TlsCipherSuite {
        get {
        let __return = dotnet.System.Net.Security.TlsCipherSuite(val: System_Net_Security_TlsCipherSuite_get_TLS_DHE_PSK_WITH_NULL_SHA256());
            return __return;
        }
    }
    // static field: System.Net.Security.TlsCipherSuite TLS_DHE_PSK_WITH_NULL_SHA384
    /**
    Represents the TLS_DHE_PSK_WITH_NULL_SHA384 cipher suite.

    */
    public static var TLS_DHE_PSK_WITH_NULL_SHA384 : dotnet.System.Net.Security.TlsCipherSuite {
        get {
        let __return = dotnet.System.Net.Security.TlsCipherSuite(val: System_Net_Security_TlsCipherSuite_get_TLS_DHE_PSK_WITH_NULL_SHA384());
            return __return;
        }
    }
    // static field: System.Net.Security.TlsCipherSuite TLS_RSA_PSK_WITH_AES_128_CBC_SHA256
    /**
    Represents the TLS_RSA_PSK_WITH_AES_128_CBC_SHA256 cipher suite.

    */
    public static var TLS_RSA_PSK_WITH_AES_128_CBC_SHA256 : dotnet.System.Net.Security.TlsCipherSuite {
        get {
        let __return = dotnet.System.Net.Security.TlsCipherSuite(val: System_Net_Security_TlsCipherSuite_get_TLS_RSA_PSK_WITH_AES_128_CBC_SHA256());
            return __return;
        }
    }
    // static field: System.Net.Security.TlsCipherSuite TLS_RSA_PSK_WITH_AES_256_CBC_SHA384
    /**
    Represents the TLS_RSA_PSK_WITH_AES_256_CBC_SHA384 cipher suite.

    */
    public static var TLS_RSA_PSK_WITH_AES_256_CBC_SHA384 : dotnet.System.Net.Security.TlsCipherSuite {
        get {
        let __return = dotnet.System.Net.Security.TlsCipherSuite(val: System_Net_Security_TlsCipherSuite_get_TLS_RSA_PSK_WITH_AES_256_CBC_SHA384());
            return __return;
        }
    }
    // static field: System.Net.Security.TlsCipherSuite TLS_RSA_PSK_WITH_NULL_SHA256
    /**
    Represents the TLS_RSA_PSK_WITH_NULL_SHA256 cipher suite.

    */
    public static var TLS_RSA_PSK_WITH_NULL_SHA256 : dotnet.System.Net.Security.TlsCipherSuite {
        get {
        let __return = dotnet.System.Net.Security.TlsCipherSuite(val: System_Net_Security_TlsCipherSuite_get_TLS_RSA_PSK_WITH_NULL_SHA256());
            return __return;
        }
    }
    // static field: System.Net.Security.TlsCipherSuite TLS_RSA_PSK_WITH_NULL_SHA384
    /**
    Represents the TLS_RSA_PSK_WITH_NULL_SHA384 cipher suite.

    */
    public static var TLS_RSA_PSK_WITH_NULL_SHA384 : dotnet.System.Net.Security.TlsCipherSuite {
        get {
        let __return = dotnet.System.Net.Security.TlsCipherSuite(val: System_Net_Security_TlsCipherSuite_get_TLS_RSA_PSK_WITH_NULL_SHA384());
            return __return;
        }
    }
    // static field: System.Net.Security.TlsCipherSuite TLS_RSA_WITH_CAMELLIA_128_CBC_SHA256
    /**
    Represents the TLS_RSA_WITH_CAMELLIA_128_CBC_SHA256 cipher suite.

    */
    public static var TLS_RSA_WITH_CAMELLIA_128_CBC_SHA256 : dotnet.System.Net.Security.TlsCipherSuite {
        get {
        let __return = dotnet.System.Net.Security.TlsCipherSuite(val: System_Net_Security_TlsCipherSuite_get_TLS_RSA_WITH_CAMELLIA_128_CBC_SHA256());
            return __return;
        }
    }
    // static field: System.Net.Security.TlsCipherSuite TLS_DH_DSS_WITH_CAMELLIA_128_CBC_SHA256
    /**
    Represents the TLS_DH_DSS_WITH_CAMELLIA_128_CBC_SHA256 cipher suite.

    */
    public static var TLS_DH_DSS_WITH_CAMELLIA_128_CBC_SHA256 : dotnet.System.Net.Security.TlsCipherSuite {
        get {
        let __return = dotnet.System.Net.Security.TlsCipherSuite(val: System_Net_Security_TlsCipherSuite_get_TLS_DH_DSS_WITH_CAMELLIA_128_CBC_SHA256());
            return __return;
        }
    }
    // static field: System.Net.Security.TlsCipherSuite TLS_DH_RSA_WITH_CAMELLIA_128_CBC_SHA256
    /**
    Represents the TLS_DH_RSA_WITH_CAMELLIA_128_CBC_SHA256 cipher suite.

    */
    public static var TLS_DH_RSA_WITH_CAMELLIA_128_CBC_SHA256 : dotnet.System.Net.Security.TlsCipherSuite {
        get {
        let __return = dotnet.System.Net.Security.TlsCipherSuite(val: System_Net_Security_TlsCipherSuite_get_TLS_DH_RSA_WITH_CAMELLIA_128_CBC_SHA256());
            return __return;
        }
    }
    // static field: System.Net.Security.TlsCipherSuite TLS_DHE_DSS_WITH_CAMELLIA_128_CBC_SHA256
    /**
    Represents the TLS_DHE_DSS_WITH_CAMELLIA_128_CBC_SHA256 cipher suite.

    */
    public static var TLS_DHE_DSS_WITH_CAMELLIA_128_CBC_SHA256 : dotnet.System.Net.Security.TlsCipherSuite {
        get {
        let __return = dotnet.System.Net.Security.TlsCipherSuite(val: System_Net_Security_TlsCipherSuite_get_TLS_DHE_DSS_WITH_CAMELLIA_128_CBC_SHA256());
            return __return;
        }
    }
    // static field: System.Net.Security.TlsCipherSuite TLS_DHE_RSA_WITH_CAMELLIA_128_CBC_SHA256
    /**
    Represents the TLS_DHE_RSA_WITH_CAMELLIA_128_CBC_SHA256 cipher suite.

    */
    public static var TLS_DHE_RSA_WITH_CAMELLIA_128_CBC_SHA256 : dotnet.System.Net.Security.TlsCipherSuite {
        get {
        let __return = dotnet.System.Net.Security.TlsCipherSuite(val: System_Net_Security_TlsCipherSuite_get_TLS_DHE_RSA_WITH_CAMELLIA_128_CBC_SHA256());
            return __return;
        }
    }
    // static field: System.Net.Security.TlsCipherSuite TLS_DH_anon_WITH_CAMELLIA_128_CBC_SHA256
    /**
    Represents the TLS_DH_anon_WITH_CAMELLIA_128_CBC_SHA256 cipher suite.

    */
    public static var TLS_DH_anon_WITH_CAMELLIA_128_CBC_SHA256 : dotnet.System.Net.Security.TlsCipherSuite {
        get {
        let __return = dotnet.System.Net.Security.TlsCipherSuite(val: System_Net_Security_TlsCipherSuite_get_TLS_DH_anon_WITH_CAMELLIA_128_CBC_SHA256());
            return __return;
        }
    }
    // static field: System.Net.Security.TlsCipherSuite TLS_RSA_WITH_CAMELLIA_256_CBC_SHA256
    /**
    Represents the TLS_RSA_WITH_CAMELLIA_256_CBC_SHA256 cipher suite.

    */
    public static var TLS_RSA_WITH_CAMELLIA_256_CBC_SHA256 : dotnet.System.Net.Security.TlsCipherSuite {
        get {
        let __return = dotnet.System.Net.Security.TlsCipherSuite(val: System_Net_Security_TlsCipherSuite_get_TLS_RSA_WITH_CAMELLIA_256_CBC_SHA256());
            return __return;
        }
    }
    // static field: System.Net.Security.TlsCipherSuite TLS_DH_DSS_WITH_CAMELLIA_256_CBC_SHA256
    /**
    Represents the TLS_DH_DSS_WITH_CAMELLIA_256_CBC_SHA256 cipher suite.

    */
    public static var TLS_DH_DSS_WITH_CAMELLIA_256_CBC_SHA256 : dotnet.System.Net.Security.TlsCipherSuite {
        get {
        let __return = dotnet.System.Net.Security.TlsCipherSuite(val: System_Net_Security_TlsCipherSuite_get_TLS_DH_DSS_WITH_CAMELLIA_256_CBC_SHA256());
            return __return;
        }
    }
    // static field: System.Net.Security.TlsCipherSuite TLS_DH_RSA_WITH_CAMELLIA_256_CBC_SHA256
    /**
    Represents the TLS_DH_RSA_WITH_CAMELLIA_256_CBC_SHA256 cipher suite.

    */
    public static var TLS_DH_RSA_WITH_CAMELLIA_256_CBC_SHA256 : dotnet.System.Net.Security.TlsCipherSuite {
        get {
        let __return = dotnet.System.Net.Security.TlsCipherSuite(val: System_Net_Security_TlsCipherSuite_get_TLS_DH_RSA_WITH_CAMELLIA_256_CBC_SHA256());
            return __return;
        }
    }
    // static field: System.Net.Security.TlsCipherSuite TLS_DHE_DSS_WITH_CAMELLIA_256_CBC_SHA256
    /**
    Represents the TLS_DHE_DSS_WITH_CAMELLIA_256_CBC_SHA256 cipher suite.

    */
    public static var TLS_DHE_DSS_WITH_CAMELLIA_256_CBC_SHA256 : dotnet.System.Net.Security.TlsCipherSuite {
        get {
        let __return = dotnet.System.Net.Security.TlsCipherSuite(val: System_Net_Security_TlsCipherSuite_get_TLS_DHE_DSS_WITH_CAMELLIA_256_CBC_SHA256());
            return __return;
        }
    }
    // static field: System.Net.Security.TlsCipherSuite TLS_DHE_RSA_WITH_CAMELLIA_256_CBC_SHA256
    /**
    Represents the TLS_DHE_RSA_WITH_CAMELLIA_256_CBC_SHA256 cipher suite.

    */
    public static var TLS_DHE_RSA_WITH_CAMELLIA_256_CBC_SHA256 : dotnet.System.Net.Security.TlsCipherSuite {
        get {
        let __return = dotnet.System.Net.Security.TlsCipherSuite(val: System_Net_Security_TlsCipherSuite_get_TLS_DHE_RSA_WITH_CAMELLIA_256_CBC_SHA256());
            return __return;
        }
    }
    // static field: System.Net.Security.TlsCipherSuite TLS_DH_anon_WITH_CAMELLIA_256_CBC_SHA256
    /**
    Represents the TLS_DH_anon_WITH_CAMELLIA_256_CBC_SHA256 cipher suite.

    */
    public static var TLS_DH_anon_WITH_CAMELLIA_256_CBC_SHA256 : dotnet.System.Net.Security.TlsCipherSuite {
        get {
        let __return = dotnet.System.Net.Security.TlsCipherSuite(val: System_Net_Security_TlsCipherSuite_get_TLS_DH_anon_WITH_CAMELLIA_256_CBC_SHA256());
            return __return;
        }
    }
    // static field: System.Net.Security.TlsCipherSuite TLS_AES_128_GCM_SHA256
    /**
    Represents the TLS_AES_128_GCM_SHA256 cipher suite.

    */
    public static var TLS_AES_128_GCM_SHA256 : dotnet.System.Net.Security.TlsCipherSuite {
        get {
        let __return = dotnet.System.Net.Security.TlsCipherSuite(val: System_Net_Security_TlsCipherSuite_get_TLS_AES_128_GCM_SHA256());
            return __return;
        }
    }
    // static field: System.Net.Security.TlsCipherSuite TLS_AES_256_GCM_SHA384
    /**
    Represents the TLS_AES_256_GCM_SHA384 cipher suite.

    */
    public static var TLS_AES_256_GCM_SHA384 : dotnet.System.Net.Security.TlsCipherSuite {
        get {
        let __return = dotnet.System.Net.Security.TlsCipherSuite(val: System_Net_Security_TlsCipherSuite_get_TLS_AES_256_GCM_SHA384());
            return __return;
        }
    }
    // static field: System.Net.Security.TlsCipherSuite TLS_CHACHA20_POLY1305_SHA256
    /**
    Represents the TLS_CHACHA20_POLY1305_SHA256 cipher suite.

    */
    public static var TLS_CHACHA20_POLY1305_SHA256 : dotnet.System.Net.Security.TlsCipherSuite {
        get {
        let __return = dotnet.System.Net.Security.TlsCipherSuite(val: System_Net_Security_TlsCipherSuite_get_TLS_CHACHA20_POLY1305_SHA256());
            return __return;
        }
    }
    // static field: System.Net.Security.TlsCipherSuite TLS_AES_128_CCM_SHA256
    /**
    Represents the TLS_AES_128_CCM_SHA256 cipher suite.

    */
    public static var TLS_AES_128_CCM_SHA256 : dotnet.System.Net.Security.TlsCipherSuite {
        get {
        let __return = dotnet.System.Net.Security.TlsCipherSuite(val: System_Net_Security_TlsCipherSuite_get_TLS_AES_128_CCM_SHA256());
            return __return;
        }
    }
    // static field: System.Net.Security.TlsCipherSuite TLS_AES_128_CCM_8_SHA256
    /**
    Represents the TLS_AES_128_CCM_8_SHA256 cipher suite.

    */
    public static var TLS_AES_128_CCM_8_SHA256 : dotnet.System.Net.Security.TlsCipherSuite {
        get {
        let __return = dotnet.System.Net.Security.TlsCipherSuite(val: System_Net_Security_TlsCipherSuite_get_TLS_AES_128_CCM_8_SHA256());
            return __return;
        }
    }
    // static field: System.Net.Security.TlsCipherSuite TLS_ECDH_ECDSA_WITH_NULL_SHA
    /**
    Represents the TLS_ECDH_ECDSA_WITH_NULL_SHA cipher suite.

    */
    public static var TLS_ECDH_ECDSA_WITH_NULL_SHA : dotnet.System.Net.Security.TlsCipherSuite {
        get {
        let __return = dotnet.System.Net.Security.TlsCipherSuite(val: System_Net_Security_TlsCipherSuite_get_TLS_ECDH_ECDSA_WITH_NULL_SHA());
            return __return;
        }
    }
    // static field: System.Net.Security.TlsCipherSuite TLS_ECDH_ECDSA_WITH_RC4_128_SHA
    /**
    Represents the TLS_ECDH_ECDSA_WITH_RC4_128_SHA cipher suite.

    */
    public static var TLS_ECDH_ECDSA_WITH_RC4_128_SHA : dotnet.System.Net.Security.TlsCipherSuite {
        get {
        let __return = dotnet.System.Net.Security.TlsCipherSuite(val: System_Net_Security_TlsCipherSuite_get_TLS_ECDH_ECDSA_WITH_RC4_128_SHA());
            return __return;
        }
    }
    // static field: System.Net.Security.TlsCipherSuite TLS_ECDH_ECDSA_WITH_3DES_EDE_CBC_SHA
    /**
    Represents the TLS_ECDH_ECDSA_WITH_3DES_EDE_CBC_SHA cipher suite.

    */
    public static var TLS_ECDH_ECDSA_WITH_3DES_EDE_CBC_SHA : dotnet.System.Net.Security.TlsCipherSuite {
        get {
        let __return = dotnet.System.Net.Security.TlsCipherSuite(val: System_Net_Security_TlsCipherSuite_get_TLS_ECDH_ECDSA_WITH_3DES_EDE_CBC_SHA());
            return __return;
        }
    }
    // static field: System.Net.Security.TlsCipherSuite TLS_ECDH_ECDSA_WITH_AES_128_CBC_SHA
    /**
    Represents the TLS_ECDH_ECDSA_WITH_AES_128_CBC_SHA cipher suite.

    */
    public static var TLS_ECDH_ECDSA_WITH_AES_128_CBC_SHA : dotnet.System.Net.Security.TlsCipherSuite {
        get {
        let __return = dotnet.System.Net.Security.TlsCipherSuite(val: System_Net_Security_TlsCipherSuite_get_TLS_ECDH_ECDSA_WITH_AES_128_CBC_SHA());
            return __return;
        }
    }
    // static field: System.Net.Security.TlsCipherSuite TLS_ECDH_ECDSA_WITH_AES_256_CBC_SHA
    /**
    Represents the TLS_ECDH_ECDSA_WITH_AES_256_CBC_SHA cipher suite.

    */
    public static var TLS_ECDH_ECDSA_WITH_AES_256_CBC_SHA : dotnet.System.Net.Security.TlsCipherSuite {
        get {
        let __return = dotnet.System.Net.Security.TlsCipherSuite(val: System_Net_Security_TlsCipherSuite_get_TLS_ECDH_ECDSA_WITH_AES_256_CBC_SHA());
            return __return;
        }
    }
    // static field: System.Net.Security.TlsCipherSuite TLS_ECDHE_ECDSA_WITH_NULL_SHA
    /**
    Represents the TLS_ECDHE_ECDSA_WITH_NULL_SHA cipher suite.

    */
    public static var TLS_ECDHE_ECDSA_WITH_NULL_SHA : dotnet.System.Net.Security.TlsCipherSuite {
        get {
        let __return = dotnet.System.Net.Security.TlsCipherSuite(val: System_Net_Security_TlsCipherSuite_get_TLS_ECDHE_ECDSA_WITH_NULL_SHA());
            return __return;
        }
    }
    // static field: System.Net.Security.TlsCipherSuite TLS_ECDHE_ECDSA_WITH_RC4_128_SHA
    /**
    Represents the TLS_ECDHE_ECDSA_WITH_RC4_128_SHA cipher suite.

    */
    public static var TLS_ECDHE_ECDSA_WITH_RC4_128_SHA : dotnet.System.Net.Security.TlsCipherSuite {
        get {
        let __return = dotnet.System.Net.Security.TlsCipherSuite(val: System_Net_Security_TlsCipherSuite_get_TLS_ECDHE_ECDSA_WITH_RC4_128_SHA());
            return __return;
        }
    }
    // static field: System.Net.Security.TlsCipherSuite TLS_ECDHE_ECDSA_WITH_3DES_EDE_CBC_SHA
    /**
    Represents the TLS_ECDHE_ECDSA_WITH_3DES_EDE_CBC_SHA cipher suite.

    */
    public static var TLS_ECDHE_ECDSA_WITH_3DES_EDE_CBC_SHA : dotnet.System.Net.Security.TlsCipherSuite {
        get {
        let __return = dotnet.System.Net.Security.TlsCipherSuite(val: System_Net_Security_TlsCipherSuite_get_TLS_ECDHE_ECDSA_WITH_3DES_EDE_CBC_SHA());
            return __return;
        }
    }
    // static field: System.Net.Security.TlsCipherSuite TLS_ECDHE_ECDSA_WITH_AES_128_CBC_SHA
    /**
    Represents the TLS_ECDHE_ECDSA_WITH_AES_128_CBC_SHA cipher suite.

    */
    public static var TLS_ECDHE_ECDSA_WITH_AES_128_CBC_SHA : dotnet.System.Net.Security.TlsCipherSuite {
        get {
        let __return = dotnet.System.Net.Security.TlsCipherSuite(val: System_Net_Security_TlsCipherSuite_get_TLS_ECDHE_ECDSA_WITH_AES_128_CBC_SHA());
            return __return;
        }
    }
    // static field: System.Net.Security.TlsCipherSuite TLS_ECDHE_ECDSA_WITH_AES_256_CBC_SHA
    /**
    Represents the TLS_ECDHE_ECDSA_WITH_AES_256_CBC_SHA cipher suite.

    */
    public static var TLS_ECDHE_ECDSA_WITH_AES_256_CBC_SHA : dotnet.System.Net.Security.TlsCipherSuite {
        get {
        let __return = dotnet.System.Net.Security.TlsCipherSuite(val: System_Net_Security_TlsCipherSuite_get_TLS_ECDHE_ECDSA_WITH_AES_256_CBC_SHA());
            return __return;
        }
    }
    // static field: System.Net.Security.TlsCipherSuite TLS_ECDH_RSA_WITH_NULL_SHA
    /**
    Represents the TLS_ECDH_RSA_WITH_NULL_SHA cipher suite.

    */
    public static var TLS_ECDH_RSA_WITH_NULL_SHA : dotnet.System.Net.Security.TlsCipherSuite {
        get {
        let __return = dotnet.System.Net.Security.TlsCipherSuite(val: System_Net_Security_TlsCipherSuite_get_TLS_ECDH_RSA_WITH_NULL_SHA());
            return __return;
        }
    }
    // static field: System.Net.Security.TlsCipherSuite TLS_ECDH_RSA_WITH_RC4_128_SHA
    /**
    Represents the TLS_ECDH_RSA_WITH_RC4_128_SHA cipher suite.

    */
    public static var TLS_ECDH_RSA_WITH_RC4_128_SHA : dotnet.System.Net.Security.TlsCipherSuite {
        get {
        let __return = dotnet.System.Net.Security.TlsCipherSuite(val: System_Net_Security_TlsCipherSuite_get_TLS_ECDH_RSA_WITH_RC4_128_SHA());
            return __return;
        }
    }
    // static field: System.Net.Security.TlsCipherSuite TLS_ECDH_RSA_WITH_3DES_EDE_CBC_SHA
    /**
    Represents the TLS_ECDH_RSA_WITH_3DES_EDE_CBC_SHA cipher suite.

    */
    public static var TLS_ECDH_RSA_WITH_3DES_EDE_CBC_SHA : dotnet.System.Net.Security.TlsCipherSuite {
        get {
        let __return = dotnet.System.Net.Security.TlsCipherSuite(val: System_Net_Security_TlsCipherSuite_get_TLS_ECDH_RSA_WITH_3DES_EDE_CBC_SHA());
            return __return;
        }
    }
    // static field: System.Net.Security.TlsCipherSuite TLS_ECDH_RSA_WITH_AES_128_CBC_SHA
    /**
    Represents the TLS_ECDH_RSA_WITH_AES_128_CBC_SHA cipher suite.

    */
    public static var TLS_ECDH_RSA_WITH_AES_128_CBC_SHA : dotnet.System.Net.Security.TlsCipherSuite {
        get {
        let __return = dotnet.System.Net.Security.TlsCipherSuite(val: System_Net_Security_TlsCipherSuite_get_TLS_ECDH_RSA_WITH_AES_128_CBC_SHA());
            return __return;
        }
    }
    // static field: System.Net.Security.TlsCipherSuite TLS_ECDH_RSA_WITH_AES_256_CBC_SHA
    /**
    Represents the TLS_ECDH_RSA_WITH_AES_256_CBC_SHA cipher suite.

    */
    public static var TLS_ECDH_RSA_WITH_AES_256_CBC_SHA : dotnet.System.Net.Security.TlsCipherSuite {
        get {
        let __return = dotnet.System.Net.Security.TlsCipherSuite(val: System_Net_Security_TlsCipherSuite_get_TLS_ECDH_RSA_WITH_AES_256_CBC_SHA());
            return __return;
        }
    }
    // static field: System.Net.Security.TlsCipherSuite TLS_ECDHE_RSA_WITH_NULL_SHA
    /**
    Represents the TLS_ECDHE_RSA_WITH_NULL_SHA cipher suite.

    */
    public static var TLS_ECDHE_RSA_WITH_NULL_SHA : dotnet.System.Net.Security.TlsCipherSuite {
        get {
        let __return = dotnet.System.Net.Security.TlsCipherSuite(val: System_Net_Security_TlsCipherSuite_get_TLS_ECDHE_RSA_WITH_NULL_SHA());
            return __return;
        }
    }
    // static field: System.Net.Security.TlsCipherSuite TLS_ECDHE_RSA_WITH_RC4_128_SHA
    /**
    Represents the TLS_ECDHE_RSA_WITH_RC4_128_SHA cipher suite.

    */
    public static var TLS_ECDHE_RSA_WITH_RC4_128_SHA : dotnet.System.Net.Security.TlsCipherSuite {
        get {
        let __return = dotnet.System.Net.Security.TlsCipherSuite(val: System_Net_Security_TlsCipherSuite_get_TLS_ECDHE_RSA_WITH_RC4_128_SHA());
            return __return;
        }
    }
    // static field: System.Net.Security.TlsCipherSuite TLS_ECDHE_RSA_WITH_3DES_EDE_CBC_SHA
    /**
    Represents the TLS_ECDHE_RSA_WITH_3DES_EDE_CBC_SHA cipher suite.

    */
    public static var TLS_ECDHE_RSA_WITH_3DES_EDE_CBC_SHA : dotnet.System.Net.Security.TlsCipherSuite {
        get {
        let __return = dotnet.System.Net.Security.TlsCipherSuite(val: System_Net_Security_TlsCipherSuite_get_TLS_ECDHE_RSA_WITH_3DES_EDE_CBC_SHA());
            return __return;
        }
    }
    // static field: System.Net.Security.TlsCipherSuite TLS_ECDHE_RSA_WITH_AES_128_CBC_SHA
    /**
    Represents the TLS_ECDHE_RSA_WITH_AES_128_CBC_SHA cipher suite.

    */
    public static var TLS_ECDHE_RSA_WITH_AES_128_CBC_SHA : dotnet.System.Net.Security.TlsCipherSuite {
        get {
        let __return = dotnet.System.Net.Security.TlsCipherSuite(val: System_Net_Security_TlsCipherSuite_get_TLS_ECDHE_RSA_WITH_AES_128_CBC_SHA());
            return __return;
        }
    }
    // static field: System.Net.Security.TlsCipherSuite TLS_ECDHE_RSA_WITH_AES_256_CBC_SHA
    /**
    Represents the TLS_ECDHE_RSA_WITH_AES_256_CBC_SHA cipher suite.

    */
    public static var TLS_ECDHE_RSA_WITH_AES_256_CBC_SHA : dotnet.System.Net.Security.TlsCipherSuite {
        get {
        let __return = dotnet.System.Net.Security.TlsCipherSuite(val: System_Net_Security_TlsCipherSuite_get_TLS_ECDHE_RSA_WITH_AES_256_CBC_SHA());
            return __return;
        }
    }
    // static field: System.Net.Security.TlsCipherSuite TLS_ECDH_anon_WITH_NULL_SHA
    /**
    Represents the TLS_ECDH_anon_WITH_NULL_SHA cipher suite.

    */
    public static var TLS_ECDH_anon_WITH_NULL_SHA : dotnet.System.Net.Security.TlsCipherSuite {
        get {
        let __return = dotnet.System.Net.Security.TlsCipherSuite(val: System_Net_Security_TlsCipherSuite_get_TLS_ECDH_anon_WITH_NULL_SHA());
            return __return;
        }
    }
    // static field: System.Net.Security.TlsCipherSuite TLS_ECDH_anon_WITH_RC4_128_SHA
    /**
    Represents the TLS_ECDH_anon_WITH_RC4_128_SHA cipher suite.

    */
    public static var TLS_ECDH_anon_WITH_RC4_128_SHA : dotnet.System.Net.Security.TlsCipherSuite {
        get {
        let __return = dotnet.System.Net.Security.TlsCipherSuite(val: System_Net_Security_TlsCipherSuite_get_TLS_ECDH_anon_WITH_RC4_128_SHA());
            return __return;
        }
    }
    // static field: System.Net.Security.TlsCipherSuite TLS_ECDH_anon_WITH_3DES_EDE_CBC_SHA
    /**
    Represents the TLS_ECDH_anon_WITH_3DES_EDE_CBC_SHA cipher suite.

    */
    public static var TLS_ECDH_anon_WITH_3DES_EDE_CBC_SHA : dotnet.System.Net.Security.TlsCipherSuite {
        get {
        let __return = dotnet.System.Net.Security.TlsCipherSuite(val: System_Net_Security_TlsCipherSuite_get_TLS_ECDH_anon_WITH_3DES_EDE_CBC_SHA());
            return __return;
        }
    }
    // static field: System.Net.Security.TlsCipherSuite TLS_ECDH_anon_WITH_AES_128_CBC_SHA
    /**
    Represents the TLS_ECDH_anon_WITH_AES_128_CBC_SHA cipher suite.

    */
    public static var TLS_ECDH_anon_WITH_AES_128_CBC_SHA : dotnet.System.Net.Security.TlsCipherSuite {
        get {
        let __return = dotnet.System.Net.Security.TlsCipherSuite(val: System_Net_Security_TlsCipherSuite_get_TLS_ECDH_anon_WITH_AES_128_CBC_SHA());
            return __return;
        }
    }
    // static field: System.Net.Security.TlsCipherSuite TLS_ECDH_anon_WITH_AES_256_CBC_SHA
    /**
    Represents the TLS_ECDH_anon_WITH_AES_256_CBC_SHA cipher suite.

    */
    public static var TLS_ECDH_anon_WITH_AES_256_CBC_SHA : dotnet.System.Net.Security.TlsCipherSuite {
        get {
        let __return = dotnet.System.Net.Security.TlsCipherSuite(val: System_Net_Security_TlsCipherSuite_get_TLS_ECDH_anon_WITH_AES_256_CBC_SHA());
            return __return;
        }
    }
    // static field: System.Net.Security.TlsCipherSuite TLS_SRP_SHA_WITH_3DES_EDE_CBC_SHA
    /**
    Represents the TLS_SRP_SHA_WITH_3DES_EDE_CBC_SHA cipher suite.

    */
    public static var TLS_SRP_SHA_WITH_3DES_EDE_CBC_SHA : dotnet.System.Net.Security.TlsCipherSuite {
        get {
        let __return = dotnet.System.Net.Security.TlsCipherSuite(val: System_Net_Security_TlsCipherSuite_get_TLS_SRP_SHA_WITH_3DES_EDE_CBC_SHA());
            return __return;
        }
    }
    // static field: System.Net.Security.TlsCipherSuite TLS_SRP_SHA_RSA_WITH_3DES_EDE_CBC_SHA
    /**
    Represents the TLS_SRP_SHA_RSA_WITH_3DES_EDE_CBC_SHA cipher suite.

    */
    public static var TLS_SRP_SHA_RSA_WITH_3DES_EDE_CBC_SHA : dotnet.System.Net.Security.TlsCipherSuite {
        get {
        let __return = dotnet.System.Net.Security.TlsCipherSuite(val: System_Net_Security_TlsCipherSuite_get_TLS_SRP_SHA_RSA_WITH_3DES_EDE_CBC_SHA());
            return __return;
        }
    }
    // static field: System.Net.Security.TlsCipherSuite TLS_SRP_SHA_DSS_WITH_3DES_EDE_CBC_SHA
    /**
    Represents the TLS_SRP_SHA_DSS_WITH_3DES_EDE_CBC_SHA cipher suite.

    */
    public static var TLS_SRP_SHA_DSS_WITH_3DES_EDE_CBC_SHA : dotnet.System.Net.Security.TlsCipherSuite {
        get {
        let __return = dotnet.System.Net.Security.TlsCipherSuite(val: System_Net_Security_TlsCipherSuite_get_TLS_SRP_SHA_DSS_WITH_3DES_EDE_CBC_SHA());
            return __return;
        }
    }
    // static field: System.Net.Security.TlsCipherSuite TLS_SRP_SHA_WITH_AES_128_CBC_SHA
    /**
    Represents the TLS_SRP_SHA_WITH_AES_128_CBC_SHA cipher suite.

    */
    public static var TLS_SRP_SHA_WITH_AES_128_CBC_SHA : dotnet.System.Net.Security.TlsCipherSuite {
        get {
        let __return = dotnet.System.Net.Security.TlsCipherSuite(val: System_Net_Security_TlsCipherSuite_get_TLS_SRP_SHA_WITH_AES_128_CBC_SHA());
            return __return;
        }
    }
    // static field: System.Net.Security.TlsCipherSuite TLS_SRP_SHA_RSA_WITH_AES_128_CBC_SHA
    /**
    Represents the TLS_SRP_SHA_RSA_WITH_AES_128_CBC_SHA cipher suite.

    */
    public static var TLS_SRP_SHA_RSA_WITH_AES_128_CBC_SHA : dotnet.System.Net.Security.TlsCipherSuite {
        get {
        let __return = dotnet.System.Net.Security.TlsCipherSuite(val: System_Net_Security_TlsCipherSuite_get_TLS_SRP_SHA_RSA_WITH_AES_128_CBC_SHA());
            return __return;
        }
    }
    // static field: System.Net.Security.TlsCipherSuite TLS_SRP_SHA_DSS_WITH_AES_128_CBC_SHA
    /**
    Represents the TLS_SRP_SHA_DSS_WITH_AES_128_CBC_SHA cipher suite.

    */
    public static var TLS_SRP_SHA_DSS_WITH_AES_128_CBC_SHA : dotnet.System.Net.Security.TlsCipherSuite {
        get {
        let __return = dotnet.System.Net.Security.TlsCipherSuite(val: System_Net_Security_TlsCipherSuite_get_TLS_SRP_SHA_DSS_WITH_AES_128_CBC_SHA());
            return __return;
        }
    }
    // static field: System.Net.Security.TlsCipherSuite TLS_SRP_SHA_WITH_AES_256_CBC_SHA
    /**
    Represents the TLS_SRP_SHA_WITH_AES_256_CBC_SHA cipher suite.

    */
    public static var TLS_SRP_SHA_WITH_AES_256_CBC_SHA : dotnet.System.Net.Security.TlsCipherSuite {
        get {
        let __return = dotnet.System.Net.Security.TlsCipherSuite(val: System_Net_Security_TlsCipherSuite_get_TLS_SRP_SHA_WITH_AES_256_CBC_SHA());
            return __return;
        }
    }
    // static field: System.Net.Security.TlsCipherSuite TLS_SRP_SHA_RSA_WITH_AES_256_CBC_SHA
    /**
    Represents the TLS_SRP_SHA_RSA_WITH_AES_256_CBC_SHA cipher suite.

    */
    public static var TLS_SRP_SHA_RSA_WITH_AES_256_CBC_SHA : dotnet.System.Net.Security.TlsCipherSuite {
        get {
        let __return = dotnet.System.Net.Security.TlsCipherSuite(val: System_Net_Security_TlsCipherSuite_get_TLS_SRP_SHA_RSA_WITH_AES_256_CBC_SHA());
            return __return;
        }
    }
    // static field: System.Net.Security.TlsCipherSuite TLS_SRP_SHA_DSS_WITH_AES_256_CBC_SHA
    /**
    Represents the TLS_SRP_SHA_DSS_WITH_AES_256_CBC_SHA cipher suite.

    */
    public static var TLS_SRP_SHA_DSS_WITH_AES_256_CBC_SHA : dotnet.System.Net.Security.TlsCipherSuite {
        get {
        let __return = dotnet.System.Net.Security.TlsCipherSuite(val: System_Net_Security_TlsCipherSuite_get_TLS_SRP_SHA_DSS_WITH_AES_256_CBC_SHA());
            return __return;
        }
    }
    // static field: System.Net.Security.TlsCipherSuite TLS_ECDHE_ECDSA_WITH_AES_128_CBC_SHA256
    /**
    Represents the TLS_ECDHE_ECDSA_WITH_AES_128_CBC_SHA256 cipher suite.

    */
    public static var TLS_ECDHE_ECDSA_WITH_AES_128_CBC_SHA256 : dotnet.System.Net.Security.TlsCipherSuite {
        get {
        let __return = dotnet.System.Net.Security.TlsCipherSuite(val: System_Net_Security_TlsCipherSuite_get_TLS_ECDHE_ECDSA_WITH_AES_128_CBC_SHA256());
            return __return;
        }
    }
    // static field: System.Net.Security.TlsCipherSuite TLS_ECDHE_ECDSA_WITH_AES_256_CBC_SHA384
    /**
    Represents the TLS_ECDHE_ECDSA_WITH_AES_256_CBC_SHA384 cipher suite.

    */
    public static var TLS_ECDHE_ECDSA_WITH_AES_256_CBC_SHA384 : dotnet.System.Net.Security.TlsCipherSuite {
        get {
        let __return = dotnet.System.Net.Security.TlsCipherSuite(val: System_Net_Security_TlsCipherSuite_get_TLS_ECDHE_ECDSA_WITH_AES_256_CBC_SHA384());
            return __return;
        }
    }
    // static field: System.Net.Security.TlsCipherSuite TLS_ECDH_ECDSA_WITH_AES_128_CBC_SHA256
    /**
    Represents the TLS_ECDH_ECDSA_WITH_AES_128_CBC_SHA256 cipher suite.

    */
    public static var TLS_ECDH_ECDSA_WITH_AES_128_CBC_SHA256 : dotnet.System.Net.Security.TlsCipherSuite {
        get {
        let __return = dotnet.System.Net.Security.TlsCipherSuite(val: System_Net_Security_TlsCipherSuite_get_TLS_ECDH_ECDSA_WITH_AES_128_CBC_SHA256());
            return __return;
        }
    }
    // static field: System.Net.Security.TlsCipherSuite TLS_ECDH_ECDSA_WITH_AES_256_CBC_SHA384
    /**
    Represents the TLS_ECDH_ECDSA_WITH_AES_256_CBC_SHA384 cipher suite.

    */
    public static var TLS_ECDH_ECDSA_WITH_AES_256_CBC_SHA384 : dotnet.System.Net.Security.TlsCipherSuite {
        get {
        let __return = dotnet.System.Net.Security.TlsCipherSuite(val: System_Net_Security_TlsCipherSuite_get_TLS_ECDH_ECDSA_WITH_AES_256_CBC_SHA384());
            return __return;
        }
    }
    // static field: System.Net.Security.TlsCipherSuite TLS_ECDHE_RSA_WITH_AES_128_CBC_SHA256
    /**
    Represents the TLS_ECDHE_RSA_WITH_AES_128_CBC_SHA256 cipher suite.

    */
    public static var TLS_ECDHE_RSA_WITH_AES_128_CBC_SHA256 : dotnet.System.Net.Security.TlsCipherSuite {
        get {
        let __return = dotnet.System.Net.Security.TlsCipherSuite(val: System_Net_Security_TlsCipherSuite_get_TLS_ECDHE_RSA_WITH_AES_128_CBC_SHA256());
            return __return;
        }
    }
    // static field: System.Net.Security.TlsCipherSuite TLS_ECDHE_RSA_WITH_AES_256_CBC_SHA384
    /**
    Represents the TLS_ECDHE_RSA_WITH_AES_256_CBC_SHA384 cipher suite.

    */
    public static var TLS_ECDHE_RSA_WITH_AES_256_CBC_SHA384 : dotnet.System.Net.Security.TlsCipherSuite {
        get {
        let __return = dotnet.System.Net.Security.TlsCipherSuite(val: System_Net_Security_TlsCipherSuite_get_TLS_ECDHE_RSA_WITH_AES_256_CBC_SHA384());
            return __return;
        }
    }
    // static field: System.Net.Security.TlsCipherSuite TLS_ECDH_RSA_WITH_AES_128_CBC_SHA256
    /**
    Represents the TLS_ECDH_RSA_WITH_AES_128_CBC_SHA256 cipher suite.

    */
    public static var TLS_ECDH_RSA_WITH_AES_128_CBC_SHA256 : dotnet.System.Net.Security.TlsCipherSuite {
        get {
        let __return = dotnet.System.Net.Security.TlsCipherSuite(val: System_Net_Security_TlsCipherSuite_get_TLS_ECDH_RSA_WITH_AES_128_CBC_SHA256());
            return __return;
        }
    }
    // static field: System.Net.Security.TlsCipherSuite TLS_ECDH_RSA_WITH_AES_256_CBC_SHA384
    /**
    Represents the TLS_ECDH_RSA_WITH_AES_256_CBC_SHA384 cipher suite.

    */
    public static var TLS_ECDH_RSA_WITH_AES_256_CBC_SHA384 : dotnet.System.Net.Security.TlsCipherSuite {
        get {
        let __return = dotnet.System.Net.Security.TlsCipherSuite(val: System_Net_Security_TlsCipherSuite_get_TLS_ECDH_RSA_WITH_AES_256_CBC_SHA384());
            return __return;
        }
    }
    // static field: System.Net.Security.TlsCipherSuite TLS_ECDHE_ECDSA_WITH_AES_128_GCM_SHA256
    /**
    Represents the TLS_ECDHE_ECDSA_WITH_AES_128_GCM_SHA256 cipher suite.

    */
    public static var TLS_ECDHE_ECDSA_WITH_AES_128_GCM_SHA256 : dotnet.System.Net.Security.TlsCipherSuite {
        get {
        let __return = dotnet.System.Net.Security.TlsCipherSuite(val: System_Net_Security_TlsCipherSuite_get_TLS_ECDHE_ECDSA_WITH_AES_128_GCM_SHA256());
            return __return;
        }
    }
    // static field: System.Net.Security.TlsCipherSuite TLS_ECDHE_ECDSA_WITH_AES_256_GCM_SHA384
    /**
    Represents the TLS_ECDHE_ECDSA_WITH_AES_256_GCM_SHA384 cipher suite.

    */
    public static var TLS_ECDHE_ECDSA_WITH_AES_256_GCM_SHA384 : dotnet.System.Net.Security.TlsCipherSuite {
        get {
        let __return = dotnet.System.Net.Security.TlsCipherSuite(val: System_Net_Security_TlsCipherSuite_get_TLS_ECDHE_ECDSA_WITH_AES_256_GCM_SHA384());
            return __return;
        }
    }
    // static field: System.Net.Security.TlsCipherSuite TLS_ECDH_ECDSA_WITH_AES_128_GCM_SHA256
    /**
    Represents the TLS_ECDH_ECDSA_WITH_AES_128_GCM_SHA256 cipher suite.

    */
    public static var TLS_ECDH_ECDSA_WITH_AES_128_GCM_SHA256 : dotnet.System.Net.Security.TlsCipherSuite {
        get {
        let __return = dotnet.System.Net.Security.TlsCipherSuite(val: System_Net_Security_TlsCipherSuite_get_TLS_ECDH_ECDSA_WITH_AES_128_GCM_SHA256());
            return __return;
        }
    }
    // static field: System.Net.Security.TlsCipherSuite TLS_ECDH_ECDSA_WITH_AES_256_GCM_SHA384
    /**
    Represents the TLS_ECDH_ECDSA_WITH_AES_256_GCM_SHA384 cipher suite.

    */
    public static var TLS_ECDH_ECDSA_WITH_AES_256_GCM_SHA384 : dotnet.System.Net.Security.TlsCipherSuite {
        get {
        let __return = dotnet.System.Net.Security.TlsCipherSuite(val: System_Net_Security_TlsCipherSuite_get_TLS_ECDH_ECDSA_WITH_AES_256_GCM_SHA384());
            return __return;
        }
    }
    // static field: System.Net.Security.TlsCipherSuite TLS_ECDHE_RSA_WITH_AES_128_GCM_SHA256
    /**
    Represents the TLS_ECDHE_RSA_WITH_AES_128_GCM_SHA256 cipher suite.

    */
    public static var TLS_ECDHE_RSA_WITH_AES_128_GCM_SHA256 : dotnet.System.Net.Security.TlsCipherSuite {
        get {
        let __return = dotnet.System.Net.Security.TlsCipherSuite(val: System_Net_Security_TlsCipherSuite_get_TLS_ECDHE_RSA_WITH_AES_128_GCM_SHA256());
            return __return;
        }
    }
    // static field: System.Net.Security.TlsCipherSuite TLS_ECDHE_RSA_WITH_AES_256_GCM_SHA384
    /**
    Represents the TLS_ECDHE_RSA_WITH_AES_256_GCM_SHA384 cipher suite.

    */
    public static var TLS_ECDHE_RSA_WITH_AES_256_GCM_SHA384 : dotnet.System.Net.Security.TlsCipherSuite {
        get {
        let __return = dotnet.System.Net.Security.TlsCipherSuite(val: System_Net_Security_TlsCipherSuite_get_TLS_ECDHE_RSA_WITH_AES_256_GCM_SHA384());
            return __return;
        }
    }
    // static field: System.Net.Security.TlsCipherSuite TLS_ECDH_RSA_WITH_AES_128_GCM_SHA256
    /**
    Represents the TLS_ECDH_RSA_WITH_AES_128_GCM_SHA256 cipher suite.

    */
    public static var TLS_ECDH_RSA_WITH_AES_128_GCM_SHA256 : dotnet.System.Net.Security.TlsCipherSuite {
        get {
        let __return = dotnet.System.Net.Security.TlsCipherSuite(val: System_Net_Security_TlsCipherSuite_get_TLS_ECDH_RSA_WITH_AES_128_GCM_SHA256());
            return __return;
        }
    }
    // static field: System.Net.Security.TlsCipherSuite TLS_ECDH_RSA_WITH_AES_256_GCM_SHA384
    /**
    Represents the TLS_ECDH_RSA_WITH_AES_256_GCM_SHA384 cipher suite.

    */
    public static var TLS_ECDH_RSA_WITH_AES_256_GCM_SHA384 : dotnet.System.Net.Security.TlsCipherSuite {
        get {
        let __return = dotnet.System.Net.Security.TlsCipherSuite(val: System_Net_Security_TlsCipherSuite_get_TLS_ECDH_RSA_WITH_AES_256_GCM_SHA384());
            return __return;
        }
    }
    // static field: System.Net.Security.TlsCipherSuite TLS_ECDHE_PSK_WITH_RC4_128_SHA
    /**
    Represents the TLS_ECDHE_PSK_WITH_RC4_128_SHA cipher suite.

    */
    public static var TLS_ECDHE_PSK_WITH_RC4_128_SHA : dotnet.System.Net.Security.TlsCipherSuite {
        get {
        let __return = dotnet.System.Net.Security.TlsCipherSuite(val: System_Net_Security_TlsCipherSuite_get_TLS_ECDHE_PSK_WITH_RC4_128_SHA());
            return __return;
        }
    }
    // static field: System.Net.Security.TlsCipherSuite TLS_ECDHE_PSK_WITH_3DES_EDE_CBC_SHA
    /**
    Represents the TLS_ECDHE_PSK_WITH_3DES_EDE_CBC_SHA cipher suite.

    */
    public static var TLS_ECDHE_PSK_WITH_3DES_EDE_CBC_SHA : dotnet.System.Net.Security.TlsCipherSuite {
        get {
        let __return = dotnet.System.Net.Security.TlsCipherSuite(val: System_Net_Security_TlsCipherSuite_get_TLS_ECDHE_PSK_WITH_3DES_EDE_CBC_SHA());
            return __return;
        }
    }
    // static field: System.Net.Security.TlsCipherSuite TLS_ECDHE_PSK_WITH_AES_128_CBC_SHA
    /**
    Represents the TLS_ECDHE_PSK_WITH_AES_128_CBC_SHA cipher suite.

    */
    public static var TLS_ECDHE_PSK_WITH_AES_128_CBC_SHA : dotnet.System.Net.Security.TlsCipherSuite {
        get {
        let __return = dotnet.System.Net.Security.TlsCipherSuite(val: System_Net_Security_TlsCipherSuite_get_TLS_ECDHE_PSK_WITH_AES_128_CBC_SHA());
            return __return;
        }
    }
    // static field: System.Net.Security.TlsCipherSuite TLS_ECDHE_PSK_WITH_AES_256_CBC_SHA
    /**
    Represents the TLS_ECDHE_PSK_WITH_AES_256_CBC_SHA cipher suite.

    */
    public static var TLS_ECDHE_PSK_WITH_AES_256_CBC_SHA : dotnet.System.Net.Security.TlsCipherSuite {
        get {
        let __return = dotnet.System.Net.Security.TlsCipherSuite(val: System_Net_Security_TlsCipherSuite_get_TLS_ECDHE_PSK_WITH_AES_256_CBC_SHA());
            return __return;
        }
    }
    // static field: System.Net.Security.TlsCipherSuite TLS_ECDHE_PSK_WITH_AES_128_CBC_SHA256
    /**
    Represents the TLS_ECDHE_PSK_WITH_AES_128_CBC_SHA256 cipher suite.

    */
    public static var TLS_ECDHE_PSK_WITH_AES_128_CBC_SHA256 : dotnet.System.Net.Security.TlsCipherSuite {
        get {
        let __return = dotnet.System.Net.Security.TlsCipherSuite(val: System_Net_Security_TlsCipherSuite_get_TLS_ECDHE_PSK_WITH_AES_128_CBC_SHA256());
            return __return;
        }
    }
    // static field: System.Net.Security.TlsCipherSuite TLS_ECDHE_PSK_WITH_AES_256_CBC_SHA384
    /**
    Represents the TLS_ECDHE_PSK_WITH_AES_256_CBC_SHA384 cipher suite.

    */
    public static var TLS_ECDHE_PSK_WITH_AES_256_CBC_SHA384 : dotnet.System.Net.Security.TlsCipherSuite {
        get {
        let __return = dotnet.System.Net.Security.TlsCipherSuite(val: System_Net_Security_TlsCipherSuite_get_TLS_ECDHE_PSK_WITH_AES_256_CBC_SHA384());
            return __return;
        }
    }
    // static field: System.Net.Security.TlsCipherSuite TLS_ECDHE_PSK_WITH_NULL_SHA
    /**
    Represents the TLS_ECDHE_PSK_WITH_NULL_SHA cipher suite.

    */
    public static var TLS_ECDHE_PSK_WITH_NULL_SHA : dotnet.System.Net.Security.TlsCipherSuite {
        get {
        let __return = dotnet.System.Net.Security.TlsCipherSuite(val: System_Net_Security_TlsCipherSuite_get_TLS_ECDHE_PSK_WITH_NULL_SHA());
            return __return;
        }
    }
    // static field: System.Net.Security.TlsCipherSuite TLS_ECDHE_PSK_WITH_NULL_SHA256
    /**
    Represents the TLS_ECDHE_PSK_WITH_NULL_SHA256 cipher suite.

    */
    public static var TLS_ECDHE_PSK_WITH_NULL_SHA256 : dotnet.System.Net.Security.TlsCipherSuite {
        get {
        let __return = dotnet.System.Net.Security.TlsCipherSuite(val: System_Net_Security_TlsCipherSuite_get_TLS_ECDHE_PSK_WITH_NULL_SHA256());
            return __return;
        }
    }
    // static field: System.Net.Security.TlsCipherSuite TLS_ECDHE_PSK_WITH_NULL_SHA384
    /**
    Represents the TLS_ECDHE_PSK_WITH_NULL_SHA384 cipher suite.

    */
    public static var TLS_ECDHE_PSK_WITH_NULL_SHA384 : dotnet.System.Net.Security.TlsCipherSuite {
        get {
        let __return = dotnet.System.Net.Security.TlsCipherSuite(val: System_Net_Security_TlsCipherSuite_get_TLS_ECDHE_PSK_WITH_NULL_SHA384());
            return __return;
        }
    }
    // static field: System.Net.Security.TlsCipherSuite TLS_RSA_WITH_ARIA_128_CBC_SHA256
    /**
    Represents the TLS_RSA_WITH_ARIA_128_CBC_SHA256 cipher suite.

    */
    public static var TLS_RSA_WITH_ARIA_128_CBC_SHA256 : dotnet.System.Net.Security.TlsCipherSuite {
        get {
        let __return = dotnet.System.Net.Security.TlsCipherSuite(val: System_Net_Security_TlsCipherSuite_get_TLS_RSA_WITH_ARIA_128_CBC_SHA256());
            return __return;
        }
    }
    // static field: System.Net.Security.TlsCipherSuite TLS_RSA_WITH_ARIA_256_CBC_SHA384
    /**
    Represents the TLS_RSA_WITH_ARIA_256_CBC_SHA384 cipher suite.

    */
    public static var TLS_RSA_WITH_ARIA_256_CBC_SHA384 : dotnet.System.Net.Security.TlsCipherSuite {
        get {
        let __return = dotnet.System.Net.Security.TlsCipherSuite(val: System_Net_Security_TlsCipherSuite_get_TLS_RSA_WITH_ARIA_256_CBC_SHA384());
            return __return;
        }
    }
    // static field: System.Net.Security.TlsCipherSuite TLS_DH_DSS_WITH_ARIA_128_CBC_SHA256
    /**
    Represents the TLS_DH_DSS_WITH_ARIA_128_CBC_SHA256 cipher suite.

    */
    public static var TLS_DH_DSS_WITH_ARIA_128_CBC_SHA256 : dotnet.System.Net.Security.TlsCipherSuite {
        get {
        let __return = dotnet.System.Net.Security.TlsCipherSuite(val: System_Net_Security_TlsCipherSuite_get_TLS_DH_DSS_WITH_ARIA_128_CBC_SHA256());
            return __return;
        }
    }
    // static field: System.Net.Security.TlsCipherSuite TLS_DH_DSS_WITH_ARIA_256_CBC_SHA384
    /**
    Represents the TLS_DH_DSS_WITH_ARIA_256_CBC_SHA384 cipher suite.

    */
    public static var TLS_DH_DSS_WITH_ARIA_256_CBC_SHA384 : dotnet.System.Net.Security.TlsCipherSuite {
        get {
        let __return = dotnet.System.Net.Security.TlsCipherSuite(val: System_Net_Security_TlsCipherSuite_get_TLS_DH_DSS_WITH_ARIA_256_CBC_SHA384());
            return __return;
        }
    }
    // static field: System.Net.Security.TlsCipherSuite TLS_DH_RSA_WITH_ARIA_128_CBC_SHA256
    /**
    Represents the TLS_DH_RSA_WITH_ARIA_128_CBC_SHA256 cipher suite.

    */
    public static var TLS_DH_RSA_WITH_ARIA_128_CBC_SHA256 : dotnet.System.Net.Security.TlsCipherSuite {
        get {
        let __return = dotnet.System.Net.Security.TlsCipherSuite(val: System_Net_Security_TlsCipherSuite_get_TLS_DH_RSA_WITH_ARIA_128_CBC_SHA256());
            return __return;
        }
    }
    // static field: System.Net.Security.TlsCipherSuite TLS_DH_RSA_WITH_ARIA_256_CBC_SHA384
    /**
    Represents the TLS_DH_RSA_WITH_ARIA_256_CBC_SHA384 cipher suite.

    */
    public static var TLS_DH_RSA_WITH_ARIA_256_CBC_SHA384 : dotnet.System.Net.Security.TlsCipherSuite {
        get {
        let __return = dotnet.System.Net.Security.TlsCipherSuite(val: System_Net_Security_TlsCipherSuite_get_TLS_DH_RSA_WITH_ARIA_256_CBC_SHA384());
            return __return;
        }
    }
    // static field: System.Net.Security.TlsCipherSuite TLS_DHE_DSS_WITH_ARIA_128_CBC_SHA256
    /**
    Represents the TLS_DHE_DSS_WITH_ARIA_128_CBC_SHA256 cipher suite.

    */
    public static var TLS_DHE_DSS_WITH_ARIA_128_CBC_SHA256 : dotnet.System.Net.Security.TlsCipherSuite {
        get {
        let __return = dotnet.System.Net.Security.TlsCipherSuite(val: System_Net_Security_TlsCipherSuite_get_TLS_DHE_DSS_WITH_ARIA_128_CBC_SHA256());
            return __return;
        }
    }
    // static field: System.Net.Security.TlsCipherSuite TLS_DHE_DSS_WITH_ARIA_256_CBC_SHA384
    /**
    Represents the TLS_DHE_DSS_WITH_ARIA_256_CBC_SHA384 cipher suite.

    */
    public static var TLS_DHE_DSS_WITH_ARIA_256_CBC_SHA384 : dotnet.System.Net.Security.TlsCipherSuite {
        get {
        let __return = dotnet.System.Net.Security.TlsCipherSuite(val: System_Net_Security_TlsCipherSuite_get_TLS_DHE_DSS_WITH_ARIA_256_CBC_SHA384());
            return __return;
        }
    }
    // static field: System.Net.Security.TlsCipherSuite TLS_DHE_RSA_WITH_ARIA_128_CBC_SHA256
    /**
    Represents the TLS_DHE_RSA_WITH_ARIA_128_CBC_SHA256 cipher suite.

    */
    public static var TLS_DHE_RSA_WITH_ARIA_128_CBC_SHA256 : dotnet.System.Net.Security.TlsCipherSuite {
        get {
        let __return = dotnet.System.Net.Security.TlsCipherSuite(val: System_Net_Security_TlsCipherSuite_get_TLS_DHE_RSA_WITH_ARIA_128_CBC_SHA256());
            return __return;
        }
    }
    // static field: System.Net.Security.TlsCipherSuite TLS_DHE_RSA_WITH_ARIA_256_CBC_SHA384
    /**
    Represents the TLS_DHE_RSA_WITH_ARIA_256_CBC_SHA384 cipher suite.

    */
    public static var TLS_DHE_RSA_WITH_ARIA_256_CBC_SHA384 : dotnet.System.Net.Security.TlsCipherSuite {
        get {
        let __return = dotnet.System.Net.Security.TlsCipherSuite(val: System_Net_Security_TlsCipherSuite_get_TLS_DHE_RSA_WITH_ARIA_256_CBC_SHA384());
            return __return;
        }
    }
    // static field: System.Net.Security.TlsCipherSuite TLS_DH_anon_WITH_ARIA_128_CBC_SHA256
    /**
    Represents the TLS_DH_anon_WITH_ARIA_128_CBC_SHA256 cipher suite.

    */
    public static var TLS_DH_anon_WITH_ARIA_128_CBC_SHA256 : dotnet.System.Net.Security.TlsCipherSuite {
        get {
        let __return = dotnet.System.Net.Security.TlsCipherSuite(val: System_Net_Security_TlsCipherSuite_get_TLS_DH_anon_WITH_ARIA_128_CBC_SHA256());
            return __return;
        }
    }
    // static field: System.Net.Security.TlsCipherSuite TLS_DH_anon_WITH_ARIA_256_CBC_SHA384
    /**
    Represents the TLS_DH_anon_WITH_ARIA_256_CBC_SHA384 cipher suite.

    */
    public static var TLS_DH_anon_WITH_ARIA_256_CBC_SHA384 : dotnet.System.Net.Security.TlsCipherSuite {
        get {
        let __return = dotnet.System.Net.Security.TlsCipherSuite(val: System_Net_Security_TlsCipherSuite_get_TLS_DH_anon_WITH_ARIA_256_CBC_SHA384());
            return __return;
        }
    }
    // static field: System.Net.Security.TlsCipherSuite TLS_ECDHE_ECDSA_WITH_ARIA_128_CBC_SHA256
    /**
    Represents the TLS_ECDHE_ECDSA_WITH_ARIA_128_CBC_SHA256 cipher suite.

    */
    public static var TLS_ECDHE_ECDSA_WITH_ARIA_128_CBC_SHA256 : dotnet.System.Net.Security.TlsCipherSuite {
        get {
        let __return = dotnet.System.Net.Security.TlsCipherSuite(val: System_Net_Security_TlsCipherSuite_get_TLS_ECDHE_ECDSA_WITH_ARIA_128_CBC_SHA256());
            return __return;
        }
    }
    // static field: System.Net.Security.TlsCipherSuite TLS_ECDHE_ECDSA_WITH_ARIA_256_CBC_SHA384
    /**
    Represents the TLS_ECDHE_ECDSA_WITH_ARIA_256_CBC_SHA384 cipher suite.

    */
    public static var TLS_ECDHE_ECDSA_WITH_ARIA_256_CBC_SHA384 : dotnet.System.Net.Security.TlsCipherSuite {
        get {
        let __return = dotnet.System.Net.Security.TlsCipherSuite(val: System_Net_Security_TlsCipherSuite_get_TLS_ECDHE_ECDSA_WITH_ARIA_256_CBC_SHA384());
            return __return;
        }
    }
    // static field: System.Net.Security.TlsCipherSuite TLS_ECDH_ECDSA_WITH_ARIA_128_CBC_SHA256
    /**
    Represents the TLS_ECDH_ECDSA_WITH_ARIA_128_CBC_SHA256 cipher suite.

    */
    public static var TLS_ECDH_ECDSA_WITH_ARIA_128_CBC_SHA256 : dotnet.System.Net.Security.TlsCipherSuite {
        get {
        let __return = dotnet.System.Net.Security.TlsCipherSuite(val: System_Net_Security_TlsCipherSuite_get_TLS_ECDH_ECDSA_WITH_ARIA_128_CBC_SHA256());
            return __return;
        }
    }
    // static field: System.Net.Security.TlsCipherSuite TLS_ECDH_ECDSA_WITH_ARIA_256_CBC_SHA384
    /**
    Represents the TLS_ECDH_ECDSA_WITH_ARIA_256_CBC_SHA384 cipher suite.

    */
    public static var TLS_ECDH_ECDSA_WITH_ARIA_256_CBC_SHA384 : dotnet.System.Net.Security.TlsCipherSuite {
        get {
        let __return = dotnet.System.Net.Security.TlsCipherSuite(val: System_Net_Security_TlsCipherSuite_get_TLS_ECDH_ECDSA_WITH_ARIA_256_CBC_SHA384());
            return __return;
        }
    }
    // static field: System.Net.Security.TlsCipherSuite TLS_ECDHE_RSA_WITH_ARIA_128_CBC_SHA256
    /**
    Represents the TLS_ECDHE_RSA_WITH_ARIA_128_CBC_SHA256 cipher suite.

    */
    public static var TLS_ECDHE_RSA_WITH_ARIA_128_CBC_SHA256 : dotnet.System.Net.Security.TlsCipherSuite {
        get {
        let __return = dotnet.System.Net.Security.TlsCipherSuite(val: System_Net_Security_TlsCipherSuite_get_TLS_ECDHE_RSA_WITH_ARIA_128_CBC_SHA256());
            return __return;
        }
    }
    // static field: System.Net.Security.TlsCipherSuite TLS_ECDHE_RSA_WITH_ARIA_256_CBC_SHA384
    /**
    Represents the TLS_ECDHE_RSA_WITH_ARIA_256_CBC_SHA384 cipher suite.

    */
    public static var TLS_ECDHE_RSA_WITH_ARIA_256_CBC_SHA384 : dotnet.System.Net.Security.TlsCipherSuite {
        get {
        let __return = dotnet.System.Net.Security.TlsCipherSuite(val: System_Net_Security_TlsCipherSuite_get_TLS_ECDHE_RSA_WITH_ARIA_256_CBC_SHA384());
            return __return;
        }
    }
    // static field: System.Net.Security.TlsCipherSuite TLS_ECDH_RSA_WITH_ARIA_128_CBC_SHA256
    /**
    Represents the TLS_ECDH_RSA_WITH_ARIA_128_CBC_SHA256 cipher suite.

    */
    public static var TLS_ECDH_RSA_WITH_ARIA_128_CBC_SHA256 : dotnet.System.Net.Security.TlsCipherSuite {
        get {
        let __return = dotnet.System.Net.Security.TlsCipherSuite(val: System_Net_Security_TlsCipherSuite_get_TLS_ECDH_RSA_WITH_ARIA_128_CBC_SHA256());
            return __return;
        }
    }
    // static field: System.Net.Security.TlsCipherSuite TLS_ECDH_RSA_WITH_ARIA_256_CBC_SHA384
    /**
    Represents the TLS_ECDH_RSA_WITH_ARIA_256_CBC_SHA384 cipher suite.

    */
    public static var TLS_ECDH_RSA_WITH_ARIA_256_CBC_SHA384 : dotnet.System.Net.Security.TlsCipherSuite {
        get {
        let __return = dotnet.System.Net.Security.TlsCipherSuite(val: System_Net_Security_TlsCipherSuite_get_TLS_ECDH_RSA_WITH_ARIA_256_CBC_SHA384());
            return __return;
        }
    }
    // static field: System.Net.Security.TlsCipherSuite TLS_RSA_WITH_ARIA_128_GCM_SHA256
    /**
    Represents the TLS_RSA_WITH_ARIA_128_GCM_SHA256 cipher suite.

    */
    public static var TLS_RSA_WITH_ARIA_128_GCM_SHA256 : dotnet.System.Net.Security.TlsCipherSuite {
        get {
        let __return = dotnet.System.Net.Security.TlsCipherSuite(val: System_Net_Security_TlsCipherSuite_get_TLS_RSA_WITH_ARIA_128_GCM_SHA256());
            return __return;
        }
    }
    // static field: System.Net.Security.TlsCipherSuite TLS_RSA_WITH_ARIA_256_GCM_SHA384
    /**
    Represents the TLS_RSA_WITH_ARIA_256_GCM_SHA384 cipher suite.

    */
    public static var TLS_RSA_WITH_ARIA_256_GCM_SHA384 : dotnet.System.Net.Security.TlsCipherSuite {
        get {
        let __return = dotnet.System.Net.Security.TlsCipherSuite(val: System_Net_Security_TlsCipherSuite_get_TLS_RSA_WITH_ARIA_256_GCM_SHA384());
            return __return;
        }
    }
    // static field: System.Net.Security.TlsCipherSuite TLS_DHE_RSA_WITH_ARIA_128_GCM_SHA256
    /**
    Represents the TLS_DHE_RSA_WITH_ARIA_128_GCM_SHA256 cipher suite.

    */
    public static var TLS_DHE_RSA_WITH_ARIA_128_GCM_SHA256 : dotnet.System.Net.Security.TlsCipherSuite {
        get {
        let __return = dotnet.System.Net.Security.TlsCipherSuite(val: System_Net_Security_TlsCipherSuite_get_TLS_DHE_RSA_WITH_ARIA_128_GCM_SHA256());
            return __return;
        }
    }
    // static field: System.Net.Security.TlsCipherSuite TLS_DHE_RSA_WITH_ARIA_256_GCM_SHA384
    /**
    Represents the TLS_DHE_RSA_WITH_ARIA_256_GCM_SHA384 cipher suite.

    */
    public static var TLS_DHE_RSA_WITH_ARIA_256_GCM_SHA384 : dotnet.System.Net.Security.TlsCipherSuite {
        get {
        let __return = dotnet.System.Net.Security.TlsCipherSuite(val: System_Net_Security_TlsCipherSuite_get_TLS_DHE_RSA_WITH_ARIA_256_GCM_SHA384());
            return __return;
        }
    }
    // static field: System.Net.Security.TlsCipherSuite TLS_DH_RSA_WITH_ARIA_128_GCM_SHA256
    /**
    Represents the TLS_DH_RSA_WITH_ARIA_128_GCM_SHA256 cipher suite.

    */
    public static var TLS_DH_RSA_WITH_ARIA_128_GCM_SHA256 : dotnet.System.Net.Security.TlsCipherSuite {
        get {
        let __return = dotnet.System.Net.Security.TlsCipherSuite(val: System_Net_Security_TlsCipherSuite_get_TLS_DH_RSA_WITH_ARIA_128_GCM_SHA256());
            return __return;
        }
    }
    // static field: System.Net.Security.TlsCipherSuite TLS_DH_RSA_WITH_ARIA_256_GCM_SHA384
    /**
    Represents the TLS_DH_RSA_WITH_ARIA_256_GCM_SHA384 cipher suite.

    */
    public static var TLS_DH_RSA_WITH_ARIA_256_GCM_SHA384 : dotnet.System.Net.Security.TlsCipherSuite {
        get {
        let __return = dotnet.System.Net.Security.TlsCipherSuite(val: System_Net_Security_TlsCipherSuite_get_TLS_DH_RSA_WITH_ARIA_256_GCM_SHA384());
            return __return;
        }
    }
    // static field: System.Net.Security.TlsCipherSuite TLS_DHE_DSS_WITH_ARIA_128_GCM_SHA256
    /**
    Represents the TLS_DHE_DSS_WITH_ARIA_128_GCM_SHA256 cipher suite.

    */
    public static var TLS_DHE_DSS_WITH_ARIA_128_GCM_SHA256 : dotnet.System.Net.Security.TlsCipherSuite {
        get {
        let __return = dotnet.System.Net.Security.TlsCipherSuite(val: System_Net_Security_TlsCipherSuite_get_TLS_DHE_DSS_WITH_ARIA_128_GCM_SHA256());
            return __return;
        }
    }
    // static field: System.Net.Security.TlsCipherSuite TLS_DHE_DSS_WITH_ARIA_256_GCM_SHA384
    /**
    Represents the TLS_DHE_DSS_WITH_ARIA_256_GCM_SHA384 cipher suite.

    */
    public static var TLS_DHE_DSS_WITH_ARIA_256_GCM_SHA384 : dotnet.System.Net.Security.TlsCipherSuite {
        get {
        let __return = dotnet.System.Net.Security.TlsCipherSuite(val: System_Net_Security_TlsCipherSuite_get_TLS_DHE_DSS_WITH_ARIA_256_GCM_SHA384());
            return __return;
        }
    }
    // static field: System.Net.Security.TlsCipherSuite TLS_DH_DSS_WITH_ARIA_128_GCM_SHA256
    /**
    Represents the TLS_DH_DSS_WITH_ARIA_128_GCM_SHA256 cipher suite.

    */
    public static var TLS_DH_DSS_WITH_ARIA_128_GCM_SHA256 : dotnet.System.Net.Security.TlsCipherSuite {
        get {
        let __return = dotnet.System.Net.Security.TlsCipherSuite(val: System_Net_Security_TlsCipherSuite_get_TLS_DH_DSS_WITH_ARIA_128_GCM_SHA256());
            return __return;
        }
    }
    // static field: System.Net.Security.TlsCipherSuite TLS_DH_DSS_WITH_ARIA_256_GCM_SHA384
    /**
    Represents the TLS_DH_DSS_WITH_ARIA_256_GCM_SHA384 cipher suite.

    */
    public static var TLS_DH_DSS_WITH_ARIA_256_GCM_SHA384 : dotnet.System.Net.Security.TlsCipherSuite {
        get {
        let __return = dotnet.System.Net.Security.TlsCipherSuite(val: System_Net_Security_TlsCipherSuite_get_TLS_DH_DSS_WITH_ARIA_256_GCM_SHA384());
            return __return;
        }
    }
    // static field: System.Net.Security.TlsCipherSuite TLS_DH_anon_WITH_ARIA_128_GCM_SHA256
    /**
    Represents the TLS_DH_anon_WITH_ARIA_128_GCM_SHA256 cipher suite.

    */
    public static var TLS_DH_anon_WITH_ARIA_128_GCM_SHA256 : dotnet.System.Net.Security.TlsCipherSuite {
        get {
        let __return = dotnet.System.Net.Security.TlsCipherSuite(val: System_Net_Security_TlsCipherSuite_get_TLS_DH_anon_WITH_ARIA_128_GCM_SHA256());
            return __return;
        }
    }
    // static field: System.Net.Security.TlsCipherSuite TLS_DH_anon_WITH_ARIA_256_GCM_SHA384
    /**
    Represents the TLS_DH_anon_WITH_ARIA_256_GCM_SHA384 cipher suite.

    */
    public static var TLS_DH_anon_WITH_ARIA_256_GCM_SHA384 : dotnet.System.Net.Security.TlsCipherSuite {
        get {
        let __return = dotnet.System.Net.Security.TlsCipherSuite(val: System_Net_Security_TlsCipherSuite_get_TLS_DH_anon_WITH_ARIA_256_GCM_SHA384());
            return __return;
        }
    }
    // static field: System.Net.Security.TlsCipherSuite TLS_ECDHE_ECDSA_WITH_ARIA_128_GCM_SHA256
    /**
    Represents the TLS_ECDHE_ECDSA_WITH_ARIA_128_GCM_SHA256 cipher suite.

    */
    public static var TLS_ECDHE_ECDSA_WITH_ARIA_128_GCM_SHA256 : dotnet.System.Net.Security.TlsCipherSuite {
        get {
        let __return = dotnet.System.Net.Security.TlsCipherSuite(val: System_Net_Security_TlsCipherSuite_get_TLS_ECDHE_ECDSA_WITH_ARIA_128_GCM_SHA256());
            return __return;
        }
    }
    // static field: System.Net.Security.TlsCipherSuite TLS_ECDHE_ECDSA_WITH_ARIA_256_GCM_SHA384
    /**
    Represents the TLS_ECDHE_ECDSA_WITH_ARIA_256_GCM_SHA384 cipher suite.

    */
    public static var TLS_ECDHE_ECDSA_WITH_ARIA_256_GCM_SHA384 : dotnet.System.Net.Security.TlsCipherSuite {
        get {
        let __return = dotnet.System.Net.Security.TlsCipherSuite(val: System_Net_Security_TlsCipherSuite_get_TLS_ECDHE_ECDSA_WITH_ARIA_256_GCM_SHA384());
            return __return;
        }
    }
    // static field: System.Net.Security.TlsCipherSuite TLS_ECDH_ECDSA_WITH_ARIA_128_GCM_SHA256
    /**
    Represents the TLS_ECDH_ECDSA_WITH_ARIA_128_GCM_SHA256 cipher suite.

    */
    public static var TLS_ECDH_ECDSA_WITH_ARIA_128_GCM_SHA256 : dotnet.System.Net.Security.TlsCipherSuite {
        get {
        let __return = dotnet.System.Net.Security.TlsCipherSuite(val: System_Net_Security_TlsCipherSuite_get_TLS_ECDH_ECDSA_WITH_ARIA_128_GCM_SHA256());
            return __return;
        }
    }
    // static field: System.Net.Security.TlsCipherSuite TLS_ECDH_ECDSA_WITH_ARIA_256_GCM_SHA384
    /**
    Represents the TLS_ECDH_ECDSA_WITH_ARIA_256_GCM_SHA384 cipher suite.

    */
    public static var TLS_ECDH_ECDSA_WITH_ARIA_256_GCM_SHA384 : dotnet.System.Net.Security.TlsCipherSuite {
        get {
        let __return = dotnet.System.Net.Security.TlsCipherSuite(val: System_Net_Security_TlsCipherSuite_get_TLS_ECDH_ECDSA_WITH_ARIA_256_GCM_SHA384());
            return __return;
        }
    }
    // static field: System.Net.Security.TlsCipherSuite TLS_ECDHE_RSA_WITH_ARIA_128_GCM_SHA256
    /**
    Represents the TLS_ECDHE_RSA_WITH_ARIA_128_GCM_SHA256 cipher suite.

    */
    public static var TLS_ECDHE_RSA_WITH_ARIA_128_GCM_SHA256 : dotnet.System.Net.Security.TlsCipherSuite {
        get {
        let __return = dotnet.System.Net.Security.TlsCipherSuite(val: System_Net_Security_TlsCipherSuite_get_TLS_ECDHE_RSA_WITH_ARIA_128_GCM_SHA256());
            return __return;
        }
    }
    // static field: System.Net.Security.TlsCipherSuite TLS_ECDHE_RSA_WITH_ARIA_256_GCM_SHA384
    /**
    Represents the TLS_ECDHE_RSA_WITH_ARIA_256_GCM_SHA384 cipher suite.

    */
    public static var TLS_ECDHE_RSA_WITH_ARIA_256_GCM_SHA384 : dotnet.System.Net.Security.TlsCipherSuite {
        get {
        let __return = dotnet.System.Net.Security.TlsCipherSuite(val: System_Net_Security_TlsCipherSuite_get_TLS_ECDHE_RSA_WITH_ARIA_256_GCM_SHA384());
            return __return;
        }
    }
    // static field: System.Net.Security.TlsCipherSuite TLS_ECDH_RSA_WITH_ARIA_128_GCM_SHA256
    /**
    Represents the TLS_ECDH_RSA_WITH_ARIA_128_GCM_SHA256 cipher suite.

    */
    public static var TLS_ECDH_RSA_WITH_ARIA_128_GCM_SHA256 : dotnet.System.Net.Security.TlsCipherSuite {
        get {
        let __return = dotnet.System.Net.Security.TlsCipherSuite(val: System_Net_Security_TlsCipherSuite_get_TLS_ECDH_RSA_WITH_ARIA_128_GCM_SHA256());
            return __return;
        }
    }
    // static field: System.Net.Security.TlsCipherSuite TLS_ECDH_RSA_WITH_ARIA_256_GCM_SHA384
    /**
    Represents the TLS_ECDH_RSA_WITH_ARIA_256_GCM_SHA384 cipher suite.

    */
    public static var TLS_ECDH_RSA_WITH_ARIA_256_GCM_SHA384 : dotnet.System.Net.Security.TlsCipherSuite {
        get {
        let __return = dotnet.System.Net.Security.TlsCipherSuite(val: System_Net_Security_TlsCipherSuite_get_TLS_ECDH_RSA_WITH_ARIA_256_GCM_SHA384());
            return __return;
        }
    }
    // static field: System.Net.Security.TlsCipherSuite TLS_PSK_WITH_ARIA_128_CBC_SHA256
    /**
    Represents the TLS_PSK_WITH_ARIA_128_CBC_SHA256 cipher suite.

    */
    public static var TLS_PSK_WITH_ARIA_128_CBC_SHA256 : dotnet.System.Net.Security.TlsCipherSuite {
        get {
        let __return = dotnet.System.Net.Security.TlsCipherSuite(val: System_Net_Security_TlsCipherSuite_get_TLS_PSK_WITH_ARIA_128_CBC_SHA256());
            return __return;
        }
    }
    // static field: System.Net.Security.TlsCipherSuite TLS_PSK_WITH_ARIA_256_CBC_SHA384
    /**
    Represents the TLS_PSK_WITH_ARIA_256_CBC_SHA384 cipher suite.

    */
    public static var TLS_PSK_WITH_ARIA_256_CBC_SHA384 : dotnet.System.Net.Security.TlsCipherSuite {
        get {
        let __return = dotnet.System.Net.Security.TlsCipherSuite(val: System_Net_Security_TlsCipherSuite_get_TLS_PSK_WITH_ARIA_256_CBC_SHA384());
            return __return;
        }
    }
    // static field: System.Net.Security.TlsCipherSuite TLS_DHE_PSK_WITH_ARIA_128_CBC_SHA256
    /**
    Represents the TLS_DHE_PSK_WITH_ARIA_128_CBC_SHA256 cipher suite.

    */
    public static var TLS_DHE_PSK_WITH_ARIA_128_CBC_SHA256 : dotnet.System.Net.Security.TlsCipherSuite {
        get {
        let __return = dotnet.System.Net.Security.TlsCipherSuite(val: System_Net_Security_TlsCipherSuite_get_TLS_DHE_PSK_WITH_ARIA_128_CBC_SHA256());
            return __return;
        }
    }
    // static field: System.Net.Security.TlsCipherSuite TLS_DHE_PSK_WITH_ARIA_256_CBC_SHA384
    /**
    Represents the TLS_DHE_PSK_WITH_ARIA_256_CBC_SHA384 cipher suite.

    */
    public static var TLS_DHE_PSK_WITH_ARIA_256_CBC_SHA384 : dotnet.System.Net.Security.TlsCipherSuite {
        get {
        let __return = dotnet.System.Net.Security.TlsCipherSuite(val: System_Net_Security_TlsCipherSuite_get_TLS_DHE_PSK_WITH_ARIA_256_CBC_SHA384());
            return __return;
        }
    }
    // static field: System.Net.Security.TlsCipherSuite TLS_RSA_PSK_WITH_ARIA_128_CBC_SHA256
    /**
    Represents the TLS_RSA_PSK_WITH_ARIA_128_CBC_SHA256 cipher suite.

    */
    public static var TLS_RSA_PSK_WITH_ARIA_128_CBC_SHA256 : dotnet.System.Net.Security.TlsCipherSuite {
        get {
        let __return = dotnet.System.Net.Security.TlsCipherSuite(val: System_Net_Security_TlsCipherSuite_get_TLS_RSA_PSK_WITH_ARIA_128_CBC_SHA256());
            return __return;
        }
    }
    // static field: System.Net.Security.TlsCipherSuite TLS_RSA_PSK_WITH_ARIA_256_CBC_SHA384
    /**
    Represents the TLS_RSA_PSK_WITH_ARIA_256_CBC_SHA384 cipher suite.

    */
    public static var TLS_RSA_PSK_WITH_ARIA_256_CBC_SHA384 : dotnet.System.Net.Security.TlsCipherSuite {
        get {
        let __return = dotnet.System.Net.Security.TlsCipherSuite(val: System_Net_Security_TlsCipherSuite_get_TLS_RSA_PSK_WITH_ARIA_256_CBC_SHA384());
            return __return;
        }
    }
    // static field: System.Net.Security.TlsCipherSuite TLS_PSK_WITH_ARIA_128_GCM_SHA256
    /**
    Represents the TLS_PSK_WITH_ARIA_128_GCM_SHA256 cipher suite.

    */
    public static var TLS_PSK_WITH_ARIA_128_GCM_SHA256 : dotnet.System.Net.Security.TlsCipherSuite {
        get {
        let __return = dotnet.System.Net.Security.TlsCipherSuite(val: System_Net_Security_TlsCipherSuite_get_TLS_PSK_WITH_ARIA_128_GCM_SHA256());
            return __return;
        }
    }
    // static field: System.Net.Security.TlsCipherSuite TLS_PSK_WITH_ARIA_256_GCM_SHA384
    /**
    Represents the TLS_PSK_WITH_ARIA_256_GCM_SHA384 cipher suite.

    */
    public static var TLS_PSK_WITH_ARIA_256_GCM_SHA384 : dotnet.System.Net.Security.TlsCipherSuite {
        get {
        let __return = dotnet.System.Net.Security.TlsCipherSuite(val: System_Net_Security_TlsCipherSuite_get_TLS_PSK_WITH_ARIA_256_GCM_SHA384());
            return __return;
        }
    }
    // static field: System.Net.Security.TlsCipherSuite TLS_DHE_PSK_WITH_ARIA_128_GCM_SHA256
    /**
    Represents the TLS_DHE_PSK_WITH_ARIA_128_GCM_SHA256 cipher suite.

    */
    public static var TLS_DHE_PSK_WITH_ARIA_128_GCM_SHA256 : dotnet.System.Net.Security.TlsCipherSuite {
        get {
        let __return = dotnet.System.Net.Security.TlsCipherSuite(val: System_Net_Security_TlsCipherSuite_get_TLS_DHE_PSK_WITH_ARIA_128_GCM_SHA256());
            return __return;
        }
    }
    // static field: System.Net.Security.TlsCipherSuite TLS_DHE_PSK_WITH_ARIA_256_GCM_SHA384
    /**
    Represents the TLS_DHE_PSK_WITH_ARIA_256_GCM_SHA384 cipher suite.

    */
    public static var TLS_DHE_PSK_WITH_ARIA_256_GCM_SHA384 : dotnet.System.Net.Security.TlsCipherSuite {
        get {
        let __return = dotnet.System.Net.Security.TlsCipherSuite(val: System_Net_Security_TlsCipherSuite_get_TLS_DHE_PSK_WITH_ARIA_256_GCM_SHA384());
            return __return;
        }
    }
    // static field: System.Net.Security.TlsCipherSuite TLS_RSA_PSK_WITH_ARIA_128_GCM_SHA256
    /**
    Represents the TLS_RSA_PSK_WITH_ARIA_128_GCM_SHA256 cipher suite.

    */
    public static var TLS_RSA_PSK_WITH_ARIA_128_GCM_SHA256 : dotnet.System.Net.Security.TlsCipherSuite {
        get {
        let __return = dotnet.System.Net.Security.TlsCipherSuite(val: System_Net_Security_TlsCipherSuite_get_TLS_RSA_PSK_WITH_ARIA_128_GCM_SHA256());
            return __return;
        }
    }
    // static field: System.Net.Security.TlsCipherSuite TLS_RSA_PSK_WITH_ARIA_256_GCM_SHA384
    /**
    Represents the TLS_RSA_PSK_WITH_ARIA_256_GCM_SHA384 cipher suite.

    */
    public static var TLS_RSA_PSK_WITH_ARIA_256_GCM_SHA384 : dotnet.System.Net.Security.TlsCipherSuite {
        get {
        let __return = dotnet.System.Net.Security.TlsCipherSuite(val: System_Net_Security_TlsCipherSuite_get_TLS_RSA_PSK_WITH_ARIA_256_GCM_SHA384());
            return __return;
        }
    }
    // static field: System.Net.Security.TlsCipherSuite TLS_ECDHE_PSK_WITH_ARIA_128_CBC_SHA256
    /**
    Represents the TLS_ECDHE_PSK_WITH_ARIA_128_CBC_SHA256 cipher suite.

    */
    public static var TLS_ECDHE_PSK_WITH_ARIA_128_CBC_SHA256 : dotnet.System.Net.Security.TlsCipherSuite {
        get {
        let __return = dotnet.System.Net.Security.TlsCipherSuite(val: System_Net_Security_TlsCipherSuite_get_TLS_ECDHE_PSK_WITH_ARIA_128_CBC_SHA256());
            return __return;
        }
    }
    // static field: System.Net.Security.TlsCipherSuite TLS_ECDHE_PSK_WITH_ARIA_256_CBC_SHA384
    /**
    Represents the TLS_ECDHE_PSK_WITH_ARIA_256_CBC_SHA384 cipher suite.

    */
    public static var TLS_ECDHE_PSK_WITH_ARIA_256_CBC_SHA384 : dotnet.System.Net.Security.TlsCipherSuite {
        get {
        let __return = dotnet.System.Net.Security.TlsCipherSuite(val: System_Net_Security_TlsCipherSuite_get_TLS_ECDHE_PSK_WITH_ARIA_256_CBC_SHA384());
            return __return;
        }
    }
    // static field: System.Net.Security.TlsCipherSuite TLS_ECDHE_ECDSA_WITH_CAMELLIA_128_CBC_SHA256
    /**
    Represents the TLS_ECDHE_ECDSA_WITH_CAMELLIA_128_CBC_SHA256 cipher suite.

    */
    public static var TLS_ECDHE_ECDSA_WITH_CAMELLIA_128_CBC_SHA256 : dotnet.System.Net.Security.TlsCipherSuite {
        get {
        let __return = dotnet.System.Net.Security.TlsCipherSuite(val: System_Net_Security_TlsCipherSuite_get_TLS_ECDHE_ECDSA_WITH_CAMELLIA_128_CBC_SHA256());
            return __return;
        }
    }
    // static field: System.Net.Security.TlsCipherSuite TLS_ECDHE_ECDSA_WITH_CAMELLIA_256_CBC_SHA384
    /**
    Represents the TLS_ECDHE_ECDSA_WITH_CAMELLIA_256_CBC_SHA384 cipher suite.

    */
    public static var TLS_ECDHE_ECDSA_WITH_CAMELLIA_256_CBC_SHA384 : dotnet.System.Net.Security.TlsCipherSuite {
        get {
        let __return = dotnet.System.Net.Security.TlsCipherSuite(val: System_Net_Security_TlsCipherSuite_get_TLS_ECDHE_ECDSA_WITH_CAMELLIA_256_CBC_SHA384());
            return __return;
        }
    }
    // static field: System.Net.Security.TlsCipherSuite TLS_ECDH_ECDSA_WITH_CAMELLIA_128_CBC_SHA256
    /**
    Represents the TLS_ECDH_ECDSA_WITH_CAMELLIA_128_CBC_SHA256 cipher suite.

    */
    public static var TLS_ECDH_ECDSA_WITH_CAMELLIA_128_CBC_SHA256 : dotnet.System.Net.Security.TlsCipherSuite {
        get {
        let __return = dotnet.System.Net.Security.TlsCipherSuite(val: System_Net_Security_TlsCipherSuite_get_TLS_ECDH_ECDSA_WITH_CAMELLIA_128_CBC_SHA256());
            return __return;
        }
    }
    // static field: System.Net.Security.TlsCipherSuite TLS_ECDH_ECDSA_WITH_CAMELLIA_256_CBC_SHA384
    /**
    Represents the TLS_ECDH_ECDSA_WITH_CAMELLIA_256_CBC_SHA384 cipher suite.

    */
    public static var TLS_ECDH_ECDSA_WITH_CAMELLIA_256_CBC_SHA384 : dotnet.System.Net.Security.TlsCipherSuite {
        get {
        let __return = dotnet.System.Net.Security.TlsCipherSuite(val: System_Net_Security_TlsCipherSuite_get_TLS_ECDH_ECDSA_WITH_CAMELLIA_256_CBC_SHA384());
            return __return;
        }
    }
    // static field: System.Net.Security.TlsCipherSuite TLS_ECDHE_RSA_WITH_CAMELLIA_128_CBC_SHA256
    /**
    Represents the TLS_ECDHE_RSA_WITH_CAMELLIA_128_CBC_SHA256 cipher suite.

    */
    public static var TLS_ECDHE_RSA_WITH_CAMELLIA_128_CBC_SHA256 : dotnet.System.Net.Security.TlsCipherSuite {
        get {
        let __return = dotnet.System.Net.Security.TlsCipherSuite(val: System_Net_Security_TlsCipherSuite_get_TLS_ECDHE_RSA_WITH_CAMELLIA_128_CBC_SHA256());
            return __return;
        }
    }
    // static field: System.Net.Security.TlsCipherSuite TLS_ECDHE_RSA_WITH_CAMELLIA_256_CBC_SHA384
    /**
    Represents the TLS_ECDHE_RSA_WITH_CAMELLIA_256_CBC_SHA384 cipher suite.

    */
    public static var TLS_ECDHE_RSA_WITH_CAMELLIA_256_CBC_SHA384 : dotnet.System.Net.Security.TlsCipherSuite {
        get {
        let __return = dotnet.System.Net.Security.TlsCipherSuite(val: System_Net_Security_TlsCipherSuite_get_TLS_ECDHE_RSA_WITH_CAMELLIA_256_CBC_SHA384());
            return __return;
        }
    }
    // static field: System.Net.Security.TlsCipherSuite TLS_ECDH_RSA_WITH_CAMELLIA_128_CBC_SHA256
    /**
    Represents the TLS_ECDH_RSA_WITH_CAMELLIA_128_CBC_SHA256 cipher suite.

    */
    public static var TLS_ECDH_RSA_WITH_CAMELLIA_128_CBC_SHA256 : dotnet.System.Net.Security.TlsCipherSuite {
        get {
        let __return = dotnet.System.Net.Security.TlsCipherSuite(val: System_Net_Security_TlsCipherSuite_get_TLS_ECDH_RSA_WITH_CAMELLIA_128_CBC_SHA256());
            return __return;
        }
    }
    // static field: System.Net.Security.TlsCipherSuite TLS_ECDH_RSA_WITH_CAMELLIA_256_CBC_SHA384
    /**
    Represents the TLS_ECDH_RSA_WITH_CAMELLIA_256_CBC_SHA384 cipher suite.

    */
    public static var TLS_ECDH_RSA_WITH_CAMELLIA_256_CBC_SHA384 : dotnet.System.Net.Security.TlsCipherSuite {
        get {
        let __return = dotnet.System.Net.Security.TlsCipherSuite(val: System_Net_Security_TlsCipherSuite_get_TLS_ECDH_RSA_WITH_CAMELLIA_256_CBC_SHA384());
            return __return;
        }
    }
    // static field: System.Net.Security.TlsCipherSuite TLS_RSA_WITH_CAMELLIA_128_GCM_SHA256
    /**
    Represents the TLS_RSA_WITH_CAMELLIA_128_GCM_SHA256 cipher suite.

    */
    public static var TLS_RSA_WITH_CAMELLIA_128_GCM_SHA256 : dotnet.System.Net.Security.TlsCipherSuite {
        get {
        let __return = dotnet.System.Net.Security.TlsCipherSuite(val: System_Net_Security_TlsCipherSuite_get_TLS_RSA_WITH_CAMELLIA_128_GCM_SHA256());
            return __return;
        }
    }
    // static field: System.Net.Security.TlsCipherSuite TLS_RSA_WITH_CAMELLIA_256_GCM_SHA384
    /**
    Represents the TLS_RSA_WITH_CAMELLIA_256_GCM_SHA384 cipher suite.

    */
    public static var TLS_RSA_WITH_CAMELLIA_256_GCM_SHA384 : dotnet.System.Net.Security.TlsCipherSuite {
        get {
        let __return = dotnet.System.Net.Security.TlsCipherSuite(val: System_Net_Security_TlsCipherSuite_get_TLS_RSA_WITH_CAMELLIA_256_GCM_SHA384());
            return __return;
        }
    }
    // static field: System.Net.Security.TlsCipherSuite TLS_DHE_RSA_WITH_CAMELLIA_128_GCM_SHA256
    /**
    Represents the TLS_DHE_RSA_WITH_CAMELLIA_128_GCM_SHA256 cipher suite.

    */
    public static var TLS_DHE_RSA_WITH_CAMELLIA_128_GCM_SHA256 : dotnet.System.Net.Security.TlsCipherSuite {
        get {
        let __return = dotnet.System.Net.Security.TlsCipherSuite(val: System_Net_Security_TlsCipherSuite_get_TLS_DHE_RSA_WITH_CAMELLIA_128_GCM_SHA256());
            return __return;
        }
    }
    // static field: System.Net.Security.TlsCipherSuite TLS_DHE_RSA_WITH_CAMELLIA_256_GCM_SHA384
    /**
    Represents the TLS_DHE_RSA_WITH_CAMELLIA_256_GCM_SHA384 cipher suite.

    */
    public static var TLS_DHE_RSA_WITH_CAMELLIA_256_GCM_SHA384 : dotnet.System.Net.Security.TlsCipherSuite {
        get {
        let __return = dotnet.System.Net.Security.TlsCipherSuite(val: System_Net_Security_TlsCipherSuite_get_TLS_DHE_RSA_WITH_CAMELLIA_256_GCM_SHA384());
            return __return;
        }
    }
    // static field: System.Net.Security.TlsCipherSuite TLS_DH_RSA_WITH_CAMELLIA_128_GCM_SHA256
    /**
    Represents the TLS_DH_RSA_WITH_CAMELLIA_128_GCM_SHA256 cipher suite.

    */
    public static var TLS_DH_RSA_WITH_CAMELLIA_128_GCM_SHA256 : dotnet.System.Net.Security.TlsCipherSuite {
        get {
        let __return = dotnet.System.Net.Security.TlsCipherSuite(val: System_Net_Security_TlsCipherSuite_get_TLS_DH_RSA_WITH_CAMELLIA_128_GCM_SHA256());
            return __return;
        }
    }
    // static field: System.Net.Security.TlsCipherSuite TLS_DH_RSA_WITH_CAMELLIA_256_GCM_SHA384
    /**
    Represents the TLS_DH_RSA_WITH_CAMELLIA_256_GCM_SHA384 cipher suite.

    */
    public static var TLS_DH_RSA_WITH_CAMELLIA_256_GCM_SHA384 : dotnet.System.Net.Security.TlsCipherSuite {
        get {
        let __return = dotnet.System.Net.Security.TlsCipherSuite(val: System_Net_Security_TlsCipherSuite_get_TLS_DH_RSA_WITH_CAMELLIA_256_GCM_SHA384());
            return __return;
        }
    }
    // static field: System.Net.Security.TlsCipherSuite TLS_DHE_DSS_WITH_CAMELLIA_128_GCM_SHA256
    /**
    Represents the TLS_DHE_DSS_WITH_CAMELLIA_128_GCM_SHA256 cipher suite.

    */
    public static var TLS_DHE_DSS_WITH_CAMELLIA_128_GCM_SHA256 : dotnet.System.Net.Security.TlsCipherSuite {
        get {
        let __return = dotnet.System.Net.Security.TlsCipherSuite(val: System_Net_Security_TlsCipherSuite_get_TLS_DHE_DSS_WITH_CAMELLIA_128_GCM_SHA256());
            return __return;
        }
    }
    // static field: System.Net.Security.TlsCipherSuite TLS_DHE_DSS_WITH_CAMELLIA_256_GCM_SHA384
    /**
    Represents the TLS_DHE_DSS_WITH_CAMELLIA_256_GCM_SHA384 cipher suite.

    */
    public static var TLS_DHE_DSS_WITH_CAMELLIA_256_GCM_SHA384 : dotnet.System.Net.Security.TlsCipherSuite {
        get {
        let __return = dotnet.System.Net.Security.TlsCipherSuite(val: System_Net_Security_TlsCipherSuite_get_TLS_DHE_DSS_WITH_CAMELLIA_256_GCM_SHA384());
            return __return;
        }
    }
    // static field: System.Net.Security.TlsCipherSuite TLS_DH_DSS_WITH_CAMELLIA_128_GCM_SHA256
    /**
    Represents the TLS_DH_DSS_WITH_CAMELLIA_128_GCM_SHA256 cipher suite.

    */
    public static var TLS_DH_DSS_WITH_CAMELLIA_128_GCM_SHA256 : dotnet.System.Net.Security.TlsCipherSuite {
        get {
        let __return = dotnet.System.Net.Security.TlsCipherSuite(val: System_Net_Security_TlsCipherSuite_get_TLS_DH_DSS_WITH_CAMELLIA_128_GCM_SHA256());
            return __return;
        }
    }
    // static field: System.Net.Security.TlsCipherSuite TLS_DH_DSS_WITH_CAMELLIA_256_GCM_SHA384
    /**
    Represents the TLS_DH_DSS_WITH_CAMELLIA_256_GCM_SHA384 cipher suite.

    */
    public static var TLS_DH_DSS_WITH_CAMELLIA_256_GCM_SHA384 : dotnet.System.Net.Security.TlsCipherSuite {
        get {
        let __return = dotnet.System.Net.Security.TlsCipherSuite(val: System_Net_Security_TlsCipherSuite_get_TLS_DH_DSS_WITH_CAMELLIA_256_GCM_SHA384());
            return __return;
        }
    }
    // static field: System.Net.Security.TlsCipherSuite TLS_DH_anon_WITH_CAMELLIA_128_GCM_SHA256
    /**
    Represents the TLS_DH_anon_WITH_CAMELLIA_128_GCM_SHA256 cipher suite.

    */
    public static var TLS_DH_anon_WITH_CAMELLIA_128_GCM_SHA256 : dotnet.System.Net.Security.TlsCipherSuite {
        get {
        let __return = dotnet.System.Net.Security.TlsCipherSuite(val: System_Net_Security_TlsCipherSuite_get_TLS_DH_anon_WITH_CAMELLIA_128_GCM_SHA256());
            return __return;
        }
    }
    // static field: System.Net.Security.TlsCipherSuite TLS_DH_anon_WITH_CAMELLIA_256_GCM_SHA384
    /**
    Represents the TLS_DH_anon_WITH_CAMELLIA_256_GCM_SHA384 cipher suite.

    */
    public static var TLS_DH_anon_WITH_CAMELLIA_256_GCM_SHA384 : dotnet.System.Net.Security.TlsCipherSuite {
        get {
        let __return = dotnet.System.Net.Security.TlsCipherSuite(val: System_Net_Security_TlsCipherSuite_get_TLS_DH_anon_WITH_CAMELLIA_256_GCM_SHA384());
            return __return;
        }
    }
    // static field: System.Net.Security.TlsCipherSuite TLS_ECDHE_ECDSA_WITH_CAMELLIA_128_GCM_SHA256
    /**
    Represents the TLS_ECDHE_ECDSA_WITH_CAMELLIA_128_GCM_SHA256 cipher suite.

    */
    public static var TLS_ECDHE_ECDSA_WITH_CAMELLIA_128_GCM_SHA256 : dotnet.System.Net.Security.TlsCipherSuite {
        get {
        let __return = dotnet.System.Net.Security.TlsCipherSuite(val: System_Net_Security_TlsCipherSuite_get_TLS_ECDHE_ECDSA_WITH_CAMELLIA_128_GCM_SHA256());
            return __return;
        }
    }
    // static field: System.Net.Security.TlsCipherSuite TLS_ECDHE_ECDSA_WITH_CAMELLIA_256_GCM_SHA384
    /**
    Represents the TLS_ECDHE_ECDSA_WITH_CAMELLIA_256_GCM_SHA384 cipher suite.

    */
    public static var TLS_ECDHE_ECDSA_WITH_CAMELLIA_256_GCM_SHA384 : dotnet.System.Net.Security.TlsCipherSuite {
        get {
        let __return = dotnet.System.Net.Security.TlsCipherSuite(val: System_Net_Security_TlsCipherSuite_get_TLS_ECDHE_ECDSA_WITH_CAMELLIA_256_GCM_SHA384());
            return __return;
        }
    }
    // static field: System.Net.Security.TlsCipherSuite TLS_ECDH_ECDSA_WITH_CAMELLIA_128_GCM_SHA256
    /**
    Represents the TLS_ECDH_ECDSA_WITH_CAMELLIA_128_GCM_SHA256 cipher suite.

    */
    public static var TLS_ECDH_ECDSA_WITH_CAMELLIA_128_GCM_SHA256 : dotnet.System.Net.Security.TlsCipherSuite {
        get {
        let __return = dotnet.System.Net.Security.TlsCipherSuite(val: System_Net_Security_TlsCipherSuite_get_TLS_ECDH_ECDSA_WITH_CAMELLIA_128_GCM_SHA256());
            return __return;
        }
    }
    // static field: System.Net.Security.TlsCipherSuite TLS_ECDH_ECDSA_WITH_CAMELLIA_256_GCM_SHA384
    /**
    Represents the TLS_ECDH_ECDSA_WITH_CAMELLIA_256_GCM_SHA384 cipher suite.

    */
    public static var TLS_ECDH_ECDSA_WITH_CAMELLIA_256_GCM_SHA384 : dotnet.System.Net.Security.TlsCipherSuite {
        get {
        let __return = dotnet.System.Net.Security.TlsCipherSuite(val: System_Net_Security_TlsCipherSuite_get_TLS_ECDH_ECDSA_WITH_CAMELLIA_256_GCM_SHA384());
            return __return;
        }
    }
    // static field: System.Net.Security.TlsCipherSuite TLS_ECDHE_RSA_WITH_CAMELLIA_128_GCM_SHA256
    /**
    Represents the TLS_ECDHE_RSA_WITH_CAMELLIA_128_GCM_SHA256 cipher suite.

    */
    public static var TLS_ECDHE_RSA_WITH_CAMELLIA_128_GCM_SHA256 : dotnet.System.Net.Security.TlsCipherSuite {
        get {
        let __return = dotnet.System.Net.Security.TlsCipherSuite(val: System_Net_Security_TlsCipherSuite_get_TLS_ECDHE_RSA_WITH_CAMELLIA_128_GCM_SHA256());
            return __return;
        }
    }
    // static field: System.Net.Security.TlsCipherSuite TLS_ECDHE_RSA_WITH_CAMELLIA_256_GCM_SHA384
    /**
    Represents the TLS_ECDHE_RSA_WITH_CAMELLIA_256_GCM_SHA384 cipher suite.

    */
    public static var TLS_ECDHE_RSA_WITH_CAMELLIA_256_GCM_SHA384 : dotnet.System.Net.Security.TlsCipherSuite {
        get {
        let __return = dotnet.System.Net.Security.TlsCipherSuite(val: System_Net_Security_TlsCipherSuite_get_TLS_ECDHE_RSA_WITH_CAMELLIA_256_GCM_SHA384());
            return __return;
        }
    }
    // static field: System.Net.Security.TlsCipherSuite TLS_ECDH_RSA_WITH_CAMELLIA_128_GCM_SHA256
    /**
    Represents the TLS_ECDH_RSA_WITH_CAMELLIA_128_GCM_SHA256 cipher suite.

    */
    public static var TLS_ECDH_RSA_WITH_CAMELLIA_128_GCM_SHA256 : dotnet.System.Net.Security.TlsCipherSuite {
        get {
        let __return = dotnet.System.Net.Security.TlsCipherSuite(val: System_Net_Security_TlsCipherSuite_get_TLS_ECDH_RSA_WITH_CAMELLIA_128_GCM_SHA256());
            return __return;
        }
    }
    // static field: System.Net.Security.TlsCipherSuite TLS_ECDH_RSA_WITH_CAMELLIA_256_GCM_SHA384
    /**
    Represents the TLS_ECDH_RSA_WITH_CAMELLIA_256_GCM_SHA384 cipher suite.

    */
    public static var TLS_ECDH_RSA_WITH_CAMELLIA_256_GCM_SHA384 : dotnet.System.Net.Security.TlsCipherSuite {
        get {
        let __return = dotnet.System.Net.Security.TlsCipherSuite(val: System_Net_Security_TlsCipherSuite_get_TLS_ECDH_RSA_WITH_CAMELLIA_256_GCM_SHA384());
            return __return;
        }
    }
    // static field: System.Net.Security.TlsCipherSuite TLS_PSK_WITH_CAMELLIA_128_GCM_SHA256
    /**
    Represents the TLS_PSK_WITH_CAMELLIA_128_GCM_SHA256 cipher suite.

    */
    public static var TLS_PSK_WITH_CAMELLIA_128_GCM_SHA256 : dotnet.System.Net.Security.TlsCipherSuite {
        get {
        let __return = dotnet.System.Net.Security.TlsCipherSuite(val: System_Net_Security_TlsCipherSuite_get_TLS_PSK_WITH_CAMELLIA_128_GCM_SHA256());
            return __return;
        }
    }
    // static field: System.Net.Security.TlsCipherSuite TLS_PSK_WITH_CAMELLIA_256_GCM_SHA384
    /**
    Represents the TLS_PSK_WITH_CAMELLIA_256_GCM_SHA384 cipher suite.

    */
    public static var TLS_PSK_WITH_CAMELLIA_256_GCM_SHA384 : dotnet.System.Net.Security.TlsCipherSuite {
        get {
        let __return = dotnet.System.Net.Security.TlsCipherSuite(val: System_Net_Security_TlsCipherSuite_get_TLS_PSK_WITH_CAMELLIA_256_GCM_SHA384());
            return __return;
        }
    }
    // static field: System.Net.Security.TlsCipherSuite TLS_DHE_PSK_WITH_CAMELLIA_128_GCM_SHA256
    /**
    Represents the TLS_DHE_PSK_WITH_CAMELLIA_128_GCM_SHA256 cipher suite.

    */
    public static var TLS_DHE_PSK_WITH_CAMELLIA_128_GCM_SHA256 : dotnet.System.Net.Security.TlsCipherSuite {
        get {
        let __return = dotnet.System.Net.Security.TlsCipherSuite(val: System_Net_Security_TlsCipherSuite_get_TLS_DHE_PSK_WITH_CAMELLIA_128_GCM_SHA256());
            return __return;
        }
    }
    // static field: System.Net.Security.TlsCipherSuite TLS_DHE_PSK_WITH_CAMELLIA_256_GCM_SHA384
    /**
    Represents the TLS_DHE_PSK_WITH_CAMELLIA_256_GCM_SHA384 cipher suite.

    */
    public static var TLS_DHE_PSK_WITH_CAMELLIA_256_GCM_SHA384 : dotnet.System.Net.Security.TlsCipherSuite {
        get {
        let __return = dotnet.System.Net.Security.TlsCipherSuite(val: System_Net_Security_TlsCipherSuite_get_TLS_DHE_PSK_WITH_CAMELLIA_256_GCM_SHA384());
            return __return;
        }
    }
    // static field: System.Net.Security.TlsCipherSuite TLS_RSA_PSK_WITH_CAMELLIA_128_GCM_SHA256
    /**
    Represents the TLS_RSA_PSK_WITH_CAMELLIA_128_GCM_SHA256 cipher suite.

    */
    public static var TLS_RSA_PSK_WITH_CAMELLIA_128_GCM_SHA256 : dotnet.System.Net.Security.TlsCipherSuite {
        get {
        let __return = dotnet.System.Net.Security.TlsCipherSuite(val: System_Net_Security_TlsCipherSuite_get_TLS_RSA_PSK_WITH_CAMELLIA_128_GCM_SHA256());
            return __return;
        }
    }
    // static field: System.Net.Security.TlsCipherSuite TLS_RSA_PSK_WITH_CAMELLIA_256_GCM_SHA384
    /**
    Represents the TLS_RSA_PSK_WITH_CAMELLIA_256_GCM_SHA384 cipher suite.

    */
    public static var TLS_RSA_PSK_WITH_CAMELLIA_256_GCM_SHA384 : dotnet.System.Net.Security.TlsCipherSuite {
        get {
        let __return = dotnet.System.Net.Security.TlsCipherSuite(val: System_Net_Security_TlsCipherSuite_get_TLS_RSA_PSK_WITH_CAMELLIA_256_GCM_SHA384());
            return __return;
        }
    }
    // static field: System.Net.Security.TlsCipherSuite TLS_PSK_WITH_CAMELLIA_128_CBC_SHA256
    /**
    Represents the TLS_PSK_WITH_CAMELLIA_128_CBC_SHA256 cipher suite.

    */
    public static var TLS_PSK_WITH_CAMELLIA_128_CBC_SHA256 : dotnet.System.Net.Security.TlsCipherSuite {
        get {
        let __return = dotnet.System.Net.Security.TlsCipherSuite(val: System_Net_Security_TlsCipherSuite_get_TLS_PSK_WITH_CAMELLIA_128_CBC_SHA256());
            return __return;
        }
    }
    // static field: System.Net.Security.TlsCipherSuite TLS_PSK_WITH_CAMELLIA_256_CBC_SHA384
    /**
    Represents the TLS_PSK_WITH_CAMELLIA_256_CBC_SHA384 cipher suite.

    */
    public static var TLS_PSK_WITH_CAMELLIA_256_CBC_SHA384 : dotnet.System.Net.Security.TlsCipherSuite {
        get {
        let __return = dotnet.System.Net.Security.TlsCipherSuite(val: System_Net_Security_TlsCipherSuite_get_TLS_PSK_WITH_CAMELLIA_256_CBC_SHA384());
            return __return;
        }
    }
    // static field: System.Net.Security.TlsCipherSuite TLS_DHE_PSK_WITH_CAMELLIA_128_CBC_SHA256
    /**
    Represents the TLS_DHE_PSK_WITH_CAMELLIA_128_CBC_SHA256 cipher suite.

    */
    public static var TLS_DHE_PSK_WITH_CAMELLIA_128_CBC_SHA256 : dotnet.System.Net.Security.TlsCipherSuite {
        get {
        let __return = dotnet.System.Net.Security.TlsCipherSuite(val: System_Net_Security_TlsCipherSuite_get_TLS_DHE_PSK_WITH_CAMELLIA_128_CBC_SHA256());
            return __return;
        }
    }
    // static field: System.Net.Security.TlsCipherSuite TLS_DHE_PSK_WITH_CAMELLIA_256_CBC_SHA384
    /**
    Represents the TLS_DHE_PSK_WITH_CAMELLIA_256_CBC_SHA384 cipher suite.

    */
    public static var TLS_DHE_PSK_WITH_CAMELLIA_256_CBC_SHA384 : dotnet.System.Net.Security.TlsCipherSuite {
        get {
        let __return = dotnet.System.Net.Security.TlsCipherSuite(val: System_Net_Security_TlsCipherSuite_get_TLS_DHE_PSK_WITH_CAMELLIA_256_CBC_SHA384());
            return __return;
        }
    }
    // static field: System.Net.Security.TlsCipherSuite TLS_RSA_PSK_WITH_CAMELLIA_128_CBC_SHA256
    /**
    Represents the TLS_RSA_PSK_WITH_CAMELLIA_128_CBC_SHA256 cipher suite.

    */
    public static var TLS_RSA_PSK_WITH_CAMELLIA_128_CBC_SHA256 : dotnet.System.Net.Security.TlsCipherSuite {
        get {
        let __return = dotnet.System.Net.Security.TlsCipherSuite(val: System_Net_Security_TlsCipherSuite_get_TLS_RSA_PSK_WITH_CAMELLIA_128_CBC_SHA256());
            return __return;
        }
    }
    // static field: System.Net.Security.TlsCipherSuite TLS_RSA_PSK_WITH_CAMELLIA_256_CBC_SHA384
    /**
    Represents the TLS_RSA_PSK_WITH_CAMELLIA_256_CBC_SHA384 cipher suite.

    */
    public static var TLS_RSA_PSK_WITH_CAMELLIA_256_CBC_SHA384 : dotnet.System.Net.Security.TlsCipherSuite {
        get {
        let __return = dotnet.System.Net.Security.TlsCipherSuite(val: System_Net_Security_TlsCipherSuite_get_TLS_RSA_PSK_WITH_CAMELLIA_256_CBC_SHA384());
            return __return;
        }
    }
    // static field: System.Net.Security.TlsCipherSuite TLS_ECDHE_PSK_WITH_CAMELLIA_128_CBC_SHA256
    /**
    Represents the TLS_ECDHE_PSK_WITH_CAMELLIA_128_CBC_SHA256 cipher suite.

    */
    public static var TLS_ECDHE_PSK_WITH_CAMELLIA_128_CBC_SHA256 : dotnet.System.Net.Security.TlsCipherSuite {
        get {
        let __return = dotnet.System.Net.Security.TlsCipherSuite(val: System_Net_Security_TlsCipherSuite_get_TLS_ECDHE_PSK_WITH_CAMELLIA_128_CBC_SHA256());
            return __return;
        }
    }
    // static field: System.Net.Security.TlsCipherSuite TLS_ECDHE_PSK_WITH_CAMELLIA_256_CBC_SHA384
    /**
    Represents the TLS_ECDHE_PSK_WITH_CAMELLIA_256_CBC_SHA384 cipher suite.

    */
    public static var TLS_ECDHE_PSK_WITH_CAMELLIA_256_CBC_SHA384 : dotnet.System.Net.Security.TlsCipherSuite {
        get {
        let __return = dotnet.System.Net.Security.TlsCipherSuite(val: System_Net_Security_TlsCipherSuite_get_TLS_ECDHE_PSK_WITH_CAMELLIA_256_CBC_SHA384());
            return __return;
        }
    }
    // static field: System.Net.Security.TlsCipherSuite TLS_RSA_WITH_AES_128_CCM
    /**
    Represents the TLS_RSA_WITH_AES_128_CCM cipher suite.

    */
    public static var TLS_RSA_WITH_AES_128_CCM : dotnet.System.Net.Security.TlsCipherSuite {
        get {
        let __return = dotnet.System.Net.Security.TlsCipherSuite(val: System_Net_Security_TlsCipherSuite_get_TLS_RSA_WITH_AES_128_CCM());
            return __return;
        }
    }
    // static field: System.Net.Security.TlsCipherSuite TLS_RSA_WITH_AES_256_CCM
    /**
    Represents the TLS_RSA_WITH_AES_256_CCM cipher suite.

    */
    public static var TLS_RSA_WITH_AES_256_CCM : dotnet.System.Net.Security.TlsCipherSuite {
        get {
        let __return = dotnet.System.Net.Security.TlsCipherSuite(val: System_Net_Security_TlsCipherSuite_get_TLS_RSA_WITH_AES_256_CCM());
            return __return;
        }
    }
    // static field: System.Net.Security.TlsCipherSuite TLS_DHE_RSA_WITH_AES_128_CCM
    /**
    Represents the TLS_DHE_RSA_WITH_AES_128_CCM cipher suite.

    */
    public static var TLS_DHE_RSA_WITH_AES_128_CCM : dotnet.System.Net.Security.TlsCipherSuite {
        get {
        let __return = dotnet.System.Net.Security.TlsCipherSuite(val: System_Net_Security_TlsCipherSuite_get_TLS_DHE_RSA_WITH_AES_128_CCM());
            return __return;
        }
    }
    // static field: System.Net.Security.TlsCipherSuite TLS_DHE_RSA_WITH_AES_256_CCM
    /**
    Represents the TLS_DHE_RSA_WITH_AES_256_CCM cipher suite.

    */
    public static var TLS_DHE_RSA_WITH_AES_256_CCM : dotnet.System.Net.Security.TlsCipherSuite {
        get {
        let __return = dotnet.System.Net.Security.TlsCipherSuite(val: System_Net_Security_TlsCipherSuite_get_TLS_DHE_RSA_WITH_AES_256_CCM());
            return __return;
        }
    }
    // static field: System.Net.Security.TlsCipherSuite TLS_RSA_WITH_AES_128_CCM_8
    /**
    Represents the TLS_RSA_WITH_AES_128_CCM_8 cipher suite.

    */
    public static var TLS_RSA_WITH_AES_128_CCM_8 : dotnet.System.Net.Security.TlsCipherSuite {
        get {
        let __return = dotnet.System.Net.Security.TlsCipherSuite(val: System_Net_Security_TlsCipherSuite_get_TLS_RSA_WITH_AES_128_CCM_8());
            return __return;
        }
    }
    // static field: System.Net.Security.TlsCipherSuite TLS_RSA_WITH_AES_256_CCM_8
    /**
    Represents the TLS_RSA_WITH_AES_256_CCM_8 cipher suite.

    */
    public static var TLS_RSA_WITH_AES_256_CCM_8 : dotnet.System.Net.Security.TlsCipherSuite {
        get {
        let __return = dotnet.System.Net.Security.TlsCipherSuite(val: System_Net_Security_TlsCipherSuite_get_TLS_RSA_WITH_AES_256_CCM_8());
            return __return;
        }
    }
    // static field: System.Net.Security.TlsCipherSuite TLS_DHE_RSA_WITH_AES_128_CCM_8
    /**
    Represents the TLS_DHE_RSA_WITH_AES_128_CCM_8 cipher suite.

    */
    public static var TLS_DHE_RSA_WITH_AES_128_CCM_8 : dotnet.System.Net.Security.TlsCipherSuite {
        get {
        let __return = dotnet.System.Net.Security.TlsCipherSuite(val: System_Net_Security_TlsCipherSuite_get_TLS_DHE_RSA_WITH_AES_128_CCM_8());
            return __return;
        }
    }
    // static field: System.Net.Security.TlsCipherSuite TLS_DHE_RSA_WITH_AES_256_CCM_8
    /**
    Represents the TLS_DHE_RSA_WITH_AES_256_CCM_8 cipher suite.

    */
    public static var TLS_DHE_RSA_WITH_AES_256_CCM_8 : dotnet.System.Net.Security.TlsCipherSuite {
        get {
        let __return = dotnet.System.Net.Security.TlsCipherSuite(val: System_Net_Security_TlsCipherSuite_get_TLS_DHE_RSA_WITH_AES_256_CCM_8());
            return __return;
        }
    }
    // static field: System.Net.Security.TlsCipherSuite TLS_PSK_WITH_AES_128_CCM
    /**
    Represents the TLS_PSK_WITH_AES_128_CCM cipher suite.

    */
    public static var TLS_PSK_WITH_AES_128_CCM : dotnet.System.Net.Security.TlsCipherSuite {
        get {
        let __return = dotnet.System.Net.Security.TlsCipherSuite(val: System_Net_Security_TlsCipherSuite_get_TLS_PSK_WITH_AES_128_CCM());
            return __return;
        }
    }
    // static field: System.Net.Security.TlsCipherSuite TLS_PSK_WITH_AES_256_CCM
    /**
    Represents the TLS_PSK_WITH_AES_256_CCM cipher suite.

    */
    public static var TLS_PSK_WITH_AES_256_CCM : dotnet.System.Net.Security.TlsCipherSuite {
        get {
        let __return = dotnet.System.Net.Security.TlsCipherSuite(val: System_Net_Security_TlsCipherSuite_get_TLS_PSK_WITH_AES_256_CCM());
            return __return;
        }
    }
    // static field: System.Net.Security.TlsCipherSuite TLS_DHE_PSK_WITH_AES_128_CCM
    /**
    Represents the TLS_DHE_PSK_WITH_AES_128_CCM cipher suite.

    */
    public static var TLS_DHE_PSK_WITH_AES_128_CCM : dotnet.System.Net.Security.TlsCipherSuite {
        get {
        let __return = dotnet.System.Net.Security.TlsCipherSuite(val: System_Net_Security_TlsCipherSuite_get_TLS_DHE_PSK_WITH_AES_128_CCM());
            return __return;
        }
    }
    // static field: System.Net.Security.TlsCipherSuite TLS_DHE_PSK_WITH_AES_256_CCM
    /**
    Represents the TLS_DHE_PSK_WITH_AES_256_CCM cipher suite.

    */
    public static var TLS_DHE_PSK_WITH_AES_256_CCM : dotnet.System.Net.Security.TlsCipherSuite {
        get {
        let __return = dotnet.System.Net.Security.TlsCipherSuite(val: System_Net_Security_TlsCipherSuite_get_TLS_DHE_PSK_WITH_AES_256_CCM());
            return __return;
        }
    }
    // static field: System.Net.Security.TlsCipherSuite TLS_PSK_WITH_AES_128_CCM_8
    /**
    Represents the TLS_PSK_WITH_AES_128_CCM_8 cipher suite.

    */
    public static var TLS_PSK_WITH_AES_128_CCM_8 : dotnet.System.Net.Security.TlsCipherSuite {
        get {
        let __return = dotnet.System.Net.Security.TlsCipherSuite(val: System_Net_Security_TlsCipherSuite_get_TLS_PSK_WITH_AES_128_CCM_8());
            return __return;
        }
    }
    // static field: System.Net.Security.TlsCipherSuite TLS_PSK_WITH_AES_256_CCM_8
    /**
    Represents the TLS_PSK_WITH_AES_256_CCM_8 cipher suite.

    */
    public static var TLS_PSK_WITH_AES_256_CCM_8 : dotnet.System.Net.Security.TlsCipherSuite {
        get {
        let __return = dotnet.System.Net.Security.TlsCipherSuite(val: System_Net_Security_TlsCipherSuite_get_TLS_PSK_WITH_AES_256_CCM_8());
            return __return;
        }
    }
    // static field: System.Net.Security.TlsCipherSuite TLS_PSK_DHE_WITH_AES_128_CCM_8
    /**
    Represents the TLS_PSK_DHE_WITH_AES_128_CCM_8 cipher suite.

    */
    public static var TLS_PSK_DHE_WITH_AES_128_CCM_8 : dotnet.System.Net.Security.TlsCipherSuite {
        get {
        let __return = dotnet.System.Net.Security.TlsCipherSuite(val: System_Net_Security_TlsCipherSuite_get_TLS_PSK_DHE_WITH_AES_128_CCM_8());
            return __return;
        }
    }
    // static field: System.Net.Security.TlsCipherSuite TLS_PSK_DHE_WITH_AES_256_CCM_8
    /**
    Represents the TLS_PSK_DHE_WITH_AES_256_CCM_8 cipher suite.

    */
    public static var TLS_PSK_DHE_WITH_AES_256_CCM_8 : dotnet.System.Net.Security.TlsCipherSuite {
        get {
        let __return = dotnet.System.Net.Security.TlsCipherSuite(val: System_Net_Security_TlsCipherSuite_get_TLS_PSK_DHE_WITH_AES_256_CCM_8());
            return __return;
        }
    }
    // static field: System.Net.Security.TlsCipherSuite TLS_ECDHE_ECDSA_WITH_AES_128_CCM
    /**
    Represents the TLS_ECDHE_ECDSA_WITH_AES_128_CCM cipher suite.

    */
    public static var TLS_ECDHE_ECDSA_WITH_AES_128_CCM : dotnet.System.Net.Security.TlsCipherSuite {
        get {
        let __return = dotnet.System.Net.Security.TlsCipherSuite(val: System_Net_Security_TlsCipherSuite_get_TLS_ECDHE_ECDSA_WITH_AES_128_CCM());
            return __return;
        }
    }
    // static field: System.Net.Security.TlsCipherSuite TLS_ECDHE_ECDSA_WITH_AES_256_CCM
    /**
    Represents the TLS_ECDHE_ECDSA_WITH_AES_256_CCM cipher suite.

    */
    public static var TLS_ECDHE_ECDSA_WITH_AES_256_CCM : dotnet.System.Net.Security.TlsCipherSuite {
        get {
        let __return = dotnet.System.Net.Security.TlsCipherSuite(val: System_Net_Security_TlsCipherSuite_get_TLS_ECDHE_ECDSA_WITH_AES_256_CCM());
            return __return;
        }
    }
    // static field: System.Net.Security.TlsCipherSuite TLS_ECDHE_ECDSA_WITH_AES_128_CCM_8
    /**
    Represents the TLS_ECDHE_ECDSA_WITH_AES_128_CCM_8 cipher suite.

    */
    public static var TLS_ECDHE_ECDSA_WITH_AES_128_CCM_8 : dotnet.System.Net.Security.TlsCipherSuite {
        get {
        let __return = dotnet.System.Net.Security.TlsCipherSuite(val: System_Net_Security_TlsCipherSuite_get_TLS_ECDHE_ECDSA_WITH_AES_128_CCM_8());
            return __return;
        }
    }
    // static field: System.Net.Security.TlsCipherSuite TLS_ECDHE_ECDSA_WITH_AES_256_CCM_8
    /**
    Represents the TLS_ECDHE_ECDSA_WITH_AES_256_CCM_8 cipher suite.

    */
    public static var TLS_ECDHE_ECDSA_WITH_AES_256_CCM_8 : dotnet.System.Net.Security.TlsCipherSuite {
        get {
        let __return = dotnet.System.Net.Security.TlsCipherSuite(val: System_Net_Security_TlsCipherSuite_get_TLS_ECDHE_ECDSA_WITH_AES_256_CCM_8());
            return __return;
        }
    }
    // static field: System.Net.Security.TlsCipherSuite TLS_ECCPWD_WITH_AES_128_GCM_SHA256
    /**
    Represents the TLS_ECCPWD_WITH_AES_128_GCM_SHA256 cipher suite.

    */
    public static var TLS_ECCPWD_WITH_AES_128_GCM_SHA256 : dotnet.System.Net.Security.TlsCipherSuite {
        get {
        let __return = dotnet.System.Net.Security.TlsCipherSuite(val: System_Net_Security_TlsCipherSuite_get_TLS_ECCPWD_WITH_AES_128_GCM_SHA256());
            return __return;
        }
    }
    // static field: System.Net.Security.TlsCipherSuite TLS_ECCPWD_WITH_AES_256_GCM_SHA384
    /**
    Represents the TLS_ECCPWD_WITH_AES_256_GCM_SHA384 cipher suite.

    */
    public static var TLS_ECCPWD_WITH_AES_256_GCM_SHA384 : dotnet.System.Net.Security.TlsCipherSuite {
        get {
        let __return = dotnet.System.Net.Security.TlsCipherSuite(val: System_Net_Security_TlsCipherSuite_get_TLS_ECCPWD_WITH_AES_256_GCM_SHA384());
            return __return;
        }
    }
    // static field: System.Net.Security.TlsCipherSuite TLS_ECCPWD_WITH_AES_128_CCM_SHA256
    /**
    Represents the TLS_ECCPWD_WITH_AES_128_CCM_SHA256 cipher suite.

    */
    public static var TLS_ECCPWD_WITH_AES_128_CCM_SHA256 : dotnet.System.Net.Security.TlsCipherSuite {
        get {
        let __return = dotnet.System.Net.Security.TlsCipherSuite(val: System_Net_Security_TlsCipherSuite_get_TLS_ECCPWD_WITH_AES_128_CCM_SHA256());
            return __return;
        }
    }
    // static field: System.Net.Security.TlsCipherSuite TLS_ECCPWD_WITH_AES_256_CCM_SHA384
    /**
    Represents the TLS_ECCPWD_WITH_AES_256_CCM_SHA384 cipher suite.

    */
    public static var TLS_ECCPWD_WITH_AES_256_CCM_SHA384 : dotnet.System.Net.Security.TlsCipherSuite {
        get {
        let __return = dotnet.System.Net.Security.TlsCipherSuite(val: System_Net_Security_TlsCipherSuite_get_TLS_ECCPWD_WITH_AES_256_CCM_SHA384());
            return __return;
        }
    }
    // static field: System.Net.Security.TlsCipherSuite TLS_ECDHE_RSA_WITH_CHACHA20_POLY1305_SHA256
    /**
    Represents the TLS_ECDHE_RSA_WITH_CHACHA20_POLY1305_SHA256 cipher suite.

    */
    public static var TLS_ECDHE_RSA_WITH_CHACHA20_POLY1305_SHA256 : dotnet.System.Net.Security.TlsCipherSuite {
        get {
        let __return = dotnet.System.Net.Security.TlsCipherSuite(val: System_Net_Security_TlsCipherSuite_get_TLS_ECDHE_RSA_WITH_CHACHA20_POLY1305_SHA256());
            return __return;
        }
    }
    // static field: System.Net.Security.TlsCipherSuite TLS_ECDHE_ECDSA_WITH_CHACHA20_POLY1305_SHA256
    /**
    Represents the TLS_ECDHE_ECDSA_WITH_CHACHA20_POLY1305_SHA256 cipher suite.

    */
    public static var TLS_ECDHE_ECDSA_WITH_CHACHA20_POLY1305_SHA256 : dotnet.System.Net.Security.TlsCipherSuite {
        get {
        let __return = dotnet.System.Net.Security.TlsCipherSuite(val: System_Net_Security_TlsCipherSuite_get_TLS_ECDHE_ECDSA_WITH_CHACHA20_POLY1305_SHA256());
            return __return;
        }
    }
    // static field: System.Net.Security.TlsCipherSuite TLS_DHE_RSA_WITH_CHACHA20_POLY1305_SHA256
    /**
    Represents the TLS_DHE_RSA_WITH_CHACHA20_POLY1305_SHA256 cipher suite.

    */
    public static var TLS_DHE_RSA_WITH_CHACHA20_POLY1305_SHA256 : dotnet.System.Net.Security.TlsCipherSuite {
        get {
        let __return = dotnet.System.Net.Security.TlsCipherSuite(val: System_Net_Security_TlsCipherSuite_get_TLS_DHE_RSA_WITH_CHACHA20_POLY1305_SHA256());
            return __return;
        }
    }
    // static field: System.Net.Security.TlsCipherSuite TLS_PSK_WITH_CHACHA20_POLY1305_SHA256
    /**
    Represents the TLS_PSK_WITH_CHACHA20_POLY1305_SHA256 cipher suite.

    */
    public static var TLS_PSK_WITH_CHACHA20_POLY1305_SHA256 : dotnet.System.Net.Security.TlsCipherSuite {
        get {
        let __return = dotnet.System.Net.Security.TlsCipherSuite(val: System_Net_Security_TlsCipherSuite_get_TLS_PSK_WITH_CHACHA20_POLY1305_SHA256());
            return __return;
        }
    }
    // static field: System.Net.Security.TlsCipherSuite TLS_ECDHE_PSK_WITH_CHACHA20_POLY1305_SHA256
    /**
    Represents the TLS_ECDHE_PSK_WITH_CHACHA20_POLY1305_SHA256 cipher suite.

    */
    public static var TLS_ECDHE_PSK_WITH_CHACHA20_POLY1305_SHA256 : dotnet.System.Net.Security.TlsCipherSuite {
        get {
        let __return = dotnet.System.Net.Security.TlsCipherSuite(val: System_Net_Security_TlsCipherSuite_get_TLS_ECDHE_PSK_WITH_CHACHA20_POLY1305_SHA256());
            return __return;
        }
    }
    // static field: System.Net.Security.TlsCipherSuite TLS_DHE_PSK_WITH_CHACHA20_POLY1305_SHA256
    /**
    Represents the TLS_DHE_PSK_WITH_CHACHA20_POLY1305_SHA256 cipher suite.

    */
    public static var TLS_DHE_PSK_WITH_CHACHA20_POLY1305_SHA256 : dotnet.System.Net.Security.TlsCipherSuite {
        get {
        let __return = dotnet.System.Net.Security.TlsCipherSuite(val: System_Net_Security_TlsCipherSuite_get_TLS_DHE_PSK_WITH_CHACHA20_POLY1305_SHA256());
            return __return;
        }
    }
    // static field: System.Net.Security.TlsCipherSuite TLS_RSA_PSK_WITH_CHACHA20_POLY1305_SHA256
    /**
    Represents the TLS_RSA_PSK_WITH_CHACHA20_POLY1305_SHA256 cipher suite.

    */
    public static var TLS_RSA_PSK_WITH_CHACHA20_POLY1305_SHA256 : dotnet.System.Net.Security.TlsCipherSuite {
        get {
        let __return = dotnet.System.Net.Security.TlsCipherSuite(val: System_Net_Security_TlsCipherSuite_get_TLS_RSA_PSK_WITH_CHACHA20_POLY1305_SHA256());
            return __return;
        }
    }
    // static field: System.Net.Security.TlsCipherSuite TLS_ECDHE_PSK_WITH_AES_128_GCM_SHA256
    /**
    Represents the TLS_ECDHE_PSK_WITH_AES_128_GCM_SHA256 cipher suite.

    */
    public static var TLS_ECDHE_PSK_WITH_AES_128_GCM_SHA256 : dotnet.System.Net.Security.TlsCipherSuite {
        get {
        let __return = dotnet.System.Net.Security.TlsCipherSuite(val: System_Net_Security_TlsCipherSuite_get_TLS_ECDHE_PSK_WITH_AES_128_GCM_SHA256());
            return __return;
        }
    }
    // static field: System.Net.Security.TlsCipherSuite TLS_ECDHE_PSK_WITH_AES_256_GCM_SHA384
    /**
    Represents the TLS_ECDHE_PSK_WITH_AES_256_GCM_SHA384 cipher suite.

    */
    public static var TLS_ECDHE_PSK_WITH_AES_256_GCM_SHA384 : dotnet.System.Net.Security.TlsCipherSuite {
        get {
        let __return = dotnet.System.Net.Security.TlsCipherSuite(val: System_Net_Security_TlsCipherSuite_get_TLS_ECDHE_PSK_WITH_AES_256_GCM_SHA384());
            return __return;
        }
    }
    // static field: System.Net.Security.TlsCipherSuite TLS_ECDHE_PSK_WITH_AES_128_CCM_8_SHA256
    /**
    Represents the TLS_ECDHE_PSK_WITH_AES_128_CCM_8_SHA256 cipher suite.

    */
    public static var TLS_ECDHE_PSK_WITH_AES_128_CCM_8_SHA256 : dotnet.System.Net.Security.TlsCipherSuite {
        get {
        let __return = dotnet.System.Net.Security.TlsCipherSuite(val: System_Net_Security_TlsCipherSuite_get_TLS_ECDHE_PSK_WITH_AES_128_CCM_8_SHA256());
            return __return;
        }
    }
    // static field: System.Net.Security.TlsCipherSuite TLS_ECDHE_PSK_WITH_AES_128_CCM_SHA256
    /**
    Represents the TLS_ECDHE_PSK_WITH_AES_128_CCM_SHA256 cipher suite.

    */
    public static var TLS_ECDHE_PSK_WITH_AES_128_CCM_SHA256 : dotnet.System.Net.Security.TlsCipherSuite {
        get {
        let __return = dotnet.System.Net.Security.TlsCipherSuite(val: System_Net_Security_TlsCipherSuite_get_TLS_ECDHE_PSK_WITH_AES_128_CCM_SHA256());
            return __return;
        }
    }
} // TlsCipherSuite


}


// System.Security
// System.Security.Authentication
extension System.Security.Authentication {
// type: System.Security.Authentication.AuthenticationException
    /**
    The exception that is thrown when authentication fails for an authentication stream.

    */
open class AuthenticationException
    :
    dotnet.System.SystemException
{
    open class override func get_type_handle() -> TypeHandle {
        return System_Security_Authentication_AuthenticationException_get_type_handle();
    }
    public required init(hndl: NonnullHandle) { super.init(hndl: hndl); }
    public required init(gval: GVal) { super.init(gval: gval); }
    // .ctor()
// docid: M:System.Security.Authentication.AuthenticationException.#ctor
    /**
    Initializes a new instance of the  class with no message.

    */
    public override init() throws {
        var __thrown : NullableHandle = nil;
        let h = System_Security_Authentication_AuthenticationException_ctor_0__0(&__thrown);
        if let __ex = __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
            super.init(hndl: h);
        }
    }
    // .ctor(System.String)
// docid: M:System.Security.Authentication.AuthenticationException.#ctor(System.String)
    /**
    Initializes a new instance of the  class with the specified message.

    - Parameter message: A  that describes the authentication failure.
    */
    public override init(message : Optional<dotnet.System.String>) throws {
        var __thrown : NullableHandle = nil;
        let h = System_Security_Authentication_AuthenticationException_ctor_0__1__String(&__thrown, message?.get_handle() ?? nil);
        if let __ex = __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
            super.init(hndl: h);
        }
    }
    // .ctor(System.String, System.Exception)
// docid: M:System.Security.Authentication.AuthenticationException.#ctor(System.String,System.Exception)
    /**
    Initializes a new instance of the  class with the specified message and inner exception.

    - Parameter message: A  that describes the authentication failure.
    - Parameter innerException: The  that is the cause of the current exception.
    */
    public override init(message : Optional<dotnet.System.String>, innerException : Optional<dotnet.System.Exception>) throws {
        var __thrown : NullableHandle = nil;
        let h = System_Security_Authentication_AuthenticationException_ctor_0__2__String_Exception(&__thrown, message?.get_handle() ?? nil, innerException?.get_handle() ?? nil);
        if let __ex = __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
            super.init(hndl: h);
        }
    }
} // AuthenticationException


// type: System.Security.Authentication.InvalidCredentialException
    /**
    The exception that is thrown when authentication fails for an authentication stream and cannot be retried.

    */
open class InvalidCredentialException
    :
    dotnet.System.Security.Authentication.AuthenticationException
{
    open class override func get_type_handle() -> TypeHandle {
        return System_Security_Authentication_InvalidCredentialException_get_type_handle();
    }
    public required init(hndl: NonnullHandle) { super.init(hndl: hndl); }
    public required init(gval: GVal) { super.init(gval: gval); }
    // .ctor()
// docid: M:System.Security.Authentication.InvalidCredentialException.#ctor
    /**
    Initializes a new instance of the  class with no message.

    */
    public override init() throws {
        var __thrown : NullableHandle = nil;
        let h = System_Security_Authentication_InvalidCredentialException_ctor_0__0(&__thrown);
        if let __ex = __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
            super.init(hndl: h);
        }
    }
    // .ctor(System.String)
// docid: M:System.Security.Authentication.InvalidCredentialException.#ctor(System.String)
    /**
    Initializes a new instance of the  class with the specified message.

    - Parameter message: A  that describes the authentication failure.
    */
    public override init(message : Optional<dotnet.System.String>) throws {
        var __thrown : NullableHandle = nil;
        let h = System_Security_Authentication_InvalidCredentialException_ctor_0__1__String(&__thrown, message?.get_handle() ?? nil);
        if let __ex = __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
            super.init(hndl: h);
        }
    }
    // .ctor(System.String, System.Exception)
// docid: M:System.Security.Authentication.InvalidCredentialException.#ctor(System.String,System.Exception)
    /**
    Initializes a new instance of the  class with the specified message and inner exception.

    - Parameter message: A  that describes the authentication failure.
    - Parameter innerException: The  that is the cause of the current exception.
    */
    public override init(message : Optional<dotnet.System.String>, innerException : Optional<dotnet.System.Exception>) throws {
        var __thrown : NullableHandle = nil;
        let h = System_Security_Authentication_InvalidCredentialException_ctor_0__2__String_Exception(&__thrown, message?.get_handle() ?? nil, innerException?.get_handle() ?? nil);
        if let __ex = __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
            super.init(hndl: h);
        }
    }
} // InvalidCredentialException


}
// System.Security.Authentication.ExtendedProtection
extension System.Security.Authentication.ExtendedProtection {
// type: System.Security.Authentication.ExtendedProtection.ExtendedProtectionPolicy
    /**
    The  class represents the extended protection policy used by the server to validate incoming client connections.

    */
open class ExtendedProtectionPolicy
    :
    dotnet.System.Object,
    System_Runtime_Serialization_ISerializable
{
    open class override func get_type_handle() -> TypeHandle {
        return System_Security_Authentication_ExtendedProtection_ExtendedProtectionPolicy_get_type_handle();
    }
    public required init(hndl: NonnullHandle) { super.init(hndl: hndl); }
    public required init(gval: GVal) { super.init(gval: gval); }
    // .ctor(System.Security.Authentication.ExtendedProtection.PolicyEnforcement)
// docid: M:System.Security.Authentication.ExtendedProtection.ExtendedProtectionPolicy.#ctor(System.Security.Authentication.ExtendedProtection.PolicyEnforcement)
    /**
    Initializes a new instance of the  class that specifies when the extended protection policy should be enforced.

    - Parameter policyEnforcement: A  value that indicates when the extended protection policy should be enforced.
    */
    public init(policyEnforcement : dotnet.System.Security.Authentication.ExtendedProtection.PolicyEnforcement) throws {
        var __thrown : NullableHandle = nil;
        let h = System_Security_Authentication_ExtendedProtection_ExtendedProtectionPolicy_ctor_0__1__PolicyEnforcement(&__thrown, policyEnforcement.get_value());
        if let __ex = __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
            super.init(hndl: h);
        }
    }
    // .ctor(System.Security.Authentication.ExtendedProtection.PolicyEnforcement, System.Security.Authentication.ExtendedProtection.ChannelBinding)
// docid: M:System.Security.Authentication.ExtendedProtection.ExtendedProtectionPolicy.#ctor(System.Security.Authentication.ExtendedProtection.PolicyEnforcement,System.Security.Authentication.ExtendedProtection.ChannelBinding)
    /**
    Initializes a new instance of the  class that specifies when the extended protection policy should be enforced and the channel binding token (CBT) to be used.

    - Parameter policyEnforcement: A  value that indicates when the extended protection policy should be enforced.
    - Parameter customChannelBinding: A  that contains a custom channel binding to use for validation.
    */
    public init(policyEnforcement : dotnet.System.Security.Authentication.ExtendedProtection.PolicyEnforcement, customChannelBinding : dotnet.System.Security.Authentication.ExtendedProtection.ChannelBinding) throws {
        var __thrown : NullableHandle = nil;
        let h = System_Security_Authentication_ExtendedProtection_ExtendedProtectionPolicy_ctor_0__2__PolicyEnforcement_ChannelBinding(&__thrown, policyEnforcement.get_value(), customChannelBinding.get_handle());
        if let __ex = __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
            super.init(hndl: h);
        }
    }
    // .ctor(System.Security.Authentication.ExtendedProtection.PolicyEnforcement, System.Security.Authentication.ExtendedProtection.ProtectionScenario, System.Collections.ICollection)
// docid: M:System.Security.Authentication.ExtendedProtection.ExtendedProtectionPolicy.#ctor(System.Security.Authentication.ExtendedProtection.PolicyEnforcement,System.Security.Authentication.ExtendedProtection.ProtectionScenario,System.Collections.ICollection)
    /**
    Initializes a new instance of the  class that specifies when the extended protection policy should be enforced, the kind of protection enforced by the policy, and a custom Service Provider Name (SPN) list that is used to match against a client's SPN.

    - Parameter policyEnforcement: A  value that indicates when the extended protection policy should be enforced.
    - Parameter protectionScenario: A  value that indicates the kind of protection enforced by the policy.
    - Parameter customServiceNames: A  that contains the custom SPN list that is used to match against a client's SPN.
    */
    public init(policyEnforcement : dotnet.System.Security.Authentication.ExtendedProtection.PolicyEnforcement, protectionScenario : dotnet.System.Security.Authentication.ExtendedProtection.ProtectionScenario, customServiceNames : Optional<dotnet.System.Collections.ICollection>) throws {
        var __thrown : NullableHandle = nil;
        let h = System_Security_Authentication_ExtendedProtection_ExtendedProtectionPolicy_ctor_0__3__PolicyEnforcement_ProtectionScenario_ICollection(&__thrown, policyEnforcement.get_value(), protectionScenario.get_value(), customServiceNames?.get_handle() ?? nil);
        if let __ex = __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
            super.init(hndl: h);
        }
    }
    // .ctor(System.Security.Authentication.ExtendedProtection.PolicyEnforcement, System.Security.Authentication.ExtendedProtection.ProtectionScenario, System.Security.Authentication.ExtendedProtection.ServiceNameCollection)
// docid: M:System.Security.Authentication.ExtendedProtection.ExtendedProtectionPolicy.#ctor(System.Security.Authentication.ExtendedProtection.PolicyEnforcement,System.Security.Authentication.ExtendedProtection.ProtectionScenario,System.Security.Authentication.ExtendedProtection.ServiceNameCollection)
    /**
    Initializes a new instance of the  class that specifies when the extended protection policy should be enforced, the kind of protection enforced by the policy, and a custom Service Provider Name (SPN) list that is used to match against a client's SPN.

    - Parameter policyEnforcement: A  value that indicates when the extended protection policy should be enforced.
    - Parameter protectionScenario: A  value that indicates the kind of protection enforced by the policy.
    - Parameter customServiceNames: A  that contains the custom SPN list that is used to match against a client's SPN.
    */
    public init(policyEnforcement : dotnet.System.Security.Authentication.ExtendedProtection.PolicyEnforcement, protectionScenario : dotnet.System.Security.Authentication.ExtendedProtection.ProtectionScenario, customServiceNames : Optional<dotnet.System.Security.Authentication.ExtendedProtection.ServiceNameCollection>) throws {
        var __thrown : NullableHandle = nil;
        let h = System_Security_Authentication_ExtendedProtection_ExtendedProtectionPolicy_ctor_0__3__PolicyEnforcement_ProtectionScenario_ServiceNameCollection(&__thrown, policyEnforcement.get_value(), protectionScenario.get_value(), customServiceNames?.get_handle() ?? nil);
        if let __ex = __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
            super.init(hndl: h);
        }
    }
    // System.String ToString()
// docid: M:System.Security.Authentication.ExtendedProtection.ExtendedProtectionPolicy.ToString
    /**
    Gets a string representation for the extended protection policy instance.

    - Returns: A  instance that contains the representation of the  instance.

    */
    open override func ToString() throws -> dotnet.System.String {
        var __thrown : NullableHandle = nil;
        let __return = System_Security_Authentication_ExtendedProtection_ExtendedProtectionPolicy_String__ToString_0__0(&__thrown, self.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return dotnet.System.String(hndl : __return);
        }
    }
    // [IsSpecialName] System.Security.Authentication.ExtendedProtection.ChannelBinding get_CustomChannelBinding()
// docid: M:System.Security.Authentication.ExtendedProtection.ExtendedProtectionPolicy.get_CustomChannelBinding
    open func get_CustomChannelBinding() throws -> Optional<dotnet.System.Security.Authentication.ExtendedProtection.ChannelBinding> {
        var __thrown : NullableHandle = nil;
        let __return = System_Security_Authentication_ExtendedProtection_ExtendedProtectionPolicy_ChannelBinding__get_CustomChannelBinding_0__0(&__thrown, self.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        if let __ret_unwrapped = __return {
            return dotnet.System.Security.Authentication.ExtendedProtection.ChannelBinding(hndl : __ret_unwrapped);
        } else {
            return nil;
        }
        }
    }
    // [IsSpecialName] System.Security.Authentication.ExtendedProtection.ServiceNameCollection get_CustomServiceNames()
// docid: M:System.Security.Authentication.ExtendedProtection.ExtendedProtectionPolicy.get_CustomServiceNames
    open func get_CustomServiceNames() throws -> Optional<dotnet.System.Security.Authentication.ExtendedProtection.ServiceNameCollection> {
        var __thrown : NullableHandle = nil;
        let __return = System_Security_Authentication_ExtendedProtection_ExtendedProtectionPolicy_ServiceNameCollection__get_CustomServiceNames_0__0(&__thrown, self.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        if let __ret_unwrapped = __return {
            return dotnet.System.Security.Authentication.ExtendedProtection.ServiceNameCollection(hndl : __ret_unwrapped);
        } else {
            return nil;
        }
        }
    }
    // [IsSpecialName] bool get_OSSupportsExtendedProtection()
// docid: M:System.Security.Authentication.ExtendedProtection.ExtendedProtectionPolicy.get_OSSupportsExtendedProtection
    open class func get_OSSupportsExtendedProtection() throws -> Bool {
        var __thrown : NullableHandle = nil;
        let __return = System_Security_Authentication_ExtendedProtection_ExtendedProtectionPolicy_bool__get_OSSupportsExtendedProtection_0__0(&__thrown);
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return (__return) != 0;
        }
    }
    // [IsSpecialName] System.Security.Authentication.ExtendedProtection.PolicyEnforcement get_PolicyEnforcement()
// docid: M:System.Security.Authentication.ExtendedProtection.ExtendedProtectionPolicy.get_PolicyEnforcement
    open func get_PolicyEnforcement() throws -> dotnet.System.Security.Authentication.ExtendedProtection.PolicyEnforcement {
        var __thrown : NullableHandle = nil;
        let __return = System_Security_Authentication_ExtendedProtection_ExtendedProtectionPolicy_PolicyEnforcement__get_PolicyEnforcement_0__0(&__thrown, self.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return dotnet.System.Security.Authentication.ExtendedProtection.PolicyEnforcement(val: __return);
        }
    }
    // [IsSpecialName] System.Security.Authentication.ExtendedProtection.ProtectionScenario get_ProtectionScenario()
// docid: M:System.Security.Authentication.ExtendedProtection.ExtendedProtectionPolicy.get_ProtectionScenario
    open func get_ProtectionScenario() throws -> dotnet.System.Security.Authentication.ExtendedProtection.ProtectionScenario {
        var __thrown : NullableHandle = nil;
        let __return = System_Security_Authentication_ExtendedProtection_ExtendedProtectionPolicy_ProtectionScenario__get_ProtectionScenario_0__0(&__thrown, self.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return dotnet.System.Security.Authentication.ExtendedProtection.ProtectionScenario(val: __return);
        }
    }
    /**
    Gets a custom channel binding token (CBT) to use for validation.

    */
    open var CustomChannelBinding : Optional<dotnet.System.Security.Authentication.ExtendedProtection.ChannelBinding> {
        get {
            return try! get_CustomChannelBinding();
        }
    }
    /**
    Gets the custom Service Provider Name (SPN) list used to match against a client's SPN.

    */
    open var CustomServiceNames : Optional<dotnet.System.Security.Authentication.ExtendedProtection.ServiceNameCollection> {
        get {
            return try! get_CustomServiceNames();
        }
    }
    /**
    Indicates whether the operating system supports integrated windows authentication with extended protection.

    */
    public static var OSSupportsExtendedProtection : Bool {
        get {
            return try! get_OSSupportsExtendedProtection();
        }
    }
    /**
    Gets when the extended protection policy should be enforced.

    */
    open var PolicyEnforcement : dotnet.System.Security.Authentication.ExtendedProtection.PolicyEnforcement {
        get {
            return try! get_PolicyEnforcement();
        }
    }
    /**
    Gets the kind of protection enforced by the extended protection policy.

    */
    open var ProtectionScenario : dotnet.System.Security.Authentication.ExtendedProtection.ProtectionScenario {
        get {
            return try! get_ProtectionScenario();
        }
    }
} // ExtendedProtectionPolicy


// type: System.Security.Authentication.ExtendedProtection.PolicyEnforcement
    /**
    The  enumeration specifies when the  should be enforced.

    */
public struct PolicyEnforcement : SGBridgeGenericValue {
    let v : Swift.Int32;
    public init(val: Swift.Int32) { self.v = val; }
    public func get_value() -> Swift.Int32 { return self.v; }
    public static func get_type_handle() -> TypeHandle {
        return System_Security_Authentication_ExtendedProtection_PolicyEnforcement_get_type_handle();
    }
    public func to_gval() -> GVal { return GVal(self.v); }
    public func dup_gval() -> GVal { return to_gval(); }
    public init(gval: GVal) { self.v = Swift.Int32(gval); }
    // static field: System.Security.Authentication.ExtendedProtection.PolicyEnforcement Never
    /**
    The  is never enforced and extended protection is disabled.

    */
    public static var Never : dotnet.System.Security.Authentication.ExtendedProtection.PolicyEnforcement {
        get {
        let __return = dotnet.System.Security.Authentication.ExtendedProtection.PolicyEnforcement(val: System_Security_Authentication_ExtendedProtection_PolicyEnforcement_get_Never());
            return __return;
        }
    }
    // static field: System.Security.Authentication.ExtendedProtection.PolicyEnforcement WhenSupported
    /**
    The  is enforced only if the client and server supports extended protection.

    */
    public static var WhenSupported : dotnet.System.Security.Authentication.ExtendedProtection.PolicyEnforcement {
        get {
        let __return = dotnet.System.Security.Authentication.ExtendedProtection.PolicyEnforcement(val: System_Security_Authentication_ExtendedProtection_PolicyEnforcement_get_WhenSupported());
            return __return;
        }
    }
    // static field: System.Security.Authentication.ExtendedProtection.PolicyEnforcement Always
    /**
    The  is always enforced. Clients that don't support extended protection will fail to authenticate.

    */
    public static var Always : dotnet.System.Security.Authentication.ExtendedProtection.PolicyEnforcement {
        get {
        let __return = dotnet.System.Security.Authentication.ExtendedProtection.PolicyEnforcement(val: System_Security_Authentication_ExtendedProtection_PolicyEnforcement_get_Always());
            return __return;
        }
    }
} // PolicyEnforcement


// type: System.Security.Authentication.ExtendedProtection.ProtectionScenario
    /**
    The  enumeration specifies the protection scenario enforced by the policy.

    */
public struct ProtectionScenario : SGBridgeGenericValue {
    let v : Swift.Int32;
    public init(val: Swift.Int32) { self.v = val; }
    public func get_value() -> Swift.Int32 { return self.v; }
    public static func get_type_handle() -> TypeHandle {
        return System_Security_Authentication_ExtendedProtection_ProtectionScenario_get_type_handle();
    }
    public func to_gval() -> GVal { return GVal(self.v); }
    public func dup_gval() -> GVal { return to_gval(); }
    public init(gval: GVal) { self.v = Swift.Int32(gval); }
    // static field: System.Security.Authentication.ExtendedProtection.ProtectionScenario TransportSelected
    /**
    The transport will select between a secure and standard protection scenario depending on the type of channel used. For secure protection, integrated Windows authentication is wrapped in a secure channel and has an exactly matching channel binding token with no Service Provider Name (SPN) validation. For standard protection, integrated Windows authentication is optionally wrapped in a secure channel with an optional channel binding token and SPN validation is required. So if the request comes through a secure channel, the channel binding token (CBT) is checked, otherwise the SPN is checked.

    */
    public static var TransportSelected : dotnet.System.Security.Authentication.ExtendedProtection.ProtectionScenario {
        get {
        let __return = dotnet.System.Security.Authentication.ExtendedProtection.ProtectionScenario(val: System_Security_Authentication_ExtendedProtection_ProtectionScenario_get_TransportSelected());
            return __return;
        }
    }
    // static field: System.Security.Authentication.ExtendedProtection.ProtectionScenario TrustedProxy
    /**
    Integrated Windows authentication is wrapped in a secure channel terminated by a trusted proxy and has a channel binding token with SPN validation required. This requires the presence of a CBT, but the CBT is not checked while the SPN is checked.

    */
    public static var TrustedProxy : dotnet.System.Security.Authentication.ExtendedProtection.ProtectionScenario {
        get {
        let __return = dotnet.System.Security.Authentication.ExtendedProtection.ProtectionScenario(val: System_Security_Authentication_ExtendedProtection_ProtectionScenario_get_TrustedProxy());
            return __return;
        }
    }
} // ProtectionScenario


// type: System.Security.Authentication.ExtendedProtection.ServiceNameCollection
    /**
    The  class is a read-only collection of service principal names.

    */
open class ServiceNameCollection
    :
    dotnet.System.Collections.ReadOnlyCollectionBase
{
    open class override func get_type_handle() -> TypeHandle {
        return System_Security_Authentication_ExtendedProtection_ServiceNameCollection_get_type_handle();
    }
    public required init(hndl: NonnullHandle) { super.init(hndl: hndl); }
    public required init(gval: GVal) { super.init(gval: gval); }
    // .ctor(System.Collections.ICollection)
// docid: M:System.Security.Authentication.ExtendedProtection.ServiceNameCollection.#ctor(System.Collections.ICollection)
    /**
    Initializes a new read-only instance of the  class based on an existing .

    - Parameter items: An instance of the  class that contains the specified values of service names to be used to initialize the class.
    */
    public init(items : dotnet.System.Collections.ICollection) throws {
        var __thrown : NullableHandle = nil;
        let h = System_Security_Authentication_ExtendedProtection_ServiceNameCollection_ctor_0__1__ICollection(&__thrown, items.get_handle());
        if let __ex = __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
            super.init(hndl: h);
        }
    }
    // bool Contains(System.String)
// docid: M:System.Security.Authentication.ExtendedProtection.ServiceNameCollection.Contains(System.String)
    /**
    Returns a value indicating whether the specified string occurs within this  instance.

    - Parameter searchServiceName: The string to seek.
    - Returns: Returns .  
  
  if the  parameter occurs within this  instance; otherwise, .

    */
    open func Contains(searchServiceName : Optional<dotnet.System.String>) throws -> Bool {
        var __thrown : NullableHandle = nil;
        let __return = System_Security_Authentication_ExtendedProtection_ServiceNameCollection_bool__Contains_0__1__String(&__thrown, self.get_handle(), searchServiceName?.get_handle() ?? nil);
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return (__return) != 0;
        }
    }
    // System.Security.Authentication.ExtendedProtection.ServiceNameCollection Merge(System.Collections.IEnumerable)
// docid: M:System.Security.Authentication.ExtendedProtection.ServiceNameCollection.Merge(System.Collections.IEnumerable)
    /**
    Merges the current  with the specified values to create a new  containing the union.

    - Parameter serviceNames: An instance of the  class that contains the specified values of service names to be merged.
    - Returns: A new  instance that contains the union of the existing  instance merged with the specified values.

    */
    open func Merge(serviceNames : dotnet.System.Collections.IEnumerable) throws -> dotnet.System.Security.Authentication.ExtendedProtection.ServiceNameCollection {
        var __thrown : NullableHandle = nil;
        let __return = System_Security_Authentication_ExtendedProtection_ServiceNameCollection_ServiceNameCollection__Merge_0__1__IEnumerable(&__thrown, self.get_handle(), serviceNames.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return dotnet.System.Security.Authentication.ExtendedProtection.ServiceNameCollection(hndl : __return);
        }
    }
    // System.Security.Authentication.ExtendedProtection.ServiceNameCollection Merge(System.String)
// docid: M:System.Security.Authentication.ExtendedProtection.ServiceNameCollection.Merge(System.String)
    /**
    Merges the current  with the specified values to create a new  containing the union.

    - Parameter serviceName: A string that contains the specified values of service names to be used to initialize the class.
    - Returns: A new  instance that contains the union of the existing  instance merged with the specified values.

    */
    open func Merge(serviceName : dotnet.System.String) throws -> dotnet.System.Security.Authentication.ExtendedProtection.ServiceNameCollection {
        var __thrown : NullableHandle = nil;
        let __return = System_Security_Authentication_ExtendedProtection_ServiceNameCollection_ServiceNameCollection__Merge_0__1__String(&__thrown, self.get_handle(), serviceName.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return dotnet.System.Security.Authentication.ExtendedProtection.ServiceNameCollection(hndl : __return);
        }
    }
} // ServiceNameCollection


}




