// this file is automatically generated
// Copyright 2021 SourceGear

import jumptable_dotnet;

// System
// System.Threading
// System.Threading.Channels
extension System.Threading.Channels {
// type: System.Threading.Channels.BoundedChannelFullMode
    /**
    Specifies the behavior to use when writing to a bounded channel that is already full.

    */
public struct BoundedChannelFullMode : SGBridgeGenericValue {
    let v : Swift.Int32;
    public init(val: Swift.Int32) { self.v = val; }
    public func get_value() -> Swift.Int32 { return self.v; }
    public static func get_type_handle() -> TypeHandle {
        return System_Threading_Channels_BoundedChannelFullMode_get_type_handle();
    }
    public func to_gval() -> GVal { return GVal(self.v); }
    public func dup_gval() -> GVal { return to_gval(); }
    public init(gval: GVal) { self.v = Swift.Int32(gval); }
    // static field: System.Threading.Channels.BoundedChannelFullMode Wait
    /**
    Waits for space to be available in order to complete the write operation.

    */
    public static var Wait : dotnet.System.Threading.Channels.BoundedChannelFullMode {
        get {
        let __return = dotnet.System.Threading.Channels.BoundedChannelFullMode(val: System_Threading_Channels_BoundedChannelFullMode_get_Wait());
            return __return;
        }
    }
    // static field: System.Threading.Channels.BoundedChannelFullMode DropNewest
    /**
    Removes and ignores the newest item in the channel in order to make room for the item being written.

    */
    public static var DropNewest : dotnet.System.Threading.Channels.BoundedChannelFullMode {
        get {
        let __return = dotnet.System.Threading.Channels.BoundedChannelFullMode(val: System_Threading_Channels_BoundedChannelFullMode_get_DropNewest());
            return __return;
        }
    }
    // static field: System.Threading.Channels.BoundedChannelFullMode DropOldest
    /**
    Removes and ignores the oldest item in the channel in order to make room for the item being written.

    */
    public static var DropOldest : dotnet.System.Threading.Channels.BoundedChannelFullMode {
        get {
        let __return = dotnet.System.Threading.Channels.BoundedChannelFullMode(val: System_Threading_Channels_BoundedChannelFullMode_get_DropOldest());
            return __return;
        }
    }
    // static field: System.Threading.Channels.BoundedChannelFullMode DropWrite
    /**
    Drops the item being written.

    */
    public static var DropWrite : dotnet.System.Threading.Channels.BoundedChannelFullMode {
        get {
        let __return = dotnet.System.Threading.Channels.BoundedChannelFullMode(val: System_Threading_Channels_BoundedChannelFullMode_get_DropWrite());
            return __return;
        }
    }
} // BoundedChannelFullMode


// type: System.Threading.Channels.BoundedChannelOptions
    /**
    Provides options that control the behavior of bounded  instances.

    */
public final class BoundedChannelOptions
    :
    dotnet.System.Threading.Channels.ChannelOptions
{
    public class override func get_type_handle() -> TypeHandle {
        return System_Threading_Channels_BoundedChannelOptions_get_type_handle();
    }
    public required init(hndl: NonnullHandle) { super.init(hndl: hndl); }
    public required init(gval: GVal) { super.init(gval: gval); }
    // .ctor(System.Int32)
// docid: M:System.Threading.Channels.BoundedChannelOptions.#ctor(System.Int32)
    /**
    Initializes the options.

    - Parameter capacity: The maximum number of items the bounded channel may store.
    */
    public init(capacity : Swift.Int32) throws {
        var __thrown : NullableHandle = nil;
        let h = System_Threading_Channels_BoundedChannelOptions_ctor_0__1__i32(&__thrown, capacity);
        if let __ex = __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
            super.init(hndl: h);
        }
    }
    // [IsSpecialName] System.Int32 get_Capacity()
// docid: M:System.Threading.Channels.BoundedChannelOptions.get_Capacity
    public func get_Capacity() throws -> Swift.Int32 {
        var __thrown : NullableHandle = nil;
        let __return = System_Threading_Channels_BoundedChannelOptions_i32__get_Capacity_0__0(&__thrown, self.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return __return;
        }
    }
    // [IsSpecialName] void set_Capacity(System.Int32)
// docid: M:System.Threading.Channels.BoundedChannelOptions.set_Capacity(System.Int32)
    public func set_Capacity(value : Swift.Int32) throws {
        var __thrown : NullableHandle = nil;
        System_Threading_Channels_BoundedChannelOptions_void__set_Capacity_0__1__i32(&__thrown, self.get_handle(), value);
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
            return;
        }
    }
    // [IsSpecialName] System.Threading.Channels.BoundedChannelFullMode get_FullMode()
// docid: M:System.Threading.Channels.BoundedChannelOptions.get_FullMode
    public func get_FullMode() throws -> dotnet.System.Threading.Channels.BoundedChannelFullMode {
        var __thrown : NullableHandle = nil;
        let __return = System_Threading_Channels_BoundedChannelOptions_BoundedChannelFullMode__get_FullMode_0__0(&__thrown, self.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return dotnet.System.Threading.Channels.BoundedChannelFullMode(val: __return);
        }
    }
    // [IsSpecialName] void set_FullMode(System.Threading.Channels.BoundedChannelFullMode)
// docid: M:System.Threading.Channels.BoundedChannelOptions.set_FullMode(System.Threading.Channels.BoundedChannelFullMode)
    public func set_FullMode(value : dotnet.System.Threading.Channels.BoundedChannelFullMode) throws {
        var __thrown : NullableHandle = nil;
        System_Threading_Channels_BoundedChannelOptions_void__set_FullMode_0__1__BoundedChannelFullMode(&__thrown, self.get_handle(), value.get_value());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
            return;
        }
    }
    /**
    Gets or sets the maximum number of items the bounded channel may store.

    */
    public var Capacity : Swift.Int32 {
        get {
            return try! get_Capacity();
        }
        set(v) {
            return try! set_Capacity(value: v);
        }
    }
    /**
    Gets or sets the behavior incurred by write operations when the channel is full.

    */
    public var FullMode : dotnet.System.Threading.Channels.BoundedChannelFullMode {
        get {
            return try! get_FullMode();
        }
        set(v) {
            return try! set_FullMode(value: v);
        }
    }
} // BoundedChannelOptions


// type: System.Threading.Channels.Channel
public struct Channel {
// TODO COPE (write_all_methods) (unused generic param) System.Threading.Channels.Channel<T> CreateBounded<T>(System.Int32)
// TODO COPE (write_all_methods) (unused generic param) System.Threading.Channels.Channel<T> CreateBounded<T>(System.Threading.Channels.BoundedChannelOptions)
    // System.Threading.Channels.Channel<T> CreateBounded<T>(System.Threading.Channels.BoundedChannelOptions, System.Action<T>)
// docid: M:System.Threading.Channels.Channel.CreateBounded``1(System.Threading.Channels.BoundedChannelOptions,System.Action{``0})
    public static func CreateBounded<UT : SGBridgeGenericValue>(options : dotnet.System.Threading.Channels.BoundedChannelOptions, itemDropped : dotnet.System.Action_1<UT>) throws -> dotnet.System.Threading.Channels.Channel_1<UT> {
        var __thrown : NullableHandle = nil;
        let __return = System_Threading_Channels_Channel_System_Threading_Channels_Channel_UT___CreateBounded_1__2__BoundedChannelOptions_System_Action_UT_(UT.get_type_handle(), &__thrown, options.get_handle(), nil);
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return dotnet.System.Threading.Channels.Channel_1(hndl : __return);
        }
    }
    // delegate closure overload
    public static func CreateBounded<UT : SGBridgeGenericValue>(options : dotnet.System.Threading.Channels.BoundedChannelOptions, itemDropped : @escaping (UT) throws -> Void) throws -> dotnet.System.Threading.Channels.Channel_1<UT> {
        let del_itemDropped = try dotnet.System.Action_1<UT>(itemDropped);
        return try CreateBounded(options: options, itemDropped: del_itemDropped);
    }
// TODO COPE (write_all_methods) (unused generic param) System.Threading.Channels.Channel<T> CreateUnbounded<T>()
// TODO COPE (write_all_methods) (unused generic param) System.Threading.Channels.Channel<T> CreateUnbounded<T>(System.Threading.Channels.UnboundedChannelOptions)
} // Channel


// type: System.Threading.Channels.ChannelClosedException
    /**
    Exception thrown when a channel is used after it's been closed.

    */
open class ChannelClosedException
    :
    dotnet.System.InvalidOperationException
{
    open class override func get_type_handle() -> TypeHandle {
        return System_Threading_Channels_ChannelClosedException_get_type_handle();
    }
    public required init(hndl: NonnullHandle) { super.init(hndl: hndl); }
    public required init(gval: GVal) { super.init(gval: gval); }
    // .ctor()
// docid: M:System.Threading.Channels.ChannelClosedException.#ctor
    /**
    Initializes a new instance of the  class.

    */
    public override init() throws {
        var __thrown : NullableHandle = nil;
        let h = System_Threading_Channels_ChannelClosedException_ctor_0__0(&__thrown);
        if let __ex = __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
            super.init(hndl: h);
        }
    }
    // .ctor(System.Exception)
// docid: M:System.Threading.Channels.ChannelClosedException.#ctor(System.Exception)
    /**
    Initializes a new instance of the  class.

    - Parameter innerException: The exception that is the cause of this exception.
    */
    public init(innerException : Optional<dotnet.System.Exception>) throws {
        var __thrown : NullableHandle = nil;
        let h = System_Threading_Channels_ChannelClosedException_ctor_0__1__Exception(&__thrown, innerException?.get_handle() ?? nil);
        if let __ex = __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
            super.init(hndl: h);
        }
    }
    // .ctor(System.String)
// docid: M:System.Threading.Channels.ChannelClosedException.#ctor(System.String)
    /**
    Initializes a new instance of the  class.

    - Parameter message: The message that describes the error.
    */
    public override init(message : Optional<dotnet.System.String>) throws {
        var __thrown : NullableHandle = nil;
        let h = System_Threading_Channels_ChannelClosedException_ctor_0__1__String(&__thrown, message?.get_handle() ?? nil);
        if let __ex = __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
            super.init(hndl: h);
        }
    }
    // .ctor(System.String, System.Exception)
// docid: M:System.Threading.Channels.ChannelClosedException.#ctor(System.String,System.Exception)
    /**
    Initializes a new instance of the  class.

    - Parameter message: The message that describes the error.
    - Parameter innerException: The exception that is the cause of this exception.
    */
    public override init(message : Optional<dotnet.System.String>, innerException : Optional<dotnet.System.Exception>) throws {
        var __thrown : NullableHandle = nil;
        let h = System_Threading_Channels_ChannelClosedException_ctor_0__2__String_Exception(&__thrown, message?.get_handle() ?? nil, innerException?.get_handle() ?? nil);
        if let __ex = __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
            super.init(hndl: h);
        }
    }
} // ChannelClosedException


// type: System.Threading.Channels.ChannelOptions
    /**
    Provides options that control the behavior of channel instances.

    */
open class ChannelOptions
    :
    dotnet.System.Object
{
    open class override func get_type_handle() -> TypeHandle {
        return System_Threading_Channels_ChannelOptions_get_type_handle();
    }
    public required init(hndl: NonnullHandle) { super.init(hndl: hndl); }
    public required init(gval: GVal) { super.init(gval: gval); }
    // [IsSpecialName] bool get_AllowSynchronousContinuations()
// docid: M:System.Threading.Channels.ChannelOptions.get_AllowSynchronousContinuations
    open func get_AllowSynchronousContinuations() throws -> Bool {
        var __thrown : NullableHandle = nil;
        let __return = System_Threading_Channels_ChannelOptions_bool__get_AllowSynchronousContinuations_0__0(&__thrown, self.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return (__return) != 0;
        }
    }
    // [IsSpecialName] void set_AllowSynchronousContinuations(bool)
// docid: M:System.Threading.Channels.ChannelOptions.set_AllowSynchronousContinuations(System.Boolean)
    open func set_AllowSynchronousContinuations(value : Bool) throws {
        var __thrown : NullableHandle = nil;
        System_Threading_Channels_ChannelOptions_void__set_AllowSynchronousContinuations_0__1__bool(&__thrown, self.get_handle(), Swift.Int32(value ? 1 : 0));
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
            return;
        }
    }
    // [IsSpecialName] bool get_SingleReader()
// docid: M:System.Threading.Channels.ChannelOptions.get_SingleReader
    open func get_SingleReader() throws -> Bool {
        var __thrown : NullableHandle = nil;
        let __return = System_Threading_Channels_ChannelOptions_bool__get_SingleReader_0__0(&__thrown, self.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return (__return) != 0;
        }
    }
    // [IsSpecialName] void set_SingleReader(bool)
// docid: M:System.Threading.Channels.ChannelOptions.set_SingleReader(System.Boolean)
    open func set_SingleReader(value : Bool) throws {
        var __thrown : NullableHandle = nil;
        System_Threading_Channels_ChannelOptions_void__set_SingleReader_0__1__bool(&__thrown, self.get_handle(), Swift.Int32(value ? 1 : 0));
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
            return;
        }
    }
    // [IsSpecialName] bool get_SingleWriter()
// docid: M:System.Threading.Channels.ChannelOptions.get_SingleWriter
    open func get_SingleWriter() throws -> Bool {
        var __thrown : NullableHandle = nil;
        let __return = System_Threading_Channels_ChannelOptions_bool__get_SingleWriter_0__0(&__thrown, self.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return (__return) != 0;
        }
    }
    // [IsSpecialName] void set_SingleWriter(bool)
// docid: M:System.Threading.Channels.ChannelOptions.set_SingleWriter(System.Boolean)
    open func set_SingleWriter(value : Bool) throws {
        var __thrown : NullableHandle = nil;
        System_Threading_Channels_ChannelOptions_void__set_SingleWriter_0__1__bool(&__thrown, self.get_handle(), Swift.Int32(value ? 1 : 0));
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
            return;
        }
    }
    /**
    
         if operations performed on a channel may synchronously invoke continuations subscribed to
            notifications of pending async operations;  if all continuations should be invoked asynchronously.

    */
    open var AllowSynchronousContinuations : Bool {
        get {
            return try! get_AllowSynchronousContinuations();
        }
        set(v) {
            return try! set_AllowSynchronousContinuations(value: v);
        }
    }
    /**
    
         readers from the channel guarantee that there will only ever be at most one read operation at a time;
             if no such constraint is guaranteed.

    */
    open var SingleReader : Bool {
        get {
            return try! get_SingleReader();
        }
        set(v) {
            return try! set_SingleReader(value: v);
        }
    }
    /**
    
         if writers to the channel guarantee that there will only ever be at most one write operation
            at a time;  if no such constraint is guaranteed.

    */
    open var SingleWriter : Bool {
        get {
            return try! get_SingleWriter();
        }
        set(v) {
            return try! set_SingleWriter(value: v);
        }
    }
} // ChannelOptions


// type: System.Threading.Channels.ChannelReader`1
    /**
    Provides a base class for reading from a channel.

    */
open class ChannelReader_1<T : SGBridgeGenericValue>
    :
    dotnet.System.Object
{
    open class override func get_type_handle() -> TypeHandle {
        return System_Threading_Channels_ChannelReader_1_get_type_handle(T.get_type_handle());
    }
    public required init(hndl: NonnullHandle) { super.init(hndl: hndl); }
    public required init(gval: GVal) { super.init(gval: gval); }
    // System.Threading.Tasks.ValueTask<T> ReadAsync(System.Threading.CancellationToken)
// docid: M:System.Threading.Channels.ChannelReader`1.ReadAsync(System.Threading.CancellationToken)
    /**
    Asynchronously reads an item from the channel.

    - Parameter cancellationToken: A  used to cancel the read operation.
    - Returns: A  that represents the asynchronous read operation.

    */
    open func ReadAsync(cancellationToken : dotnet.System.Threading.CancellationToken = System.Threading.CancellationToken.None) throws -> dotnet.System.Threading.Tasks.ValueTask_1<T> {
        var __thrown : NullableHandle = nil;
        let __return = System_Threading_Channels_ChannelReader_1_System_Threading_Tasks_ValueTask_T___ReadAsync_0__1__CancellationToken(T.get_type_handle(), &__thrown, self.get_handle(), cancellationToken.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return dotnet.System.Threading.Tasks.ValueTask_1(hndl : __return);
        }
    }
    // bool TryPeek(ref T)
// docid: M:System.Threading.Channels.ChannelReader`1.TryPeek(`0@)
    open func TryPeek(item : inout T) throws -> Bool {
        var __thrown : NullableHandle = nil;
            var _tmp_out_item = item.to_gval();
        let __return = System_Threading_Channels_ChannelReader_1_bool__TryPeek_0__1__outT(T.get_type_handle(), &__thrown, self.get_handle(), &_tmp_out_item);
            let _tmp2_item = T(gval: _tmp_out_item);
            item = _tmp2_item;
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return (__return) != 0;
        }
    }
    // bool TryRead(ref T)
// docid: M:System.Threading.Channels.ChannelReader`1.TryRead(`0@)
    /**
    Attempts to read an item from the channel.

    - Parameter item: The read item, or a default value if no item could be read.
    - Returns: 
         if an item was read; otherwise, .

    */
    open func TryRead(item : inout T) throws -> Bool {
        var __thrown : NullableHandle = nil;
            var _tmp_out_item = item.to_gval();
        let __return = System_Threading_Channels_ChannelReader_1_bool__TryRead_0__1__outT(T.get_type_handle(), &__thrown, self.get_handle(), &_tmp_out_item);
            let _tmp2_item = T(gval: _tmp_out_item);
            item = _tmp2_item;
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return (__return) != 0;
        }
    }
    // System.Threading.Tasks.ValueTask<bool> WaitToReadAsync(System.Threading.CancellationToken)
// docid: M:System.Threading.Channels.ChannelReader`1.WaitToReadAsync(System.Threading.CancellationToken)
    /**
    Returns a  that will complete when data is available to read.

    - Parameter cancellationToken: A  used to cancel the wait operation.
    - Returns: 
        A  that will complete with a  result when data is available to read
            or with a  result when no further data will ever be available to be read due to the channel completing successfully.
        If the channel completes with an exception, the task will also complete with an exception.
      

    */
    open func WaitToReadAsync(cancellationToken : dotnet.System.Threading.CancellationToken = System.Threading.CancellationToken.None) throws -> dotnet.System.Threading.Tasks.ValueTask_1<Bool> {
        var __thrown : NullableHandle = nil;
        let __return = System_Threading_Channels_ChannelReader_1_System_Threading_Tasks_ValueTask_bool___WaitToReadAsync_0__1__CancellationToken(T.get_type_handle(), &__thrown, self.get_handle(), cancellationToken.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return dotnet.System.Threading.Tasks.ValueTask_1(hndl : __return);
        }
    }
    // System.Collections.Generic.IAsyncEnumerable<T> ReadAllAsync(System.Threading.CancellationToken)
// docid: M:System.Threading.Channels.ChannelReader`1.ReadAllAsync(System.Threading.CancellationToken)
    /**
    Creates an  that enables reading all of the data from the channel.

    - Parameter cancellationToken: The cancellation token to use to cancel the enumeration.
    - Returns: The created async enumerable.

    */
    open func ReadAllAsync(cancellationToken : dotnet.System.Threading.CancellationToken = System.Threading.CancellationToken.None) throws -> dotnet.System.Collections.Generic.IAsyncEnumerable_1<T> {
        var __thrown : NullableHandle = nil;
        let __return = System_Threading_Channels_ChannelReader_1_System_Collections_Generic_IAsyncEnumerable_T___ReadAllAsync_0__1__CancellationToken(T.get_type_handle(), &__thrown, self.get_handle(), cancellationToken.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return dotnet.System.Collections.Generic.IAsyncEnumerable_1(hndl : __return);
        }
    }
    // [IsSpecialName] bool get_CanCount()
// docid: M:System.Threading.Channels.ChannelReader`1.get_CanCount
    open func get_CanCount() throws -> Bool {
        var __thrown : NullableHandle = nil;
        let __return = System_Threading_Channels_ChannelReader_1_bool__get_CanCount_0__0(T.get_type_handle(), &__thrown, self.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return (__return) != 0;
        }
    }
    // [IsSpecialName] bool get_CanPeek()
// docid: M:System.Threading.Channels.ChannelReader`1.get_CanPeek
    open func get_CanPeek() throws -> Bool {
        var __thrown : NullableHandle = nil;
        let __return = System_Threading_Channels_ChannelReader_1_bool__get_CanPeek_0__0(T.get_type_handle(), &__thrown, self.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return (__return) != 0;
        }
    }
    // [IsSpecialName] System.Threading.Tasks.Task get_Completion()
// docid: M:System.Threading.Channels.ChannelReader`1.get_Completion
    open func get_Completion() throws -> dotnet.System.Threading.Tasks.Task {
        var __thrown : NullableHandle = nil;
        let __return = System_Threading_Channels_ChannelReader_1_Task__get_Completion_0__0(T.get_type_handle(), &__thrown, self.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return dotnet.System.Threading.Tasks.Task(hndl : __return);
        }
    }
    // [IsSpecialName] System.Int32 get_Count()
// docid: M:System.Threading.Channels.ChannelReader`1.get_Count
    open func get_Count() throws -> Swift.Int32 {
        var __thrown : NullableHandle = nil;
        let __return = System_Threading_Channels_ChannelReader_1_i32__get_Count_0__0(T.get_type_handle(), &__thrown, self.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return __return;
        }
    }
    /**
    Gets a value that indicates whether  is available for use on this  instance.

    */
    open var CanCount : Bool {
        get {
            return try! get_CanCount();
        }
    }
    open var CanPeek : Bool {
        get {
            return try! get_CanPeek();
        }
    }
    /**
    Gets a  that completes when no more data will ever
            be available to be read from this channel.

    */
    open var Completion : dotnet.System.Threading.Tasks.Task {
        get {
            return try! get_Completion();
        }
    }
    /**
    Gets the current number of items available from this channel reader.

    */
    open var Count : Swift.Int32 {
        get {
            return try! get_Count();
        }
    }
} // ChannelReader_1


// type: System.Threading.Channels.ChannelWriter`1
    /**
    Provides a base class for writing to a channel.

    */
open class ChannelWriter_1<T : SGBridgeGenericValue>
    :
    dotnet.System.Object
{
    open class override func get_type_handle() -> TypeHandle {
        return System_Threading_Channels_ChannelWriter_1_get_type_handle(T.get_type_handle());
    }
    public required init(hndl: NonnullHandle) { super.init(hndl: hndl); }
    public required init(gval: GVal) { super.init(gval: gval); }
    // void Complete(System.Exception)
// docid: M:System.Threading.Channels.ChannelWriter`1.Complete(System.Exception)
    /**
    Mark the channel as being complete, meaning no more items will be written to it.

    - Parameter error: Optional Exception indicating a failure that's causing the channel to complete.
    */
    open func Complete(error : Optional<dotnet.System.Exception> = nil) throws {
        var __thrown : NullableHandle = nil;
        System_Threading_Channels_ChannelWriter_1_void__Complete_0__1__Exception(T.get_type_handle(), &__thrown, self.get_handle(), error?.get_handle() ?? nil);
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
            return;
        }
    }
    // bool TryComplete(System.Exception)
// docid: M:System.Threading.Channels.ChannelWriter`1.TryComplete(System.Exception)
    /**
    Attempts to mark the channel as being completed, meaning no more data will be written to it.

    - Parameter error: An  indicating the failure causing no more data to be written, or null for success.
    - Returns: 
         if this operation successfully completes the channel; otherwise,  if the channel could not be marked for completion,
            for example due to having already been marked as such, or due to not supporting completion.
          .

    */
    open func TryComplete(error : Optional<dotnet.System.Exception> = nil) throws -> Bool {
        var __thrown : NullableHandle = nil;
        let __return = System_Threading_Channels_ChannelWriter_1_bool__TryComplete_0__1__Exception(T.get_type_handle(), &__thrown, self.get_handle(), error?.get_handle() ?? nil);
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return (__return) != 0;
        }
    }
    // bool TryWrite(T)
// docid: M:System.Threading.Channels.ChannelWriter`1.TryWrite(`0)
    /**
    Attempts to write the specified item to the channel.

    - Parameter item: The item to write.
    - Returns: 
         if the item was written; otherwise, .

    */
    open func TryWrite(item : T) throws -> Bool {
        var __thrown : NullableHandle = nil;
        let __return = System_Threading_Channels_ChannelWriter_1_bool__TryWrite_0__1__T(T.get_type_handle(), &__thrown, self.get_handle(), item.to_gval());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return (__return) != 0;
        }
    }
    // System.Threading.Tasks.ValueTask<bool> WaitToWriteAsync(System.Threading.CancellationToken)
// docid: M:System.Threading.Channels.ChannelWriter`1.WaitToWriteAsync(System.Threading.CancellationToken)
    /**
    Returns a  that will complete when space is available to write an item.

    - Parameter cancellationToken: A  used to cancel the wait operation.
    - Returns: A  that will complete with a  result when space is available to write an item
            or with a  result when no further writing will be permitted.

    */
    open func WaitToWriteAsync(cancellationToken : dotnet.System.Threading.CancellationToken = System.Threading.CancellationToken.None) throws -> dotnet.System.Threading.Tasks.ValueTask_1<Bool> {
        var __thrown : NullableHandle = nil;
        let __return = System_Threading_Channels_ChannelWriter_1_System_Threading_Tasks_ValueTask_bool___WaitToWriteAsync_0__1__CancellationToken(T.get_type_handle(), &__thrown, self.get_handle(), cancellationToken.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return dotnet.System.Threading.Tasks.ValueTask_1(hndl : __return);
        }
    }
    // System.Threading.Tasks.ValueTask WriteAsync(T, System.Threading.CancellationToken)
// docid: M:System.Threading.Channels.ChannelWriter`1.WriteAsync(`0,System.Threading.CancellationToken)
    /**
    Asynchronously writes an item to the channel.

    - Parameter item: The value to write to the channel.
    - Parameter cancellationToken: A  used to cancel the write operation.
    - Returns: A  that represents the asynchronous write operation.

    */
    open func WriteAsync(item : T, cancellationToken : dotnet.System.Threading.CancellationToken = System.Threading.CancellationToken.None) throws -> dotnet.System.Threading.Tasks.ValueTask {
        var __thrown : NullableHandle = nil;
        let __return = System_Threading_Channels_ChannelWriter_1_ValueTask__WriteAsync_0__2__T_CancellationToken(T.get_type_handle(), &__thrown, self.get_handle(), item.to_gval(), cancellationToken.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return dotnet.System.Threading.Tasks.ValueTask(hndl : __return);
        }
    }
} // ChannelWriter_1


// type: System.Threading.Channels.Channel`1
    /**
    Provides a base class for channels that support reading and writing elements of type .

    */
open class Channel_1<T : SGBridgeGenericValue>
    :
    dotnet.System.Threading.Channels.Channel_2<T,T>
{
    open class override func get_type_handle() -> TypeHandle {
        return System_Threading_Channels_Channel_1_get_type_handle(T.get_type_handle());
    }
    public required init(hndl: NonnullHandle) { super.init(hndl: hndl); }
    public required init(gval: GVal) { super.init(gval: gval); }
} // Channel_1


// type: System.Threading.Channels.Channel`2
    /**
    Provides a base class for channels that support reading elements of type  and writing elements of type .

    */
open class Channel_2<TWrite : SGBridgeGenericValue,TRead : SGBridgeGenericValue>
    :
    dotnet.System.Object
{
    open class override func get_type_handle() -> TypeHandle {
        return System_Threading_Channels_Channel_2_get_type_handle(TWrite.get_type_handle(),TRead.get_type_handle());
    }
    public required init(hndl: NonnullHandle) { super.init(hndl: hndl); }
    public required init(gval: GVal) { super.init(gval: gval); }
    // [IsSpecialName] System.Threading.Channels.ChannelReader<TRead> op_Implicit(System.Threading.Channels.Channel<TWrite,TRead>)
// docid: M:System.Threading.Channels.Channel`2.op_Implicit(System.Threading.Channels.Channel{`0,`1})
    open class func op_Implicit(channel : dotnet.System.Threading.Channels.Channel_2<TWrite,TRead>) throws -> dotnet.System.Threading.Channels.ChannelReader_1<TRead> {
        var __thrown : NullableHandle = nil;
        let __return = System_Threading_Channels_Channel_2_System_Threading_Channels_ChannelReader_TRead___op_Implicit_0__1__System_Threading_Channels_Channel_TWrite_TRead_(TWrite.get_type_handle(), TRead.get_type_handle(), &__thrown, channel.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return dotnet.System.Threading.Channels.ChannelReader_1(hndl : __return);
        }
    }
    // [IsSpecialName] System.Threading.Channels.ChannelWriter<TWrite> op_Implicit(System.Threading.Channels.Channel<TWrite,TRead>)
// docid: M:System.Threading.Channels.Channel`2.op_Implicit(System.Threading.Channels.Channel{`0,`1})
    open class func op_Implicit(channel : dotnet.System.Threading.Channels.Channel_2<TWrite,TRead>) throws -> dotnet.System.Threading.Channels.ChannelWriter_1<TWrite> {
        var __thrown : NullableHandle = nil;
        let __return = System_Threading_Channels_Channel_2_System_Threading_Channels_ChannelWriter_TWrite___op_Implicit_0__1__System_Threading_Channels_Channel_TWrite_TRead_(TWrite.get_type_handle(), TRead.get_type_handle(), &__thrown, channel.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return dotnet.System.Threading.Channels.ChannelWriter_1(hndl : __return);
        }
    }
    // [IsSpecialName] System.Threading.Channels.ChannelReader<TRead> get_Reader()
// docid: M:System.Threading.Channels.Channel`2.get_Reader
    open func get_Reader() throws -> dotnet.System.Threading.Channels.ChannelReader_1<TRead> {
        var __thrown : NullableHandle = nil;
        let __return = System_Threading_Channels_Channel_2_System_Threading_Channels_ChannelReader_TRead___get_Reader_0__0(TWrite.get_type_handle(), TRead.get_type_handle(), &__thrown, self.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return dotnet.System.Threading.Channels.ChannelReader_1(hndl : __return);
        }
    }
    // [IsSpecialName] void set_Reader(System.Threading.Channels.ChannelReader<TRead>)
// docid: M:System.Threading.Channels.Channel`2.set_Reader(System.Threading.Channels.ChannelReader{`1})
    open func set_Reader(value : dotnet.System.Threading.Channels.ChannelReader_1<TRead>) throws {
        var __thrown : NullableHandle = nil;
        System_Threading_Channels_Channel_2_void__set_Reader_0__1__System_Threading_Channels_ChannelReader_TRead_(TWrite.get_type_handle(), TRead.get_type_handle(), &__thrown, self.get_handle(), value.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
            return;
        }
    }
    // [IsSpecialName] System.Threading.Channels.ChannelWriter<TWrite> get_Writer()
// docid: M:System.Threading.Channels.Channel`2.get_Writer
    open func get_Writer() throws -> dotnet.System.Threading.Channels.ChannelWriter_1<TWrite> {
        var __thrown : NullableHandle = nil;
        let __return = System_Threading_Channels_Channel_2_System_Threading_Channels_ChannelWriter_TWrite___get_Writer_0__0(TWrite.get_type_handle(), TRead.get_type_handle(), &__thrown, self.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
        return dotnet.System.Threading.Channels.ChannelWriter_1(hndl : __return);
        }
    }
    // [IsSpecialName] void set_Writer(System.Threading.Channels.ChannelWriter<TWrite>)
// docid: M:System.Threading.Channels.Channel`2.set_Writer(System.Threading.Channels.ChannelWriter{`0})
    open func set_Writer(value : dotnet.System.Threading.Channels.ChannelWriter_1<TWrite>) throws {
        var __thrown : NullableHandle = nil;
        System_Threading_Channels_Channel_2_void__set_Writer_0__1__System_Threading_Channels_ChannelWriter_TWrite_(TWrite.get_type_handle(), TRead.get_type_handle(), &__thrown, self.get_handle(), value.get_handle());
        if let __ex =  __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
            return;
        }
    }
    /**
    Gets the readable half of this channel.

    */
    open var Reader : dotnet.System.Threading.Channels.ChannelReader_1<TRead> {
        get {
            return try! get_Reader();
        }
        set(v) {
            return try! set_Reader(value: v);
        }
    }
    /**
    Gets the writable half of this channel.

    */
    open var Writer : dotnet.System.Threading.Channels.ChannelWriter_1<TWrite> {
        get {
            return try! get_Writer();
        }
        set(v) {
            return try! set_Writer(value: v);
        }
    }
} // Channel_2


// type: System.Threading.Channels.UnboundedChannelOptions
    /**
    Provides options that control the behavior of unbounded  instances.

    */
public final class UnboundedChannelOptions
    :
    dotnet.System.Threading.Channels.ChannelOptions
{
    public class override func get_type_handle() -> TypeHandle {
        return System_Threading_Channels_UnboundedChannelOptions_get_type_handle();
    }
    public required init(hndl: NonnullHandle) { super.init(hndl: hndl); }
    public required init(gval: GVal) { super.init(gval: gval); }
    // .ctor()
// docid: M:System.Threading.Channels.UnboundedChannelOptions.#ctor
    /**
    Initializes a new instance of the  class.

    */
    public init() throws {
        var __thrown : NullableHandle = nil;
        let h = System_Threading_Channels_UnboundedChannelOptions_ctor_0__0(&__thrown);
        if let __ex = __thrown {
            throw dotnet.System.Exception(hndl: __ex);
        } else {
            super.init(hndl: h);
        }
    }
} // UnboundedChannelOptions


}



